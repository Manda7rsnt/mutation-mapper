(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("underscore"), require("jquery"), require("qtip2"), require("qtip2/dist/jquery.qtip.css"), require("backbone"), require("d3"), require("jquery-ui/tabs"), require("jquery-tipTip/jquery.tipTip.js"), require("jquery-tipTip/tipTip.css"), require("jquery-ui-css/all.css"), require("jquery-expander"), require("filesaver.js-npm"), require("jquery-ui/draggable"), require("jquery-ui/resizable"), require("datatables.net"), require("drmonty-datatables-colvis"), require("drmonty-datatables-colvis/css/dataTables.colVis.css"), require("datatables-tabletools"), require("datatables.net-dt/css/jquery.dataTables.css"), require("jquery-flesler-scrollto"), require("jquery-ui/slider"));
	else if(typeof define === 'function' && define.amd)
		define(["underscore", "jquery", "qtip2", "qtip2/dist/jquery.qtip.css", "backbone", "d3", "jquery-ui/tabs", "jquery-tipTip/jquery.tipTip.js", "jquery-tipTip/tipTip.css", "jquery-ui-css/all.css", "jquery-expander", "filesaver.js-npm", "jquery-ui/draggable", "jquery-ui/resizable", "datatables.net", "drmonty-datatables-colvis", "drmonty-datatables-colvis/css/dataTables.colVis.css", "datatables-tabletools", "datatables.net-dt/css/jquery.dataTables.css", "jquery-flesler-scrollto", "jquery-ui/slider"], factory);
	else if(typeof exports === 'object')
		exports["mutationMapper"] = factory(require("underscore"), require("jquery"), require("qtip2"), require("qtip2/dist/jquery.qtip.css"), require("backbone"), require("d3"), require("jquery-ui/tabs"), require("jquery-tipTip/jquery.tipTip.js"), require("jquery-tipTip/tipTip.css"), require("jquery-ui-css/all.css"), require("jquery-expander"), require("filesaver.js-npm"), require("jquery-ui/draggable"), require("jquery-ui/resizable"), require("datatables.net"), require("drmonty-datatables-colvis"), require("drmonty-datatables-colvis/css/dataTables.colVis.css"), require("datatables-tabletools"), require("datatables.net-dt/css/jquery.dataTables.css"), require("jquery-flesler-scrollto"), require("jquery-ui/slider"));
	else
		root["mutationMapper"] = factory(root["_"], root["jQuery"], root["qtip2"], root["qtip2/dist/jquery.qtip.css"], root["Backbone"], root["d3"], root["jquery-ui/tabs"], root["jquery-tipTip/jquery.tipTip.js"], root["jquery-tipTip/tipTip.css"], root["jquery-ui-css/all.css"], root["jquery-expander"], root["window"], root["jquery-ui/draggable"], root["jquery-ui/resizable"], root["datatables.net"], root["drmonty-datatables-colvis"], root["drmonty-datatables-colvis/css/dataTables.colVis.css"], root["datatables-tabletools"], root["datatables.net-dt/css/jquery.dataTables.css"], root["jquery-flesler-scrollto"], root["jquery-ui/slider"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_12__, __WEBPACK_EXTERNAL_MODULE_19__, __WEBPACK_EXTERNAL_MODULE_86__, __WEBPACK_EXTERNAL_MODULE_88__, __WEBPACK_EXTERNAL_MODULE_89__, __WEBPACK_EXTERNAL_MODULE_90__, __WEBPACK_EXTERNAL_MODULE_140__, __WEBPACK_EXTERNAL_MODULE_142__, __WEBPACK_EXTERNAL_MODULE_144__, __WEBPACK_EXTERNAL_MODULE_145__, __WEBPACK_EXTERNAL_MODULE_157__, __WEBPACK_EXTERNAL_MODULE_158__, __WEBPACK_EXTERNAL_MODULE_159__, __WEBPACK_EXTERNAL_MODULE_160__, __WEBPACK_EXTERNAL_MODULE_162__, __WEBPACK_EXTERNAL_MODULE_163__, __WEBPACK_EXTERNAL_MODULE_172__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// TODO this is manual: not a desired way to expose sub-modules
	module.exports = {
		MutationMapper: __webpack_require__(1),
		model: {
			MutationCollection: __webpack_require__(112)
		},
		data: {
			MutationDataProxy: __webpack_require__(111)
		},
		util: {
			MutationInputParser: __webpack_require__(182),
			MutationDetailsTableFormatter: __webpack_require__(154),
			MutationDetailsUtil: __webpack_require__(114),
			MutationViewsUtil: __webpack_require__(129),
			BackboneTemplateCache: __webpack_require__(23),
			VepParser: __webpack_require__(4)
		}
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDataManager = __webpack_require__(2);
	var MutationDetailsView = __webpack_require__(21);
	var DataProxyUtil = __webpack_require__(107);
	var PfamDataProxy = __webpack_require__(108);
	var VariantAnnotationDataProxy = __webpack_require__(110);
	var MutationDataProxy = __webpack_require__(111);
	var ClinicalDataProxy = __webpack_require__(115);
	var PdbDataProxy = __webpack_require__(116);
	var PancanMutationDataProxy = __webpack_require__(117);
	var MutationAlignerDataProxy = __webpack_require__(118);
	var PortalDataProxy = __webpack_require__(119);
	var MutationDetailsController = __webpack_require__(120);

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);

	/**
	 * Main wrapper for the whole mutation mapper instance.
	 *
	 * @param options   data, view options, and proxy settings
	 * @constructor
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationMapper(options)
	{
		var self = this;
		var _mutationDetailsView = null;
		var _mutationDetailsController = null;

		// default options object
		var _defaultOpts = {
			// target html container
			el: "#mutation_details",
			// initial data (genes & samples)
			data: {
				geneList: [],
				sampleList: []
			},
			// view component options
			view: {
				mutationDiagram: {},
				mutationTable: {},
				mutationSummary: {},
			    pdbPanel: {},
				pdbTable: {},
				infoPanel: {},
				vis3d: {}
			},
			// TODO make all backbone view classes customizable this way!
			// this is mainly to override the default rendering behavior of backbone views
			render: {
				// MutationDetailsView options
				mutationDetails: {
					init: null, // function for custom init
					format: null, // function for custom format
					activate3dOnInit: false
				},
				mainMutation: {},
				pdbPanel: {},
				mutation3dVis: {}
			},
			// data proxy configuration
			// instance: custom instance, if provided all other parameters are ignored
			// instanceClass: constructor to initialize the data proxy
			// options: options to be passed to the data proxy constructor (see AbstractDataProxy default options)
			proxy: {
				pfamProxy: {
					instance: null,
					instanceClass: PfamDataProxy,
					options: {
						data: {}
					}
				},
				variantAnnotationProxy: {
					instance: null,
					instanceClass: VariantAnnotationDataProxy,
					options: {
						data: {}
					}
				},
				mutationProxy: {
					instance: null,
					instanceClass: MutationDataProxy,
					options: {
						data: {},
						params: {},
						geneList: ""
					}
				},
				clinicalProxy: {
					instance: null,
					instanceClass: ClinicalDataProxy,
					options: {
						data: {}
					}
				},
				pdbProxy: {
					instance: null,
					instanceClass: PdbDataProxy,
					options: {
						data: {
							pdbData: {},
							infoData: {},
							summaryData: {},
							positionData: {}
						},
						mutationUtil: {}
					}
				},
				pancanProxy: {
					instance: null,
					instanceClass: PancanMutationDataProxy,
					options: {
						data: {
							byKeyword: {},
							byProteinChange: {},
							byProteinPosition: {},
							byGeneSymbol: {}
						}
					}
				},
				mutationAlignerProxy: {
					instance: null,
					instanceClass: MutationAlignerDataProxy,
					options: {
						data: {}
					}
				},
				portalProxy: {
					instance: null,
					instanceClass: PortalDataProxy,
					options: {
						data: {}
					}
				}
			},
			// data manager configuration,
			// dataFn: additional custom data retrieval functions
			// dataProxies: additional data proxies
			dataManager: {
				dataFn: {},
				dataProxies: {}
			}
		};

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		function init()
		{
			_options.proxy.mutationProxy.options.geneList = _options.data.geneList.join(" ");

			// init all data proxies & data manager
			var dataProxies = DataProxyUtil.initDataProxies(_options.proxy);
			_options.dataManager = jQuery.extend(true, {}, _options.dataManager, {dataProxies: dataProxies});
			var dataManager = new MutationDataManager(_options.dataManager);

			// TODO pass other view options (pdb table, pdb diagram, etc.)

			var model = {
				mutationProxy: dataProxies.mutationProxy
			};

			var viewOptions = {el: _options.el,
				config: _options.render.mutationDetails,
				model: model};

			var mutationDetailsView = new MutationDetailsView(viewOptions);
			_mutationDetailsView = mutationDetailsView;

			// init main controller...
			var controller = new MutationDetailsController(
				mutationDetailsView,
				dataManager,
				dataProxies,
				_options);

			_mutationDetailsController = controller;

			// ...and let the fun begin!
			mutationDetailsView.render();
		}

		/**
		 * Initializes a MutationMapper instance. Postpones the actual rendering of
		 * the view contents until clicking on the corresponding mutations tab. Provided
		 * tabs assumed to be the main tabs instance containing the mutation tabs.
		 *
		 * @param el        {String} container selector
		 * @param tabs      {String} tabs selector (main tabs containing mutations tab)
		 * @param tabName   {String} name of the target tab (actual mutations tab)
		 * @return {MutationMapper}    a MutationMapper instance
		 */
		function delayedInit(el, tabs, tabName)
		{
			var initialized = false;

			// init view without a delay if the target container is already visible
			if ($(el).is(":visible"))
			{
				self.init();
				initialized = true;
			}

			// add a click listener for the "mutations" tab
			$(tabs).bind("tabsactivate", function(event, ui) {
				// init when clicked on the mutations tab, and init only once
				if (ui.newTab.text().trim().toLowerCase() == tabName.toLowerCase())
				{
					// init only if it is not initialized yet
					if (!initialized)
					{
						self.init();
						initialized = true;
					}
					// if already init, then refresh genes tab
					// (a fix for ui.tabs.plugin resize problem)
					else
					{
						self.getView().refreshGenesTab();
					}
				}
			});

			return self;
		}

		this.init = init;
		this.delayedInit = delayedInit;
		this.getView = function() {return _mutationDetailsView;};
		this.getController = function() {return _mutationDetailsController;};
	}

	module.exports = MutationMapper;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var VariantAnnotationUtil = __webpack_require__(3);
	var PdbDataUtil = __webpack_require__(10);
	var PancanMutationDataUtil = __webpack_require__(18);
	var RequestQueue = __webpack_require__(20);

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);

	/**
	 * Global data manager for Mutation Data, and for other data proxies.
	 *
	 * @param options   data manager options (proxies, views, etc.)
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationDataManager(options)
	{
		var _viewMap = {};

		// default options
		var _defaultOpts = {
			dataFn: {
				variantAnnotation: function(dataProxies, params, callback) {
					//var mutations = params.mutationTable.getMutations();
					var mutations = params.mutations || params.mutationTable.getMutations();
					var annotationProxy = dataProxies.variantAnnotationProxy;
					var variants = [];

					_.each(mutations, function(mutation, idx) {
						var variantKey = mutation.get("variantKey") ||
						                 VariantAnnotationUtil.generateVariantKey(mutation);

						if (!_.isUndefined(variantKey))
						{
							variants.push(variantKey);
						}
					});

					if (variants.length > 0 && annotationProxy)
					{
						// make variants a comma separated list
						variants = variants.join(",");

						annotationProxy.getAnnotationData(variants, function(annotationData) {
							// enrich current mutation data with the annotation data
							VariantAnnotationUtil.addAnnotationData(mutations, annotationData);

							if (_.isFunction(callback))
							{
								callback(params);
							}
						});
					}
					else if (_.isFunction(callback))
					{
						callback(params);
					}
				},
				pdbMatch: function(dataProxies, params, callback) {
					var mutations = params.mutations || params.mutationTable.getMutations();
					var gene = params.gene || params.mutationTable.getGene();
					var pdbProxy = dataProxies.pdbProxy;
					//var uniprotId = params.uniprotId;

					// TODO this is not a safe way of getting the uniprot ID!
					var mainView = _viewMap[gene];
					var uniprotId = mainView.model.uniprotId;

					if (mutations && pdbProxy && uniprotId)
					{
						pdbProxy.getPdbRowData(uniprotId, function(pdbRowData) {
							PdbDataUtil.addPdbMatchData(mutations, pdbRowData);

							if (_.isFunction(callback))
							{
								callback(params);
							}
						});
					}
					else if (_.isFunction(callback))
					{
						callback(params);
					}
				},
				cBioPortal: function(dataProxies, params, callback) {
					var pancanProxy = dataProxies.pancanProxy;
					var mutationUtil = params.mutationUtil || params.mutationTable.getMutationUtil();
					var mutations = params.mutations || params.mutationTable.getMutations();

					// get the pancan data and update the data & display values
					pancanProxy.getPancanData({cmd: "byProteinPos"}, mutationUtil, function(dataByPos) {
						pancanProxy.getPancanData({cmd: "byHugos"}, mutationUtil, function(dataByGeneSymbol) {
							var frequencies = PancanMutationDataUtil.getMutationFrequencies(
								{protein_pos_start: dataByPos, hugo: dataByGeneSymbol});

							// update mutation counts (cBioPortal data field) for each datum
							_.each(mutations, function(ele, i) {
								//var proteinPosStart = ele[indexMap["datum"]].mutation.get("proteinPosStart");
								var proteinPosStart = ele.get("proteinPosStart");

								// update the value of the datum only if proteinPosStart value is valid
								if (proteinPosStart > 0)
								{
									var value = PancanMutationDataUtil.countByKey(frequencies, proteinPosStart) || 0;
									//ele[indexMap["datum"]].mutation.set({cBioPortal: value});
									ele.set({cBioPortal: value});
								}
								else
								{
									//ele[indexMap["datum"]].mutation.set({cBioPortal: 0});
									ele.set({cBioPortal: 0});
								}
							});

							if (_.isFunction(callback))
							{
								// frequencies is the custom data, that we should not attach to the
								// mutation object directly, so passing it to the callback function
								callback(params, frequencies);
							}
						});
					});
				}
			},
			dataProxies : {}
		};

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		// list of request queues keyed by data request type
		// <type, RequestQueue instance> pairs
		var _requestManager = {};

		/**
		 * Retrieves the data for the given data type by invoking the corresponding
		 * data retrieval function
		 *
		 * @param type      data type
		 * @param params    params to be passed over the callback function
		 * @param callback  callback function to be invoked after data retrieval
		 */
		function getData(type, params, callback)
		{
			// init a different queue for each distinct type
			if (_requestManager[type] == null)
			{
				_requestManager[type] = new RequestQueue();

				// init with a custom request process function
				_requestManager[type].init(function(element) {
					// corresponding data retrieval function
					var dataFn = _options.dataFn[element.type];

					if (_.isFunction(dataFn))
					{
						// call the function, with a special callback
						dataFn(_options.dataProxies, element.params, function(params, data) {
							// call the actual callback function
							element.callback(params, data);

							// process of the current element complete
							_requestManager[element.type].complete();
						});
					}
					// no data function is registered for this data field
					else
					{
						element.callback(element.params, null);
						// process of the current element complete
						_requestManager[type].complete();
					}
				});
			}

			// add the request to the corresponding queue.
			// this helps preventing simultaneously requests to the server for the same type
			// (NOTE: this does not check if the parameters are exactly the same or not)
			_requestManager[type].add({type: type, params: params, callback: callback});
		}

		function addView(gene, mainView)
		{
			_viewMap[gene] = mainView;
		}

		this.getData = getData;
		this.addView = addView;
	}

	module.exports = MutationDataManager;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2016 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var VepParser = __webpack_require__(4);

	var cbio = {
		util: __webpack_require__(6)
	};

	var _ = __webpack_require__(5);

	/**
	 * Singleton utility class for variant annotation related tasks.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var VariantAnnotationUtil = (function()
	{
		function addAnnotationData(mutations, annotationData, parseFn)
		{
			var indexedData = _.indexBy(annotationData, "variant");

			if (!_.isFunction(parseFn))
			{
				parseFn = defaultParseAnnotationData;
			}

			_.each(mutations, function(mutation, idx) {
				var annotation = indexedData[mutation.get("variantKey")];
				var parsed = null;

				// check if annotation has an id field
				if (annotation && annotation.id)
				{
					parsed = parseFn(annotation);
				}
				// if no id field, then try the annotationJSON field
				else if (annotation && annotation.annotationJSON)
				{
					parsed = parseFn(annotation.annotationJSON);
				}

				if (parsed)
				{
					// only update undefined fields!
					setUndefinedFields(mutation, parsed);
				}
			});
		}

		/**
		 * Updates only the undefined fields of the given mutation.
		 *
		 * @param mutation  a MutationModel instance
		 * @param annotation    annotation data for single variant
		 */
		function setUndefinedFields(mutation, annotation)
		{
			var update = {};

			_.each(_.keys(annotation), function(fieldName) {
				if (_.isUndefined(mutation.get(fieldName)))
				{
					update[fieldName] = annotation[fieldName];
				}
			});

			if (!_.isEmpty(update))
			{
				mutation.set(update);
			}
		}

		/**
		 * Default parse function that retrieves the partial data from
		 * the raw annotation data.
		 *
		 * @param annotation    raw annotation data (from VEP)
		 * @returns {object} parsed annotation data
		 */
		function defaultParseAnnotationData(annotation)
		{
			var vepData = VepParser.parseJSON(annotation);
			var canonical = vepData.canonicalTranscript;

			// in case of empty annotation data (possible error),
			// corresponding data fields will be empty string

			// TODO define a proper VariantAnnotation model instead?
			var empty = {
				startPos: "",
				endPos: "",
				chr: "",
				referenceAllele: "",
				variantAllele: "",
				proteinChange: ""
			};

			// remove unused fields
			delete(vepData.rawData);
			delete(vepData.transcripts);
			delete(vepData.refseqIds);
			delete(vepData.canonicalTranscript);

			// copy canonical data properties
			return _.extend(empty, vepData, canonical);
		}

		/**
		 * Generates variant key for annotation queries.
		 * This function assumes that basic mutation data (chromosome number,
		 * start position, reference allele, variant allele) is available
		 * for the provided mutation. If not, returns undefined.
		 *
		 * Example keys: 10:g.152595854G>A
		 *               17:g.36002278_36002277insA
		 *               1:g.206811015_206811016delAC
		 *
		 * @param mutation mutation attributes or a MutationModel instance
		 * @returns {string|undefined} variant key (to be used for annotation query)
		 */
		function generateVariantKey(mutation)
		{
			var key = undefined;

			var chr = mutation.chr;
			var startPos = mutation.startPos;
			var endPos = mutation.endPos;
			var referenceAllele = mutation.referenceAllele;
			var variantAllele = mutation.variantAllele;

			// if mutation has a get function, assume that it is a MutationModel instance
			if (_.isFunction(mutation.get))
			{
				chr = mutation.get("chr");
				startPos = mutation.get("startPos");
				endPos = mutation.get("endPos");
				referenceAllele = mutation.get("referenceAllele");
				variantAllele = mutation.get("variantAllele");
			}

			if (referenceAllele != null &&
			    referenceAllele === variantAllele)
			{
				console.log("[VariantAnnotationUtil.generateVariantKey] " +
				            "Warning: Reference allele (" + referenceAllele + ") for " +
				            chr + ":" + startPos + "-" + endPos + " is the same as variant allele");
			}

			function adjustPosition()
			{
				var start = parseInt(startPos);
				var end = parseInt(endPos);

				if (_.isNaN(start) && _.isNaN(end))
				{
					// start or end position is not a number,
					// cannot process further
					return;
				}

				// remove common prefix and adjust variant position accordingly

				var prefix = cbio.util.lcss(referenceAllele, variantAllele);

				if (prefix.length > 0)
				{
					referenceAllele = referenceAllele.substring(prefix.length);
					variantAllele = variantAllele.substring(prefix.length);

					start += prefix.length;
					// TODO end position may already be correct
					// (no need to update in that case)
					end += prefix.length;

					startPos = start.toString();
					endPos = end.toString();
				}
			}

			if (chr && startPos && referenceAllele && variantAllele)
			{
				adjustPosition();

				// this is what we will end up with if there is no endPos is provided
				// example SNP: 2 216809708 216809708 C T
				// example key: 2:g.216809708C>T
				key = chr + ":g." + startPos + referenceAllele + ">" + variantAllele;

				if (endPos)
				{
					// example insertion: 17 36002277 36002278 - A
					// example key:       17:g.36002278_36002277insA
					if (referenceAllele === "-" ||
					    referenceAllele.length === 0)
					{
						key = chr+ ":g." + endPos + "_" + startPos + "ins" + variantAllele;
					}
					// Example deletion: 1 206811015 206811016  AC -
					// Example key:      1:g.206811015_206811016delAC
					else if(variantAllele === "-" ||
					        variantAllele.length === 0)
					{
						key = chr + ":g." + startPos + "_" + endPos + "del" + referenceAllele;
					}
				}
			}

			return key;
		}

		return {
			generateVariantKey: generateVariantKey,
			addAnnotationData: addAnnotationData
		};
	})();

	module.exports = VariantAnnotationUtil;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(5);

	/**
	 * Parses JSON Retrieved from VEP web service.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var VepParser = (function()
	{
		var _aa3to1 = {
			"Ala": "A",
			"Arg": "R",
			"Asn": "N",
			"Asp": "D",
			"Asx": "B",
			"Cys": "C",
			"Glu": "E",
			"Gln": "Q",
			"Glx": "Z",
			"Gly": "G",
			"His": "H",
			"Ile": "I",
			"Leu": "L",
			"Lys": "K",
			"Met": "M",
			"Phe": "F",
			"Pro": "P",
			"Ser": "S",
			"Thr": "T",
			"Trp": "W",
			"Tyr": "Y",
			"Val": "V",
			"Xxx": "X",
			"Ter": "*"
		};

		var _variantMap = {
			"splice_acceptor_variant": "Splice_Site",
			"splice_donor_variant": "Splice_Site",
			"transcript_ablation": "Splice_Site",
			"stop_gained": "Nonsense_Mutation",
			"frameshift_variant": "Frame_Shift",
			"stop_lost": "Nonstop_Mutation",
			"initiator_codon_variant": "Translation_Start_Site",
			"start_lost": "Translation_Start_Site",
			"inframe_insertion": "In_Frame_Ins",
			"inframe_deletion": "In_Frame_Del",
			"missense_variant": "Missense_Mutation",
			"protein_altering_variant": "Missense_Mutation", // TODO Not sure if this is correct
			"coding_sequence_variant": "Missense_Mutation",
			"conservative_missense_variant": "Missense_Mutation",
			"rare_amino_acid_variant": "Missense_Mutation",
			"transcript_amplification": "Intron",
			"splice_region_variant": "Intron",
			"intron_variant": "Intron",
			"INTRAGENIC": "Intron",
			"intragenic_variant": "Intron",
			"incomplete_terminal_codon_variant": "Silent",
			"synonymous_variant": "Silent",
			"stop_retained_variant": "Silent",
			"NMD_transcript_variant": "Silent",
			"mature_miRNA_variant": "RNA",
			"non_coding_exon_variant": "RNA",
			"non_coding_transcript_exon_variant": "RNA",
			"non_coding_transcript_variant": "RNA",
			"nc_transcript_variant": "RNA",
			"5_prime_UTR_variant": "5'UTR",
			"5_prime_UTR_premature_start_codon_gain_variant": "5'UTR",
			"3_prime_UTR_variant": "3'UTR",
			"TF_binding_site_variant": "IGR",
			"regulatory_region_variant": "IGR",
			"regulatory_region": "IGR",
			"intergenic_variant": "IGR",
			"intergenic_region": "IGR",
			"upstream_gene_variant": "5'Flank",
			"downstream_gene_variant": "3'Flank",
			"TFBS_ablation": "Targeted_Region",
			"TFBS_amplification": "Targeted_Region",
			"regulatory_region_ablation": "Targeted_Region",
			"regulatory_region_amplification": "Targeted_Region",
			"feature_elongation": "Targeted_Region",
			"feature_truncation": "Targeted_Region"
		};

		/**
		 * Parses the raw annotation JSON object.
		 *
		 * @param annotation  JSON object returned by the web service
		 * @return {object}  parsed JSON, or null in case of an error
		 */
		function parseJSON(annotation)
		{
			var vepData = {};

			if (!annotation)
			{
				console.log("[warning] VEP parser error");
				return {};
			}
			else if (annotation.error)
			{
				console.log("[warning] VEP parser error: " + annotation.error);
				return {};
			}

			// proceed in case of no JSON error
			var alleleString = annotation["allele_string"];
			var alleles = alleleString.split("/", -1);

			if (alleles.length === 2)
			{
				vepData.referenceAllele = alleles[0];
				//vepData.put(AnnoMafProcessor.VEP_REFERENCE_ALLELE.toLowerCase(), alleles[0]);
				//vepData.put(AnnoMafProcessor.VEP_TUMOR_SEQ_ALLELE.toLowerCase(), alleles[1]);

				//vepData.put(AnnoMafProcessor.VEP_VARIANT_TYPE.toLowerCase(), variantType);
				vepData.variantType = getVariantType(alleles[0], alleles[1]);
			}

			vepData.ncbiBuildNo = annotation["assembly_name"];
			vepData.chr = annotation["seq_region_name"];
			vepData.startPos = annotation["start"];
			vepData.endPos = annotation["end"];
			vepData.strand = strandSign(annotation["strand"]);

			var transcripts = annotation["transcript_consequences"];
			var mostSevereConsequence = annotation["most_severe_consequence"];

			// parse all transcripts
			vepData.transcripts = [];
			_.each(transcripts, function(transcript, idx) {
				vepData.transcripts.push(
					parseTranscript(transcript, mostSevereConsequence, vepData.variantType));
			});

			// TODO what to do in case no canonical transcript can be determined?
			var canonicalTranscript = getCanonicalTranscript(transcripts, mostSevereConsequence);

			if (canonicalTranscript &&
			    vepData.transcripts[canonicalTranscript.index])
			{
				vepData.canonicalTranscript = vepData.transcripts[canonicalTranscript.index];
			}

			// also attach the original raw data
			vepData.rawData = annotation;

			return vepData;
		}

		function parseTranscript(transcript, mostSevereConsequence, variantType, vepData)
		{
			vepData = vepData || {};

			vepData.geneSymbol = transcript["gene_symbol"];

			// JsonNode variantAllele = transcript.path("variant_allele");
			// if (!variantAllele.isMissingNode()) {
			// vepData.put(AnnoMafProcessor.VEP_TUMOR_SEQ_ALLELE.toLowerCase(), variantAllele.asText());
			// }

			var consequenceTerms = transcript["consequence_terms"];

			if (consequenceTerms != null &&
			    consequenceTerms.length > 0)
			{
				// TODO what if more than one consequence term?
				var variantClass = variantClassification(consequenceTerms[0]);

				if(variantClass === "Frame_Shift") {
					if (variantType != null && variantType === "INS") {
						variantClass += "_Ins";
					}
					else if (variantType === "DEL") {
						variantClass += "_Del";
					}
				}

				vepData.variantClassification = variantClass;
			}

			var refseqIds = transcript["refseq_transcript_ids"];

			if (refseqIds != null &&
			    refseqIds.length > 0)
			{
				vepData.refseqIds = refseqIds;
			}

			var hgvsc = transcript["hgvsc"];
			if (hgvsc != null) {
				vepData.hgvsc = hgvsc.substr(hgvsc.indexOf(":")+1);
			}

			var hgvsp = transcript["hgvsp"];
			if (hgvsp != null)
			{
				// TODO (p.%3D) ?
				//if (hgvsp.indexOf("(p.%3D)") != -1) {
				//	vepData.put(AnnoMafProcessor.VEP_HGVSP.toLowerCase(), "p.=");
				//}

				vepData.hgvsp = hgvsp.substr(hgvsp.indexOf(":")+1);
			}

			vepData.transcriptId = transcript["transcript_id"];
			vepData.proteinPosStart = transcript["protein_start"];
			vepData.proteinPosEnd = transcript["protein_end"];
			vepData.codons = transcript["codons"];

			// create a shorter HGVS protein format
			var hgvspShort;

			if (hgvsp != null)
			{
				hgvspShort = hgvsp.substr(hgvsp.indexOf(":")+1);

				_.each(_.pairs(_aa3to1), function(pair, idx) {
					hgvspShort = hgvspShort.replace(new RegExp(pair[0], 'g'), pair[1]);
				});

				vepData.hgvspShort = hgvspShort;
			}

			if (mostSevereConsequence === "splice_acceptor_variant" ||
			    mostSevereConsequence === "splice_donor_variant")
			{
				//Pattern pattern = Pattern.compile("^c.([0-9]+)*");
				//Matcher matcher = pattern.matcher(hgvsc.asText().substring(iHgsvc+1));

				//if( matcher.find() ) {
				//	int cPos = Integer.parseInt(matcher.group(1));
				//	if( cPos < 1 ) {
				//		cPos = 1;
				//	}
				//
				//	var pPos = Integer.toString(( cPos + cPos % 3 ) / 3 );
				//
				//	vepData.hgvspShort = "p.X" + pPos + "_splice";
				//}

				if (vepData.hgvsc)
				{
					var match = /c\.([0-9]+)*/.exec(vepData.hgvsc);

					if (match && match.length == 2)
					{
						var cPos = parseInt(match[1]);

						if (cPos < 1) {
							cPos = 1;
						}

						var pPos = cPos + (cPos % 3) / 3;

						vepData.hgvspShort = "p.X" + pPos + "_splice";
					}
				}
			}

			if (mostSevereConsequence === "synonymous_variant")
			{
				hgvspShort = "p." +
					transcript["amino_acids"] +
					transcript["protein_start"] +
					transcript["amino_acids"];

				vepData.hgvspShort = hgvspShort;
			}

			// set aliases
			vepData.mutationType = vepData.variantClassification;
			vepData.proteinChange = vepData.hgvspShort;
			if (vepData.refseqIds && vepData.refseqIds.length > 0) {
				// TODO is it okay to pick the first one as the default refseq id?
				vepData.refseqMrnaId = vepData.refseqIds[0];
			}

			return vepData;
		}

		/**
		 * Finds and returns the canonical transcript within the given transcript list.
		 * Returns null in case no canonical transcript can be determined.
		 *
		 * @param transcripts list of transcript nodes
		 * @param  mostSevereConsequence
		 * @return {object} canonical transcript node
		 */
		function getCanonicalTranscript(transcripts, mostSevereConsequence)
		{
			var list = [];

			_.each(transcripts, function(transcript, idx) {
				if (transcript["canonical"] == 1)
				{
					list.push({index: idx, transcript:transcript});
				}
			});

			// trivial case: only one transcript marked as canonical
			if (list.length === 1)
			{
				return list[0];
			}
			// more than one transcript is marked as canonical,
			// use most severe consequence to decide which one to pick
			// among the ones marked as canonical
			else if (list.length > 1)
			{
				return transcriptWithMostSevereConsequence(list, mostSevereConsequence);
			}
			// no transcript is marked as canonical (list.size() == 0),
			// use most severe consequence to decide which one to pick
			// among all available transcripts
			else
			{
				_.each(transcripts, function(transcript, idx) {
					list.push({index: idx, transcript:transcript});
				});

				return transcriptWithMostSevereConsequence(list, mostSevereConsequence);
			}
		}

		/**
		 * Finds and returns the transcript node which has the given
		 * most severe consequence in its consequence terms. Returns
		 * null in case no match.
		 *
		 * @param transcripts           list of transcript nodes
		 * @param mostSevereConsequence most severe consequence
		 * @return transcript node containing most severe consequence
		 */
		function transcriptWithMostSevereConsequence(transcripts, mostSevereConsequence)
		{
			// default value is null in case of no match
			var transcriptWithMSC = null;

			_.each(transcripts, function(ele, idx) {
				var consequenceTerms = ele.transcript["consequence_terms"];

				if (transcriptWithMSC == null &&
				    consequenceTerms != null &&
				    mostSevereConsequence != null)
				{
					_.each(consequenceTerms, function(consequence, idx) {
						if (consequence.trim().toLowerCase() ===
						    mostSevereConsequence.trim().toLowerCase())
						{
							transcriptWithMSC = ele;
						}
					});
				}
			});

			return transcriptWithMSC;
		}

		function getVariantType(refAllele, varAllele)
		{
			var refLength = refAllele.length;
			var varLength = varAllele.length;
			refLength = refAllele === "-" ? 0 : refLength;
			varLength = varAllele === "-" ? 0 : varLength;

			if (refLength === varLength) {
				var npType = ["SNP", "DNP", "TNP"];
				return (refLength < 3 ? npType[refLength - 1] : "ONP");
			}
			else {
				if (refLength < varLength) {
					return "INS";
				}
				else {
					return "DEL";
				}
			}
		}

		function variantClassification(variant)
		{
			return _variantMap[variant.toLowerCase()];
		}

		function strandSign(strand)
		{
			var sign;

			if (strand == null ||
			    strand === "+" ||
			    strand === "-")
			{
				sign = strand;
			}
			else
			{
				if (strand < 0)
				{
					sign = "-";
				}
				else if (strand > 0)
				{
					sign = "+";
				}
				else
				{
					sign = strand;
				}
			}

			return sign;
		}

		return {
			parseJSON: parseJSON
		};
	})();

	module.exports = VepParser;

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This file is part of cBioPortal.
	 *
	 * cBioPortal is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as
	 * published by the Free Software Foundation, either version 3 of the
	 * License.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/

	var $ = __webpack_require__(7);
	var jQuery = $;
	__webpack_require__(8);
	__webpack_require__(9);

	if (cbio === undefined)
	{
		var cbio = {};
	}

	cbio.util = (function() {

	    /**
	     * Determines the longest common starting substring
	     * for the given two strings
	     *
	     * @param str1  first string
	     * @param str2  second string
	     * @return {String} longest common starting substring
	     */
	    var lcss = function (str1, str2)
	    {
	        var i = 0;

	        while (i < str1.length && i < str2.length)
	        {
	            if (str1[i] === str2[i])
	            {
	                i++;
	            }
	            else
	            {
	                break;
	            }
	        }

	        return str1.substring(0, i);
	    };

		/**
		 * Converts base 64 encoded string into an array of byte arrays.
		 *
		 * @param b64Data   base 64 encoded string
		 * @param sliceSize size of each byte array (default: 512)
		 * @returns {Array} an array of byte arrays
		 */
		function b64ToByteArrays(b64Data, sliceSize) {
			sliceSize = sliceSize || 512;

			var byteCharacters = atob(b64Data);
			var byteArrays = [];

			for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
				var slice = byteCharacters.slice(offset, offset + sliceSize);

				var byteNumbers = new Array(slice.length);
				for (var i = 0; i < slice.length; i++) {
					byteNumbers[i] = slice.charCodeAt(i);
				}

				var byteArray = new Uint8Array(byteNumbers);

				byteArrays.push(byteArray);
			}

			return byteArrays;
		}

		/**
		 * Detects browser and its version.
		 * This function is implemented as an alternative to the deprecated jQuery.browser object.
		 *
		 * @return {object} browser information as an object
		 */
		var detectBrowser = function ()
		{
			var browser = {};
			var uagent = navigator.userAgent.toLowerCase();

			browser.firefox = /mozilla/.test(uagent) &&
			                  /firefox/.test(uagent);

			browser.mozilla = browser.firefox; // this is just an alias

			browser.chrome = /webkit/.test(uagent) &&
			                 /chrome/.test(uagent);

			browser.safari = /applewebkit/.test(uagent) &&
			                 /safari/.test(uagent) &&
			                 !/chrome/.test(uagent);

			browser.opera = /opera/.test(uagent);

			browser.msie = /msie/.test(uagent);

			browser.version = "";

			// check for IE 11
			if (!(browser.msie ||
			      browser.firefox ||
			      browser.chrome ||
			      browser.safari ||
			      browser.opera))
			{
				// TODO probably we need to update this for future IE versions
				if (/trident/.test(uagent))
				{
					browser.msie = true;
					browser.version = 11;
				}
			}

			if (browser.version === "")
			{
				for (var x in browser)
				{
					if (browser[x])
					{
						browser.version = uagent.match(new RegExp("(" + x + ")( |/)([0-9]+)"))[3];
						break;
					}
				}
			}

			return browser;
		};

		/**
		 * Retrieves the page origin from the global window object. This function is
		 * introduced to eliminate cross-browser issues (window.location.origin is
		 * undefined for IE)
		 */
		var getOrigin = function()
		{
			var origin = window.location.origin;

			if (!origin)
			{
				origin = window.location.protocol + "//" +
				         window.location.hostname +
				         (window.location.port ? ':' + window.location.port: '');
			}

			return origin;
		};

		/**
		 * Replaces problematic characters with an underscore for the given string.
		 * Those characters cause problems with the properties of an HTML object,
		 * especially for the id and class properties.
		 *
		 * @param property  string to be modified
		 * @return {string} safe version of the given string
		 */
		var safeProperty = function(property)
		{
			return property.replace(/[^a-zA-Z0-9-]/g,'_');
		};

		/**
		 * Hides the child html element on mouse leave, and shows on
		 * mouse enter. This function is designed to hide a child
		 * element within a parent element.
		 *
		 * @param parentElement target of mouse events
		 * @param childElement  element to show/hide
		 */
		function autoHideOnMouseLeave(parentElement, childElement)
		{
			$(parentElement).mouseenter(function(evt) {
				childElement.fadeIn({complete: function() {
					$(this).css({"visibility":"visible"});
					$(this).css({"display":"inline"});
				}});
			});

			$(parentElement).mouseleave(function(evt) {
				// fade out without setting display to none
				childElement.fadeOut({complete: function() {
					// fade out uses hide() function, but it may change
					// the size of the parent element
					// so this is a workaround to prevent resize
					// due to display: "none"
					$(this).css({"visibility":"hidden"});
					$(this).css({"display":"inline"});
				}});
			});
		}

		/**
		 * Returns the content window for the given target frame.
		 *
		 * @param id    id of the target frame
		 */
		function getTargetWindow(id)
		{
			var frame = document.getElementById(id);
			var targetWindow = frame;

			if (frame.contentWindow)
			{
				targetWindow = frame.contentWindow;
			}

			return targetWindow;
		}

		/**
		 * Returns the content document for the given target frame.
		 *
		 * @param id    id of the target frame
		 */
		function getTargetDocument(id)
		{
			var frame = document.getElementById(id);
			var targetDocument = frame.contentDocument;

			if (!targetDocument && frame.contentWindow)
			{
				targetDocument = frame.contentWindow.document;
			}

			return targetDocument;
		}

	    function getLinkToPatientView(cancerStudyId, patientId) {
	        return "case.do?cancer_study_id=" + cancerStudyId + "&case_id=" + patientId;
	    }

	    function getLinkToSampleView(cancerStudyId, sampleId) {
	        return "case.do?cancer_study_id=" + cancerStudyId + "&sample_id=" + sampleId;
	    }

	    /**
	     * Adds qTip to the provided target when first time mouse enter
	     *
	     * @param target qTip target, could be a class name, id or any jquery acceptable element
	     * @param qTipOpts qTip initialization options
	     */
	    function addTargetedQTip(target, qTipOpts) {
	        if(target) {
	            var opts = {
	                show: {ready: true},
	                hide: {fixed: true, delay: 100},
	                style: {classes: 'qtip-light qtip-rounded qtip-shadow', tip: true},
	                position: {my: 'top left', at: 'bottom right', viewport: $(window)}
	            };

		        // check if target[0] is SVG
		        if (target[0] && target[0].ownerSVGElement)
		        {
			        target = target[0];
		        }
		        // check if target[0][0] is SVG
		        else if (target[0] && target[0][0] && target[0][0].ownerSVGElement)
		        {
			        target = target[0][0];
		        }

	            jQuery.extend(true, opts, qTipOpts);
	            $(target).one('mouseenter', function () {
	                $(this).qtip(opts);
	            });
	        } else {
	            console.error('qTip target is not defined.');
	        }
	    }

	    return {
	        lcss: lcss,
		    b64ToByteArrays: b64ToByteArrays,
	        browser: detectBrowser(), // returning the browser object, not the function itself
	        getWindowOrigin: getOrigin,
	        safeProperty: safeProperty,
	        autoHideOnMouseLeave: autoHideOnMouseLeave,
		    getTargetWindow: getTargetWindow,
		    getTargetDocument: getTargetDocument,
	        getLinkToPatientView: getLinkToPatientView,
	        getLinkToSampleView: getLinkToSampleView,
	        addTargetedQTip: addTargetedQTip
	    };

	})();

	module.exports = cbio.util;

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_7__;

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var PdbAlignmentModel = __webpack_require__(11);
	var PdbChainModel = __webpack_require__(13);
	var PdbModel = __webpack_require__(15);
	var PdbCollection = __webpack_require__(17);

	var _ = __webpack_require__(5);

	/**
	 * Singleton utility class for PDB data related tasks.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var PdbDataUtil = (function()
	{
		// constants
		var ALIGNMENT_GAP = "*";
		var ALIGNMENT_PLUS = "+";
		var ALIGNMENT_MINUS = "-";
		var ALIGNMENT_SPACE = " ";

		/**
		 * Processes the pdb data (received from the server) to create
		 * a collection of PdbModel instances.
		 *
		 * @param data  pdb alignment data with a position map
		 * @return {PdbCollection}   PdbModel instances representing the processed data
		 */
		function processPdbData(data)
		{
			// ascending sort
			// TODO do not sort if already sorted?
			data.sort(function(a, b) {
				var diff = a.uniprotFrom - b.uniprotFrom;

				// for consistency sort alphabetically if positions are same
				if (diff === 0)
				{
					if (a.pdbId > b.pdbId)
					{
						diff = -1;
					}
					else
					{
						diff = 1;
					}
				}

				return diff;
			});

			var alignmentModel = null;
			var pdbList = [];
			var pdbMap = {};

			_.each(data, function(alignment, idx) {
				alignmentModel = new PdbAlignmentModel(alignment);
				alignmentModel.alignmentString = alignment.alignmentString ||
				                                 alignmentString(alignment);

				if (pdbMap[alignmentModel.pdbId] == undefined)
				{
					pdbMap[alignmentModel.pdbId] = {};
				}

				if (pdbMap[alignmentModel.pdbId][alignmentModel.chain] == undefined)
				{
					pdbMap[alignmentModel.pdbId][alignmentModel.chain] = [];
				}

				pdbMap[alignmentModel.pdbId][alignmentModel.chain].push(alignmentModel);
			});

			// instantiate chain models
			_.each(_.keys(pdbMap), function(pdbId) {
				var chains = [];

				_.each(_.keys(pdbMap[pdbId]), function(chain) {
					var attributes = {
						chainId: chain,
						alignments: pdbMap[pdbId][chain]
					};

					var chainModel = new PdbChainModel(attributes);
					// TODO define a model for merged alignments (PdbMergedAlignment) ?
					chainModel.mergedAlignment = mergeAlignments(attributes.alignments);

					chains.push(chainModel);
				});

				var pdbModel = new PdbModel({pdbId: pdbId,
					chains: chains});

				pdbList.push(pdbModel);
			});

			// return new pdb model
			return new PdbCollection(pdbList);
		}

		function alignmentString(attributes)
		{
			var sb = [];

			// process 3 alignment strings and create a visualization string
			var midline = attributes.midlineAlign;
			var uniprot = attributes.uniprotAlign;
			var pdb = attributes.pdbAlign;

			if (midline.length === uniprot.length &&
			    midline.length === pdb.length)
			{
				for (var i = 0; i < midline.length; i++)
				{
					// do not append anything if there is a gap in uniprot alignment
					if (uniprot[i] !== '-')
					{
						if (pdb[i] === '-')
						{
							sb.push('-');
						}
						else
						{
							sb.push(midline[i]);
						}
					}
				}
			}
			else
			{
				// the execution should never reach here,
				// if everything is OK with the data...
				sb.push("NA");
			}

			return sb.join("");
		}

		/**
		 * Generates a pdb info summary for the given full pdb info object
		 * and the chain id.
		 *
		 * @param pdbInfo   pdb info data (retrieved from server)
		 * @param chainId   chain id as a string
		 * @returns {Object} pdb summary for the given chain
		 */
		function generatePdbInfoSummary(pdbInfo, chainId)
		{
			var summary = {};
			summary.title = pdbInfo.title;

			// TODO cache?

			// get chain specific molecule info
			_.find(pdbInfo.compound, function(mol) {
				if (mol.molecule &&
				    _.indexOf(mol.chain, chainId.toLowerCase()) != -1)
				{
					// chain is associated with this mol,
					// get the organism info from the source
					summary.molecule = mol.molecule;
					return mol;
				}
			});

			return summary;
		}

		/**
		 * Finds the organism for the given full pdb info object
		 * and the chain id.
		 *
		 * @param pdbInfo   pdb info data (retrieved from server)
		 * @param chainId   chain id as a string
		 * @returns {String} organism data corresponding to the given chain
		 */
		function getOrganism(pdbInfo, chainId)
		{
			var organism = "NA";

			// TODO cache?
			_.find(pdbInfo.compound, function(mol) {
				if (_.indexOf(mol.chain, chainId.toLowerCase()) != -1 &&
				    pdbInfo.source[mol.mol_id] != null)
				{
					// chain is associated with this mol,
					// get the organism info from the source
					organism = pdbInfo.source[mol.mol_id].organism_scientific ||
					           organism;
					return mol;
				}
			});

			return organism;
		}

		/**
		 * Merge alignments in the given array.
		 *
		 * @param alignments    an array of PdbAlignmentModel instances
		 */
		function mergeAlignments(alignments)
		{
			// TODO merge without assuming it is sorted (write a new algorithm)
			return mergeSortedAlignments(alignments);
		}

		/**
		 * Merge alignments in the given array, assuming that
		 * they are sorted by uniprotFrom field.
		 *
		 * @param alignments    an array of PdbAlignmentModel instances
		 * @return {Object}     merged alignment object
		 */
		function mergeSortedAlignments(alignments)
		{
			var mergedAlignment = {mergedString: "", uniprotFrom: -1, uniprotTo: -1, pdbFrom: -1};
			var mergedStr = "";
			var end = -1;
			var prev;

			if (alignments.length > 0)
			{
				mergedStr += alignments[0].alignmentString;
				end = alignments[0].uniprotTo;
				prev = alignments[0];
			}
			else
			{
				return mergedAlignment;
			}

			_.each(alignments, function(alignment, idx) {
				var distance = alignment.uniprotFrom - end - 1;

				var str = alignment.alignmentString;

				// check for overlapping uniprot positions...

				// no overlap, and the next alignment starts exactly after the current merge
				if (distance == 0)
				{
					// just concatenate two strings
					mergedStr += str;
				}
				// no overlap, but there is a gap
				else if (distance > 0)
				{
					var gap = [];

					// add gap characters (character count = distance)
					for (var i=0; i<distance; i++)
					{
						gap.push(ALIGNMENT_GAP);
					}

					// also add the actual string
					gap.push(str);

					mergedStr += gap.join("");

				}
				// overlapping
				else
				{
					var overlap = [];
					var subLength = Math.min(-1 * distance, str.length);

					overlap.push(mergedStr.substr(mergedStr.length + distance, subLength));
					overlap.push(str.substr(0, subLength));

					if (overlap[0] != overlap[1])
					{
						console.log("[warning] alignment mismatch: " +
						            prev.alignmentId + " & " + alignment.alignmentId);
						console.log(overlap[0]);
						console.log(overlap[1]);
					}

					// merge two strings
					mergedStr += str.substr(-1 * distance);
				}

				// update the end position
				end = Math.max(end, alignment.uniprotTo);

				if (end == alignment.uniprotTo)
				{
					// keep reference to the previous alignment
					prev = alignment;
				}
			});

			mergedAlignment.uniprotFrom = alignments[0].uniprotFrom;
			mergedAlignment.uniprotTo = mergedAlignment.uniprotFrom + mergedStr.length;
			mergedAlignment.pdbFrom = alignments[0].pdbFrom;
			mergedAlignment.mergedString = mergedStr;
			mergedAlignment.identityPerc = calcIdentityPerc(mergedStr);
			mergedAlignment.identity = calcIdentity(mergedStr);

			return mergedAlignment;
		}

		/**
		 * Finds the first matching pdb id & chain for the given mutation and
		 * row of chains.
		 *
		 * @param mutation  a MutationModel instance
		 * @param rowData   ranked chain data (2D array)
		 * @return {Object} {pdbId, chainId}
		 */
		function mutationToPdb(mutation, rowData)
		{
			var pdbMatch = null;

			var location = mutation.getProteinStartPos();
			var type = mutation.get("mutationType") || "";
			type = type.trim().toLowerCase();

			// skip fusions or invalid locations
			if (location == null ||
			    type === "fusion")
			{
				return pdbMatch;
			}

			// iterate all chains to find the first matching position
			for (var i=0;
			     i < rowData.length && !pdbMatch;
			     i++)
			{
				var allocation = rowData[i];

				for (var j=0;
				     j < allocation.length && !pdbMatch;
				     j++)
				{
					var datum = allocation[j];

					var alignment = datum.chain.mergedAlignment;

					// use merged alignment to see if there is a match
					var rangeWithin = location >= alignment.uniprotFrom &&
					                  location <= alignment.uniprotTo;

					// check for match condition
					if (rangeWithin && alignmentMatch(alignment, location))
					{
						pdbMatch = {pdbId: datum.pdbId,
							chainId: datum.chain.chainId};

						// found a matching pdb residue, break the inner loop
						break;
					}
				}

				if (pdbMatch)
				{
					// found a matching pdb residue, break the outer loop
					break;
				}
			}

			return pdbMatch;
		}

		/**
		 * Processes mutation data to add pdb match data
		 *
		 * @param mutationData  array of MutationModel instances
		 * @param pdbRowData    pdb row data for the corresponding uniprot id
		 * @return {Array}      mutation data array with additional attrs
		 */
		function addPdbMatchData(mutationData, pdbRowData)
		{
			if (!pdbRowData)
			{
				return mutationData;
			}

			//var map = mutationUtil.getMutationIdMap();

			_.each(mutationData, function(mutation, idx) {
				if (mutation == null)
				{
					console.log('warning [processMutationData]: mutation (at index %d) is null.', idx);
					return;
				}

				// find the matching pdb
				var match = PdbDataUtil.mutationToPdb(mutation, pdbRowData);
				// update the raw mutation object
				mutation.set({pdbMatch: match});
			});

			return mutationData;
		}

		/**
		 * Checks for a match for the specified location on the
		 * given merged alignment.
		 *
		 * @param alignment merged alignment
		 * @param location  protein change location
		 * @return {boolean}    true if match, false otherwise
		 */
		function alignmentMatch(alignment, location)
		{
			var index = location - alignment.uniprotFrom;

			var symbol = alignment.mergedString[index];

			var mismatch = (symbol == ALIGNMENT_GAP);

			return !mismatch;
		}

		/**
		 * Calculates the identity percentage of the given alignment string
		 * based on mismatch ratio.
		 *
		 * @param mergedStr merged alignment string
		 * @return {Number} identity percentage value
		 */
		function calcIdentityPerc(mergedStr)
		{
			var gap = 0;
			var mismatch = 0;

			for (var count=0; count < mergedStr.length; count++)
			{
				var symbol = mergedStr[count];
				if (symbol == ALIGNMENT_GAP)
				{
					// increment gap count (gaps excluded from ratio calculation)
					gap++;
				}
				else if (symbol == ALIGNMENT_MINUS ||
					symbol == ALIGNMENT_PLUS ||
					symbol == ALIGNMENT_SPACE)
				{
					// any special symbol other than a gap is considered as a mismatch
					// TODO is it better to assign a different weight for each symbol?
					mismatch++;
				}
			}

			return 1.0 - (mismatch / (count - gap));
		}

		/**
		 * Calculates the identity (number of matches) for
		 * the given alignment string.
		 *
		 * @param mergedStr merged alignment string
		 * @return {Number} identity value
		 */
		function calcIdentity(mergedStr)
		{
			mergedStr = mergedStr.toLowerCase();

			var match = 0;

			for (var count=0; count < mergedStr.length; count++)
			{
				var symbol = mergedStr[count];

				if (symbol.match(/[a-z]/))
				{
					match++;
				}
			}

			return match;
		}

		/**
		 * Creates row data by allocating position for each chain.
		 * A row may have multiple chains if there is no overlap
		 * between chains.
		 *
		 * @param pdbColl   a PdbCollection instance
		 * @return {Array}  a 2D array of chain allocation
		 */
		function allocateChainRows(pdbColl)
		{
			// sort chains by rank (high to low)
			var chainData = sortChainsDesc(pdbColl);

			var rows = [];

			_.each(chainData, function(datum, idx) {
				var chain = datum.chain;

				if (chain.alignments.length > 0)
				{
					var inserted = false;

					// find the first available row for this chain
					for (var i=0; i < rows.length; i++)
					{
						var row = rows[i];
						var conflict = false;

						// check for conflict for this row
						for (var j=0; j < row.length; j++)
						{
							if (overlaps(chain, row[j].chain))
							{
								// set the flag, and break the loop
								conflict = true;
								break;
							}
						}

						// if there is space available in this row,
						// insert the chain into the current row
						if (!conflict)
						{
							// insert the chain, set the flag, and break the loop
							row.push(datum);
							inserted = true;
							break;
						}
					}

					// if there is no available space in any row,
					// then insert the chain to the next row
					if (!inserted)
					{
						var newAllocation = [];
						newAllocation.push(datum);
						rows.push(newAllocation);
					}
				}
			});

			// sort alignments in each row by start position (lowest comes first)
	//		_.each(rows, function(allocation, idx) {
	//			allocation.sort(function(a, b){
	//				return (a.chain.mergedAlignment.uniprotFrom -
	//				        b.chain.mergedAlignment.uniprotFrom);
	//			});
	//		});

			// sort alignments in the first row by alignment length
			if (rows.length > 0)
			{
				rows[0].sort(function(a, b){
					return (b.chain.mergedAlignment.mergedString.length -
					        a.chain.mergedAlignment.mergedString.length);
				});
			}

			return rows;
		}

		/**
		 * Checks if the given two chain alignments (positions) overlaps
		 * with each other.
		 *
		 * @param chain1    first chain
		 * @param chain2    second chain
		 * @return {boolean}    true if intersects, false if distinct
		 */
		function overlaps(chain1, chain2)
		{
			var overlap = true;

			if (chain1.mergedAlignment.uniprotFrom >= chain2.mergedAlignment.uniprotTo ||
			    chain2.mergedAlignment.uniprotFrom >= chain1.mergedAlignment.uniprotTo)
			{
				// no conflict
				overlap = false;
			}

			return overlap;
		}

		/**
		 * Creates a sorted array of chain datum (a {pdbId, PdbChainModel} pair).
		 * The highest ranked chain will be the first element of the returned
		 * data array.
		 *
		 * @param pdbColl   a PdbCollection instance
		 * @return {Array}  an array of <pdb id, PdbChainModel> pairs
		 */
		function sortChainsDesc(pdbColl)
		{
			var chains = [];

			// put all chains in a single array
			pdbColl.each(function(pdb, idx) {
				// create rectangle(s) for each chain
				pdb.chains.each(function(chain, idx) {
					var datum = {pdbId: pdb.pdbId, chain: chain};
					chains.push(datum);
				});
			});

			// rank the chains
			sortChains(chains, [
				compareIdentity, // first, sort by identity
				compareMergedLength, // then by length
				compareIdentityPerc, // then by identity percentage
				comparePdbId, // then by pdb id (A-Z)
				compareChainId // then by chain id (A-Z)
			]);

			return chains;
		}

		/**
		 * Sort chains wrt the given comparator functions.
		 *
		 * @param chains        an array of PDB chain data
		 * @param comparators   an array of comparator functions
		 */
		function sortChains(chains, comparators)
		{
			// compare using given comparator functions
			chains.sort(function(a, b) {
				var result = 0;

				// continue to compare until the result is different than zero
				for (var i=0;
				     i < comparators.length && result == 0;
				     i++)
				{
					var fn = comparators[i];
					result = fn(a, b);
				}

				return result;
			});
		}

		function chainKey(pdbId, chainId)
		{
			return pdbId + ":" + chainId;
		}

		function compareIdentity(a, b)
		{
			// higher value should comes first
			return (b.chain.mergedAlignment.identity -
			        a.chain.mergedAlignment.identity);
		}

		function compareIdentityPerc(a, b)
		{
			// higher value should comes first
			return (b.chain.mergedAlignment.identityPerc -
			        a.chain.mergedAlignment.identityPerc);
		}

		function compareMergedLength(a, b)
		{
			// longer string should comes first in the sorted array
			return (b.chain.mergedAlignment.mergedString.length -
			        a.chain.mergedAlignment.mergedString.length);
		}

		function comparePdbId(a, b)
		{
			// A-Z sort
			if (b.pdbId > a.pdbId) {
				return -1;
			} else if (b.pdbId < a.pdbId) {
				return 1;
			} else {
				return 0;
			}

			//return (a.pdbId - b.pdbId);
		}

		function compareChainId(a, b)
		{
			// A-Z sort
			if (b.chain.chainId > a.chain.chainId) {
				return -1;
			} else if (b.chain.chainId < a.chain.chainId) {
				return 1;
			} else {
				return 0;
			}

			//return (a.chain.chainId - b.chain.chainId);
		}

		function compareEValue(a, b)
		{
			// lower e value should comes first in the sorted array
			return (getMinValue(a.chain.alignments, "eValue") -
			        getMinValue(b.chain.alignments, "eValue"));
		}

		function compareIdentP(a, b)
		{
			// higher percentage should comes first in the sorted array
			return (getMinValue(b.chain.alignments, "identityPerc") -
			        getMinValue(a.chain.alignments, "identityPerc"));
		}

		/**
		 * Calculates total number of chains for the given PDB data.
		 *
		 * @param data      PDB data (collection of PdbModel instances)
		 * @return {number} total number of chains
		 */
		function calcChainCount(data)
		{
			var chainCount = 0;

			data.each(function(pdb, idx) {
				chainCount += pdb.chains.length;
			});

			return chainCount;
		}

		function getMinValue(alignments, field)
		{
			var min = Infinity;

			alignments.each(function(ele, idx) {
				if (ele[field] < min)
				{
					min = ele[field];
				}
			});

			return min;
		}

		function getMaxValue(alignments, field)
		{
			var max = -Infinity;

			alignments.each(function(ele, idx) {
				if (ele[field] > max)
				{
					max = ele[field];
				}
			});

			return max;
		}

		return {
			// public constants
			ALIGNMENT_GAP: ALIGNMENT_GAP,
			ALIGNMENT_PLUS: ALIGNMENT_PLUS,
			ALIGNMENT_MINUS: ALIGNMENT_MINUS,
			ALIGNMENT_SPACE: ALIGNMENT_SPACE,
			// public functions
			alignmentString: alignmentString,
			processPdbData: processPdbData,
			mutationToPdb: mutationToPdb,
			addPdbMatchData: addPdbMatchData,
			allocateChainRows: allocateChainRows,
			mergeAlignments: mergeAlignments,
			generatePdbInfoSummary: generatePdbInfoSummary,
			getOrganism: getOrganism,
			chainKey: chainKey
		};
	})();

	module.exports = PdbDataUtil;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var Backbone = __webpack_require__(12);

	var PdbAlignmentModel = Backbone.Model.extend({
		initialize: function(attributes) {
			this.alignmentId = attributes.alignmentId;
			this.pdbId = attributes.pdbId;
			this.chain = attributes.chain;
			this.uniprotId = attributes.uniprotId;
			this.pdbFrom = attributes.pdbFrom;
			this.pdbTo = attributes.pdbTo;
			this.uniprotFrom = attributes.uniprotFrom;
			this.uniprotTo = attributes.uniprotTo;
			this.alignmentString = attributes.alignmentString;
			this.eValue = attributes.eValue;
			this.identityPerc = attributes.identityPerc;
		}
	});

	module.exports = PdbAlignmentModel;

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_12__;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var PdbAlignmentCollection = __webpack_require__(14);

	var Backbone = __webpack_require__(12);

	/**
	 * PDB Chain Model.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var PdbChainModel = Backbone.Model.extend({
		initialize: function(attributes) {
			// chain id (A, B, C, X, etc.)
			this.chainId = attributes.chainId;
			//  map of (mutation id, pdb position) pairs
			this.positionMap = attributes.positionMap;
			// collection of PdbAlignmentModel instances
			this.alignments = new PdbAlignmentCollection(attributes.alignments);
			// summary of all alignments (merged alignments)
			this.mergedAlignment = attributes.mergedAlignment;
		}
	});

	module.exports = PdbChainModel;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone = __webpack_require__(12);
	var PdbAlignmentModel = __webpack_require__(11);

	/**
	 * Collection of pdb alignment data (PdbAlignmentModel instances).
	 */
	var PdbAlignmentCollection = Backbone.Collection.extend({
		model: PdbAlignmentModel,
		initialize: function(options) {
			// TODO add & set attributes if required
		}
	});

	module.exports = PdbAlignmentCollection;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var PdbChainCollection = __webpack_require__(16);

	var Backbone = __webpack_require__(12);

	/**
	 * PDB data model.
	 *
	 * Contains PDB id and a chain list.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var PdbModel = Backbone.Model.extend({
		initialize: function(attributes) {
			// pdb id (e.g: 1d5r)
			this.pdbId = attributes.pdbId;
			// collection of PdbChainModel instances
			this.chains = new PdbChainCollection(attributes.chains);
		}
	});

	module.exports = PdbModel;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone = __webpack_require__(12);
	var PdbChainModel = __webpack_require__(13);

	/**
	 * Collection of pdb data (PdbModel instances).
	 */
	var PdbChainCollection = Backbone.Collection.extend({
		model: PdbChainModel,
		initialize: function(options) {
			// TODO add & set attributes if required
		}
	});

	module.exports = PdbChainCollection;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone = __webpack_require__(12);
	var PdbModel = __webpack_require__(15);

	/**
	 * Collection of pdb data (PdbModel instances).
	 */
	var PdbCollection = Backbone.Collection.extend({
		model: PdbModel,
		initialize: function(options) {
			// TODO add & set attributes if required
		}
	});

	module.exports = PdbCollection;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var d3 = __webpack_require__(19);
	var _ = __webpack_require__(5);

	/**
	 * Singleton utility function for Pancancer Mutation Data.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var PancanMutationDataUtil = (function()
	{
		function munge(response, key)
		{
			// munge data to get it into the format: keyword -> corresponding datum
			return d3.nest()
				.key(function(d) {
					return d[key];
				})
				.entries(response)
				.reduce(function(acc, next) {
					acc[next.key] = next.values;
					return acc;
				},
				{});
		}

		function getMutationFrequencies(data)
		{
			var frequencies = {};

			_.each(_.keys(data), function(key, i) {
				frequencies = _.extend(frequencies, munge(data[key], key));
			});

			return frequencies;
		}

		/**
		 * Counts number of total mutations for the given frequencies and key.
		 *
		 * @param frequencies   pancan mutation frequencies
		 * @param key           key (keyword, gene symbol or protein change)
		 * @returns {Object}    mutation count
		 */
		function countByKey(frequencies, key)
		{
			var data = frequencies[key];

			return _.reduce(data, function(acc, next) {
				return acc + next.count;
			}, 0);
		}

		return {
			getMutationFrequencies: getMutationFrequencies,
			countByKey: countByKey
		};
	})();

	module.exports = PancanMutationDataUtil;

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_19__;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2016 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);
	var Backbone = __webpack_require__(12);

	/**
	 * A simple queue implementation for serializing requests.
	 *
	 * @author Selcuk Onur Sumer
	 */
	function RequestQueue(options)
	{
		var self = this;

		var _defaultOpts = {
			completeEvent: "requestQueueProcessComplete",
			newRequestEvent: "requestQueueNewRequest"
		};

		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		var _queryQueue = [];
		var _queryInProgress = false;
		var _dispatcher = {};
		_.extend(_dispatcher, Backbone.Events);

		/**
		 * Initializes the queue with the provided process function.
		 *
		 * @param processFn function to be invoked to process queue elements
		 */
		function init(processFn)
		{
			_dispatcher.on(_options.newRequestEvent, function() {
				// no query in progress, ready to consume
				if (!_queryInProgress)
				{
					processQueue(processFn);
				}
			});

			_dispatcher.on(_options.completeEvent, function() {
				processQueue(processFn);
			});
		}

		// TODO find an efficient way to avoid hitting the server more than once
		// for the exact same simultaneous query

		/**
		 * Processes the queue by invoking the given process function
		 * for the current element in the queue.
		 *
		 * @param processFn function to process the queue element
		 */
		function processQueue(processFn)
		{
			// get the first element from the queue
			var element = _.first(_queryQueue);
			_queryQueue = _.rest(_queryQueue);

			// still elements in queue
			if (element)
			{
				_queryInProgress = element;

				if (_.isFunction(processFn))
				{
					processFn(element);
				}
			}
			// no more query to process
			else
			{
				_queryInProgress = false;
			}
		}

		/**
		 * Function to be invoked upon completion of the process of a queue element.
		 */
		function complete()
		{
			_queryInProgress = false;
			_dispatcher.trigger(_options.completeEvent);
		}

		/**
		 * Adds a new element into the queue, and triggers a new request event.
		 *
		 * @param element   a new queue element
		 */
		function add(element)
		{
			_queryQueue.push(element);
			_dispatcher.trigger(_options.newRequestEvent);
		}

		self.add = add;
		self.complete = complete;
		self.init = init;
	}

	module.exports = RequestQueue;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDetailsEvents = __webpack_require__(22);
	var BackboneTemplateCache = __webpack_require__(23);

	var loaderImage = __webpack_require__(85);

	var cbio = {
		util: __webpack_require__(6)
	};

	var Backbone = __webpack_require__(12);
	var _ = __webpack_require__(5);
	var $ = __webpack_require__(7);
	var jQuery = $;
	//require('jquery-ui-css/core.css');
	//require('jquery-ui-css/tabs.css');
	//require('jquery-ui-css/theme.css');
	__webpack_require__(86);
	__webpack_require__(87);
	__webpack_require__(88);
	__webpack_require__(89);

	// TODO these should be included in a modular fashion in the corresponding components!
	__webpack_require__(90);
	__webpack_require__(91);
	__webpack_require__(95);
	__webpack_require__(97);
	__webpack_require__(99);
	__webpack_require__(101);
	__webpack_require__(103);
	__webpack_require__(105);

	/**
	 * Default mutation details view for the entire mutation details tab.
	 * Creates a separate MainMutationView (another Backbone view) for each gene.
	 *
	 * options: {el: [target container],
	 *           model: {mutationProxy: [mutation data proxy]}
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationDetailsView = Backbone.View.extend({
		initialize : function (options) {
			var defaultOpts = {
				config: {
					loaderImage: loaderImage,
					coreTemplate: "default_mutation_details_template",
					mainContentTemplate: "default_mutation_details_main_content_template",
					listContentTemplate: "default_mutation_details_list_content_template"
				}
			};

			this.options = jQuery.extend(true, {}, defaultOpts, options);

			this._3dPanelInitialized = false;

			// custom event dispatcher
			this.dispatcher = {};
			_.extend(this.dispatcher, Backbone.Events);
		},
		render: function() {
			var self = this;

			var content = self._generateContent();

			var variables = {loaderImage: self.options.config.loaderImage,
				listContent: content.listContent,
				mainContent: content.mainContent};

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn(self.options.config.coreTemplate);
			var template = templateFn(variables);

			// load the compiled HTML into the Backbone "el"
			self.$el.html(template);

			if (self.model.mutationProxy.hasData())
			{
				if (_.isFunction(self.options.config.init))
				{
					self.options.config.init(self);
				}
				else
				{
					// init default view, if no custom init function is provided
					self._initDefaultView();
				}
			}

			// format after render

			if (self.options.config.format)
			{
				self.options.config.format(self);
			}
			else
			{
				self.format();
			}
		},
		/**
		 * Formats the contents of the view after the initial rendering.
		 */
		format: function()
		{
			var self = this;

			if (self.model.mutationProxy.hasData())
			{
				var mainContent = self.$el.find(".mutation-details-content");
				mainContent.tabs();
				mainContent.tabs('paging', {tabsPerPage: 10, follow: true, cycle: false});
				mainContent.tabs("option", "active", 0);
				self.$el.find(".mutation-details-tabs-ref").tipTip(
					{defaultPosition: "bottom", delay:"100", edgeOffset: 10, maxWidth: 200});
			}
		},
		/**
		 * Refreshes the genes tab.
		 * (Intended to fix a resize problem with ui.tabs.paging plugin)
		 */
		refreshGenesTab: function()
		{
			// tabs("refresh") is problematic...
	//		var self = this;
	//		var mainContent = self.$el.find(".mutation-details-content");
	//		mainContent.tabs("refresh");

	        // just trigger the window resize event,
	        // rest is handled by the resize handler in ui.tabs.paging plugin.
			// it would be better to directly call the resize handler of the plugin,
			// but the function doesn't have public access...
			$(window).trigger('resize');
		},
		init3dPanel: function()
		{
			var self = this;

			self.dispatcher.trigger(
				MutationDetailsEvents.VIS_3D_PANEL_INIT);

			self._3dPanelInitialized = true;
		},
		is3dPanelInitialized: function()
		{
			var self = this;

			return self._3dPanelInitialized;
		},
		/**
		 * Generates the content structure by creating div elements for each
		 * gene.
		 *
		 * @return {Object} content backbone with div elements for each gene
		 */
		_generateContent: function()
		{
			var self = this;
			var mainContent = "";
			var listContent = "";

			// create a div for for each gene
			_.each(self.model.mutationProxy.getGeneList(), function(gene, idx) {
				var templateFn = BackboneTemplateCache.getTemplateFn(self.options.config.mainContentTemplate);

				mainContent += templateFn(
						{loaderImage: self.options.config.loaderImage,
							geneSymbol: gene,
							geneId: cbio.util.safeProperty(gene)});

				templateFn = BackboneTemplateCache.getTemplateFn(self.options.config.listContentTemplate);

				listContent += templateFn(
					{geneSymbol: gene,
						geneId: cbio.util.safeProperty(gene)});
			});

			return {mainContent: mainContent,
				listContent: listContent};
		},
		/**
		 * Initializes the mutation view for the current mutation data.
		 * Use this function if you want to have a default view of mutation
		 * details composed of different backbone views (by default params).
		 *
		 * If you want to have more customized components, it is better
		 * to initialize all the component separately.
		 */
		_initDefaultView: function()
		{
			var self = this;

			var contentSelector = self.$el.find(".mutation-details-content");

			// reset all previous tabs related listeners (if any)
			contentSelector.bind('tabscreate', false);
			contentSelector.bind('tabsactivate', false);

			// init view for the first gene only
			contentSelector.bind('tabscreate', function(event, ui) {
				// hide loader image
				self.$el.find(".mutation-details-loader").hide();

				// trigger corresponding event
				self.dispatcher.trigger(
					MutationDetailsEvents.GENE_TABS_CREATED);
			});

			// init other views upon selecting the corresponding tab
			contentSelector.bind('tabsactivate', function(event, ui) {
				// note: ui.index is replaced with ui.newTab.index() after jQuery 1.9
				//var gene = genes[ui.newTab.index()];

				// using index() causes problems with ui.tabs.paging plugin,
				// get the gene name directly from the html content
				var gene = ui.newTab.text().trim();

				// trigger corresponding event
				self.dispatcher.trigger(
					MutationDetailsEvents.GENE_TAB_SELECTED,
					gene);
			});
		}
	});

	module.exports = MutationDetailsView;

/***/ },
/* 22 */
/***/ function(module, exports) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	/**
	 * Singleton utility class to define custom events triggered by
	 * Mutation Details components.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationDetailsEvents = (function()
	{
		var _mutationSelected = "mutationDataSelected";
		var _mutationHighlighted = "mutationDataHighlighted";
		var _mutationFiltered = "mutationDataFiltered";

		var _lollipopSingleSelect = "mutationDiagramLollipopSingleSelect";
		var _lollipopMultiSelect = "mutationDiagramLollipopMultiSelect";
		var _lollipopSelected = "mutationDiagramLollipopSelected";
		var _lollipopDeselected = "mutationDiagramLollipopDeselected";
		var _allLollipopsDeselected = "mutationDiagramAllDeselected";
		var _lollipopMouseover = "mutationDiagramLollipopMouseover";
		var _lollipopMouseout = "mutationDiagramLollipopMouseout";
		var _mainViewInit = "mainMutationViewInit";
		var _diagramInit = "mutationDiagramInitialized";
		var _diagramPlotUpdated = "mutationDiagramPlotUpdated";
		var _diagramPlotReset = "mutationDiagramPlotReset";
		var _mutationTableFiltered = "mutationTableFiltered";
		var _mutationTableInitialized = "mutationTableInitialized";
		var _mutationTableRedrawn = "mutationTableRedrawn";
		var _mutationTableHeaderCreated = "mutationTableHeaderCreated";
		var _proteinChangeLinkClicked = "mutationTableProteinChangeLinkClicked";
		var _mutationTypeSelected = "infoPanelMutationTypeSelected";
		var _infoPanelInit = "infoPanelInit";
		var _pdbLinkClicked = "mutationTablePdbLinkClicked";
		var _pdbPanelResizeStarted = "mutationPdbPanelResizeStarted";
		var _pdbPanelResizeEnded = "mutationPdbPanelResizeEnded";
		var _panelChainSelected = "mutationPdbPanelChainSelected";
		var _tableChainSelected = "mutationPdbTableChainSelected";
		var _tableChainMouseout = "mutationPdbTableChainMouseout";
		var _tableChainMouseover = "mutationPdbTableChainMouseover";
		var _pdbTableReady = "mutationPdbTableReady";
		var _geneTabSelected = "mutationDetailsGeneTabSelected";
		var _geneTabsCreated = "mutationDetailsGeneTabsCreated";
		var _3dVisInit = "mutation3dPanelInit";
		var _3dVisCreated = "mutation3dPanelCreated";
		var _3dPanelClosed = "mutation3dPanelClosed";
		var _3dStructureReloaded = "mutation3dStructureReloaded";

		return {
			MUTATION_HIGHLIGHT: _mutationHighlighted,
			MUTATION_SELECT: _mutationSelected,
			MUTATION_FILTER: _mutationFiltered,
			LOLLIPOP_SINGLE_SELECT: _lollipopSingleSelect,
			LOLLIPOP_MULTI_SELECT: _lollipopMultiSelect,
			LOLLIPOP_SELECTED: _lollipopSelected,
			LOLLIPOP_DESELECTED: _lollipopDeselected,
			LOLLIPOP_MOUSEOVER: _lollipopMouseover,
			LOLLIPOP_MOUSEOUT: _lollipopMouseout,
			ALL_LOLLIPOPS_DESELECTED: _allLollipopsDeselected,
			MAIN_VIEW_INIT: _mainViewInit,
			DIAGRAM_INIT: _diagramInit,
			DIAGRAM_PLOT_UPDATED: _diagramPlotUpdated,
			DIAGRAM_PLOT_RESET: _diagramPlotReset,
			MUTATION_TABLE_INITIALIZED: _mutationTableInitialized,
			MUTATION_TABLE_FILTERED: _mutationTableFiltered,
			MUTATION_TABLE_REDRAWN: _mutationTableRedrawn,
			MUTATION_TABLE_HEADER_CREATED: _mutationTableHeaderCreated,
			PROTEIN_CHANGE_LINK_CLICKED: _proteinChangeLinkClicked,
			INFO_PANEL_MUTATION_TYPE_SELECTED: _mutationTypeSelected,
			INFO_PANEL_INIT: _infoPanelInit,
			PDB_LINK_CLICKED: _pdbLinkClicked,
			PDB_PANEL_RESIZE_STARTED: _pdbPanelResizeStarted,
			PDB_PANEL_RESIZE_ENDED: _pdbPanelResizeEnded,
			PANEL_CHAIN_SELECTED: _panelChainSelected,
			TABLE_CHAIN_SELECTED: _tableChainSelected,
			TABLE_CHAIN_MOUSEOUT: _tableChainMouseout,
			TABLE_CHAIN_MOUSEOVER: _tableChainMouseover,
			PDB_TABLE_READY: _pdbTableReady,
			GENE_TAB_SELECTED: _geneTabSelected,
			GENE_TABS_CREATED: _geneTabsCreated,
			VIS_3D_PANEL_INIT: _3dVisInit,
			VIS_3D_PANEL_CREATED: _3dVisCreated,
			VIEW_3D_STRUCTURE_RELOADED: _3dStructureReloaded,
			VIEW_3D_PANEL_CLOSED: _3dPanelClosed
		};
	})();

	module.exports = MutationDetailsEvents;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var $ = __webpack_require__(7);
	var _ = __webpack_require__(5);

	/**
	 * Singleton utility class to precompile & cache backbone templates.
	 * Using precompiled templates increases rendering speed dramatically.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var BackboneTemplateCache = (function () {
		var _cache = {};

		var _legacyIdMapping =
		{
			"3Dmol_basic_interaction": "3d/3Dmol_basic_interaction",
			"jsmol_basic_interaction": "3d/jsmol_basic_interaction",
			"mutation_3d_view_template": "3d/mutation_3d_view",
			"mutation_3d_vis_template": "3d/mutation_3d_vis",
			"mutation_3d_vis_info_template": "3d/mutation_3d_vis_info",
			"mutation_3d_non_protein_tip_template": "3d/non_protein_tip",
			"mutation_3d_side_chain_tip_template": "3d/side_chain_tip",
			"mutation_3d_structure_color_tip_template": "3d/structure_color_tip",
			"mutation_3d_type_color_tip_template": "3d/type_color_tip",
			"mutation_info_panel_template": "info_panel/info_panel",
			"mutation_info_panel_type_template": "info_panel/info_panel_type",
			"default_mutation_details_gene_info_template": "mutation_details/gene_info",
			"default_mutation_details_info_template": "mutation_details/info",
			"default_mutation_details_list_content_template": "mutation_details/list_content",
			"default_mutation_details_main_content_template": "mutation_details/main_content",
			"default_mutation_details_template": "mutation_details/mutation_details",
			"mutation_summary_view_template": "mutation_details/mutation_summary_view",
			"mutation_view_template": "mutation_details/mutation_view",
			"mutation_details_lollipop_tip_template": "mutation_diagram/lollipop_tip",
			"mutation_details_lollipop_tip_stats_template": "mutation_diagram/lollipop_tip_stats",
			"mutation_aligner_info_template": "mutation_diagram/mutation_aligner_info",
			"mutation_customize_panel_template": "mutation_diagram/mutation_customize_panel",
			"mutation_diagram_view_template": "mutation_diagram/mutation_diagram_view",
			"mutation_help_panel_template": "mutation_diagram/mutation_help_panel",
			"mutation_details_region_tip_template": "mutation_diagram/region_tip",
			"mutation_table_cancer_study_template": "mutation_table/cancer_study",
			"mutation_table_case_id_template": "mutation_table/case_id",
			"mutation_table_cbio_portal_template": "mutation_table/cbio_portal",
			"mutation_table_cna_template": "mutation_table/cna",
			"mutation_table_cosmic_template": "mutation_table/cosmic",
			"mutation_details_cosmic_tip_template": "mutation_table/cosmic_tip",
			"mutation_table_end_pos_template": "mutation_table/end_position",
			"mutation_details_fis_tip_template": "mutation_table/fis_tip",
			"mutation_table_igv_link_template": "mutation_table/igv_link",
			"mutation_table_mutation_assessor_template": "mutation_table/mutation_assessor",
			"mutation_table_mutation_count_template": "mutation_table/mutation_count",
			"mutation_table_mutation_status_template": "mutation_table/mutation_status",
			"mutation_details_table_template": "mutation_table/mutation_table",
			"mutation_table_placeholder_template": "mutation_table/mutation_table_placeholder",
			"mutation_table_mutation_type_template": "mutation_table/mutation_type",
			"mutation_table_normal_alt_count_template": "mutation_table/normal_alt_count",
			"mutation_table_normal_freq_template": "mutation_table/normal_freq",
			"mutation_table_normal_ref_count_template": "mutation_table/normal_ref_count",
			"pancan_mutation_hist_tip_template": "mutation_table/pancan_mutation_hist_tip",
			"mutation_table_protein_change_template": "mutation_table/protein_change",
			"mutation_table_start_pos_template": "mutation_table/start_position",
			"mutation_table_tumor_alt_count_template": "mutation_table/tumor_alt_count",
			"mutation_table_tumor_freq_template": "mutation_table/tumor_freq",
			"mutation_table_tumor_ref_count_template": "mutation_table/tumor_ref_count",
			"mutation_table_tumor_type_template": "mutation_table/tumor_type",
			"mutation_table_validation_status_template": "mutation_table/validation_status",
			"mutation_details_pdb_chain_tip_template": "pdb_panel/pdb_chain_tip",
			"mutation_details_pdb_help_tip_template": "pdb_panel/pdb_help_tip",
			"pdb_panel_view_template": "pdb_panel/pdb_panel_view",
			"mutation_pdb_table_chain_cell_template": "pdb_table/chain_cell",
			"mutation_pdb_table_pdb_cell_template": "pdb_table/pdb_cell",
			"pdb_table_view_template": "pdb_table/pdb_table_view",
			"mutation_pdb_table_summary_cell_template": "pdb_table/summary_cell"
		};

		// TODO not a good practice, templates should be required when needed
		// pre-compile existing templates
		_.each(_.keys(_legacyIdMapping), function(id) {
			_cache[id] = __webpack_require__(24)("./" + _legacyIdMapping[id] + ".html");
		});

		/**
		 * Compiles the template for the given template id
		 * by using underscore template function.
		 *
		 * @param templateId    html id of the template content
		 * @returns function    compiled template function
		 */
		function compileTemplate(templateId)
		{
			// this is for the moustache-like templates
			_.templateSettings = {
				interpolate : /\{\{(.+?)\}\}/g
			};

			return _.template($("#" + templateId).html());
		}

		/**
		 * Gets the template function corresponding to the given template id.
		 *
		 * @param templateId    html id of the template content
		 * @returns function    template function
		 */
		function getTemplateFn(templateId)
		{
			// try to use the cached value first
			var templateFn = _cache[templateId];

			// compile if not compiled yet
			if (templateFn == null)
			{
				templateFn = compileTemplate(templateId);
				_cache[templateId] = templateFn;
			}

			return templateFn;
		}

		return {
			getTemplateFn: getTemplateFn
		};
	})();

	module.exports = BackboneTemplateCache;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./3d/3Dmol_basic_interaction.html": 25,
		"./3d/jsmol_basic_interaction.html": 26,
		"./3d/mutation_3d_view.html": 27,
		"./3d/mutation_3d_vis.html": 28,
		"./3d/mutation_3d_vis_info.html": 29,
		"./3d/non_protein_tip.html": 30,
		"./3d/side_chain_tip.html": 31,
		"./3d/structure_color_tip.html": 32,
		"./3d/type_color_tip.html": 33,
		"./info_panel/info_panel.html": 34,
		"./info_panel/info_panel_type.html": 35,
		"./mutation_details/gene_info.html": 36,
		"./mutation_details/info.html": 37,
		"./mutation_details/list_content.html": 38,
		"./mutation_details/main_content.html": 39,
		"./mutation_details/mutation_details.html": 40,
		"./mutation_details/mutation_summary_view.html": 41,
		"./mutation_details/mutation_view.html": 42,
		"./mutation_diagram/lollipop_tip.html": 43,
		"./mutation_diagram/lollipop_tip_stats.html": 44,
		"./mutation_diagram/mutation_aligner_info.html": 45,
		"./mutation_diagram/mutation_customize_panel.html": 46,
		"./mutation_diagram/mutation_diagram_view.html": 47,
		"./mutation_diagram/mutation_help_panel.html": 48,
		"./mutation_diagram/region_tip.html": 49,
		"./mutation_table/cancer_study.html": 50,
		"./mutation_table/case_id.html": 51,
		"./mutation_table/cbio_portal.html": 52,
		"./mutation_table/cna.html": 53,
		"./mutation_table/cosmic.html": 54,
		"./mutation_table/cosmic_tip.html": 55,
		"./mutation_table/end_position.html": 56,
		"./mutation_table/fis_tip.html": 57,
		"./mutation_table/igv_link.html": 59,
		"./mutation_table/mutation_assessor.html": 60,
		"./mutation_table/mutation_count.html": 61,
		"./mutation_table/mutation_status.html": 62,
		"./mutation_table/mutation_table.html": 63,
		"./mutation_table/mutation_table_placeholder.html": 64,
		"./mutation_table/mutation_type.html": 65,
		"./mutation_table/normal_alt_count.html": 66,
		"./mutation_table/normal_freq.html": 67,
		"./mutation_table/normal_ref_count.html": 68,
		"./mutation_table/pancan_mutation_hist_tip.html": 69,
		"./mutation_table/protein_change.html": 70,
		"./mutation_table/start_position.html": 72,
		"./mutation_table/tumor_alt_count.html": 73,
		"./mutation_table/tumor_freq.html": 74,
		"./mutation_table/tumor_ref_count.html": 75,
		"./mutation_table/tumor_type.html": 76,
		"./mutation_table/validation_status.html": 77,
		"./pdb_panel/pdb_chain_tip.html": 78,
		"./pdb_panel/pdb_help_tip.html": 79,
		"./pdb_panel/pdb_panel_view.html": 80,
		"./pdb_table/chain_cell.html": 81,
		"./pdb_table/pdb_cell.html": 82,
		"./pdb_table/pdb_table_view.html": 83,
		"./pdb_table/summary_cell.html": 84
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 24;


/***/ },
/* 25 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class="mutation-3d-vis-help-close">\n    <a href="#"><b>&times;</b></a>\n</div>\n<h4>3D visualizer basic interaction</h4>\n<b>Zoom in/out:</b> Press and hold the SHIFT key and the left mouse button,\nand then move the mouse backward/forward.<br>\n<b>Pan:</b> Press and hold the CTRL key, click and hold the left mouse button,\nand then move the mouse in the desired direction.<br>\n<b>Rotate:</b> Press and hold the left mouse button, and then move the mouse in the desired\ndirection to rotate along the x and y axes.<br>';
	}
	return __p;
	};


/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class="mutation-3d-vis-help-close">\n    <a href="#"><b>&times;</b></a>\n</div>\n<h4>3D visualizer basic interaction</h4>\n<b>Zoom in/out:</b> Press and hold the SHIFT key and the left mouse button,\nand then move the mouse backward/forward.<br>\n<b>Pan:</b> Press and hold the SHIFT key, double click and hold the left mouse button,\nand then move the mouse in the desired direction.<br>\n<b>Rotate:</b> Press and hold the left mouse button, and then move the mouse in the desired\ndirection to rotate along the x and y axes. To be able to rotate along the z-axis, you need to\npress and hold the SHIFT key and the left mouse button, and then move the mouse left or right.<br>\n<b>Reset:</b> Press and hold the SHIFT key, and then double click on the background\nto reset the orientation and the zoom level to the initial state.\n';
	}
	return __p;
	};


/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<button class=\'mutation-3d-vis btn btn-default\'>\n    3D Structure &#187;\n</button>\n';
	}
	return __p;
	};


/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class=\'mutation-3d-vis-header\'>\n    <span class=\'mutation-3d-close ui-icon ui-icon-circle-close\' title=\'close\'></span>\n    <span class=\'mutation-3d-minimize ui-icon ui-icon-circle-minus\' title=\'minimize\'></span>\n    <div class=\'mutation-3d-info-title\'>\n        3D Structure\n    </div>\n</div>\n<div class=\'mutation-3d-vis-main-loader\'>\n    <img src=\''+
	((__t=(loaderImage))==null?'':__t)+
	'\' alt=\'Loading 3d visualization\' />\n</div>\n<div class=\'mutation-3d-vis-body\'>\n    <div class=\'mutation-3d-info\'></div>\n    <div class=\'mutation-3d-residue-warning\'>\n        <span class="mutation-3d-unmapped-info">Selected mutation</span>\n        cannot be mapped onto this structure.\n    </div>\n    <div class=\'mutation-3d-nomap-warning\'>\n        None of the mutations can be mapped onto this structure.\n    </div>\n    <div class=\'mutation-3d-vis-loader\'>\n        <img src=\''+
	((__t=(loaderImage))==null?'':__t)+
	'\' alt=\'Loading 3d visualization\' />\n    </div>\n    <div class=\'mutation-3d-vis-container\'></div>\n    <div class=\'mutation-3d-vis-toolbar\'>\n        <div class=\'mutation-3d-vis-help-init\'>\n            <table>\n                <tr>\n                    <td align="left">\n                        <button class=\'mutation-3d-pymol-dload\'>PyMOL</button>\n                    </td>\n                    <td align="right">\n                        <a class=\'mutation-3d-vis-help-open\' href="#">how to pan/zoom/rotate?</a>\n                    </td>\n                </tr>\n            </table>\n        </div>\n        <div class=\'mutation-3d-vis-help-content\'></div>\n        <table class="mutation-3d-controls-menu" cellpadding="0">\n            <tr>\n                <td class=\'mutation-3d-protein-style-menu\' valign=\'top\'>\n                    <div class=\'mutation-3d-style-header\'>\n                        <label>Protein Style</label>\n                    </div>\n                    <table cellpadding=\'0\'>\n                        <tr>\n                            <td>\n                                <label>\n                                    <input class=\'mutation-3d-display-non-protein\'\n                                           type=\'checkbox\'\n                                           checked=\'checked\'>\n                                    Display bound molecules\n                                </label>\n                                <img class=\'display-non-protein-help\' src=\''+
	((__t=(helpImage))==null?'':__t)+
	'\'\n                                     alt=\'Help (non-protein display)\' />\n                            </td>\n                        </tr>\n                        <tr>\n                            <td>\n                                <label>Scheme:</label>\n                                <select class=\'mutation-3d-protein-style-select\'\n                                        title=\'Select 3d protein style\'>\n                                    <option value=\'cartoon\'\n                                            title=\'Switch to the Cartoon Scheme\'>cartoon</option>\n                                    <option value=\'spaceFilling\'\n                                            title=\'Switch to the Space-filling Scheme\'>space-filling</option>\n                                    <option value=\'trace\'\n                                            title=\'Switch to the Trace Scheme\'>trace</option>\n                                </select>\n                            </td>\n                        </tr>\n                        <tr>\n                            <td>\n                                <label>Color:</label>\n                                <select class=\'mutation-3d-protein-color-select\'\n                                        title=\'Select 3d protein coloring\'>\n                                    <option value=\'uniform\'\n                                            title=\'Uniform Color\'>uniform</option>\n                                    <option value=\'bySecondaryStructure\'\n                                            title=\'Color by Secondary Structure\'>secondary structure</option>\n                                    <option value=\'byChain\'\n                                            title=\'Color by Rainbow Gradient\'>N-C rainbow</option>\n                                    <option value=\'byAtomType\'\n                                            title=\'Color by Atom Type\'\n                                            disabled=\'disabled\'>atom type</option>\n                                </select>\n                                <img class=\'protein-struct-color-help\' src=\''+
	((__t=(helpImage))==null?'':__t)+
	'\'\n                                     alt=\'Help (protein coloring)\' />\n                            </td>\n                        </tr>\n                    </table>\n                </td>\n                <td class=\'mutation-3d-mutation-style-menu\' valign=\'top\'>\n                    <div class=\'mutation-3d-style-header\'>\n                        <label>Mutation Style</label>\n                    </div>\n                    <table cellpadding="0">\n                        <tr>\n                            <td>\n                                <!--label>\n                                    <input class=\'mutation-3d-side-chain\'\n                                           type=\'checkbox\'\n                                           checked=\'checked\'>\n                                    Display side chain\n                                </label-->\n                                <label>Side chain:</label>\n                                <select class=\'mutation-3d-side-chain-select\'\n                                        title=\'Select 3d protein side-chain display\'>\n                                    <option value=\'all\'\n                                            title=\'Display side chain for all mapped residues\'>all</option>\n                                    <option value=\'highlighted\'\n                                            selected=\'selected\'\n                                            title=\'Display side chain for highlighted residues only\'>selected</option>\n                                    <option value=\'none\'\n                                            title=\'Do not display side chains\'>none</option>\n                                </select>\n                                <img class=\'display-side-chain-help\' src=\''+
	((__t=(helpImage))==null?'':__t)+
	'\'\n                                     alt=\'Help (side chain display)\' />\n                            </td>\n                        </tr>\n                        <tr>\n                            <td>\n                                <label>Color:</label>\n                                <select class=\'mutation-3d-mutation-color-select\'\n                                        title=\'Select 3d protein mutation color\'>\n                                    <option value=\'uniform\'\n                                            title=\'Uniform color\'>uniform</option>\n                                    <option value=\'byMutationType\'\n                                            selected=\'selected\'\n                                            title=\'Color by mutation type\'>mutation type</option>\n                                    <option value=\'none\'\n                                            title=\'Do not color\'>none</option>\n                                </select>\n                                <img class=\'mutation-type-color-help\' src=\''+
	((__t=(helpImage))==null?'':__t)+
	'\'\n                                     alt=\'Help (mutation type coloring)\' />\n                            </td>\n                        </tr>\n                    </table>\n                </td>\n            </tr>\n        </table>\n    </div>\n</div>\n';
	}
	return __p;
	};


/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class=\'mutation-3d-info-main\'>\n    PDB\n    <span class=\'mutation-3d-pdb-id\'>\n        <a href="http://www.rcsb.org/pdb/explore/explore.do?structureId='+
	((__t=(pdbId))==null?'':__t)+
	'"\n           target="_blank">\n            '+
	((__t=(pdbId))==null?'':__t)+
	'\n        </a>\n    </span>\n    <span class=\'mutation-3d-pdb-info\'>: '+
	((__t=(pdbInfo))==null?'':__t)+
	'</span><br>\n    Chain\n    <span class=\'mutation-3d-chain-id\'>'+
	((__t=(chainId))==null?'':__t)+
	'</span>\n    <span class=\'mutation-3d-mol-info\'>: '+
	((__t=(molInfo))==null?'':__t)+
	'</span>\n</div>';
	}
	return __p;
	};


/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='Displays co-crystalized molecules.\nThis option has no effect if the current structure does not contain any co-crystalized bound molecules.\n';
	}
	return __p;
	};


/***/ },
/* 31 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='Display options for the side chain atoms.<br>\n<br>\n<b>All:</b> Displays the side chain atoms for every mapped residue.<br>\n<b>Selected:</b> Displays the side chain atoms only for the selected mutations.<br>\n<b>None:</b> Hides the side chain atoms.<br>\n<br>\nThis option has no effect for the space-filling protein scheme.';
	}
	return __p;
	};


/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='Color options for the protein structure.<br>\n<br>\n<b>Uniform:</b> Colors the entire protein structure with a\n<span class=\'mutation-3d-loop\'>single color</span>.<br>\n<b>Secondary structure:</b> Colors the protein by secondary structure.\nAssigns different colors for <span class=\'mutation-3d-alpha-helix\'>alpha helices</span>,\n<span class=\'mutation-3d-beta-sheet\'>beta sheets</span>, and\n<span class=\'mutation-3d-loop\'>loops</span>.\nThis color option is not available for the space-filling protein scheme.<br>\n<b>N-C rainbow:</b> Colors the protein with a rainbow gradient\nfrom red (N-terminus) to blue (C-terminus).<br>\n<b>Atom Type:</b> Colors the structure with respect to the atom type (CPK color scheme).\nThis color option is only available for the space-filling protein scheme.<br>\n<br>\nThe selected chain is always displayed with full opacity while the rest of the structure\nhas some transparency to help better focusing on the selected chain.\n';
	}
	return __p;
	};


/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='Color options for the mapped mutations.<br>\n<br>\n<b>Uniform:</b> Colors all mutated residues with a\n<span class=\'uniform_mutation\'>single color</span>.<br>\n<b>Mutation type:</b> Enables residue coloring by mutation type.\nMutation types and corresponding color codes are as follows:\n<ul>\n    <li><span class=\'missense_mutation\'>Missense Mutations</span></li>\n    <li><span class=\'trunc_mutation\'>Truncating Mutations</span>\n        (Nonsense, Nonstop, FS del, FS ins)</li>\n    <li><span class=\'inframe_mutation\'>Inframe Mutations</span>\n        (IF del, IF ins)</li>\n</ul>\n<b>None:</b> Disables coloring of the mutated residues\nexcept for manually selected (highlighted) residues.<br>\n<br>\nHighlighted residues are colored with <span class=\'mutation-3d-highlighted\'>yellow</span>.\n';
	}
	return __p;
	};


/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class="mutation-info-panel-content">\n    <div class="mutation-info-panel-mutation-type">\n        '+
	((__t=(mutationTypeContent))==null?'':__t)+
	'\n    </div>\n</div>';
	}
	return __p;
	};


/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\'mutation-type-info\'>\n    <span class="mutation-type-info-link" alt=\''+
	((__t=(mutationType))==null?'':__t)+
	'\'>\n        <span class=\'mutation-type-count '+
	((__t=(countStyle))==null?'':__t)+
	'\'>'+
	((__t=(count))==null?'':__t)+
	'</span>\n        <span class=\'mutation-type-label '+
	((__t=(textStyle))==null?'':__t)+
	'\'>'+
	((__t=(type))==null?'':__t)+
	'</span>\n    </span>\n</span>';
	}
	return __p;
	};


/***/ },
/* 36 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<p>There are no mutation details available for this gene.</p>\n<br>\n<br>';
	}
	return __p;
	};


/***/ },
/* 37 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<p>There are no mutation details available for the gene set entered.</p>\n<br>\n<br>';
	}
	return __p;
	};


/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<li>\n    <a href="#mutation_details_'+
	((__t=(geneId))==null?'':__t)+
	'"\n       class="mutation-details-tabs-ref"\n       title="'+
	((__t=(geneSymbol))==null?'':__t)+
	' mutations">\n        <span>'+
	((__t=(geneSymbol))==null?'':__t)+
	'</span>\n    </a>\n</li>';
	}
	return __p;
	};


/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div id=\'mutation_details_'+
	((__t=(geneId))==null?'':__t)+
	'\'>\n    <img src=\''+
	((__t=(loaderImage))==null?'':__t)+
	'\' alt=\'Loading mutation details for gene\' />\n</div>';
	}
	return __p;
	};


/***/ },
/* 40 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class=\'mutation-3d-container\'></div>\n<div class=\'mutation-details-loader\'>\n    <img src=\''+
	((__t=(loaderImage))==null?'':__t)+
	'\' alt=\'Loading mutation details\' />\n</div>\n<div class=\'mutation-details-content\'>\n    <ul>\n        '+
	((__t=(listContent))==null?'':__t)+
	'\n    </ul>\n    '+
	((__t=(mainContent))==null?'':__t)+
	'\n</div>';
	}
	return __p;
	};


/***/ },
/* 41 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<h4>'+
	((__t=(geneSymbol))==null?'':__t)+
	': '+
	((__t=(mutationSummary))==null?'':__t)+
	'</h4>';
	}
	return __p;
	};


/***/ },
/* 42 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class=\'mutation-summary-view\'></div>\n<div>\n    <table>\n        <tr>\n            <td>\n                <div class=\'mutation-diagram-view\'></div>\n            </td>\n            <td valign="bottom">\n                <div class="mutation-3d-initializer"></div>\n            </td>\n        </tr>\n    </table>\n</div>\n<div class="mutation-pdb-panel-view"></div>\n<div class=\'mutation-details-no-data-info\'>\n    There are no '+
	((__t=(geneSymbol))==null?'':__t)+
	' mutations in the selected samples.\n</div>\n<div class=\'mutation-info-panel-container\'></div>\n<div class=\'mutation-details-filter-info\'>\n    Current view shows filtered results.\n    Click <a class=\'mutation-details-filter-reset\'>here</a> to reset all filters.\n</div>\n<div class=\'mutation-table-container\'></div>';
	}
	return __p;
	};


/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div>\n    <div class=\'diagram-lollipop-tip\'>\n        <b>'+
	((__t=(count))==null?'':__t)+
	' '+
	((__t=(mutationStr))==null?'':__t)+
	'</b>\n        <br/>AA Change: '+
	((__t=(label))==null?'':__t)+
	'\n        <div class="lollipop-stats">\n            <table>\n                <thead>\n                <tr>\n                    <th>Cancer Type</th>\n                    <th>Count</th>\n                </tr>\n                </thead>\n                <tbody>\n                </tbody>\n            </table>\n        </div>\n    </div>\n</div>';
	}
	return __p;
	};


/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<tr>\n    <td>'+
	((__t=(cancerType))==null?'':__t)+
	'</td>\n    <td>'+
	((__t=(count))==null?'':__t)+
	'</td>\n</tr>';
	}
	return __p;
	};


/***/ },
/* 45 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<a href="'+
	((__t=(linkToMutationAligner))==null?'':__t)+
	'" target="_blank">Mutation Aligner</a>';
	}
	return __p;
	};


/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class="diagram-customize-close">\n    <a href="#">&times;</a>\n</div>\n<h4>Customize</h4>\n<table>\n    <tr>\n        <td>\n            <div class="diagram-y-axis-slider-area">\n                <div class="diagram-slider-title"><label>max y-axis value</label></div>\n                <table>\n                    <tr>\n                        <td width="90%" valign="top">\n                            <div class="diagram-y-axis-slider"></div>\n                            <span class="diagram-slider-min-label">'+
	((__t=(minY))==null?'':__t)+
	'</span>\n                            <span class="diagram-slider-max-label">'+
	((__t=(maxY))==null?'':__t)+
	'</span>\n                        </td>\n                        <td valign="top">\n                            <input class="diagram-y-axis-limit-input" size="2" type=\'text\'>\n                        </td>\n                    </tr>\n                </table>\n            </div>\n        </td>\n    </tr>\n</table>';
	}
	return __p;
	};


/***/ },
/* 47 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class=\'mutation-diagram-toolbar\'>\n    <a href=\'http://www.uniprot.org/uniprot/'+
	((__t=(uniprotId))==null?'':__t)+
	'\'\n       class=\'mutation-details-uniprot-link\'\n       target=\'_blank\'>'+
	((__t=(uniprotId))==null?'':__t)+
	'</a>\n    <span class=\'mutation-diagram-toolbar-buttons\'>\n        <button class=\'diagram-to-pdf\'>PDF</button>\n        <button class=\'diagram-to-svg\'>SVG</button>\n        <button class="diagram-customize">Customize</button>\n        <button class="diagram-help">Color Codes</button>\n    </span>\n</div>\n<div class="mutation-diagram-help ui-widget"></div>\n<div class="mutation-diagram-customize ui-widget"></div>\n<div class=\'mutation-diagram-container\'></div>';
	}
	return __p;
	};


/***/ },
/* 48 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class="diagram-help-close">\n    <a href="#">&times;</a>\n</div>\n<h4>Color Codes</h4>\n<div>\n    Mutation diagram circles are colored with respect to\n    the corresponding mutation types. In case of different mutation<br>\n    types at a single position, color of the circle is determined\n    with respect to the most frequent mutation type.<br><br>\n    Mutation types and corresponding color codes are as follows:\n    <ul>\n        <li><span class=\'missense_mutation\'>Missense Mutations</span></li>\n        <li><span class=\'trunc_mutation\'>Truncating Mutations</span>\n            : Nonsense, Nonstop, Frameshift deletion, Frameshift insertion, Splice site</li>\n        <li><span class=\'inframe_mutation\'>Inframe Mutations</span>\n            : Inframe deletion, Inframe insertion</li>\n        <li><span class=\'other_mutation\'>Other Mutations</span>\n            : All other types of mutations</li>\n    </ul>\n</div>';
	}
	return __p;
	};


/***/ },
/* 49 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class="diagram-region-tip">\n    <div>'+
	((__t=(identifier))==null?'':__t)+
	' '+
	((__t=(type))==null?'':__t)+
	', '+
	((__t=(description))==null?'':__t)+
	' ('+
	((__t=(start))==null?'':__t)+
	' - '+
	((__t=(end))==null?'':__t)+
	')</div>\n    <div>\n        <a href="http://pfam.xfam.org/family/'+
	((__t=(pfamAccession))==null?'':__t)+
	'" class="diagram-pfam-link" target="_blank">PFAM</a>\n        '+
	((__t=(mutationAlignerInfo))==null?'':__t)+
	'\n    </div>\n</div>';
	}
	return __p;
	};


/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<a href=\''+
	((__t=(cancerStudyLink))==null?'':__t)+
	'\' target=\'_blank\'>\n    <b title="'+
	((__t=(cancerStudy))==null?'':__t)+
	'"\n       alt="'+
	((__t=(cancerStudy))==null?'':__t)+
	'"\n       class="cc-short-study-name simple-tip">'+
	((__t=(cancerStudyShort))==null?'':__t)+
	'</b>\n</a>';
	}
	return __p;
	};


/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<a href=\''+
	((__t=(linkToPatientView))==null?'':__t)+
	'\' target=\'_blank\'>\n    <b alt="'+
	((__t=(caseIdTip))==null?'':__t)+
	'"\n       class="'+
	((__t=(caseIdClass))==null?'':__t)+
	'">'+
	((__t=(caseId))==null?'':__t)+
	'</b>\n</a>';
	}
	return __p;
	};


/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(portalClass))==null?'':__t)+
	'\'>'+
	((__t=(portalFrequency))==null?'':__t)+
	'</span>';
	}
	return __p;
	};


/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span alt=\''+
	((__t=(cnaTip))==null?'':__t)+
	'\' class=\'simple-tip '+
	((__t=(cnaClass))==null?'':__t)+
	'\'>'+
	((__t=(cna))==null?'':__t)+
	'</span>\n';
	}
	return __p;
	};


/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(cosmicClass))==null?'':__t)+
	'\'>'+
	((__t=(cosmicCount))==null?'':__t)+
	'</span>';
	}
	return __p;
	};


/***/ },
/* 55 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class=\'cosmic-details-tip-info\'>\n    <b>'+
	((__t=(cosmicTotal))==null?'':__t)+
	' occurrences of '+
	((__t=(mutationKeyword))==null?'':__t)+
	' mutations in COSMIC</b>\n</div>\n<table class=\'cosmic-details-table display\'\n       cellpadding=\'0\' cellspacing=\'0\' border=\'0\'>\n    <thead>\n    <tr>\n        <th>COSMIC ID</th>\n        <th>Protein Change</th>\n        <th>Count</th>\n    </tr>\n    </thead>\n    <tbody>'+
	((__t=(cosmicDataRows))==null?'':__t)+
	'</tbody>\n</table>';
	}
	return __p;
	};


/***/ },
/* 56 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(endPosClass))==null?'':__t)+
	'\'>'+
	((__t=(endPos))==null?'':__t)+
	'</span>';
	}
	return __p;
	};


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='Predicted impact score: <b>'+
	((__t=(impact))==null?'':__t)+
	'</b>\n<div class=\'mutation-assessor-main-link mutation-assessor-link\'>\n    <a href=\''+
	((__t=(linkOut))==null?'':__t)+
	'\' target=\'_blank\'>\n        <img height=15 width=19 src=\'' + __webpack_require__(58) + '\'\n             alt=\'Mutation Assessor\' />\n        Go to Mutation Assessor\n    </a>\n</div>\n<div class=\'mutation-assessor-msa-link mutation-assessor-link\'>\n    <a href=\''+
	((__t=(msaLink))==null?'':__t)+
	'\' target=\'_blank\'>\n        <span class="ma-msa-icon">msa</span>\n        Multiple Sequence Alignment\n    </a>\n</div>\n<div class=\'mutation-assessor-3d-link mutation-assessor-link\'>\n    <a href=\''+
	((__t=(pdbLink))==null?'':__t)+
	'\' target=\'_blank\'>\n        <span class="ma-3d-icon">3D</span>\n        Mutation Assessor 3D View\n    </a>\n</div>';
	}
	return __p;
	};


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "images/ma.png";

/***/ },
/* 59 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<a href=\''+
	((__t=(igvLink))==null?'':__t)+
	'\' class=\'igv-link\'>\n    <span class="mutation-table-igv-icon">IGV</span>\n</a>';
	}
	return __p;
	};


/***/ },
/* 60 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(omaClass))==null?'':__t)+
	' '+
	((__t=(fisClass))==null?'':__t)+
	'\'>'+
	((__t=(fisText))==null?'':__t)+
	'</span>';
	}
	return __p;
	};


/***/ },
/* 61 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(mutationCountClass))==null?'':__t)+
	'\'>'+
	((__t=(mutationCount))==null?'':__t)+
	'</span>';
	}
	return __p;
	};


/***/ },
/* 62 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span alt=\''+
	((__t=(mutationStatusTip))==null?'':__t)+
	'\' class=\'simple-tip '+
	((__t=(mutationStatusClass))==null?'':__t)+
	'\'>\n	'+
	((__t=(mutationStatusText))==null?'':__t)+
	'\n</span>';
	}
	return __p;
	};


/***/ },
/* 63 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<table class=\'display mutation_details_table\' cellpadding=\'0\' cellspacing=\'0\' border=\'0\'></table>';
	}
	return __p;
	};


/***/ },
/* 64 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<img width=\''+
	((__t=(width))==null?'':__t)+
	'\' height=\''+
	((__t=(height))==null?'':__t)+
	'\' src=\''+
	((__t=(loaderImage))==null?'':__t)+
	'\' alt=\'Loading mutation table\' />\n';
	}
	return __p;
	};


/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(mutationTypeClass))==null?'':__t)+
	'\'>'+
	((__t=(mutationTypeText))==null?'':__t)+
	'</span>';
	}
	return __p;
	};


/***/ },
/* 66 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(normalAltCountClass))==null?'':__t)+
	'\'>'+
	((__t=(normalAltCount))==null?'':__t)+
	'</span>';
	}
	return __p;
	};


/***/ },
/* 67 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span alt=\'<b>'+
	((__t=(normalAltCount))==null?'':__t)+
	'</b> variant reads out of <b>'+
	((__t=(normalTotalCount))==null?'':__t)+
	'</b> total\'\n      class=\''+
	((__t=(normalFreqClass))==null?'':__t)+
	' '+
	((__t=(normalFreqTipClass))==null?'':__t)+
	'\'>'+
	((__t=(normalFreq))==null?'':__t)+
	'</span>\n';
	}
	return __p;
	};


/***/ },
/* 68 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(normalRefCountClass))==null?'':__t)+
	'\'>'+
	((__t=(normalRefCount))==null?'':__t)+
	'</span>';
	}
	return __p;
	};


/***/ },
/* 69 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div>\n    <div>\n        <h3>'+
	((__t=(gene))==null?'':__t)+
	' mutations across all cancer studies</h3>\n    </div>\n    <div style=\'float:right;\'>\n        <button class=\'cross-cancer-download\' file-type=\'pdf\'>PDF</button>\n        <button class=\'cross-cancer-download\' file-type=\'svg\'>SVG</button>\n    </div>\n</div>\n<div>\n    <p class="overall-count"></p>\n</div>\n<div class="pancan-histogram-container"></div>';
	}
	return __p;
	};


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(proteinChangeClass))==null?'':__t)+
	'\' alt=\''+
	((__t=(proteinChangeTip))==null?'':__t)+
	'\'>\n    <a>'+
	((__t=(proteinChange))==null?'':__t)+
	'</a>\n</span>\n<span class=\'mutation-table-additional-protein-change simple-tip\'\n      alt=\''+
	((__t=(additionalProteinChangeTip))==null?'':__t)+
	'\'>\n    <img height=12 width=12 style=\'opacity:0.2\' src=\'' + __webpack_require__(71) + '\' />\n</span>\n<a href=\''+
	((__t=(pdbMatchLink))==null?'':__t)+
	'\' class="mutation-table-3d-link">\n    <span class="mutation-table-3d-icon">3D</span>\n</a>\n';
	}
	return __p;
	};


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "images/warning.gif";

/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(startPosClass))==null?'':__t)+
	'\'>'+
	((__t=(startPos))==null?'':__t)+
	'</span>';
	}
	return __p;
	};


/***/ },
/* 73 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(tumorAltCountClass))==null?'':__t)+
	'\'>'+
	((__t=(tumorAltCount))==null?'':__t)+
	'</span>\n';
	}
	return __p;
	};


/***/ },
/* 74 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span alt=\'<b>'+
	((__t=(tumorAltCount))==null?'':__t)+
	'</b> variant reads out of <b>'+
	((__t=(tumorTotalCount))==null?'':__t)+
	'</b> total\'\n      class=\''+
	((__t=(tumorFreqClass))==null?'':__t)+
	' '+
	((__t=(tumorFreqTipClass))==null?'':__t)+
	'\'>'+
	((__t=(tumorFreq))==null?'':__t)+
	'</span>';
	}
	return __p;
	};


/***/ },
/* 75 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(tumorRefCountClass))==null?'':__t)+
	'\'>'+
	((__t=(tumorRefCount))==null?'':__t)+
	'</span>\n';
	}
	return __p;
	};


/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\''+
	((__t=(tumorTypeClass))==null?'':__t)+
	'\' alt=\''+
	((__t=(tumorTypeTip))==null?'':__t)+
	'\'>\n	'+
	((__t=(tumorType))==null?'':__t)+
	'\n</span>';
	}
	return __p;
	};


/***/ },
/* 77 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span alt=\''+
	((__t=(validationStatusTip))==null?'':__t)+
	'\' class="simple-tip '+
	((__t=(validationStatusClass))==null?'':__t)+
	'">\n	'+
	((__t=(validationStatusText))==null?'':__t)+
	'\n</span>';
	}
	return __p;
	};


/***/ },
/* 78 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\'pdb-chain-tip\'>\n	PDB\n	<a href="http://www.rcsb.org/pdb/explore/explore.do?structureId='+
	((__t=(pdbId))==null?'':__t)+
	'"\n	   target="_blank">\n		<b>'+
	((__t=(pdbId))==null?'':__t)+
	'</b>\n	</a>\n	<span class="chain-rectangle-tip-pdb-info">'+
	((__t=(pdbInfo))==null?'':__t)+
	'</span><br>\n	Chain <b>'+
	((__t=(chainId))==null?'':__t)+
	'</b>\n	<span class="chain-rectangle-tip-mol-info">'+
	((__t=(molInfo))==null?'':__t)+
	'</span>\n</span>';
	}
	return __p;
	};


/***/ },
/* 79 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class=\'pdb-chain-tip\'>\n	This panel displays a list of PDB chains for the corresponding uniprot ID.\n	PDB chains are ranked with respect to their sequence similarity ratio,\n	and aligned to the y-axis of the mutation diagram.\n	Highly ranked chains have darker color than the lowly ranked ones.<br>\n	<br>\n	Each chain is represented by a single rectangle.\n	Gaps within the chains are represented by a thin line connecting the segments of the chain.<br>\n	<br>\n	By default, only a first few rows are displayed.\n	To see more chains, use the scroll bar next to the panel.\n	To see the detailed list of all available PDB chains in a table\n	click on the link below the panel.<br>\n	<br>\n	To select a chain, simply click on it.\n	Selected chain is highlighted with a different frame color.\n	You can also select a chain by clicking on a row in the table.\n	Selecting a chain reloads the PDB data for the 3D structure visualizer.\n</span>';
	}
	return __p;
	};


/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<table class=\'mutation-pdb-main-container\'>\n    <tr>\n        <td valign="top">\n            <div class=\'mutation-pdb-panel-container\'></div>\n        </td>\n    </tr>\n    <tr>\n        <td valign="top" align="center">\n            <button class=\'expand-collapse-pdb-panel\'\n                    title=\'Expand/Collapse PDB Chains\'></button>\n        </td>\n    </tr>\n    <tr class=\'pdb-table-controls\'>\n        <td>\n            <span class="triangle triangle-right ui-icon ui-icon-triangle-1-e"></span>\n            <span class="triangle triangle-down ui-icon ui-icon-triangle-1-s"></span>\n            <a href="#" class=\'init-pdb-table\'>PDB Chain Table</a>\n        </td>\n    </tr>\n    <tr>\n        <td>\n            <div class=\'pdb-table-wrapper\'>\n                <div class="mutation-pdb-table-view"></div>\n            </div>\n        </td>\n    </tr>\n</table>';
	}
	return __p;
	};


/***/ },
/* 81 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<span class="pbd-chain-table-chain-cell">\n	<label>'+
	((__t=(chainId))==null?'':__t)+
	'</label>\n	<a href="#" class="pdb-table-3d-link">\n		<span alt="Click to update the 3D view with this chain"\n			  class="pdb-table-3d-icon">3D</span>\n	</a>\n</span>';
	}
	return __p;
	};


/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<a href="http://www.rcsb.org/pdb/explore/explore.do?structureId='+
	((__t=(pdbId))==null?'':__t)+
	'"\n   target="_blank"><b>'+
	((__t=(pdbId))==null?'':__t)+
	'</b></a>';
	}
	return __p;
	};


/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<div class=\'pdb-chain-table-loader\'>\n    <img src=\''+
	((__t=(loaderImage))==null?'':__t)+
	'\' alt=\'Loading chain table\' />\n</div>\n<table>\n    <tr>\n        <td valign="top" class=\'pdb-chain-table-container\'>\n            <table class=\'display pdb-chain-table\'\n                   cellpadding=\'0\' cellspacing=\'0\' border=\'0\'>\n            </table>\n        </td>\n        <td></td>\n    </tr>\n</table>';
	}
	return __p;
	};


/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = function(obj){
	var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
	with(obj||{}){
	__p+='<b>pdb:</b> '+
	((__t=(summary))==null?'':__t)+
	' <br>\n<b>chain:</b> '+
	((__t=(molecule))==null?'':__t)+
	'';
	}
	return __p;
	};


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "images/ajax-loader.gif";

/***/ },
/* 86 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_86__;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/*
	 * UI Tabs Paging extension - v1.2.2 (for jQuery 1.9.0 and jQuery UI 1.9.0)
	 *
	 * Copyright (c) 2013, http://seyfertdesign.com/jquery/ui-tabs-paging.html
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 * Depends:
	 *   jquery.ui.core.js
	 *   jquery.ui.widget.js
	 *   jquery.ui.tabs.js
	 */

	(function($) {

	//  overridden ui.tabs functions
	var uiTabsFuncs = {
		refresh: $.ui.tabs.prototype.refresh,
		option: $.ui.tabs.prototype.option
	};

	// DEPRECATED in jQuery UI 1.9
	if ( $.uiBackCompat !== false ) {
		uiTabsFuncs = $.extend(
				uiTabsFuncs,
				{
					add: $.ui.tabs.prototype.add,
					remove: $.ui.tabs.prototype.remove
				}
		);
	}

	$.extend($.ui.tabs.prototype, {
		paging: function(options) {
			var opts = {
				tabsPerPage: 0,       // Max number of tabs to display at one time.  0 automatically sizing.
				nextButton: '&#187;', // Text displayed for next button.
				prevButton: '&#171;', // Text displayed for previous button.
				follow: false,        // When clicking next button, automatically make first tab active.  When clicking previous button automatically make last tab active.
				cycle: false,         // When at end of list, next button returns to first page.  When at beginning of list previous button goes to end of list.
				activeOnAdd: false,   // When new tab is added, make tab active automatically
				followOnActive: false // When tab is changed to active, automatically go move to that tab group.
			};

			opts = $.extend(opts, options);

			var self = this, initialized = false, currentPage,
				buttonWidth, containerWidth, allTabsWidth, tabWidths,
				maxPageWidth, pages, resizeTimer = null,
				windowHeight, windowWidth;

			// initialize paging
			function init() {
				destroy();

				windowHeight = $(window).height();
				windowWidth = $(window).width();

				allTabsWidth = 0, currentPage = 0, maxPageWidth = 0, buttonWidth = 0,
					pages = new Array(), tabWidths = new Array(), selectedTabWidths = new Array();

				containerWidth = self.element.width();

				// loops through LIs, get width of each tab when selected and unselected.
				var maxDiff = 0;  // the max difference between a selected and unselected tab
				self.tabs.each(function(i) {
					if (i == self.options.active) {
						selectedTabWidths[i] = $(this).outerWidth(true);
						tabWidths[i] = self.tabs.eq(i).removeClass('ui-tabs-active').outerWidth(true);
						self.tabs.eq(i).addClass('ui-tabs-active');
						maxDiff = Math.min(maxDiff, Math.abs(selectedTabWidths[i] - tabWidths[i]));
						allTabsWidth += tabWidths[i];
					} else {
						tabWidths[i] = $(this).outerWidth(true);
						selectedTabWidths[i] = self.tabs.eq(i).addClass('ui-tabs-active').outerWidth(true);
						self.tabs.eq(i).removeClass('ui-tabs-active');
						maxDiff = Math.max(maxDiff, Math.abs(selectedTabWidths[i] - tabWidths[i]));
						allTabsWidth += tabWidths[i];
					}
				});

				// fix padding issues with buttons
				// TODO determine a better way to handle this
				allTabsWidth += maxDiff + 9;

				// if the width of all tables is greater than the container's width, calculate the pages
				if (allTabsWidth > containerWidth) {
					// create next button
					li = $('<li></li>')
						.addClass('ui-state-default ui-tabs-paging-next')
						.append($('<a href="#"></a>')
								.click(function() { page('next'); return false; })
								.html(opts.nextButton));

					self.tablist.append(li);
					buttonWidth = li.outerWidth(true);

					// create prev button
					li = $('<li></li>')
						.addClass('ui-state-default ui-tabs-paging-prev')
						.append($('<a href="#"></a>')
								.click(function() { page('prev'); return false; })
								.html(opts.prevButton));
					self.tablist.prepend(li);
					buttonWidth += li.outerWidth(true);

					// TODO determine fix for padding issues to next button
					buttonWidth += 19;

					var pageIndex = 0, pageWidth = 0, maxTabPadding = 0;

					// start calculating pageWidths
					for (var i = 0; i < tabWidths.length; i++) {
						// if first tab of page or selected tab's padding larger than the current max, set the maxTabPadding
						if (pageWidth == 0 || selectedTabWidths[i] - tabWidths[i] > maxTabPadding)
							maxTabPadding = (selectedTabWidths[i] - tabWidths[i]);

						// if first tab of page, initialize pages variable for page
						if (pages[pageIndex] == null) {
							pages[pageIndex] = { start: i };

						} else if ((i > 0 && (i % opts.tabsPerPage) == 0) || (tabWidths[i] + pageWidth + buttonWidth + 12) > containerWidth) {
							if ((pageWidth + maxTabPadding) > maxPageWidth)
								maxPageWidth = (pageWidth + maxTabPadding);
							pageIndex++;
							pages[pageIndex] = { start: i };
							pageWidth = 0;
						}
						pages[pageIndex].end = i+1;
						pageWidth += tabWidths[i];
						if (i == self.options.active) currentPage = pageIndex;
					}
					if ((pageWidth + maxTabPadding) > maxPageWidth)
						maxPageWidth = (pageWidth + maxTabPadding);

				    // hide all tabs then show tabs for current page
					self.tabs.hide().slice(pages[currentPage].start, pages[currentPage].end).show();
					if (currentPage == (pages.length - 1) && !opts.cycle)
						disableButton('next');
					if (currentPage == 0 && !opts.cycle)
						disableButton('prev');

					// calculate the right padding for the next button
					buttonPadding = containerWidth - maxPageWidth - buttonWidth;
					if (buttonPadding > 0)
						$('.ui-tabs-paging-next', self.element).css({ paddingRight: buttonPadding + 'px' });
				} else {
					destroy();
				}

				$(window).bind('resize', handleResize);

				initialized = true;
			}

			// handles paging forward and backward
			function page(direction) {
				currentPage = currentPage + (direction == 'prev'?-1:1);

				if ((direction == 'prev' && currentPage < 0 && opts.cycle) ||
					(direction == 'next' && currentPage >= pages.length && !opts.cycle))
					currentPage = pages.length - 1;
				else if ((direction == 'prev' && currentPage < 0) ||
						 (direction == 'next' && currentPage >= pages.length && opts.cycle))
					currentPage = 0;

				var start = pages[currentPage].start;
				var end = pages[currentPage].end;
				self.tabs.hide().slice(start, end).show();

				if (direction == 'prev') {
					enableButton('next');
					if (opts.follow && (self.options.active < start || self.options.active > (end-1))) self.option('active', end-1);
					if (!opts.cycle && start <= 0) disableButton('prev');
				} else {
					enableButton('prev');
					if (opts.follow && (self.options.active < start || self.options.active > (end-1))) self.option('active', start);
					if (!opts.cycle && end >= self.tabs.length) disableButton('next');
				}
			}

			// change styling of next/prev buttons when disabled
			function disableButton(direction) {
				$('.ui-tabs-paging-'+direction, self.element).addClass('ui-tabs-paging-disabled');
			}

			function enableButton(direction) {
				$('.ui-tabs-paging-'+direction, self.element).removeClass('ui-tabs-paging-disabled');
			}

			// special function defined to handle IE resize issues
			function handleResize() {
				if (resizeTimer) clearTimeout(resizeTimer);

				if (windowHeight != $(window).height() || windowWidth != $(window).width())
				{
					resizeTimer = setTimeout(init, 100);
				}
			}

			// remove all paging related changes and events
			function destroy() {
				// remove buttons
				$('.ui-tabs-paging-next', self.element).remove();
				$('.ui-tabs-paging-prev', self.element).remove();

				// show all tabs
				self.tabs.show();

				initialized = false;

				$(window).unbind('resize', handleResize);
			}



			// ------------- OVERRIDDEN PUBLIC FUNCTIONS -------------
			self.option = function(optionName, value) {
				var retVal = uiTabsFuncs.option.apply(this, [optionName, value]);

				// if "followOnActive" is true, then move page when selection changes
				if (optionName == "active")
				{
					// if paging is not initialized or it is not configured to
					// change pages when a new tab is active, then do nothing
					if (!initialized || !opts.followOnActive)
						return retVal;

					// find the new page based on index of the active tab
					for (var i in pages) {
						var start = pages[i].start;
						var end = pages[i].end;
						if (value >= start && value < end) {
							// if the the active tab is not within the currentPage of tabs, then change pages
							if (i != currentPage) {
								this.tabs.hide().slice(start, end).show();

								currentPage = parseInt(i);
								if (currentPage == 0) {
									enableButton('next');
									if (!opts.cycle && start <= 0) disableButton('prev');
								} else {
									enableButton('prev');
									if (!opts.cycle && end >= this.tabs.length) disableButton('next');
								}
							}
							break;
						}
					}
				}

				return retVal;
			}

			self.refresh = function() {
				if (initialized)
				{
					destroy();

					uiTabsFuncs.refresh.apply(this);

					// re-initialize paging buttons
					init();
				}

				uiTabsFuncs.refresh.apply(this);
			}


			// DEPRECATED in jQuery UI 1.9
			if ( $.uiBackCompat !== false )
			{
				// temporarily remove paging buttons before adding a tab
				self.add = function(url, label, index) {
					if (initialized)
					{
						destroy();

						uiTabsFuncs.add.apply(this, [url, label, index]);

						if (opts.activeOnAdd) {
							if (index == undefined) index = this.tabs.length-1;
							this.option('active', index);
						}
						// re-initialize paging buttons
						init();

						return this;
					}

					return uiTabsFuncs.add.apply(this, [url, label, index]);
				}

				// temporarily remove paging buttons before removing a tab
				self.remove = function(index) {
					if (initialized)
					{
						destroy();
						uiTabsFuncs.remove.apply(this, [index]);
						init();

						return this;
					}

					return uiTabsFuncs.remove.apply(this, [index]);
				}
			}


			// ------------- PUBLIC FUNCTIONS -------------
			$.extend($.ui.tabs.prototype, {
				// public function for removing paging
				pagingDestroy: function() {
					destroy();
					return this;
				},

				// public function to handle resizes that are not on the window
				pagingResize: function() {
					init();
					return this;
				}
			});

			// initialize on startup!
			init();
		}
	});


	})(jQuery);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 88 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_88__;

/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_89__;

/***/ },
/* 90 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_90__;

/***/ },
/* 91 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 96 */,
/* 97 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 98 */,
/* 99 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 100 */,
/* 101 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 102 */,
/* 103 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 104 */,
/* 105 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 106 */,
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var _ = __webpack_require__(5);

	/**
	 * Singleton utility class for data proxy related tasks.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var DataProxyUtil = (function()
	{
		/**
		 * Initializes data proxy instances for the given options.
		 *
		 * @param options   data proxy options (for all proxies)
		 */
		function initDataProxies(options)
		{
			// init proxies
			var dataProxies = {};

			// workaround: alphabetically sorting to ensure that mutationProxy is
			// initialized before pdpProxy, since pdbProxy depends on the mutationProxy instance
			_.each(_.keys(options).sort(), function(proxy) {
				var proxyOpts = options[proxy];
				var instance = null;

				// TODO see if it is possible to remove pdb proxy's dependency on mutation proxy

				// special initialization required for mutation proxy
				// and pdb proxy, so a custom function is provided
				// as an additional parameter to the initDataProxy function
				if (proxy == "pdbProxy")
				{
					instance = initDataProxy(proxyOpts, function(proxyOpts) {
						var mutationProxy = dataProxies["mutationProxy"];

						if (mutationProxy != null &&
						    mutationProxy.hasData())
						{
							proxyOpts.options.mutationUtil = mutationProxy.getMutationUtil();
							return true;
						}
						else
						{
							// do not initialize pdbProxy at all
							return false;
						}
					});
				}
				else
				{
					// regular init for all other proxies...
					instance = initDataProxy(proxyOpts);
				}

				dataProxies[proxy] = instance;
			});

			return dataProxies;
		}

		/**
		 *
		 * @param proxyOpts     data proxy options (for a single proxy)
		 * @param preProcessFn  [optional] pre processing function, should return a boolean value.
		 * @returns {Object}    a data proxy instance
		 */
		function initDataProxy(proxyOpts, preProcessFn)
		{
			// use the provided custom instance if available
			var instance = proxyOpts.instance;

			if (instance == null)
			{
				// custom pre process function for the proxy options
				// before initialization
				if (preProcessFn != null &&
				    _.isFunction(preProcessFn))
				{
					// if preprocess is not successful do not initialize
					if (!preProcessFn(proxyOpts))
					{
						return null;
					}
				}

				// init data proxy
				var Constructor = proxyOpts.instanceClass;
				instance = new Constructor(proxyOpts.options);
				instance.init();
			}

			return instance;
		}

		return {
			initDataProxies: initDataProxies,
			initDataProxy: initDataProxy
		};
	})();

	module.exports = DataProxyUtil;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var AbstractDataProxy = __webpack_require__(109);

	var $ = __webpack_require__(7);
	var jQuery = $;

	/**
	 * This class is designed to retrieve PFAM data on demand.
	 *
	 * @param options  additional options
	 *
	 * @author Selcuk Onur Sumer
	 */
	function PfamDataProxy(options)
	{
		var self = this;

		// default options
		var _defaultOpts = {
			servletName: "getPfamSequence.json"
		};

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		// call super constructor to init options and other params
		AbstractDataProxy.call(this, _options);
		_options = self._options;

		// map of <gene, data> pairs
		var _pfamDataCache = {};

		/**
		 * Initializes with full PFAM data. Once initialized with full data,
		 * this proxy class assumes that there will be no additional data.
		 *
		 * @param options   data proxy options
		 */
		function fullInit(options)
		{
			//assuming the given data is a map of <gene, sequence data> pairs
			_pfamDataCache = options.data;
		}

		function getPfamData(servletParams, callback)
		{
			// TODO allow more than one gene at a time? (see MutationDataProxy)
			var gene = servletParams.geneSymbol;

			if (gene == null)
			{
				// no gene symbol provided, nothing to retrieve
				callback(null);
				return;
			}

			// retrieve data from the server if not cached
			if (_pfamDataCache[gene] == undefined)
			{
				if (self.isFullInit())
				{
					callback(null);
					return;
				}

				// process & cache the raw data
				var processData = function(data) {
					_pfamDataCache[gene] = data;

					// forward the processed data to the provided callback function
					callback(data);
				};

				// retrieve data from the servlet
				var ajaxOpts = {
					type: "POST",
					url: _options.servletName,
					data: servletParams,
					success: processData,
					dataType: "json"
				};

				self.requestData(ajaxOpts);
			}
			else
			{
				// data is already cached, just forward it
				callback(_pfamDataCache[gene]);
			}
		}

		// override required base functions
		self.fullInit = fullInit;

		// class specific functions
		self.getPfamData = getPfamData;
	}

	// PdbDataProxy extends AbstractDataProxy...
	PfamDataProxy.prototype = new AbstractDataProxy();
	PfamDataProxy.prototype.constructor = PfamDataProxy;

	module.exports = PfamDataProxy;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var RequestQueue = __webpack_require__(20);

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);

	/**
	 * Base class for data proxy instances.
	 *
	 * @author Selcuk Onur Sumer
	 */
	function AbstractDataProxy(options)
	{
		var self = this;

		// default options
		self._defaultOpts = {
			initMode: "lazy", // "lazy" or "full"
			servletName: "",  // name of the servlet to retrieve the actual data (used for AJAX query)
			data: {}          // actual data, will be used only if it is a full init, i.e {initMode: "full"}
		};

		self._queryQueue = new RequestQueue();

		// merge options with default options to use defaults for missing values
		self._options = jQuery.extend(true, {}, self._defaultOpts, options);

		/**
		 * Initializes the data proxy with respect to init mode.
		 */
		self.init = function()
		{
			self._queryQueue.init(function(options) {
				$.ajax(options);
			});

			if (self.isFullInit())
			{
				self.fullInit(self._options);
			}
			else
			{
				self.lazyInit(self._options);
			}
		};

		/**
		 * Initializes the proxy without actually grabbing anything from the server.
		 * Provided servlet name will be used later.
		 *
		 * @param options   data proxy options
		 */
		self.lazyInit = function(options)
		{
			// no default implementation, can be overridden by subclasses
		};

		/**
		 * Initializes with full data. Once initialized with full data,
		 * this proxy class assumes that there will be no additional data.
		 *
		 * @param options   data proxy options
		 */
		self.fullInit = function(options)
		{
			// method body should be overridden by subclasses
		};

		/**
		 * Checks if the initialization is full or lazy.
		 *
		 * @return {boolean} true if full init, false otherwise
		 */
		self.isFullInit = function()
		{
			return !(self._options.initMode.toLowerCase() === "lazy");
		};


		/**
		 * This function ensures that at most only one ajax request is
		 * sent from a particular DataProxy instance. This is to prevent
		 * too many simultaneous requests.
		 *
		 * @ajaxOptions jQuery ajax options
		 */
		self.requestData = function(ajaxOptions)
		{
			var complete = ajaxOptions.complete;

			var defaultOpts = {
				complete: function(request, status)
				{
					self._queryQueue.complete();

					if (_.isFunction(complete))
					{
						complete(request, status);
					}
				}
			};

			// extend options with default options
			var options = jQuery.extend(true, {}, ajaxOptions, defaultOpts);

			self._queryQueue.add(options);
		};
	}

	module.exports = AbstractDataProxy;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2016 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var AbstractDataProxy = __webpack_require__(109);

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);

	/**
	 * This class is designed to retrieve annotation data on demand,
	 * but it can be also initialized with the full annotation data.
	 *
	 * @param options  proxy options
	 *
	 * @author Selcuk Onur Sumer
	 */
	function VariantAnnotationDataProxy(options)
	{
		var self = this;

		// map of <variant, data> pairs
		var _annotationDataCache = {};

		// default options
		var _defaultOpts = {
			servletName: "variant_annotation/hgvs"
		};

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		// call super constructor to init options and other params
		AbstractDataProxy.call(this, _options);
		_options = self._options;

		/**
		 * Initializes with full annotation data. Once initialized with full data,
		 * this proxy class assumes that there will be no additional data.
		 *
		 * @param options   data proxy options
		 */
		function fullInit(options)
		{
			//assuming the given data is a map of <variant, annotation data> pairs
			_annotationDataCache = options.data;
		}

		/**
		 * Returns the mutation data for the given gene(s).
		 *
		 * @param variantList  list of variants as a comma separated string
		 * @param callback  callback function to be invoked after retrieval
		 */
		function getAnnotationData(variantList, callback)
		{
			var variants = variantList.trim().split(",");
			var variantsToQuery = [];

			// get previously grabbed data (if any)
			var annotationData = [];

			// process each variant in the given list
			_.each(variants, function(variant, idx) {
				// variant annotator is case sensitive!
				//variant = variant.toUpperCase();

				var data = _annotationDataCache[variant];

				if (data == undefined || _.isEmpty(data))
				{
					// annotation data does not exist for this variant, add it to the list
					variantsToQuery.push(variant);
				}
				else
				{
					// data is already cached for this variant, update the data array
					annotationData = annotationData.concat(data);
				}
			});

			// all data is already retrieved (full init)
			if (self.isFullInit())
			{
				// just forward the call the callback function
				callback(annotationData);
			}
			// we need to retrieve missing data (lazy init)
			else
			{
				var process = function(data) {
					// cache data (assuming data is an array)
					_.each(data, function(variant, idx) {
						// parse annotation JSON string
						processAnnotationJSON(variant);

						// first check if variant.id exists
						if (variant.id)
						{
							_annotationDataCache[variant.id] = variant;
						}
						// if not then try annotationJSON
						else if (variant.annotationJSON.id)
						{
							_annotationDataCache[variant.annotationJSON.id] = variant;
						}
					});

					// concat new data with already cached data,
					// and forward it to the callback function
					annotationData = annotationData.concat(data);
					callback(annotationData);
				};

				// some (or all) data is missing,
				// send ajax request for missing genes
				if (variantsToQuery.length > 0)
				{
					var variantsData = variantsToQuery.join(",");
					// retrieve data from the server
					//$.post(_options.servletName, servletParams, process, "json");
					var ajaxOpts = {
						type: "POST",
						url: _options.servletName,
						data: {variants: variantsData},
						success: process,
						error: function() {
							console.log("[VariantDataProxy.getAnnotationData] " +
							            "error retrieving annotation data for variants: " +
							            variantsData);
							process([]);
						},
						//processData: false,
						//contentType: false,
						dataType: "json"
					};

					self.requestData(ajaxOpts);
				}
				// data for all requested genes already cached
				else
				{
					// just forward the data to the callback function
					callback(annotationData);
				}
			}
		}

		/**
		 * Processes the annotationJSON string and converts it to a regular JSON.
		 *
		 * @param variant   variant to process
		 */
		function processAnnotationJSON(variant)
		{
			if (_.isString(variant.annotationJSON))
			{
				// assuming it is a JSON string
				var annotation = JSON.parse(variant.annotationJSON);

				if (_.isArray(annotation) &&
				    annotation.length > 0)
				{
					annotation = annotation[0];
				}

				variant.annotationJSON = annotation;
			}
		}

		// override required base functions
		self.fullInit = fullInit;

		// class specific functions
		self.getAnnotationData = getAnnotationData;
	}

	// VariantAnnotationDataProxy extends AbstractDataProxy...
	VariantAnnotationDataProxy.prototype = new AbstractDataProxy();
	VariantAnnotationDataProxy.prototype.constructor = VariantAnnotationDataProxy;

	module.exports = VariantAnnotationDataProxy;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var AbstractDataProxy = __webpack_require__(109);
	var MutationCollection = __webpack_require__(112);
	var MutationDetailsUtil = __webpack_require__(114);

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);

	/**
	 * This class is designed to retrieve mutation data on demand, but it can be also
	 * initialized with the full mutation data already retrieved from the server.
	 *
	 * @param options  additional options
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationDataProxy(options)
	{
		var self = this;

		// default options
		var _defaultOpts = {
			servletName: "getMutationData.json",
			geneList: "", // list of target genes (genes of interest) as a string
			params: {},    // fixed servlet params
			paramsPromise: null // alternative servlet params as a promise object
		};

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		// call super constructor to init options and other params
		AbstractDataProxy.call(this, _options);
		_options = self._options;

		// MutationDetailsUtil instance
		var _util = new MutationDetailsUtil();
		// list of target genes as an array of strings (in the exact input order)
		var _unsortedGeneList = _options.geneList.trim().split(/\s+/);
		// alphabetically sorted list of target genes as an array of strings
		var _geneList = _options.geneList.trim().split(/\s+/).sort();

		/**
		 * Initializes with full mutation data. Once initialized with full data,
		 * this proxy class assumes that there will be no additional mutation data.
		 *
		 * @param options   data proxy options
		 */
		function fullInit(options)
		{
			var data = options.data;
			var mutations = data;

			// convert to a collection if required
			// (if not an array, assuming it is a MutationCollection)
			if (_.isArray(data))
			{
				mutations = new MutationCollection(data);
			}

			_util.processMutationData(mutations);
		}

		function getGeneList()
		{
			// TODO lazy init: to find out genes with mutation data ONLY,
			// we need to query the server before hand. Otherwise,
			// we cannot remove the genes without data from the list until
			// the corresponding gene tab is clicked.
			return _geneList;
		}

		function getUnsortedGeneList()
		{
			return _unsortedGeneList;
		}

		function getRawGeneList()
		{
			return _options.geneList;
		}

		function getMutationUtil()
		{
			return _util;
		}

		/**
		 * Returns the mutation data for the given gene(s).
		 *
		 * @param geneList  list of hugo gene symbols as a whitespace delimited string
		 * @param callback  callback function to be invoked after retrieval
		 */
		function getMutationData(geneList, callback)
		{
			var genes = geneList.trim().split(/\s+/);
			var genesToQuery = [];

			// get previously grabbed data (if any)
			var mutationData = [];
			var mutationMap = _util.getMutationGeneMap();

			// process each gene in the given list
			_.each(genes, function(gene, idx) {
				gene = gene.toUpperCase();

				var data = mutationMap[gene];

				if (data == undefined ||
				    data.length == 0)
				{
					// mutation data does not exist for this gene, add it to the list
					genesToQuery.push(gene);
				}
				else
				{
					// data is already cached for this gene, update the data array
					mutationData = mutationData.concat(data);
				}
			});

			// all data is already retrieved (full init)
			if (self.isFullInit())
			{
				// just forward the call the callback function
				callback(mutationData);
			}
			// we need to retrieve missing data (lazy init)
			else
			{
				var process = function(data) {
					// process new data retrieved from server
					var mutations = new MutationCollection(data);
					_util.processMutationData(mutations);

					// concat new data with already cached data,
					// and forward it to the callback function
					mutationData = mutationData.concat(mutations.models);
					callback(mutationData);
				};

				var paramsPromise = _options.paramsPromise ||
				                    (new $.Deferred()).resolve(_options.params);

				paramsPromise.then(function(servletParams) {
					// some (or all) data is missing,
					// send ajax request for missing genes
					if (genesToQuery.length > 0)
					{
						// add genesToQuery to the servlet params
						servletParams.geneList = genesToQuery.join(" ");

						// retrieve data from the server
						//$.post(_options.servletName, servletParams, process, "json");
						var ajaxOpts = {
							type: "POST",
							url: _options.servletName,
							data: servletParams,
							success: process,
							error: function() {
								console.log("[MutationDataProxy.getMutationData] " +
									"error retrieving mutation data for genetic profiles: " + servletParams.geneticProfiles);
								process([]);
							},
							dataType: "json"
						};

						self.requestData(ajaxOpts);
					}
					// data for all requested genes already cached
					else
					{
						// just forward the data to the callback function
						callback(mutationData);
					}
				});
			}
		}

		/**
		 * Checks if there is mutation data for the current query
		 * (For the current gene list, case list, and cancer study).
		 *
		 * @return {boolean} true if there is mutation data, false otherwise.
		 */
		function hasData()
		{
			// TODO returning true in any case for now
			// we need to query server side for lazy init
			// since initially there is definitely no data
			//return (_util.getMutations().length > 0);
			return true;
		}

		// override required base functions
		self.fullInit = fullInit;

		// class specific functions
		self.getMutationData = getMutationData;
		self.getGeneList = getGeneList;
		self.getRawGeneList = getRawGeneList;
		self.getUnsortedGeneList = getUnsortedGeneList;
		self.getMutationUtil = getMutationUtil;
		self.hasData = hasData;
	}

	// MutationDataProxy extends AbstractDataProxy...
	MutationDataProxy.prototype = new AbstractDataProxy();
	MutationDataProxy.prototype.constructor = MutationDataProxy;

	module.exports = MutationDataProxy;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var Backbone = __webpack_require__(12);
	var MutationModel = __webpack_require__(113);

	/**
	 * Collection of mutations (MutationModel instances).
	 */
	var MutationCollection = Backbone.Collection.extend({
		model: MutationModel,
		initialize: function(options) {
			// TODO add & set attributes if required
		},
		parse: function(response) {
			// TODO parse response (returned from web service)
			// this.attributes = function() { return response.attributes; };   // save the attributes
			// return response.data;    // but the data is what is to be model-ed
		},
		url: function() {
			// TODO implement this to get the data from a web service
			var urlStr = "webservice.do?cmd=...";
		}
	});

	module.exports = MutationCollection;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var Backbone = __webpack_require__(12);

	/**
	 * Mutation Model.
	 *
	 * Current model is sufficient to visualize both the table and the diagram.
	 * Later we may add more data if necessary.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationModel = Backbone.Model.extend({
		// TODO update initialize method when all done!
		_initialize: function(attributes) {
			this.mutationId = attributes.mutationId;
	        this.mutationSid = attributes.mutationSid;
			this.geneticProfileId = attributes.geneticProfileId;
			this.mutationEventId = attributes.mutationEventId;
			this.caseId = attributes.caseId;
			this.geneSymbol = attributes.geneSymbol;
			this.linkToPatientView = attributes.linkToPatientView;
	        this.cancerType = attributes.cancerType;
	        this.cancerStudy = attributes.cancerStudy;
	        this.cancerStudyShort = attributes.cancerStudyShort;
	        this.cancerStudyLink = attributes.cancerStudyLink;
			this.tumorType = attributes.tumorType;
			this.proteinChange = attributes.proteinChange;
			this.aminoAcidChange = attributes.aminoAcidChange;
			this.mutationType = attributes.mutationType;
			this.cosmic = attributes.cosmic;
			this.cosmicCount = this.calcCosmicCount(attributes.cosmic);
			this.functionalImpactScore = attributes.functionalImpactScore;
			this.fisValue = attributes.fisValue;
			this.msaLink = attributes.msaLink;
			this.xVarLink = attributes.xVarLink;
			this.pdbLink = attributes.pdbLink;
			this.pdbMatch = attributes.pdbMatch; // {pdbId, chainId} pair
			this.igvLink = attributes.igvLink;
			this.mutationStatus = attributes.mutationStatus;
			this.validationStatus = attributes.validationStatus;
			this.sequencingCenter = attributes.sequencingCenter;
			this.ncbiBuildNo = attributes.ncbiBuildNo;
			this.chr = attributes.chr;
			this.startPos = attributes.startPos;
			this.endPos = attributes.endPos;
			this.referenceAllele = attributes.referenceAllele;
			this.variantAllele = attributes.variantAllele;
			this.tumorFreq = attributes.tumorFreq;
			this.normalFreq = attributes.normalFreq;
			this.tumorRefCount = attributes.tumorRefCount;
			this.tumorAltCount = attributes.tumorAltCount;
			this.normalRefCount = attributes.normalRefCount;
			this.normalAltCount = attributes.normalAltCount;
			this.canonicalTranscript = attributes.canonicalTranscript;
			this.refseqMrnaId = attributes.refseqMrnaId;
			this.codonChange = attributes.codonChange;
			this.uniprotId = attributes.uniprotId;
			this.uniprotAcc = attributes.uniprotAcc;
			this.proteinPosStart = attributes.proteinPosStart;
			this.proteinPosEnd = attributes.proteinPosEnd;
			this.mutationCount = attributes.mutationCount;
			this.specialGeneData = attributes.specialGeneData;
			this.keyword = attributes.keyword;
			this.cna = attributes.cna;
			this.myCancerGenome = attributes.myCancerGenome;
			this.isHotspot = attributes.isHotspot;
		},
		url: function() {
			// TODO implement this to get the data from a web service
			var urlStr = "webservice.do?cmd=...";
		},
		/**
		 * Finds out the protein start position for this mutation.
		 * The field proteinPosStart has a priority over proteinChange.
		 * If none of these has a valid value, then this function
		 * returns null.
		 *
		 * @return protein start position
		 */
		getProteinStartPos: function()
		{
			// first try protein start pos
			var position = this.get("proteinPosStart");

			// if not valid, then try protein change value
			if (position == null ||
			    position.length == 0 ||
			    position == "NA" ||
			    position < 0)
			{
				position = this.getProteinChangeLocation();
			}

			return position;
		},
		/**
		 * Finds the uniprot location for the protein change of
		 * the given mutation.
		 *
		 * @return {String} protein location as a string value
		 */
		getProteinChangeLocation: function()
		{
			var location = null;
			var result = null;
			var proteinChange = this.get("proteinChange");

			if (proteinChange != null)
			{
				result = proteinChange.match(/[0-9]+/);
			}

			if (result && result.length > 0)
			{
				location = result[0];
			}

			return location;
		},
		getCosmicCount: function()
		{
			// if already set, return the current value
			if (this.get("cosmicCount")) {
				return this.get("cosmicCount");
			}
			// if not set yet, calculate & set & return the value
			else if (this.get("cosmic")) {
				var cosmicCount = this.calcCosmicCount(this.get("cosmic"));
				this.set({cosmicCount: cosmicCount});
				return cosmicCount;
			}
			// NA
			else {
				return null;
			}
		},
		calcCosmicCount: function(cosmic)
		{
			var cosmicCount = 0;

			if (cosmic)
			{
				cosmic.forEach(function(c) {
					cosmicCount += c[2];
				});
			}

			return cosmicCount;
		}
	});

	module.exports = MutationModel;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var _ = __webpack_require__(5);

	/**
	 * Utility class for processing collection of mutations.
	 *
	 * @param mutations     [optional] a MutationCollection instance
	 * @constructor
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationDetailsUtil = function(mutations)
	{
		var GERMLINE = "germline"; // germline mutation constant
		var VALID = "valid";

		// init class variables
		var _mutationGeneMap = {};
		var _mutationCaseMap = {};
		var _mutationIdMap = {};
		var _mutationKeywordMap = {};
		var _mutationProteinChangeMap = {};
		var _mutationProteinPosStartMap = {};
		var _mutations = [];

		this.getMutationGeneMap = function()
		{
			return _mutationGeneMap;
		};

		this.getMutationCaseMap = function()
		{
			return _mutationCaseMap;
		};

		this.getMutationIdMap = function()
		{
			return _mutationIdMap;
		};

		this.getProteinChangeMap = function()
		{
			return _mutationProteinChangeMap;
		};

		this.getMutations = function()
		{
			return _mutations;
		};

		/**
		 * Updates existing maps and collections by processing the given mutations.
		 * This method appends given mutations to the existing ones, it does not
		 * reset previous mutations.
		 *
		 * @param mutations a MutationCollection instance (list of mutations)
		 */
		this.processMutationData = function(mutations)
		{
			// update collections, arrays, maps, etc.
			_mutationGeneMap = this._updateGeneMap(mutations);
			_mutationCaseMap = this._updateCaseMap(mutations);
			_mutationIdMap = this._updateIdMap(mutations);
			_mutationKeywordMap = this._updateKeywordMap(mutations);
			_mutationProteinChangeMap = this._updateProteinChangeMap(mutations);
			_mutationProteinPosStartMap = this._updateProteinPosStartMap(mutations);
			_mutations = _mutations.concat(mutations.models);
		};

		/**
		 * Retrieves protein positions corresponding to the mutations
		 * for the given gene symbol.
		 *
		 * @param gene      hugo gene symbol
		 * @return {Array}  array of protein positions
		 */
		this.getProteinPositions = function(gene)
		{
			var mutations = _mutationGeneMap[gene];

			var positions = [];

			if (mutations != null)
			{
				for(var i=0; i < mutations.length; i++)
				{
					var position = {id: mutations[i].get("mutationId"),
						start: mutations[i].getProteinStartPos(),
						end: mutations[i].get("proteinPosEnd")};

					positions.push(position);
				}
			}

			return positions;
		};

		this.getAllKeywords = function()
		{
			return _.keys(_mutationKeywordMap);
		};

		this.getAllProteinChanges = function()
		{
			return _.keys(_mutationProteinChangeMap);
		};

		this.getAllProteinPosStarts = function()
		{
			return _.keys(_mutationProteinPosStartMap);
		};

		this.getAllGenes = function()
		{
			return _.keys(_mutationGeneMap);
		};

		/**
		 * Processes the collection of mutations, and creates a map of
		 * <geneSymbol, mutation array> pairs.
		 *
		 * @param mutations collection of mutations
		 * @return {object} map of mutations (keyed on gene symbol)
		 * @private
		 */
		this._updateGeneMap = function(mutations)
		{
			var mutationMap = _mutationGeneMap;

			// process raw data to group mutations by genes
			for (var i=0; i < mutations.length; i++)
			{
				var gene = mutations.at(i).get("geneSymbol");

				if (gene != null)
				{
					gene = gene.toUpperCase();

					if (mutationMap[gene] == undefined)
					{
						mutationMap[gene] = [];
					}

					mutationMap[gene].push(mutations.at(i));
				}
			}

			return mutationMap;
		};

		/**
		 * Processes the collection of mutations, and creates a map of
		 * <case id, mutation array> pairs.
		 *
		 * @param mutations collection of mutations
		 * @return {object} map of mutations (keyed on case id)
		 * @private
		 */
		this._updateCaseMap = function(mutations)
		{
			var mutationMap = _mutationCaseMap;

			// process raw data to group mutations by genes
			for (var i=0; i < mutations.length; i++)
			{
				var caseId = mutations.at(i).get("caseId");

				if (caseId != null)
				{
					caseId = caseId.toLowerCase();

					if (mutationMap[caseId] == undefined)
					{
						mutationMap[caseId] = [];
					}

					mutationMap[caseId].push(mutations.at(i));
				}
			}

			return mutationMap;
		};

		/**
		 * Processes the collection of mutations, and creates a map of
		 * <mutation id, mutation> pairs.
		 *
		 * @param mutations collection of mutations
		 * @return {object} map of mutations (keyed on mutation id)
		 * @private
		 */
		this._updateIdMap = function(mutations)
		{
			var mutationMap = _mutationIdMap;

			// process raw data to group mutations by genes
			for (var i=0; i < mutations.length; i++)
			{
				var mutationId = mutations.at(i).get("mutationId");
				mutationMap[mutationId] = mutations.at(i);
			}

			return mutationMap;
		};

		/**
		 * Processes the collection of mutations, and creates a map of
		 * <mutation keyword, mutation array> pairs.
		 *
		 * @param mutations collection of mutations
		 * @return {object} map of mutations (keyed on mutation keyword)
		 * @private
		 */
		this._updateKeywordMap = function(mutations)
		{
			var mutationMap = _mutationKeywordMap;

			// process raw data to group mutations by genes
			for (var i=0; i < mutations.length; i++)
			{
				var keyword = mutations.at(i).get("keyword");

				if (keyword != null)
				{
					if (mutationMap[keyword] == undefined)
					{
						mutationMap[keyword] = [];
					}

					mutationMap[keyword].push(mutations.at(i));
				}
			}

			return mutationMap;
		};

		/**
		 * Processes the collection of mutations, and creates a map of
		 * <protein change, mutation array> pairs.
		 *
		 * @param mutations collection of mutations
		 * @returns {object} map of mutations (keyed on protein change)
		 * @private
		 */
		this._updateProteinChangeMap = function(mutations)
		{
			var mutationMap = _mutationProteinChangeMap;

			// process raw data to group mutations by genes
			for (var i=0; i < mutations.length; i++)
			{
				var proteinChange = mutations.at(i).get("proteinChange");

				if (proteinChange != null)
				{
					if (mutationMap[proteinChange] == undefined)
					{
						mutationMap[proteinChange] = [];
					}

					mutationMap[proteinChange].push(mutations.at(i));
				}
			}

			return mutationMap;
		};

		/**
		 * Processes the collection of mutations, and creates a map of
		 * <protein position start, mutation array> pairs.
		 *
		 * @param mutations collection of mutations
		 * @returns {object} map of mutations (keyed on protein position start)
		 * @private
		 */
		this._updateProteinPosStartMap = function(mutations)
		{
			var mutationMap = _mutationProteinPosStartMap;

			// process raw data to group mutations by genes
			for (var i=0; i < mutations.length; i++)
			{
				// using only protein position start is ambiguous,
				// so we also need gene symbol for the key...
				var gene = mutations.at(i).get("geneSymbol");
				var proteinPosStart = mutations.at(i).get("proteinPosStart");

				if (proteinPosStart != null && gene != null)
				{
					var key = gene + "_" + proteinPosStart;

					if (mutationMap[key] == undefined)
					{
						mutationMap[key] = [];
					}

					mutationMap[key].push(mutations.at(i));
				}
			}

			return mutationMap;
		};

		/**
		 * Generates a single line summary with mutation rate.
		 *
		 * @param mutationCount mutation count values as an object
		 *                      {numCases, numMutated, numSomatic, numGermline}
		 * @return {string}     single line summary string
		 */
		this.generateSummary = function(mutationCount)
		{
			var summary = "[";
			var rate;
	        var germlineDenominator = mutationCount.numCases;
	                
			if (mutationCount.numGermline > 0)
			{
	            if (mutationCount.numGermlineCases !== undefined)
	            {
	                if (mutationCount.numGermlineCases > 0) {
	                    germlineDenominator = mutationCount.numGermlineCases;
	                }                        
	            }
				rate = (mutationCount.numGermline / germlineDenominator) * 100;
				summary += "Germline Mutation Rate: " + rate.toFixed(1) + "%, ";
			}

			rate = (mutationCount.numSomatic / mutationCount.numCases) * 100;
			summary += "Somatic Mutation Rate: " + rate.toFixed(1) + "%]";

			return summary;
		};

		/**
		 * Counts the number of total cases, number of mutated cases, number of cases
		 * with somatic mutation, and number of cases with germline mutation.
		 *
		 * Returns an object with these values.
		 *
		 * @param gene  hugo gene symbol
		 * @param cases array of cases (strings)
		 * @return {{numCases: number,
		 *          numMutated: number,
		 *          numSomatic: number,
		 *          numGermline: number}}
		 */
		this.countMutations = function(gene, cases)
		{
			var numCases = cases.length;
			var numMutated = 0;
			var numSomatic = 0;
			var numGermline = 0;

			// count mutated cases (also count somatic and germline mutations)
			for (var i=0; i < cases.length; i++)
			{
				// get the mutations for the current case
				var mutations = _mutationCaseMap[cases[i].toLowerCase()];

				// check if case has a mutation
				if (mutations != null)
				{
					var somatic = 0;
					var germline = 0;

					for (var j=0; j < mutations.length; j++)
					{
						// skip mutations with different genes
						if (mutations[j].get("geneSymbol").toLowerCase() != gene.toLowerCase())
						{
							continue;
						}

						if (mutations[j].get("mutationStatus") &&
							mutations[j].get("mutationStatus").toLowerCase() === GERMLINE)
						{
							// case has at least one germline mutation
							germline = 1;
						}
						else
						{
							// case has at least one somatic mutation
							somatic = 1;
						}
					}

					// update counts
					numSomatic += somatic;
					numGermline += germline;
					numMutated++;
				}
			}

			// return an array of calculated values
			return {numCases: numCases,
				numMutated: numMutated,
				numSomatic: numSomatic,
				numGermline: numGermline};
		};

	    /**
	     * Checks if there all mutations come from a single cancer study
	     *
	     * @param gene  hugo gene symbol
	     */
	    this.cancerStudyAllTheSame = function(gene)
	    {
	        var self = this;
	        gene = gene.toUpperCase();
		    var mutations = _mutationGeneMap[gene];

	        if (mutations != null)
	        {
	            var prevStudy = null;

	            for (var i=0; i < mutations.length; i++)
	            {
	                var cancerStudy = mutations[i].get("cancerStudy");
	                if(prevStudy == null) {
	                    prevStudy = cancerStudy;
	                } else if(prevStudy != cancerStudy) {
	                    return false;
	                }
	            }
	        }

	        return true;
	    };

		this._contains = function(gene, matchFn)
		{
			var contains = false;

			gene = gene.toUpperCase();

			var mutations = _mutationGeneMap[gene];

			if (mutations != null)
			{
				for (var i=0; i < mutations.length; i++)
				{
					contains = matchFn(mutations[i]);

					if (contains)
					{
						break;
					}
				}
			}

			return contains;
		};

	    /**
		 * Checks if there is a germline mutation for the given gene.
		 *
		 * @param gene  hugo gene symbol
		 */
		this.containsGermline = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("mutationStatus") &&
				        mutation.get("mutationStatus").toLowerCase() == GERMLINE);
			});
		};

		/**
		 * Checks if there is a "valid" validation status for the given gene.
		 *
		 * @param gene  hugo gene symbol
		 */
		this.containsValidStatus = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("validationStatus") &&
				        mutation.get("validationStatus").toLowerCase() == VALID);
			});
		};

		/**
		 * Checks if there is a link to IGV BAM file for the given gene.
		 *
		 * @param gene  hugo gene symbol
		 */
		this.containsIgvLink = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("igvLink") &&
				        mutation.get("igvLink") != "NA");
			});
		};

		/**
		 * Checks if there is valid allele frequency data for the given gene.
		 *
		 * @param gene  hugo gene symbol
		 */
		this.containsAlleleFreqT = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("tumorFreq") &&
				        mutation.get("tumorFreq") != "NA");
			});
		};

		/**
		 * Checks if there is valid copy number data for the given gene.
		 *
		 * @param gene  hugo gene symbol
		 */
		this.containsCnaData = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("cna") &&
				        mutation.get("cna") != "NA" &&
				        mutation.get("cna") != "unknown");
			});
		};

		this.containsProteinChange = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("proteinChange") &&
				        mutation.get("proteinChange") != "NA" &&
				        mutation.get("proteinChange") != "unknown");
			});
		};

		this.containsCaseId = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("caseId") &&
				        mutation.get("caseId") != "NA");
			});
		};

		this.containsChr = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("chr") &&
				        mutation.get("chr") != "NA");
			});
		};

		this.containsStartPos = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("startPos") &&
				        mutation.get("startPos") > 0);
			});
		};

		this.containsRefAllele = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("referenceAllele") &&
				        mutation.get("referenceAllele") != "NA");
			});
		};

		this.containsVarAllele = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("variantAllele") &&
				        mutation.get("variantAllele") != "NA");
			});
		};

		this.containsEndPos = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("endPos") &&
				        mutation.get("endPos") > 0);
			});
		};

		this.containsFis = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("functionalImpactScore") &&
				        mutation.get("functionalImpactScore") != "NA");
			});
		};

		this.containsCosmic = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("cosmic") &&
				        mutation.getCosmicCount() &&
						mutation.getCosmicCount() > 0);
			});
		};

		this.containsMutationType = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("mutationType") &&
				        mutation.get("mutationType") != "NA");
			});
		};

		this.containsMutationCount = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("mutationCount") &&
				        mutation.get("mutationCount") > 0);
			});
		};

		this.containsKeyword = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("keyword") &&
				        mutation.get("keyword") != "NA");
			});
		};

		this.containsMutationEventId = function(gene)
		{
			return this._contains(gene, function(mutation) {
				return (mutation.get("mutationEventId") &&
				        mutation.get("mutationEventId") != "NA");
			});
		};

		/**
		 * Returns the number of distinct cancer type values for
		 * the given gene
		 *
		 * @param gene  hugo gene symbol
		 * @returns {Number}    number of distinct cancer type values
		 */
		this.distinctTumorTypeCount = function(gene)
		{
			gene = gene.toUpperCase();
			var mutations = _mutationGeneMap[gene];
			var tumorTypeMap = {};

			if (mutations != null)
			{
				for (var i=0; i < mutations.length; i++)
				{
					if (mutations[i].get("tumorType"))
					{
						tumorTypeMap[mutations[i].get("tumorType")] = true;
					}
				}
			}

			return _.keys(tumorTypeMap).length;
		};

		/**
		 * Returns a sorted array of data field counts for the given gene.
		 * Does not include counts for the values provided within
		 * the exclude list.
		 *
		 * @param gene          hugo gene symbol
		 * @param dataField     data field name
		 * @param excludeList   data values to exclude while counting
		 * @return {Array}  array of data value count info
		 */
		this.dataFieldCount = function(gene, dataField, excludeList)
		{
			gene = gene.toUpperCase();
			var mutations = _mutationGeneMap[gene];
			var valueCountMap = {};

			if (mutations != null)
			{
				for (var i=0; i < mutations.length; i++)
				{
					var value = mutations[i].get(dataField);

					if (value &&
					    !_.contains(excludeList, value))
					{
						if (valueCountMap[value] === undefined)
						{
							valueCountMap[value] = 0;
						}

						valueCountMap[value]++;
					}
				}
			}

			var pairs = _.pairs(valueCountMap);

			pairs.sort(function(a, b) {
				return (b[1] - a[1]);
			});

			var result = [];

			_.each(pairs, function(pair, i) {
				var obj = {count: pair[1]};
				obj[dataField] = pair[0];
				result.push(obj);
			});

			return result;
		};

		// init maps by processing the initial mutations
		if (mutations != null)
		{
			this.processMutationData(mutations);
		}
	};

	module.exports = MutationDetailsUtil;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2016 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var AbstractDataProxy = __webpack_require__(109);

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);

	/**
	 * This class is designed to retrieve cBio Portal specific data on demand.
	 *
	 * @param options  additional options
	 *
	 * @author Selcuk Onur Sumer
	 */
	function ClinicalDataProxy(options)
	{
		var self = this;

		// default options
		var _defaultOpts = {
			servletName: "api-legacy/clinicaldata",
			subService: {
				patients: "patients"
			}
		};

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		// call super constructor to init options and other params
		AbstractDataProxy.call(this, _options);
		_options = self._options;

		// cache
		var _data = {};

		/**
		 * Initializes with full data. Once initialized with full data,
		 * this proxy class assumes that there will be no additional data.
		 *
		 * @param options   data proxy options
		 */
		function fullInit(options)
		{
			_data = options.data;
		}

		function getPatientData(samples, callback)
		{
			// TODO full init & cache...

			var cancerStudyId;
			var patientSampleMap = {};
			var patientIds = [];
			var querySession = null;

			// TODO we need to find a better way to plug portal data into MutationMapper!
			// workaround: since QuerySession is actually live in cBioPortal
			// we need to make sure that it doesn't break the standalone MutationMapper instances
			try {
				querySession = window.QuerySession;
			} catch (e) {
				// undefined reference: QuerySession
			}

			if (querySession) {
				cancerStudyId = querySession.cancer_study_ids[0];
				querySession.getPatientSampleIdMap().then(function (patientSampleMap){
	                for (var i = 0; i < samples.length; i++) {
	                    patientIds.push(patientSampleMap[samples[i]]);
	                }
	                makePatientData();
	            });
			}
			else {
				cancerStudyId = window.cancer_study_id;
	            makePatientData();
			}

	        function makePatientData() {
	            // no cancer study id or patient information...
			    if (!cancerStudyId || _.size(patientIds) === 0)
			    {
				    callback(null);
				    return;
			    }

			    var args = {study_id:cancerStudyId, attribute_ids:["12_245_PARTC_CONSENTED"], patient_ids:patientIds};
			    var arg_strings = [];
			    for (var k in args) {
				    if (args.hasOwnProperty(k)) {
				        arg_strings.push(k + '=' + [].concat(args[k]).join(","));
				    }
			    }

			    var arg_string = arg_strings.join("&") || "?";

			    var ajaxOpts = {
				    type: "POST",
				    url: _options.servletName + "/" + _options.subService.patients,
				    data: arg_string,
				    dataType: "json",
				    success: function(data) {
					    callback(data);
				    },
				    error: function(data) {
					    callback(null);
				    }
			    };

			    self.requestData(ajaxOpts);
	        }
		}

		// override required base functions
		self.fullInit = fullInit;

		// class specific functions
		self.getPatientData = getPatientData;
	}

	// ClinicalDataProxy extends AbstractDataProxy...
	ClinicalDataProxy.prototype = new AbstractDataProxy();
	ClinicalDataProxy.prototype.constructor = ClinicalDataProxy;

	module.exports = ClinicalDataProxy;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var AbstractDataProxy = __webpack_require__(109);
	var PdbDataUtil = __webpack_require__(10);

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);

	/**
	 * This class is designed to retrieve PDB data on demand.
	 *
	 * @param options  additional options
	 *
	 * @author Selcuk Onur Sumer
	 */
	function PdbDataProxy(options)
	{
		var self = this;

		// default options
		var _defaultOpts = {
			//servletName: "get3dPdb.json",
			servletName: "pdb_annotation",
			subService: {
				alignmentByPdb: "alignment/byPdb",
				alignmentByUniprot: "alignment/byUniprot",
				header: "header",
				map: "map",
				summary: "summary"
			},
			listJoiner: ",",
			mutationUtil: {} // an instance of MutationDetailsUtil class
		};

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		// call super constructor to init options and other params
		AbstractDataProxy.call(this, _options);
		_options = self._options;

		var _util = _options.mutationUtil;

		// cache for PDB data:

		// map of <uniprot id, PdbCollection> pairs
		var _pdbDataCache = {};

		// map of <uniprot id, PdbChain[][]> pairs
		var _pdbRowDataCache = {};

		// map of <pdb id, pdb info> pairs
		var _pdbInfoCache = {};

		// map of <uniprot id, pdb data summary> pairs
		var _pdbDataSummaryCache = {};

		// map of <gene_pdbId_chainId, positionMap> pairs
		var _positionMapCache = {};

		/**
		 *
		 * @param options   data proxy options
		 */
		function fullInit(options)
		{
			var data = options.data;

			// process pdb data
			_.each(_.keys(data.pdbData), function(uniprotId) {
				var pdbColl = PdbDataUtil.processPdbData(data.pdbData[uniprotId]);
				_pdbDataCache[uniprotId] = pdbColl;
				_pdbRowDataCache[uniprotId] = PdbDataUtil.allocateChainRows(pdbColl);
			});

			// set info data
			_pdbInfoCache = data.infoData;

			// set summary data
			_pdbDataSummaryCache = data.summaryData;

			// process position data
	//		_.each(_.keys(data.positionData), function(key) {
	//			// TODO this is a bit tricky so let the user provide whole cache for now...
	//		});

			// set position data
			_positionMapCache = data.positionData;
		}

		/**
		 * Retrieves the position map for the given gene and chain.
		 * Invokes the given callback function after retrieving the data.
		 *
		 * @param gene          hugo gene symbol
		 * @param chain         a PdbChainModel instance
		 * @param callbackFn    function to be invoked after data retrieval
		 */
		function getPositionMap(gene, chain, callbackFn)
		{
			// collection of alignments (PdbAlignmentCollection)
			var alignments = chain.alignments;
			var cacheKey = generatePositionMapCacheKey(gene, chain);

			// do not retrieve data if it is already there
			if (self.isFullInit() || _positionMapCache[cacheKey] != null)
			{
				callbackFn(_positionMapCache[cacheKey] || {});
				return;
			}

			// get protein positions for current mutations
			var positions = _util.getProteinPositions(gene);

			// populate position data array
			// first create as an object (map),
			// then convert to an array to avoid duplicate positions
			var positionObj = {};

			// only add positions which fall between chain start & end positions
			_.each(positions, function(ele, i) {
				if (ele.start > -1 &&
				    ele.start >= chain.mergedAlignment.uniprotFrom &&
				    ele.start <= chain.mergedAlignment.uniprotTo)
				{
					positionObj[ele.start] = ele.start;
				}

				if (ele.end > ele.start &&
				    ele.end >= chain.mergedAlignment.uniprotFrom &&
				    ele.end <= chain.mergedAlignment.uniprotTo)
				{
					positionObj[ele.end] = ele.end;
				}
			});

			// convert object to array
			var positionData = _.values(positionObj);

			// populate alignment data array
			var alignmentData = [];

			alignments.each(function(ele, i) {
				alignmentData.push(ele.alignmentId);
			});

			// callback function for the AJAX call
			var processData = function(data) {
				var positionMap = {};
				var mutations = _util.getMutationGeneMap()[gene];

				// this is to be compatible with both old and the new services...
				var positionData = data.positionMap || data;

				if (positionData != null &&
				    _.size(positionData) > 0)
				{
					// re-map mutation ids with positions by using the raw position map
					for(var i=0; i < mutations.length; i++)
					{
						var start = positionData[mutations[i].getProteinStartPos()];

						// TODO if the data is an array pick the longest one...
						if (_.isArray(start) && _.size(start) > 0)
						{
							start = start[0];
						}

						var end = start;

						var type = mutations[i].get("mutationType");

						// ignore end position for mutation other than in frame del
						if (type != null &&
							type.toLowerCase() === "in_frame_del")
						{
							end = positionData[mutations[i].get("proteinPosEnd")] || end;

							// TODO if array pick the longest one...
							if (_.isArray(end) && _.size(end) > 0)
							{
								end = end[0];
							}
						}

						// if no start and end position found for this mutation,
						// then it means this mutation position is not in this chain
						if (start != null &&
						    end != null)
						{
							positionMap[mutations[i].get("mutationId")] =
								{start: start, end: end};
						}
					}
				}

				// cache the map
				if (cacheKey)
				{
					_positionMapCache[cacheKey] = positionMap;
					//console.log("%s", JSON.stringify(_positionMapCache));
				}

				// call the callback function with the updated position map
				callbackFn(positionMap);
			};

			// check if there are positions to map
			if (positionData.length > 0)
			{
				var url = _options.servletName;

				// this is to be compatible with both old and the new services...
				if (_options.subService && _options.subService.map)
				{
					url = url + "/" + _options.subService.map;
				}

				// get pdb data for the current mutations
				var ajaxOpts = {
					type: "POST",
					url: url,
					data: {
						positions: positionData.join(_options.listJoiner),
						alignments: alignmentData.join(_options.listJoiner)
					},
					success: processData,
					dataType: "json"
				};

				self.requestData(ajaxOpts);
			}
			// no position data: no need to query the server
			else
			{
				// just forward to callback with empty data
				callbackFn({});
			}
		}

		/**
		 * Generates a cache key for the position map
		 * by the given gene and chain information.
		 *
		 * @param gene  hugo gene symbol
		 * @param chain a PdbChainModel instance
		 * @returns {String} cache key as a string
		 */
		function generatePositionMapCacheKey(gene, chain)
		{
			var key = null;

			if (chain.alignments.length > 0)
			{
				// TODO make sure that the key is unique!
				key = gene + "_" + chain.alignments.at(0).pdbId + "_" + chain.chainId;
			}

			return key;
		}

		/**
		 * Retrieves the PDB data for the provided uniprot id. Passes
		 * the retrieved data as a parameter to the given callback function
		 * assuming that the callback function accepts a single parameter.
		 *
		 * @param uniprotId     uniprot id
		 * @param callback      callback function to be invoked
		 */
		function getPdbData(uniprotId, callback)
		{
			if (self.isFullInit())
			{
				callback(_pdbDataCache[uniprotId]);
				return;
			}

			// retrieve data from the server if not cached
			if (_pdbDataCache[uniprotId] == undefined)
			{
				// process & cache the raw data
				var processData = function(data) {
					var pdbColl = PdbDataUtil.processPdbData(data);
					_pdbDataCache[uniprotId] = pdbColl;

					// forward the processed data to the provided callback function
					callback(pdbColl);
				};

				var url = _options.servletName;

				if (_options.subService &&
				    _options.subService.alignmentByUniprot)
				{
					url = url + "/" + _options.subService.alignmentByUniprot;
				}

				//retrieve data from the servlet
				var ajaxOpts = {
					type: "POST",
					url: url,
					data: {uniprotId: uniprotId, uniprotIds: uniprotId},
					success: processData,
					dataType: "json"
				};

				self.requestData(ajaxOpts);
			}
			else
			{
				// data is already cached, just forward it
				callback(_pdbDataCache[uniprotId]);
			}
		}

		/**
		 * Retrieves the PDB data for the provided uniprot id, and creates
		 * a 2D-array of pdb chains ranked by length and other criteria.
		 *
		 * Forwards the processed data to the given callback function
		 * assuming that the callback function accepts a single parameter.
		 *
		 * @param uniprotId     uniprot id
		 * @param callback      callback function to be invoked
		 */
		function getPdbRowData(uniprotId, callback)
		{
			// retrieve data if not cached yet
			if (!self.isFullInit() &&
			    _pdbRowDataCache[uniprotId] == undefined)
			{
				getPdbData(uniprotId, function(pdbColl) {
					// get the data & cache
					var rowData = PdbDataUtil.allocateChainRows(pdbColl);
					_pdbRowDataCache[uniprotId] = rowData;

					// forward to the callback
					callback(rowData);
				});
			}
			else
			{
				// data is already cached, just forward it
				callback(_pdbRowDataCache[uniprotId]);
			}
		}

		/**
		 * Retrieves the PDB data summary for the provided uniprot id. Passes
		 * the retrieved data as a parameter to the given callback function
		 * assuming that the callback function accepts a single parameter.
		 *
		 * @param uniprotId     uniprot id
		 * @param callback      callback function to be invoked
		 */
		function getPdbDataSummary(uniprotId, callback)
		{
			// retrieve data from the server if not cached
			if (!self.isFullInit() &&
				_pdbDataSummaryCache[uniprotId] == undefined)
			{
				// process & cache the raw data
				var processData = function(data) {
					var summaryData = data;

					if (_.isArray(summaryData) &&
					    _.size(summaryData) > 0)
					{
						summaryData = summaryData[0];
					}

					_pdbDataSummaryCache[uniprotId] = summaryData;

					// forward the processed data to the provided callback function
					callback(summaryData);
				};

				var url = _options.servletName;

				if (_options.subService &&
				    _options.subService.summary)
				{
					url = url + "/" + _options.subService.summary;
				}

				// retrieve data from the servlet
				var ajaxOpts = {
					type: "POST",
					url: url,
					data: {
						uniprotId: uniprotId,
						uniprotIds: uniprotId,
						type: "summary"
					},
					success: processData,
					dataType: "json"
				};

				self.requestData(ajaxOpts);
			}
			else
			{
				// data is already cached, just forward it
				callback(_pdbDataSummaryCache[uniprotId]);
			}
		}

		/**
		 * Checks if there is structure (PDB) data available for the provided
		 * uniprot id. Passes a boolean parameter to the given callback function
		 * assuming that the callback function accepts a single parameter.
		 *
		 * @param uniprotId     uniprot id
		 * @param callback      callback function to be invoked
		 */
		function hasPdbData(uniprotId, callback)
		{
			var processData = function(data) {
				var hasData = data && (data.alignmentCount > 0);
				callback(hasData);
			};

			getPdbDataSummary(uniprotId, processData);
		}

		/**
		 * Retrieves the PDB information for the provided PDB id(s). Passes
		 * the retrieved data as a parameter to the given callback function
		 * assuming that the callback function accepts a single parameter.
		 *
		 * @param pdbIdList list of PDB ids as a white-space delimited string
		 * @param callback  callback function to be invoked
		 */
		function getPdbInfo(pdbIdList, callback)
		{
			var pdbIds = pdbIdList.trim().split(/\s+/);
			var pdbToQuery = [];

			// get previously grabbed data (if any)

			var pdbData = {};

			// process each pdb id in the given list
			_.each(pdbIds, function(pdbId, idx) {
				//pdbId = pdbId.toLowerCase();

				var data = _pdbInfoCache[pdbId];

				if (data == undefined ||
				    data.length == 0)
				{
					// data does not exist for this pdb, add it to the list
					pdbToQuery.push(pdbId);
				}
				else
				{
					// data is already cached for this pdb id, update the data object
					pdbData[pdbId] = data;
				}
			});

			if (self.isFullInit())
			{
				// no additional data to retrieve
				callback(pdbData);
				return;
			}

			var servletParams = {};

			// some (or all) data is missing,
			// send ajax request for missing ids
			if (pdbToQuery.length > 0)
			{
				// process & cache the raw data
				var processData = function(data) {
					var pdbInfoData = data;

					if (_.isArray(data))
					{
						pdbInfoData = _.indexBy(data, 'pdbId');
					}

					_.each(pdbIds, function(pdbId, idx) {
						if (pdbInfoData[pdbId] != null)
						{
							_pdbInfoCache[pdbId] = pdbInfoData[pdbId];

							// concat new data with already cached data
							pdbData[pdbId] = pdbInfoData[pdbId];
						}
					});

					// forward the final data to the callback function
					callback(pdbData);
				};

				// add pdbToQuery to the servlet params
				servletParams.pdbIds = pdbToQuery.join(_options.listJoiner);

				var url = _options.servletName;

				if (_options.subService &&
				    _options.subService.header)
				{
					url = url + "/" + _options.subService.header;
				}

				// retrieve data from the server
				var ajaxOpts = {
					type: "POST",
					url: url,
					data: servletParams,
					success: processData,
					dataType: "json"
				};

				self.requestData(ajaxOpts);
			}
			// data for all requested chains already cached
			else
			{
				// just forward the data to the callback function
				callback(pdbData);
			}
		}

		// override required base functions
		self.fullInit = fullInit;

		// class specific functions
		self.hasPdbData = hasPdbData;
		self.getPdbData = getPdbData;
		self.getPdbRowData = getPdbRowData;
		self.getPdbInfo = getPdbInfo;
		self.getPositionMap = getPositionMap;
	}

	// PdbDataProxy extends AbstractDataProxy...
	PdbDataProxy.prototype = new AbstractDataProxy();
	PdbDataProxy.prototype.constructor = PdbDataProxy;

	module.exports = PdbDataProxy;

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var AbstractDataProxy = __webpack_require__(109);

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);

	/**
	 * This class is designed to retrieve PFAM data on demand.
	 *
	 * @param options  additional options
	 *
	 * @author Selcuk Onur Sumer
	 */
	function PancanMutationDataProxy(options)
	{
		var self = this;

		// default options
		var _defaultOpts = {
			servletName: "pancancerMutations.json"
		};

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		// call super constructor to init options and other params
		AbstractDataProxy.call(this, _options);
		_options = self._options;

		// map of <keyword, data> pairs
		var _cacheByKeyword = {};
		// map of <proteinChange, data> pairs
		var _cacheByProteinChange = {};
		// map of <proteinPosStart, data> pairs
		var _cacheByProteinPosition = {};
		// map of <gene, data> pairs
		var _cacheByGeneSymbol = {};

		/**
		 * Initializes with full data. Once initialized with full data,
		 * this proxy class assumes that there will be no additional data.
		 *
		 * @param options   data proxy options
		 */
		function fullInit(options)
		{
			var data = options.data;

			_cacheByKeyword = data.byKeyword;
			_cacheByProteinChange = data.byProteinChange;
			_cacheByGeneSymbol = data.byGeneSymbol;
			_cacheByProteinPosition = data.byProteinPosition;
		}

		function getPancanData(servletParams, mutationUtil, callback)
		{
			var cmd = servletParams.cmd;
			var q = servletParams.q;

			var data = null;
			var toQuery = null;

			if (cmd == null)
			{
				// no command provided, nothing to retrieve
				callback(null);
			}
			else if (cmd == "byKeywords")
			{
				// if no query params (keywords) provided, use all available
				var keywords = (q == null) ? mutationUtil.getAllKeywords() : q.split(",");
				getData(cmd, keywords, _cacheByKeyword, ["keyword"], callback);
			}
			else if (cmd == "byHugos")
			{
				// if no query params (genes) provided, use all available
				var genes = (q == null) ? mutationUtil.getAllGenes() : q.split(",");
				getData(cmd, genes, _cacheByGeneSymbol, ["hugo"], callback);
			}
			else if (cmd == "byProteinChanges")
			{
				// if no query params (genes) provided, use all available
				var proteinChanges = (q == null) ? mutationUtil.getAllProteinChanges() : q.split(",");
				getData(cmd, proteinChanges, _cacheByProteinChange, ["protein_change"], callback);
			}
			else if (cmd == "byProteinPos")
			{
				// if no query params (genes) provided, use all available
				var proteinPositions = (q == null) ? mutationUtil.getAllProteinPosStarts() : q.split(",");
				getData(cmd, proteinPositions, _cacheByProteinPosition, ["hugo", "protein_pos_start"], callback);
			}
			else
			{
				// invalid command
				callback(null);
			}
		}

		/**
		 * Retrieves the data from the cache and/or server.
		 *
		 * @param cmd       cmd (byHugos or byKeyword)
		 * @param keys      keys used to get cached data
		 * @param cache     target cache (byKeyword or byGeneSymbol)
		 * @param fields     field names to be used as a cache key
		 * @param callback  callback function to forward the data
		 */
		function getData(cmd, keys, cache, fields, callback)
		{
			// get cached data
			var data = getCachedData(keys, cache);
			// get keywords to query
			var toQuery = getQueryContent(data);

			if (toQuery.length > 0 &&
			    !self.isFullInit())
			{
				// retrieve missing data from the servlet
				var ajaxOpts = {
					type: "POST",
					url: _options.servletName,
					data: {cmd: cmd, q: toQuery.join(",")},
					success: function(response) {
						processData(response, data, cache, fields, callback);
					},
					dataType: "json"
				};

				self.requestData(ajaxOpts);
			}
			// everything is already cached (or full init)
			else
			{
				processData([], data, cache, fields, callback);
			}
		}

		/**
		 * Processes and caches the raw data.
		 *
		 * @param response  raw data
		 * @param data      previously cached data (for provided keys)
		 * @param cache     target cache (byKeyword or byGeneSymbol)
		 * @param fields     field names to be used as a cache key
		 * @param callback  callback function to forward the processed data
		 */
		function processData (response, data, cache, fields, callback) {
			_.each(response, function(ele, idx) {
				var keyValues = [];

				_.each(fields, function(field, idx){
					keyValues.push(ele[field]);
				});

				var key = keyValues.join("_");

				// init the list if not init yet
				if (cache[key] == null)
				{
					cache[key] = [];
				}

				if (data[key] == null)
				{
					data[key] = [];
				}

				// add data to the cache
				cache[key].push(ele);
				data[key].push(ele);
			});

			var dataArray = [];
			_.each(data, function(ele) {
				dataArray = dataArray.concat(ele);
			});

			// forward the processed data to the provided callback function
			callback(dataArray);
		}

		/**
		 * Get already cached data for the given keys.
		 * Returned object has null data for not-yet-cached keys.
		 *
		 * @param keys      cache keys
		 * @param cache     data cache
		 * @returns {Object} cached data as a map
		 */
		function getCachedData(keys, cache)
		{
			var data = {};

			_.each(keys, function(key) {
				data[key] = cache[key];
			});

			return data;
		}

		/**
		 * Returns the list of keys to query.
		 *
		 * @param data  map of <key, data> pairs
		 * @returns {Array}     list of keys to query
		 */
		function getQueryContent(data)
		{
			// keys to query
			var toQuery = [];

			_.each(_.keys(data), function(key) {
				// data not cached yet for the given key
				if (data[key] == null)
				{
					toQuery.push(key);
				}
			});

			return toQuery
		}

		// override required base functions
		self.fullInit = fullInit;

		// class specific functions
		self.getPancanData = getPancanData;
	}

	// PancanMutationDataProxy extends AbstractDataProxy...
	PancanMutationDataProxy.prototype = new AbstractDataProxy();
	PancanMutationDataProxy.prototype.constructor = PancanMutationDataProxy;

	module.exports = PancanMutationDataProxy;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var AbstractDataProxy = __webpack_require__(109);

	var $ = __webpack_require__(7);
	var jQuery = $;

	/**
	 * This class is designed to retrieve Mutation Aligner data on demand.
	 *
	 * @param options  additional options
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationAlignerDataProxy(options)
	{
		var self = this;

		// default options
		var _defaultOpts = {
			servletName: "getMutationAligner.json"
		};

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		// call super constructor to init options and other params
		AbstractDataProxy.call(this, _options);
		_options = self._options;

		// map of <gene, data> pairs
		var _maDataCache = {};

		/**
		 * Initializes with full PFAM data. Once initialized with full data,
		 * this proxy class assumes that there will be no additional data.
		 *
		 * @param options   data proxy options
		 */
		function fullInit(options)
		{
			//assuming the given data is a map of <gene, sequence data> pairs
			_maDataCache = options.data;
		}

		function getMutationAlignerData(servletParams, callback)
		{
			// TODO allow more than one accession at a time? (see MutationDataProxy)
			var pfamAccession = servletParams.pfamAccession;

			if (pfamAccession == null)
			{
				// no gene symbol provided, nothing to retrieve
				callback(null);
				return;
			}

			// retrieve data from the server if not cached
			if (_maDataCache[pfamAccession] == undefined)
			{
				if (self.isFullInit())
				{
					callback(null);
					return;
				}

				// process & cache the raw data
				var processData = function(data) {
					_maDataCache[pfamAccession] = data;

					// forward the processed data to the provided callback function
					callback(data);
				};

				// retrieve data from the servlet
				var ajaxOpts = {
					type: "POST",
					url: _options.servletName,
					data: servletParams,
					success: processData,
					dataType: "json"
				};

				self.requestData(ajaxOpts);
			}
			else
			{
				// data is already cached, just forward it
				callback(_maDataCache[pfamAccession]);
			}
		}

		// override required base functions
		self.fullInit = fullInit;

		// class specific functions
		self.getMutationAlignerData = getMutationAlignerData;
	}

	// MutationAlignerDataProxy extends AbstractDataProxy...
	MutationAlignerDataProxy.prototype = new AbstractDataProxy();
	MutationAlignerDataProxy.prototype.constructor = MutationAlignerDataProxy;

	module.exports = MutationAlignerDataProxy;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */


	var AbstractDataProxy = __webpack_require__(109);

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);

	/**
	 * This class is designed to retrieve cBio Portal specific data on demand.
	 *
	 * @param options  additional options
	 *
	 * @author Selcuk Onur Sumer
	 */
	function PortalDataProxy(options)
	{
		var self = this;

		// default options
		var _defaultOpts = {
			servletName: "portalMetadata.json"
		};

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		// call super constructor to init options and other params
		AbstractDataProxy.call(this, _options);
		_options = self._options;

		// cache
		var _data = {};

		/**
		 * Initializes with full portal data. Once initialized with full data,
		 * this proxy class assumes that there will be no additional data.
		 *
		 * @param options   data proxy options
		 */
		function fullInit(options)
		{
			_data = options.data;
		}

		function getPortalData(servletParams, callback)
		{
			// for each servlet param, retrieve data (if not cached yet)
			var metadata = {};
			var queryParams = {};

			_.each(_.keys(servletParams), function(key, idx) {
				// not cached yet
				if (_data[key] == null)
				{
					// update query params
					queryParams[key] = servletParams[key];
				}
				// already cached
				else
				{
					// get data from cache
					metadata[key] = _data[key];
				}
			});

			var processData = function(data)
			{
				// update the cache
				_.each(_.keys(data), function(key, idx) {
					_data[key] = data[key];
				});

				// forward data to the callback function
				if(_.isFunction(callback))
				{
					callback(jQuery.extend(true, {}, metadata, data));
				}
			};

			// TODO full init...

			// everything is cached
			if (_.isEmpty(queryParams))
			{
				// just forward
				processData(metadata);
			}
			else
			{
				// retrieve data from the servlet
				var ajaxOpts = {
					type: "POST",
					url: _options.servletName,
					data: queryParams,
					success: processData,
					dataType: "json"
				};

				self.requestData(ajaxOpts);
			}
		}

		// override required base functions
		self.fullInit = fullInit;

		// class specific functions
		self.getPortalData = getPortalData;
	}

	// PdbDataProxy extends AbstractDataProxy...
	PortalDataProxy.prototype = new AbstractDataProxy();
	PortalDataProxy.prototype.constructor = PortalDataProxy;

	module.exports = PortalDataProxy;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDetailsEvents = __webpack_require__(22);
	var MutationDataFilterController = __webpack_require__(121);
	var MutationDetailsTableController = __webpack_require__(122);
	var MutationInfoController = __webpack_require__(123);
	var MutationDiagramController = __webpack_require__(124);
	var MainMutationController = __webpack_require__(126);
	var Mutation3dController = __webpack_require__(127);
	var Mutation3dVis = __webpack_require__(131);
	var Mutation3dVisView = __webpack_require__(138);
	var MainMutationView = __webpack_require__(146);
	var MutationData = __webpack_require__(181);

	var cbio = {
		util: __webpack_require__(6)
	};

	var $ = __webpack_require__(7);
	var jQuery = $;

	/**
	 * Controller class for the Mutation Details view.
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationDetailsController(
		mutationDetailsView, dataManager, dataProxies, options)
	{
		var sampleArray = options.data.sampleList;
		var viewOptions = options.view;
		var renderOptions = options.render;
		var mutationProxy = dataProxies.mutationProxy;
		var pfamProxy = dataProxies.pfamProxy;
		var pdbProxy = dataProxies.pdbProxy;

		var _geneTabView = {};

		// a single 3D view instance shared by all MainMutationView instances
		var _mut3dVisView = null;

		var _3dController = null;

		function init()
		{
			// add listeners to the custom event dispatcher of the view
			mutationDetailsView.dispatcher.on(
				MutationDetailsEvents.GENE_TAB_SELECTED,
				geneTabSelectHandler);

			mutationDetailsView.dispatcher.on(
				MutationDetailsEvents.GENE_TABS_CREATED,
				geneTabCreateHandler);

			mutationDetailsView.dispatcher.on(
				MutationDetailsEvents.VIS_3D_PANEL_INIT,
				vis3dInitHandler);
		}

		function vis3dInitHandler(container)
		{
			var vis3dOpts = viewOptions.vis3d;

			if (!vis3dOpts)
			{
				return;
			}

			var basicOpts = {
				appOptions: {el: container || "#mutation_details"}
			};

			var options = jQuery.extend(true, {}, basicOpts, vis3dOpts);
			var mut3dVis = new Mutation3dVis("default3dView", options);
			mut3dVis.init();
			init3dView(mut3dVis);
		}

		function geneTabSelectHandler(gene)
		{
			if (_geneTabView[gene] == null)
			{
				initView(gene, sampleArray, viewOptions);
			}
		}

		function geneTabCreateHandler()
		{
			// initially hide 3d container
			//init3dView(null);
			mutationDetailsView.$el.find(".mutation-3d-container").hide();

			// init the view for the first gene only
			var genes = mutationProxy.getGeneList();
			initView(genes[0], sampleArray, viewOptions);
		}

		function init3dView(mut3dVis)
		{
			var container3d = mutationDetailsView.$el.find(".mutation-3d-container");

			// init 3D view if the visualizer is available
			if (mut3dVis)
			{
				// TODO remove mutationProxy?
				var mutation3dVisView = new Mutation3dVisView({
					el: container3d,
					config: renderOptions.mutation3dVis,
					mut3dVis: mut3dVis,
					pdbProxy: pdbProxy,
					mutationProxy: mutationProxy
				});

				mutation3dVisView.render();

				// update reference to the 3d vis view
				_mut3dVisView = mutation3dVisView;

				mutationDetailsView.dispatcher.trigger(
					MutationDetailsEvents.VIS_3D_PANEL_CREATED,
					mutation3dVisView);
			}
			// if no visualizer, hide the 3D vis container
			else
			{
				$(container3d).hide();
			}
		}

		/**
		 * Initializes mutation view for the given gene and cases.
		 *
		 * @param gene          hugo gene symbol
	     * @param cases         array of case ids (samples)
	     * @param viewOptions   [optional] view options
		 */
		function initView(gene, cases, viewOptions)
		{
			// callback function to init view after retrieving
			// sequence information.
			var init = function(sequenceData, mutationData)
			{
				// TODO a new util for each instance instead?
	//			var mutationUtil = new MutationDetailsUtil(
	//				new MutationCollection(mutationData));
				var mutationUtil = mutationProxy.getMutationUtil();

				var uniprotId = "";

				// TODO get uniprot id(s) from elsewhere
				if (sequenceData) {
					uniprotId = sequenceData.metadata.identifier;
				}

				var mutationModel = new MutationData();
				mutationModel.setData(mutationData);

				// prepare data for mutation view
				var model = {geneSymbol: gene,
					mutationData: mutationModel,
					dataProxies: dataProxies,
					dataManager: dataManager,
					uniprotId: uniprotId,
					sampleArray: cases};

				// init the main view
				var mainView = new MainMutationView({
					el: "#mutation_details_" + cbio.util.safeProperty(gene),
					config: renderOptions.mainMutation,
					model: model});

				mutationDetailsView.dispatcher.trigger(
					MutationDetailsEvents.MAIN_VIEW_INIT,
					mainView);

				mainView.render();

				// init mutation data filter controller
				new MutationDataFilterController(mainView);

				// update the references after rendering the view
				_geneTabView[gene].mainMutationView = mainView;
				dataManager.addView(gene, mainView);

				// no mutation data, nothing to show...
				if (mutationData == null ||
				    mutationData.length == 0)
				{
					mainView.showNoDataInfo();
				}
				else
				{
					initComponents(mainView, gene, mutationUtil, sequenceData, viewOptions);
				}
			};

			// get mutation data for the current gene
			mutationProxy.getMutationData(gene, function(data) {
				// init reference mapping
				_geneTabView[gene] = {};

				// create an empty array if data is null
				if (data == null)
				{
					data = [];
				}

				// get the sequence data for the current gene & init view

				// get the most frequent uniprot accession string (excluding "NA")
				var uniprotInfo = mutationProxy.getMutationUtil().dataFieldCount(
					gene, "uniprotAcc", ["NA"]);

				var uniprotAcc = null;
				var servletParams = {geneSymbol: gene};

				if (uniprotInfo.length > 0)
				{
					uniprotAcc = uniprotInfo[0].uniprotAcc;
				}

				// if exists, also add uniprotAcc to the servlet params
				if (uniprotAcc)
				{
					servletParams.uniprotAcc = uniprotAcc;
				}

				// TODO table can be initialized without the PFAM data...
				pfamProxy.getPfamData(servletParams, function(sequenceData) {
					// sequenceData may be null for unknown genes...
					var sequence = null;

					if (sequenceData == null) {
						console.log("[warning] no pfam data found: %o", servletParams);
					}
					else {
						// get the first sequence from the response
						sequence = sequenceData[0];
					}

					// get annotation data in any case
					dataManager.getData("variantAnnotation",
	                    {mutations: data},
	                    function(params, data) {
		                    init(sequence, params.mutations);
	                    });

				});
			});
		}

		function initComponents(mainView, gene, mutationUtil, sequenceData, viewOptions)
		{
			var diagramOpts = viewOptions.mutationDiagram;
			var tableOpts = viewOptions.mutationTable;
			var vis3dOpts = viewOptions.vis3d;
			var infoPanelOpts = viewOptions.infoPanel;
			var summaryOpts = viewOptions.mutationSummary;

			// init mutation table
			var tableView = null;

			if (tableOpts)
			{
				tableView = mainView.initMutationTableView(tableOpts);
				new MutationDetailsTableController(mainView, mutationDetailsView);
			}

			var summaryView = null;

			if (summaryOpts)
			{
				summaryView = mainView.initSummaryView(tableOpts);
			}

			// init mutation diagram
			var diagramView = null;

			function initDiagram()
			{
				if (diagramOpts && sequenceData)
				{
					diagramView = mainView.initMutationDiagramView(diagramOpts, sequenceData);

					var mutationTable = null;

					if (tableView)
					{
						mutationTable = tableView.mutationTable;
					}

					var infoView = null;

					// TODO info view can be initialized without depending on diagram view!
					if (infoPanelOpts)
					{
						infoView = mainView.initMutationInfoView(infoPanelOpts);
						new MutationInfoController(mainView);
					}

					new MutationDiagramController(mainView);
				}
			}

			if (mutationUtil.containsProteinChange(gene))
			{
				initDiagram();
			}
			// cannot initialize mutation diagram without protein change data
			else
			{
				dataManager.getData("variantAnnotation",
					//{mutationTable: tableView.mutationTable},
					{mutations: mainView.model.mutationData},
				    function(params, data) {
						initDiagram();
					});

				// TODO diagram place holder?
			}

			// init main mutation controller
			new MainMutationController(mainView);

			if (vis3dOpts)
			{
				// just init the 3D button
				var view3d = mainView.init3dView(null);

				_3dController = new Mutation3dController(mutationDetailsView, mainView, viewOptions, renderOptions,
					_mut3dVisView, view3d, pdbProxy, mutationUtil, gene);

				if (renderOptions.mutationDetails.activate3dOnInit)
				{
					_3dController.reset3dView(renderOptions.mutationDetails.activate3dOnInit.pdbId,
					                          renderOptions.mutationDetails.activate3dOnInit.chain);
				}
			}
		}

		init();

		// public functions
		this.getMainView = function(key)
		{
			return _geneTabView[key];
		};

		this.get3dController = function() {return _3dController;};
		this.get3dVisView = function() {return _mut3dVisView;};
		this.getMainViews = function() {return _geneTabView;};
		this.getDataManager = function() {return dataManager};
		this.getDataProxies = function() {return dataProxies};
	}

	module.exports = MutationDetailsController;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var MutationDetailsEvents = __webpack_require__(22);

	var $ = __webpack_require__(7);
	var _ = __webpack_require__(5);

	/**
	 * Mutation Data Filter/Select/Highlight/Update controller.
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationDataFilterController(mainMutationView)
	{
		var _mutationDiagram = null;
		var _mutationTable = null;
		var _mutationData = mainMutationView.model.mutationData;

		function init()
		{
			if (mainMutationView.diagramView)
			{
				diagramInitHandler(mainMutationView.diagramView.mutationDiagram);
			}
			else
			{
				mainMutationView.dispatcher.on(
					MutationDetailsEvents.DIAGRAM_INIT,
					diagramInitHandler);
			}

			if (mainMutationView.tableView)
			{
				tableInitHandler(mainMutationView.tableView.mutationTable);
			}
			else
			{
				mainMutationView.dispatcher.on(
					MutationDetailsEvents.MUTATION_TABLE_INITIALIZED,
					tableInitHandler);
			}

			if (mainMutationView.infoView)
			{
				infoPanelInitHandler(mainMutationView.infoView);
			}
			else
			{
				mainMutationView.dispatcher.on(
					MutationDetailsEvents.INFO_PANEL_INIT,
					infoPanelInitHandler);
			}
		}

		function infoPanelInitHandler(infoView)
		{
			// add listeners to the custom event dispatcher of the info panel view
			if (infoView)
			{
				infoView.dispatcher.on(
					MutationDetailsEvents.INFO_PANEL_MUTATION_TYPE_SELECTED,
					infoPanelFilterHandler);
			}
		}

		function tableInitHandler(mutationTable)
		{
			// update class variable
			_mutationTable = mutationTable;

			mutationTable.dispatcher.on(
				MutationDetailsEvents.MUTATION_TABLE_FILTERED,
				tableFilterHandler);

			mutationTable.dispatcher.on(
				MutationDetailsEvents.PDB_LINK_CLICKED,
				pdbLinkHandler);

			mutationTable.dispatcher.on(
				MutationDetailsEvents.PROTEIN_CHANGE_LINK_CLICKED,
				proteinChangeLinkHandler);
		}

		function diagramInitHandler(mutationDiagram)
		{
			// update class variable
			_mutationDiagram = mutationDiagram;

			// add listeners to the custom event dispatcher of the diagram
			mutationDiagram.dispatcher.on(
				MutationDetailsEvents.ALL_LOLLIPOPS_DESELECTED,
				allDeselectHandler);

			mutationDiagram.dispatcher.on(
				MutationDetailsEvents.LOLLIPOP_SINGLE_SELECT,
				diagramSingleSelectHandler);

			mutationDiagram.dispatcher.on(
				MutationDetailsEvents.LOLLIPOP_MULTI_SELECT,
				diagramMultiSelectHandler);

			mutationDiagram.dispatcher.on(
				MutationDetailsEvents.LOLLIPOP_MOUSEOVER,
				diagramMouseoverHandler);

			mutationDiagram.dispatcher.on(
				MutationDetailsEvents.LOLLIPOP_MOUSEOUT,
				diagramMouseoutHandler);
		}

		function allDeselectHandler()
		{
			if (_.size(_mutationData.getState().selected) > 0) {
				_mutationData.unSelectMutations();
			}

			if (_.size(_mutationData.getState().highlighted) > 0) {
				_mutationData.unHighlightMutations();
			}
		}

		function diagramSingleSelectHandler(datum, index)
		{
			diagramSelectHandler(datum, index, false);
		}

		function diagramMultiSelectHandler(datum, index)
		{
			diagramSelectHandler(datum, index, true);
		}

		function diagramSelectHandler(datum, index, multi)
		{
			var selected = [];

			// TODO intersection function might be very expensive in case too many lollipops selected!
			// find a faster way to check if the given mutations are already selected!
			var alreadySelected =
				_.size(_.intersection(_mutationData.getState().selected, datum.mutations)) ===
				_.size(datum.mutations);

			// check if the mutations are already selected
			if (multi)
			{
				if (alreadySelected)
				{
					_mutationData.unSelectMutations(datum.mutations);
					_mutationData.unHighlightMutations(datum.mutations);
				}
				else
				{
					_mutationData.selectMutations(datum.mutations);
				}
			}
			else if (!alreadySelected)
			{
				selected = selected.concat(datum.mutations);
				_mutationData.updateSelectedMutations(selected);
			}
			else
			{
				// no multi selection and not already selected,
				// so nothing should be selected in this case
				allDeselectHandler();
			}
		}

		function infoPanelFilterHandler(mutationType)
		{
			// get currently filtered mutations
			var filtered = mainMutationView.infoView.currentMapByType[mutationType];

			// if all the mutations of this type are already filtered out,
			// then show all mutations of this type
			if (_.size(filtered) === 0)
			{
				filtered = mainMutationView.infoView.initialMapByType[mutationType];
			}

			// update currently filtered set of mutations
			_mutationData.updateFilteredMutations(filtered);
		}

		function diagramMouseoverHandler(datum, index)
		{
			// update currently highlighted set of mutations
			_mutationData.updateHighlightedMutations(datum.mutations);
		}

		function diagramMouseoutHandler(datum, index)
		{
			// reset currently highlighted set of mutations
			_mutationData.unHighlightMutations();
		}

		function tableFilterHandler(tableSelector)
		{
			var filtered = [];

			// add current (filtered) mutations into an array
			var rowData = [];

			// TODO this try/catch block is for backward compatibility,
			// we will no longer need this once we completely migrate to DataTables 1.10
			try {
				// first, try new API.
				// this is not backward compatible, requires DataTables 1.10 or later.
				rowData = $(tableSelector).DataTable().rows({filter: "applied"}).data();
			} catch(err) {
				// if DataTables 1.10 is not available, try the old API function.
				// DataTables 1.9.4 compatible code (which doesn't work with deferRender):
				rowData = $(tableSelector).dataTable()._('tr', {filter: "applied"});
			}

			_.each(rowData, function(data, index) {
				// assuming only the first element contains the datum
				var mutation = data[0].mutation;

				if (mutation)
				{
					filtered.push(mutation);
				}
			});

			_mutationData.updateFilteredMutations(filtered, {view: mainMutationView.tableView});
		}

		function proteinChangeLinkHandler(mutationId)
		{
			var mutationMap = _mutationData.getDataUtil().getMutationIdMap();
			var mutation = mutationMap[mutationId];

			if (mutation)
			{
				_mutationData.updateHighlightedMutations([mutation]);
			}
			else
			{
				_mutationData.unHighlightMutations();
			}
		}

		function pdbLinkHandler(mutationId)
		{
			proteinChangeLinkHandler(mutationId);
		}

		init();
	}

	module.exports = MutationDataFilterController;

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDetailsEvents = __webpack_require__(22);

	var $ = __webpack_require__(7);
	var _ = __webpack_require__(5);

	/**
	 * Controller class for the Mutation Table view.
	 * Listens to the various events and make necessary changes
	 * on the view wrt each event type.
	 *
	 * @param mainMutationView  a MainMutationView instance
	 * @param mutationDetailsView   a MutationDetailsView instance
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationDetailsTableController(mainMutationView, mutationDetailsView)
	{
		function init()
		{
			// add listeners for the mutation details view
			mutationDetailsView.dispatcher.on(
				MutationDetailsEvents.GENE_TAB_SELECTED,
				geneTabSelectHandler);

			var mutationDataDispatcher = $(mainMutationView.model.mutationData.dispatcher);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_FILTER,
			    mutationFilterHandler
			);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_HIGHLIGHT,
				mutationHighlightHandler
			);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_SELECT,
				mutationSelectHandler
			);
		}

		function mutationSelectHandler(event, params)
		{
			var mutationData = params.mutationData;

			if (mainMutationView.tableView)
			{
				// remove all table highlights
				mainMutationView.tableView.clearHighlights();

				// get all selected elements
				var selected = mutationData.getState().selected;
				var filtered = mutationData.getState().filtered;

				// if there are selected mutations, then only show selected
				if (!_.isEmpty(selected))
				{
					// filter table for the selected mutations
					mainMutationView.tableView.filter(selected);
				}
				// if currently no selected mutations, then show only filtered ones
				else if (!_.isEmpty(filtered))
				{
					// filter table for the selected mutations
					mainMutationView.tableView.filter(filtered);
				}
				// nothing selected, nothing filtered, show nothing
				else
				{
					// TODO hide everything!
					// (currently we don't need this because, table filter handles this internally)
				}
			}
		}

		function mutationHighlightHandler(event, params)
		{
			var mutationData = params.mutationData;

			if (mainMutationView.tableView)
			{
				// remove all table highlights
				mainMutationView.tableView.clearHighlights();

				var mutations = mutationData.getState().highlighted;

				// get all highlighted elements
				if (!_.isEmpty(mutations))
				{
					// highlight table for the highlighted mutations
					mainMutationView.tableView.highlight(mutations);
				}
			}
		}

		function mutationFilterHandler(event, params)
		{
			// if the source view is this table view, no need to filter again
			// this is a workaround for now to prevent double filtering!
			var needToFilter = (params && params.view && params.view !== mainMutationView.tableView) ||
			                   (params && !params.view) ||
			                   !params;

			if (needToFilter)
			{
				mutationSelectHandler(event, params);
			}
		}

		function geneTabSelectHandler(gene)
		{
			if (mainMutationView.tableView)
			{
				var oTable = mainMutationView.tableView.mutationTable.getDataTable();

				// alternatively we can check if selected gene is this view's gene
				if (oTable.is(":visible"))
				{
					oTable.fnAdjustColumnSizing();
				}
			}
		}

		init();
	}

	module.exports = MutationDetailsTableController;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2016 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDetailsEvents = __webpack_require__(22);

	var $ = __webpack_require__(7);
	var _ = __webpack_require__(5);


	/**
	 * Controller class for the Mutation Info Panel.
	 * Listens to the various events and make necessary changes
	 * on the view wrt each event type.
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationInfoController(mainMutationView)
	{
		function init()
		{
			var mutationDataDispatcher = $(mainMutationView.model.mutationData.dispatcher);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_FILTER,
				mutationFilterHandler
			);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_HIGHLIGHT,
				mutationHighlightHandler
			);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_SELECT,
				mutationSelectHandler
			);
		}

		function mutationSelectHandler(event, params)
		{
			var mutationData = params.mutationData;

			if (mainMutationView.infoView)
			{
				// get all selected elements
				var selected = mutationData.getState().selected;
				var filtered = mutationData.getState().filtered;

				// if there are selected mutations, then only show selected
				if (!_.isEmpty(selected))
				{
					// filter info for the selected mutations
					mainMutationView.infoView.updateView(selected);
				}
				// if currently no selected mutations, filter info filtered ones
				else if (!_.isEmpty(filtered))
				{
					// filter table for the selected mutations
					mainMutationView.infoView.updateView(filtered);
				}
				// nothing selected, nothing filtered, show nothing
				else
				{
					// reset all previous table filters
					mainMutationView.infoView.updateView([]);
				}
			}
		}

		function mutationHighlightHandler(event, params)
		{
			// no need to handle for now, update if required...
		}

		function mutationFilterHandler(event, params)
		{
			mutationSelectHandler(event, params);
		}

		init();
	}

	module.exports = MutationInfoController;


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDataConverter = __webpack_require__(125);
	var MutationDetailsEvents = __webpack_require__(22);

	var $ = __webpack_require__(7);
	var _ = __webpack_require__(5);

	/**
	 * Controller class for the Mutation Diagram.
	 * Listens to the various events and make necessary changes
	 * on the view wrt each event type.
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationDiagramController(mainMutationView)
	{
		function init()
		{
			var mutationDataDispatcher = $(mainMutationView.model.mutationData.dispatcher);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_FILTER,
				mutationFilterHandler
			);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_HIGHLIGHT,
				mutationHighlightHandler
			);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_SELECT,
				mutationSelectHandler
			);
		}

		function mutationSelectHandler(event, params)
		{
			var mutationData = params.mutationData;

			if (mainMutationView.diagramView)
			{
				var diagram = mainMutationView.diagramView.mutationDiagram;
				var selected = mutationData.getState().selected;
				var highlighted = mutationData.getState().highlighted;

				// TODO do not clear highlights, just update the diff of current and prev selections!
				// We need the previous state of the mutation data to have a seamless visual transition
				diagram.clearHighlights();

				_.each(_.union(selected, highlighted), function(mutation) {
					diagram.highlightMutation(
						mutation.get("mutationSid"));
				});
			}
		}

		function mutationHighlightHandler(event, params)
		{
			mutationSelectHandler(event, params);
		}

		function mutationFilterHandler(event, params)
		{
			var mutationData = params.mutationData;

			if (mainMutationView.diagramView)
			{
				var filtered = mutationData.getState().filtered;

				mainMutationView.diagramView.mutationDiagram.updatePlot(
					MutationDataConverter.convertToCollection(filtered));
			}
		}

		init();
	}

	module.exports = MutationDiagramController;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2016 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationCollection = __webpack_require__(112);

	/**
	 * Singleton utility class.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationDataConverter = (function()
	{
		function convertToCollection(models)
		{
			var collection = new (MutationCollection.extend({
				// this is to make sure that no new MutationModel is created for any given model
				model: function (model, options) {
					return model;
				}
			}))();

			collection.add(models);

			return collection;
		}

		return {
			convertToCollection: convertToCollection
		};
	})();

	module.exports = MutationDataConverter;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDetailsEvents = __webpack_require__(22);

	var $ = __webpack_require__(7);
	var _ = __webpack_require__(5);

	/**
	 * Controller class for the Main Mutation view.
	 * Listens to the various events and make necessary changes
	 * on the view wrt each event type.
	 *
	 * @param mainMutationView  a MainMutationView instance
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MainMutationController(mainMutationView)
	{
		var _mutationDiagram = null;

		function init()
		{
			// init reset link call back
			mainMutationView.addResetCallback(handleReset);

			var mutationDataDispatcher = $(mainMutationView.model.mutationData.dispatcher);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_FILTER,
				mutationFilterHandler
			);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_HIGHLIGHT,
				mutationHighlightHandler
			);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_SELECT,
				mutationSelectHandler
			);
		}

		function mutationSelectHandler(event, params)
		{
			var mutationData = params.mutationData;
			// get all selected elements
			var selected = mutationData.getState().selected;
			var filtered = mutationData.getState().filtered;
			var data = mutationData.getData();

			// if there are selected or filtered out mutations then show filter info
			if (!_.isEmpty(selected) ||
			    _.size(data) !== _.size(filtered))
			{
				mainMutationView.showFilterInfo();
			}
			// nothing selected, nothing filtered out, hide filter info
			else
			{
				mainMutationView.hideFilterInfo();
			}
		}

		function mutationHighlightHandler(event, params)
		{
			// no need to handle for now, update if necessary
		}

		function mutationFilterHandler(event, params)
		{
			mutationSelectHandler(event, params);
		}

		function handleReset(event)
		{
			// TODO it might be better to call one function instead of three!
			mainMutationView.model.mutationData.unHighlightMutations();
			mainMutationView.model.mutationData.unSelectMutations();
			mainMutationView.model.mutationData.unfilterMutations();
		}

		init();
	}

	module.exports = MainMutationController;

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDetailsEvents = __webpack_require__(22);
	var PileupUtil = __webpack_require__(128);
	var MutationDataConverter = __webpack_require__(125);

	var $ = __webpack_require__(7);
	var _ = __webpack_require__(5);

	/**
	 * Controller class for the 3D Mutation view.
	 * Listens to the various events and make necessary changes
	 * on the view wrt each event type.
	 *
	 * @param mutationDetailsView   a MutationDetailsView instance
	 * @param mainMutationView      a MainMutationView instance
	 * @param viewOptions           view component options
	 * @param renderOptions         view class options
	 * @param mut3dVisView          a Mutation3dVisView instance
	 * @param mut3dView             a Mutation3dView instance
	 * @param pdbProxy              proxy for pdb data
	 * @param mutationUtil          data utility class (having the related mutations)
	 * @param geneSymbol            hugo gene symbol (string value)
	 *
	 * @author Selcuk Onur Sumer
	 */
	function Mutation3dController(mutationDetailsView, mainMutationView, viewOptions, renderOptions,
		mut3dVisView, mut3dView, pdbProxy, mutationUtil, geneSymbol)
	{
		// we cannot get pdb panel view as a constructor parameter,
		// since it is initialized after initializing this controller
		var _pdbPanelView = null;
		var _pdbTableView = null;

		var _mut3dVisView = null; // a Mutation3dVisView instance
		var _mut3dVis = null;     // singleton Mutation3dVis instance
		var _mutationDiagram = null;

		// TODO this can be implemented in a better/safer way
		// ...find a way to bind the source info to the actual event

		// flags for distinguishing actual event sources
		var _chainSelectedByTable = false;

		function init()
		{
			if (mainMutationView.diagramView &&
			    mainMutationView.diagramView.mutationDiagram)
			{
				//diagramInitHandler(mainMutationView.diagramView.mutationDiagram);
				_mutationDiagram = mainMutationView.diagramView.mutationDiagram;
			}
			else
			{
				mainMutationView.dispatcher.on(
					MutationDetailsEvents.DIAGRAM_INIT,
					function(diagram) {
						_mutationDiagram = diagram;
					});
			}

			if (mainMutationView.tableView &&
			    mainMutationView.tableView.mutationTable)
			{
				// add listeners for the mutation table view
				mainMutationView.tableView.mutationTable.dispatcher.on(
					MutationDetailsEvents.PDB_LINK_CLICKED,
					pdbLinkHandler);
			}

			// add listeners for the mutation 3d view
			mut3dView.addInitCallback(mut3dInitHandler);

			// add listeners for the mutation details view
			mutationDetailsView.dispatcher.on(
				MutationDetailsEvents.GENE_TAB_SELECTED,
				geneTabSelectHandler);

			// set mut3dVisView instance if it is already initialized
			if (mut3dVisView)
			{
				vis3dCreateHandler(mut3dVisView)
			}
			// if not init yet, wait for the init event
			else
			{
				mutationDetailsView.dispatcher.on(
					MutationDetailsEvents.VIS_3D_PANEL_CREATED,
					vis3dCreateHandler);
			}

			var mutationDataDispatcher = $(mainMutationView.model.mutationData.dispatcher);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_FILTER,
				mutationFilterHandler
			);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_HIGHLIGHT,
				mutationHighlightHandler
			);

			mutationDataDispatcher.on(
				MutationDetailsEvents.MUTATION_SELECT,
				mutationSelectHandler
			);
		}

		function mutationSelectHandler(event, params, noWarning)
		{
			var mutationData = params.mutationData;

			if (_mut3dVisView && _mut3dVisView.isVisible())
			{
				// get all selected and highlighted elements
				var selected = mutationData.getState().selected;
				var highlighted = mutationData.getState().highlighted;

				var combined = _.union(selected, highlighted);

				if (!_.isEmpty(combined))
				{
					// TODO this is an expensive conversion,
					// find a better/faster way to highlight residues without using pileup data
					var pileups = PileupUtil.convertToPileups(
						MutationDataConverter.convertToCollection(combined));
					highlight3dResidues(pileups, noWarning);
				}
				// nothing selected, nothing filtered, show nothing
				else
				{
					// remove all highlights!
					_mut3dVisView.resetHighlight();
					_mut3dVisView.hideResidueWarning();
				}
			}
		}

		function mutationHighlightHandler(event, params)
		{
			// in case of highlight event, no need to update the warning message.
			// so set noWarning = true
			mutationSelectHandler(event, params, true);
		}

		function mutationFilterHandler(event, params)
		{
			// refresh view wrt to filtered data
			if (_mut3dVisView && _mut3dVisView.isVisible())
			{
				// reset all previous visualizer filters
				_mut3dVisView.refreshView();
			}
		}

		function vis3dCreateHandler(mutation3dVisView)
		{
			// init the 3d view initializer & 3D controller
			if (mutation3dVisView)
			{
				_mut3dVisView = mutation3dVisView;
				_mut3dVis = mutation3dVisView.options.mut3dVis;

				// add listeners for the mutation 3d vis view
				_mut3dVisView.dispatcher.on(
					MutationDetailsEvents.VIEW_3D_PANEL_CLOSED,
					view3dPanelCloseHandler);

				_mut3dVisView.dispatcher.on(
					MutationDetailsEvents.VIEW_3D_STRUCTURE_RELOADED,
					view3dReloadHandler);
			}
		}

		function geneTabSelectHandler(gene)
		{
	//		var sameGene = (gene.toLowerCase() == geneSymbol.toLowerCase());
	//		var reset = sameGene &&
	//		            mut3dView &&
	//					mut3dVisView &&
	//		            mut3dVisView.isVisible();

			// reset if the 3D panel is visible,
			// and selected gene is this controller's gene
	//		if (reset)
	//		{
	//			// TODO instead of reset, restore to previous config:
	//			// may need to update resetView and loadDefaultChain methods
	//			// (see issue #456)
	//			mut3dView.resetView();
	//		}

			// just hide the 3D view for now

			if (_mut3dVisView)
			{
				_mut3dVisView.resetPanelPosition();
				_mut3dVisView.hideView();
			}
		}

		function view3dPanelCloseHandler()
		{
			// hide the corresponding pdb panel and table views

			if (_pdbPanelView)
			{
				_pdbPanelView.hideView();
			}
		}

		function mut3dInitHandler(event)
		{
			reset3dView();

			if (_mut3dVisView != null)
			{
				_mut3dVisView.resetPanelPosition();
				_mut3dVisView.maximizeView();
			}
		}

		function panelResizeStartHandler(newHeight, prevHeight, maxHeight)
		{
			// check if it is expanded beyond the max height
			if (newHeight > maxHeight)
			{
				// add the toggle bar at the beginning of the resize
				_pdbPanelView.toggleScrollBar(maxHeight);
			}
		}

		function panelResizeEndHandler(newHeight, prevHeight, maxHeight)
		{
			// check if it is collapsed
			if (newHeight <= maxHeight)
			{
				// remove the toggle bar at the end of the resize
				_pdbPanelView.toggleScrollBar(-1);
			}

			// if there is a change in the size,
			// then also scroll to the correct position
			if (prevHeight != newHeight)
			{
				_pdbPanelView.scrollToSelected();
			}
		}

		function panelChainSelectHandler(element)
		{
			// scroll to the selected chain if selection triggered by the table
			// (i.e: exclude manual selection for the sake of user-friendliness)
			if (_chainSelectedByTable)
			{
				// scroll the view
				_pdbPanelView.scrollToSelected();
			}

			// update 3D view with the selected chain data
			var datum = element.datum();

			if (_mut3dVisView != null)
			{
				_mut3dVisView.maximizeView();
				_mut3dVisView.updateView(geneSymbol, datum.pdbId, datum.chain);
			}

			// also update the pdb table (highlight the corresponding row)
			if (!_chainSelectedByTable &&
			    _pdbTableView != null)
			{
				_pdbTableView.resetFilters();
				_pdbTableView.selectChain(datum.pdbId, datum.chain.chainId);
				_pdbTableView.scrollToSelected();
			}

			// reset the flag
			_chainSelectedByTable = false;
		}

		function view3dReloadHandler()
		{
			var mutationData = mainMutationView.model.mutationData;

			// highlight mutations on the 3D view only if there are mutations to highlight
			if (!_.isEmpty(mutationData.getState().selected) ||
			    !_.isEmpty(mutationData.getState().highlighted))
			{
				highlightSelected();
			}
		}

		function tableChainSelectHandler(pdbId, chainId)
		{
			if (pdbId && chainId)
			{
				_pdbPanelView.selectChain(pdbId, chainId);
				_chainSelectedByTable = true;
			}
		}

		function tableMouseoutHandler()
		{
			_pdbPanelView.pdbPanel.minimizeToHighlighted();
		}

		function tableMouseoverHandler(pdbId, chainId)
		{
			if (pdbId && chainId)
			{
				_pdbPanelView.pdbPanel.minimizeToChain(
					_pdbPanelView.pdbPanel.getChainGroup(pdbId, chainId));
			}
		}

		function initPdbPanel(pdbColl)
		{
			// init pdb panel view if not initialized yet
			if (_pdbPanelView == null)
			{
				_pdbPanelView = mainMutationView.initPdbPanelView(renderOptions.pdbPanel,
					viewOptions.pdbPanel, viewOptions.pdbTable, pdbColl);

				if (_pdbPanelView.pdbPanel)
				{
					// add listeners to the custom event dispatcher of the pdb panel
					_pdbPanelView.pdbPanel.dispatcher.on(
						MutationDetailsEvents.PANEL_CHAIN_SELECTED,
						panelChainSelectHandler);

					_pdbPanelView.pdbPanel.dispatcher.on(
						MutationDetailsEvents.PDB_PANEL_RESIZE_STARTED,
						panelResizeStartHandler);

					_pdbPanelView.pdbPanel.dispatcher.on(
						MutationDetailsEvents.PDB_PANEL_RESIZE_ENDED,
						panelResizeEndHandler);
				}

				// add listeners for the mutation 3d view
				if (viewOptions.pdbTable) {
					_pdbPanelView.addInitCallback(function(event) {
						initPdbTable(pdbColl);
					});
				}
				else {
					// TODO not an ideal way of disabling a view component...
					_pdbPanelView.$el.find(".pdb-table-controls").remove();
				}
			}
		}

		function initPdbTable(pdbColl)
		{
			// init pdb table view if not initialized yet
			if (_pdbTableView == null &&
			    _pdbPanelView != null &&
			    pdbColl.length > 0)
			{
				_pdbTableView = _pdbPanelView.initPdbTableView(pdbColl, function(view, table) {
					// we need to register a callback to add this event listener
					table.dispatcher.on(
						MutationDetailsEvents.PDB_TABLE_READY,
						pdbTableReadyHandler);

					_pdbTableView = view;
				});

				// add listeners to the custom event dispatcher of the pdb table

				_pdbTableView.pdbTable.dispatcher.on(
					MutationDetailsEvents.TABLE_CHAIN_SELECTED,
					tableChainSelectHandler);

				_pdbTableView.pdbTable.dispatcher.on(
					MutationDetailsEvents.TABLE_CHAIN_MOUSEOUT,
					tableMouseoutHandler);

				_pdbTableView.pdbTable.dispatcher.on(
					MutationDetailsEvents.TABLE_CHAIN_MOUSEOVER,
					tableMouseoverHandler);
			}

			if (_pdbPanelView != null &&
			    _pdbTableView != null)
			{
				_pdbPanelView.toggleTableControls();
				_pdbTableView.toggleView();
			}
		}

		function pdbTableReadyHandler()
		{
			if (_pdbPanelView != null)
			{
				// find currently selected chain in the panel
				var gChain = _pdbPanelView.getSelectedChain();

				// select the corresponding row on the table
				if (gChain != null)
				{
					var datum = gChain.datum();
					_pdbTableView.selectChain(datum.pdbId, datum.chain.chainId);
					_pdbTableView.scrollToSelected();
				}
			}
		}

		function pdbLinkHandler(mutationId)
		{
			var mutationMap = mutationUtil.getMutationIdMap();
			var mutation = mutationMap[mutationId];

			if (mutation)
			{
				// reset the view with the selected chain
				reset3dView(mutation.get("pdbMatch").pdbId,
					mutation.get("pdbMatch").chainId);
			}
		}

		/**
		 * Retrieves the pileup data from the selected mutation diagram
		 * elements.
		 *
		 * @return {Array} an array of Pileup instances
		 * @deprecated
		 */
		function getSelectedPileups()
		{
			var pileups = [];

			if (_mutationDiagram)
			{
				// get mutations for all selected elements
				_.each(_mutationDiagram.getSelectedElements(), function (ele, i) {
					pileups = pileups.concat(ele.datum());
				});
			}

			return pileups;
		}

		/**
		 * Highlights 3D residues for the selected diagram elements.
		 */
		function highlightSelected()
		{
			mutationSelectHandler(null, {mutationData: mainMutationView.model.mutationData});
		}

		/**
		 * Highlight residues on the 3D diagram for the given pileup data.
		 *
		 *
		 * @param pileupData    pileups to be highlighted
		 * @param noWarning     if set true, warning messages are not be updated
		 */
		function highlight3dResidues(pileupData, noWarning)
		{
			// highlight 3D residues for the initially selected diagram elements
			var mappedCount = _mut3dVisView.highlightView(pileupData, true);

			var unmappedCount = pileupData.length - mappedCount;

			// no warning flag is provided, do not update the warning text
			if (noWarning)
			{
				return;
			}

			// show a warning message if there is at least one unmapped selection
			if (unmappedCount > 0)
			{
				_mut3dVisView.showResidueWarning(unmappedCount, pileupData.length);
			}
			else
			{
				_mut3dVisView.hideResidueWarning();
			}
		}

		/**
		 * Resets the 3D view to its initial state. This function also initializes
		 * the PDB panel view if it is not initialized yet.
		 *
		 * @param pdbId     initial pdb structure to select
		 * @param chainId   initial chain to select
		 */
		function reset3dView(pdbId, chainId)
		{
			var gene = geneSymbol;
			var uniprotId = mut3dView.model.uniprotId; // TODO get this from somewhere else

			// init (singleton) 3D panel if not initialized yet
			if (!mutationDetailsView.is3dPanelInitialized())
			{
				mutationDetailsView.init3dPanel();
			}

			var initView = function(pdbColl)
			{
				// init pdb panel view if not initialized yet
				if (_pdbPanelView == null)
				{
					initPdbPanel(pdbColl);
				}

				// reload the visualizer content with the given pdb and chain
				if (_mut3dVisView != null &&
				    _pdbPanelView != null &&
				    pdbColl.length > 0)
				{
					updateColorMapper();
					_pdbPanelView.showView();

					if (pdbId && chainId)
					{
						_pdbPanelView.selectChain(pdbId, chainId);
					}
					else
					{
						// select default chain if none provided
						_pdbPanelView.selectDefaultChain();
					}

					// initiate auto-collapse
					_pdbPanelView.autoCollapse();
				}
			};

			if (mut3dView != null &&
			    _mut3dVisView != null)
			{
				_mut3dVisView.showMainLoader();
				_mut3dVisView.showView();
			}

			// init view with the pdb data
			pdbProxy.getPdbData(uniprotId, initView);
		}

		/**
		 * Updates the color mapper of the 3D visualizer.
		 */
		function updateColorMapper()
		{
			// TODO this is not an ideal solution, but...
			// ...while we have multiple diagrams, the 3d visualizer is a singleton
			if (_mutationDiagram)
			{
				var colorMapper = function(mutationId, pdbId, chain) {
					return _mutationDiagram.mutationColorMap[mutationId];
				};

				_mut3dVis.updateOptions({mutationColorMapper: colorMapper});
			}
		}

		init();

		this.reset3dView = reset3dView;
		this.highlightSelected = highlightSelected;
	}

	module.exports = Mutation3dController;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationViewsUtil = __webpack_require__(129);
	var Pileup = __webpack_require__(130);

	var cbio = {
		util: __webpack_require__(6)
	};

	var _ = __webpack_require__(5);

	/**
	 * Singleton utility class for pileup related tasks.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var PileupUtil = (function()
	{
		var _idCounter = 0;

		/**
		 * Processes a Pileup instance, and creates a map of
		 * <mutation type, mutation array> pairs.
		 *
		 * @param pileup    a pileup instance
		 * @return {object} map of mutations (keyed on mutation type)
		 * @private
		 */
		function generateTypeMap(pileup)
		{
			var mutations = pileup.mutations;
			var mutationMap = {};

			// process raw data to group mutations by types
			_.each(mutations, function(mutation) {
				var type = mutation.get("mutationType") || "";
				type = type.trim().toLowerCase();

				if (mutationMap[type] == undefined)
				{
					mutationMap[type] = [];
				}

				mutationMap[type].push(mutation);
			});

			return mutationMap;
		}

		/**
		 * Processes a Pileup instance, and creates an array of
		 * <mutation type, count> pairs. The final array is sorted
		 * by mutation count.
		 *
		 * @param pileup    a pileup instance
		 * @return {Array}  array of mutation type and count pairs
		 */
		function groupMutationsByType(pileup)
		{
			var map = generateTypeMap(pileup);
			var typeArray = [];

			// convert to array and sort by length (count)
			_.each(_.keys(map), function(key) {
				typeArray.push({type: key, count: map[key].length});
			});

			typeArray.sort(function(a, b) {
				// TODO tie condition: priority?
				// descending sort
				return b.count - a.count;
			});

			return typeArray;
		}

		/**
		 * Processes a Pileup instance, and creates an array of
		 * <mutation type group, count> pairs. The final array
		 * is sorted by mutation count.
		 *
		 * @param pileup    a pileup instance
		 * @return {Array}  array of mutation type group and count pairs
		 */
		function groupMutationsByMainType(pileup)
		{
			var mutationTypeMap = MutationViewsUtil.getVisualStyleMaps().mutationType;

			var typeMap = generateTypeMap(pileup);
			var groupArray = [];
			var groupCountMap = {};

			// group mutation types by using the type map
			// and count number of mutations in a group

			_.each(_.keys(typeMap), function(type) {
				// grouping mutations by the style (not by the type)
				var group = undefined;

				if (mutationTypeMap[type] != null)
				{
					group = mutationTypeMap[type].mainType;
				}

				if (group == undefined)
				{
					group = mutationTypeMap.other.mainType;
				}

				if (groupCountMap[group] == undefined)
				{
					// init count
					groupCountMap[group] = 0;
				}

				groupCountMap[group] += typeMap[type].length;
			});

			// convert to array and sort by length (count)

			_.each(_.keys(groupCountMap), function(group) {
				groupArray.push({type: group,
					count: groupCountMap[group],
					priority: mutationTypeMap[group].priority});
			});

			groupArray.sort(function(a, b) {
				if (b.count === a.count) {
					// tie condition: use mutation type priority
					return b.priority - a.priority;
				}
				else {
					// descending sort
					return b.count - a.count;
				}
			});

			return groupArray;
		}

		function nextId()
		{
			_idCounter++;

			return "pileup_" + _idCounter;
		}

		/**
		 * Creates a map of <mutation sid>, <pileup id> pairs.
		 *
		 * @param pileups   list of pileups
		 * @return {Object} <mutation sid> to <pileup id> map
		 */
		function mapToMutations(pileups)
		{
			var map = {};

			// map each mutation sid to its corresponding pileup
			_.each(pileups, function(pileup) {
				_.each(pileup.mutations, function(mutation) {
					map[mutation.get("mutationSid")] = pileup.pileupId;
				})
			});

			return map;
		}

		/**
		 * Converts the provided mutation data into a list of Pileup instances.
		 *
		 * @param mutationColl  collection of Mutation models (MutationCollection)
		 * @param converter     [optional] custom pileup converter function
		 * @return {Array}      a list of pileup mutations
		 */
		function convertToPileups(mutationColl, converter)
		{
			// remove redundant mutations by sid
			mutationColl = removeRedundantMutations(mutationColl);

			// create a map of mutations (key is the mutation location)
			var mutations = {};

			for (var i=0; i < mutationColl.length; i++)
			{
				var mutation = mutationColl.at(i);

				var location = mutation.getProteinStartPos();
				var type = mutation.get("mutationType") || "";
				type = type.trim().toLowerCase();

				if (location != null && type != "fusion")
				{
					if (mutations[location] == null)
					{
						mutations[location] = [];
					}

					mutations[location].push(mutation);
				}
			}

			// convert map into an array of piled mutation objects
			var pileupList = [];

			_.each(_.keys(mutations), function(key) {
				var pileup = {};

				if (_.isFunction(converter)) {
					pileup = converter(mutations, key);
				}
				else {
					pileup = initPileup(mutations, key);
				}

				pileupList.push(new Pileup(pileup));
			});

			// sort (descending) the list wrt mutation count
			pileupList.sort(function(a, b) {
				var diff = b.count - a.count;

				// if equal, then compare wrt position (for consistency)
				if (diff == 0)
				{
					diff = b.location - a.location;
				}

				return diff;
			});

			return pileupList;
		}

		function initPileup(mutations, location)
		{
			var pileup = {};

			pileup.pileupId = PileupUtil.nextId();
			pileup.mutations = mutations[location];
			pileup.count = mutations[location].length;
			pileup.location = parseInt(location);
			pileup.label = generateLabel(mutations[location]);

			// TODO can we separate this in the cbioportal codebase as a custom converter?
			// The following calculates dist of mutations by cancer type
			pileup.stats = _.chain(mutations[location])
				.groupBy(function(mut) { return mut.get("cancerType"); })
				.sortBy(function(stat) { return -stat.length; })
				.reduce(function(seed, o) {
					seed.push({ cancerType: o[0].get("cancerType"), count: o.length });
					return seed;
				}, []).value();

			return pileup;
		}

		// TODO first remove by mutationSid, and then remove by patientId
		function removeRedundantMutations(mutationData)
		{
			// remove redundant mutations by sid
			var redMap = {};
			var removeItems = [];

			for (var i=0; i < mutationData.length; i++)
			{
				var aMutation = mutationData.at(i);
				var exists = redMap[aMutation.get("mutationSid")];
				if(exists == null) {
					redMap[aMutation.get("mutationSid")] = true;
				} else {
					removeItems.push(aMutation);
				}
			}

			mutationData.remove(removeItems);

			return mutationData;
		}

		/**
		 * Generates a pileup label by joining all unique protein change
		 * information in the given array of mutations.
		 *
	 	 * @param mutations     a list of mutations
		 * @returns {string}    pileup label
		 */
		function generateLabel(mutations)
		{
			var mutationSet = {};

			// create a set of protein change labels
			// (this is to eliminate duplicates)
			_.each(mutations, function(mutation) {
				if (mutation.get("proteinChange") != null &&
				    mutation.get("proteinChange").length > 0)
				{
					mutationSet[mutation.get("proteinChange")] = mutation.get("proteinChange");
				}
			});

			// convert to array & sort
			var mutationArray = _.keys(mutationSet).sort();

			// find longest common starting substring
			// (this is to truncate redundant starting substring)

			var startStr = "";

			if (mutationArray.length > 1)
			{
				startStr = cbio.util.lcss(mutationArray[0],
				                          mutationArray[mutationArray.length - 1]);

	//			console.log(mutationArray[0] + " n " +
	//			            mutationArray[mutationArray.length - 1] + " = " +
	//			            startStr);
			}

			// generate the string
			var label = startStr;

			_.each(mutationArray, function(mutation) {
				label += mutation.substring(startStr.length) + "/";
			});

			// remove the last slash
			return label.substring(0, label.length - 1);
		}

		/**
		 * Counts the number of total mutations for the given
		 * Pileup array.
		 *
		 * @param pileups   an array of Pileup instances
		 */
		function countMutations(pileups)
		{
			var total = 0;

			_.each(pileups, function(pileup) {
				total += pileup.count;
			});

			return total;
		}

		/**
		 * Returns all the mutation model instances within the given
		 * collection of pileups.
		 *
		 * @param pileups   a collection of pileups
		 * @returns {Array} mutations within the given pileups
		 */
		function getPileupMutations(pileups)
		{
			var mutations = [];

			_.each(pileups, function(pileup) {
				mutations = mutations.concat(pileup.get("mutations") || []);
			});

			return mutations;
		}

		return {
			nextId: nextId,
			mapToMutations: mapToMutations,
			convertToPileups: convertToPileups,
			initPileup: initPileup,
			countMutations: countMutations,
			getPileupMutations: getPileupMutations,
			getMutationTypeMap: generateTypeMap,
			groupMutationsByType: groupMutationsByType,
			groupMutationsByMainType: groupMutationsByMainType
		};
	})();

	module.exports = PileupUtil;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var BackboneTemplateCache = __webpack_require__(23);

	var loaderImage = __webpack_require__(85);

	var $ = __webpack_require__(7);
	var _ = __webpack_require__(5);

	/**
	 * Singleton utility class for Mutation View related tasks.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationViewsUtil = (function()
	{
		/**
		 * Mapping between the mutation type (data) values and
		 * view values.
		 */

		var _mutationStyleMap = {
			missense: {label: "Missense",
				longName: "Missense",
				style: "missense_mutation",
				mainType: "missense",
				priority: 1},
			inframe: {label: "IF",
				longName: "In-frame",
				style: "inframe_mutation",
				mainType: "inframe",
				priority: 2},
			truncating: {
				label: "Truncating",
				longName: "Truncating",
				style: "trunc_mutation",
				mainType: "truncating",
				priority: 4},
			nonsense: {label: "Nonsense",
				longName: "Nonsense",
				style: "trunc_mutation",
				mainType: "truncating",
				priority: 6},
			nonstop: {label: "Nonstop",
				longName: "Nonstop",
				style: "trunc_mutation",
				mainType: "truncating",
				priority: 7},
			nonstart: {label: "Nonstart",
				longName: "Nonstart",
				style: "trunc_mutation",
				mainType: "truncating",
				priority: 8},
			frameshift: {label: "FS",
				longName: "Frame Shift",
				style: "trunc_mutation",
				mainType: "truncating",
				priority: 4},
			frame_shift_del: {label: "FS del",
				longName: "Frame Shift Deletion",
				style: "trunc_mutation",
				mainType: "truncating",
				priority: 4},
			frame_shift_ins: {label: "FS ins",
				longName: "Frame Shift Insertion",
				style: "trunc_mutation",
				mainType: "truncating",
				priority: 5},
			in_frame_ins: {label: "IF ins",
				longName: "In-frame Insertion",
				style: "inframe_mutation",
				mainType: "inframe",
				priority: 3},
			in_frame_del: {label: "IF del",
				longName: "In-frame Deletion",
				style: "inframe_mutation",
				mainType: "inframe",
				priority: 2},
			splice_site: {label: "Splice",
				longName: "Splice site",
				style: "trunc_mutation",
				mainType: "truncating",
				priority: 9},
			fusion: {label: "Fusion",
				longName: "Fusion",
				style: "fusion",
				mainType: "other",
				priority: 10},
			silent: {label: "Silent",
				longName: "Silent",
				style: "other_mutation",
				mainType: "other",
				priority: 11},
			// this
			default: {label: "Other",
				longName: "Other",
				style: "other_mutation",
				mainType: "other",
				priority: 11},
			// mutations mapped to "other" will be labelled
			// with their original data value
			other: {style: "other_mutation",
				mainType: "other",
				priority: 11}
		};

		var _mutationTypeMap = {
			"missense_mutation": _mutationStyleMap.missense,
			"missense": _mutationStyleMap.missense,
			"missense_variant": _mutationStyleMap.missense,
			"frame_shift_ins": _mutationStyleMap.frame_shift_ins,
			"frame_shift_del": _mutationStyleMap.frame_shift_del,
			"frameshift": _mutationStyleMap.frameshift,
			"frameshift_deletion": _mutationStyleMap.frame_shift_del,
			"frameshift_insertion": _mutationStyleMap.frame_shift_ins,
			"de_novo_start_outofframe": _mutationStyleMap.frameshift,
			"frameshift_variant": _mutationStyleMap.frameshift,
			"nonsense_mutation": _mutationStyleMap.nonsense,
			"nonsense": _mutationStyleMap.nonsense,
			"stopgain_snv": _mutationStyleMap.nonsense,
			"stop_gained": _mutationStyleMap.nonsense,
			"splice_site": _mutationStyleMap.splice_site,
			"splice": _mutationStyleMap.splice_site,
			"splice site": _mutationStyleMap.splice_site,
			"splicing": _mutationStyleMap.splice_site,
			"splice_site_snp": _mutationStyleMap.splice_site,
			"splice_site_del": _mutationStyleMap.splice_site,
			"splice_site_indel": _mutationStyleMap.splice_site,
			"splice_region_variant": _mutationStyleMap.splice_site,
			"translation_start_site":  _mutationStyleMap.nonstart,
			"initiator_codon_variant": _mutationStyleMap.nonstart,
			"start_codon_snp": _mutationStyleMap.nonstart,
			"start_codon_del": _mutationStyleMap.nonstart,
			"nonstop_mutation": _mutationStyleMap.nonstop,
			"stop_lost": _mutationStyleMap.nonstop,
			"in_frame_del": _mutationStyleMap.in_frame_del,
			"in_frame_deletion": _mutationStyleMap.in_frame_del,
			"in_frame_ins": _mutationStyleMap.in_frame_ins,
			"in_frame_insertion": _mutationStyleMap.in_frame_ins,
			"indel": _mutationStyleMap.in_frame_del,
			"nonframeshift_deletion": _mutationStyleMap.inframe,
			"nonframeshift": _mutationStyleMap.inframe,
			"nonframeshift insertion": _mutationStyleMap.inframe,
			"nonframeshift_insertion": _mutationStyleMap.inframe,
			"targeted_region": _mutationStyleMap.inframe,
			"inframe": _mutationStyleMap.inframe,
			"truncating": _mutationStyleMap.truncating,
			"feature_truncation": _mutationStyleMap.truncating,
			"fusion": _mutationStyleMap.fusion,
			"silent": _mutationStyleMap.silent,
			"synonymous_variant": _mutationStyleMap.silent,
			"any": _mutationStyleMap.default,
			"other": _mutationStyleMap.default
		};

		/**
		 * Mapping between the validation status (data) values and
		 * view values.
		 */
		var _validationStatusMap = {
			valid: {label: "V", style: "valid", tooltip: "Valid"},
			validated: {label: "V", style: "valid", tooltip: "Valid"},
			wildtype: {label: "W", style: "wildtype", tooltip: "Wildtype"},
			unknown: {label: "U", style: "unknown", tooltip: "Unknown"},
			not_tested: {label: "U", style: "unknown", tooltip: "Unknown"},
			none: {label: "U", style: "unknown", tooltip: "Unknown"},
			na: {label: "U", style: "unknown", tooltip: "Unknown"}
		};

		/**
		 * Mapping between the mutation status (data) values and
		 * view values.
		 */
		var _mutationStatusMap = {
			somatic: {label: "S", style: "somatic", tooltip: "Somatic"},
			germline: {label: "G", style: "germline", tooltip: "Germline"},
			unknown: {label: "U", style: "unknown", tooltip: "Unknown"},
			none: {label: "U", style: "unknown", tooltip: "Unknown"},
			na: {label: "U", style: "unknown", tooltip: "Unknown"}
		};

		/**
		 * Mapping between the functional impact score (data) values and
		 * view values.
		 */
		var _omaScoreMap = {
			h: {label: "High", style: "oma_high", tooltip: "High"},
			m: {label: "Medium", style: "oma_medium", tooltip: "Medium"},
			l: {label: "Low", style: "oma_low", tooltip: "Low"},
			n: {label: "Neutral", style: "oma_neutral", tooltip: "Neutral"}
		};

		/**
		 * Mapping btw the copy number (data) values and view values.
		 */
		var _cnaMap = {
			"-2": {label: "DeepDel", style: "cna-homdel", tooltip: "Deep deletion"},
			"-1": {label: "ShallowDel", style: "cna-hetloss", tooltip: "Shallow deletion"},
			"0": {label: "Diploid", style: "cna-diploid", tooltip: "Diploid / normal"},
			"1": {label: "Gain", style: "cna-gain", tooltip: "Low-level gain"},
			"2": {label: "AMP", style: "cna-amp", tooltip: "High-level amplification"},
			"unknown" : {label: "NA", style: "cna-unknown", tooltip: "CNA data is not available for this gene"}
		};

		/**
		 * Returns all visual style mappings in a single object.
		 *
		 * @return {Object} style maps in a single object
		 */
		function getVisualStyleMaps()
		{
			return {
				mutationType: _mutationTypeMap,
				validationStatus: _validationStatusMap,
				mutationStatus: _mutationStatusMap,
				omaScore: _omaScoreMap,
				cna: _cnaMap
			};
		}

		function defaultTableTooltipOpts()
		{
			return {
				content: {attr: 'alt'},
				show: {event: 'mouseover'},
				hide: {fixed: true, delay: 100, event: 'mouseout'},
				style: {classes: 'mutation-details-tooltip qtip-shadow qtip-light qtip-rounded'},
				position: {my:'top left', at:'bottom right', viewport: $(window)}
			};
		}

		/**
		 * Renders a placeholder image for data tables cell.
		 *
		 * @param imageLocation place holder image location (url)
		 * @returns {String} html string
		 */
		function renderTablePlaceholder(imageLocation)
		{
			imageLocation = imageLocation || loaderImage;

			// TODO customize width & height?
			var vars = {loaderImage: imageLocation, width: 15, height: 15};
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_placeholder_template");
			return templateFn(vars);
		}

		/**
		 * Refreshes the entire column in the data table.
		 * This function does NOT update the actual value of the cells.
		 * The update is for re-rendering purposes only.
		 *
		 * @param dataTable
		 * @param indexMap
		 * @param columnName
		 */
		function refreshTableColumn(dataTable, indexMap, columnName)
		{
			var tableData = dataTable.fnGetData();

			_.each(tableData, function(ele, i) {
				dataTable.fnUpdate(null, i, indexMap[columnName], false, false);
			});

			if (tableData.length > 0)
			{
				// this update is required to re-render the entire column!
				dataTable.fnUpdate(null, 0, indexMap[columnName]);
			}
		}

		return {
			renderTablePlaceHolder: renderTablePlaceholder,
			refreshTableColumn: refreshTableColumn,
			defaultTableTooltipOpts: defaultTableTooltipOpts,
			getVisualStyleMaps: getVisualStyleMaps
		};
	})();

	module.exports = MutationViewsUtil;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var Backbone = __webpack_require__(12);

	/**
	 * Pileup Model.
	 *
	 * This model is designed to represent multiple mutations at the same
	 * position. This is intended to be used for mutation diagram.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var Pileup = Backbone.Model.extend({
		initialize: function(attributes) {
			this.pileupId = attributes.pileupId; // incremental id (client-side generated)
			this.mutations = attributes.mutations; // array of mutations at this data point
			this.count = attributes.count; // number of mutations at this data point
			this.location = attributes.location; // the location of the mutations
			this.label = attributes.label; // text label for this data point
			this.stats = attributes.stats;
		}
	});

	module.exports = Pileup;

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var Mol3DScriptGenerator = __webpack_require__(132);
	var Mol3DWrapper = __webpack_require__(135);
	var PymolScriptGenerator = __webpack_require__(136);

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);

	/**
	 * 3D Mutation Visualizer, currently built on Jmol/JSmol lib.
	 *
	 * @param name      name of the visualizer (applet/application name)
	 * @param options   visualization (Jmol) options
	 * @constructor
	 *
	 * @author Selcuk Onur Sumer
	 */
	function Mutation3dVis(name, options)
	{
		// main container -- html element
		var _container = null;

		// actual 3D application wrapper
		var _3dApp = null;

		// flag to indicate panel size minimization
		var _minimized = false;

		// current selection (mutation positions as Jmol script compatible strings)
		// this is a map of <color, position array> pairs
		var _selection = null;

		// map of mutation ids to corresponding residue positions
		var _highlighted = {};

		// current chain (PdbChainModel instance)
		var _chain = null;

		// current pdb id
		var _pdbId = null;

		// spin indicator (initially off)
		var _spin = "OFF";

		// used for glow effect on highlighted mutations
		var _glowInterval = null;

		// default visualization options
		var defaultOpts = {
			// applet/application (Jmol/JSmol) options
			appOptions: {
				width: 400,
				height: 300,
				debug: false,
				color: "white"
			},
			pdbUri: "http://www.rcsb.org/pdb/files/", // default PDB database URI
			frame: "jsmol_frame.html",  // default JSmol frame target
			proteinScheme: "cartoon", // default style of the protein structure
			restrictProtein: false, // restrict to protein only (hide other atoms)
			defaultColor: "#DDDDDD", // default color of the whole structure
			structureColors: { // default colors for special structures
				alphaHelix: "#FFA500",
				betaSheet: "#0000FF",
				loop: "#DDDDDD"
			}, // structure color takes effect only when corresponding flag is set
			defaultTranslucency: 5, // translucency (opacity) of the whole structure
			chainColor: "#888888", // color of the selected chain
			chainTranslucency: 0, // translucency (opacity) of the selected chain
			colorProteins: "uniform", // "uniform": single color, effective for all schemes
			                          // "bySecondaryStructure": not effective for space-filling scheme
			                          // "byAtomType": effective only for space-filling scheme
			                          // "byChain": not effective for space-filling scheme
			colorMutations: "byMutationType", // "byMutationType": use mutation colors for type
			                                  // "uniform": use a single color
			                                  // "none": do not color (use default atom colors)
			mutationColor: "#8A2BE2",  // uniform color of the mutated residues
			highlightColor: "#FFDD00", // color of the user-selected mutations
			highlightGradient: ["#FFDD00", "#000000"], // gradient highlight colors used for glow effect
			addGlowEffect: false, // whether to add glow effect to highlighted mutations
			displaySideChain: "highlighted", // highlighted: display side chain for only selected mutations
			                                 // all: display side chain for all mapped mutations
			                                 // none: do not display side chain atoms
			defaultZoom: 100, // default (unfocused) zoom level
			focusZoom: 250, // focused zoom level
			containerPadding: 10, // padding for the vis container (this is to prevent overlapping)
			// TODO minimized length is actually depends on padding values, it might be better to calculate it
			minimizedHeight: 10, // minimized height of the container (assuming this will hide everything but the title)
			// color mapper function for mutations
			mutationColorMapper: function (mutationId, pdbId, chain) {
				return "#FF0000"; // just return the default color for all
			}
		};

		var _options = jQuery.extend(true, {}, defaultOpts, options);

		// main script generator for the embedded visualizer
		//var _scriptGen = new JmolScriptGenerator();
		var _scriptGen = new Mol3DScriptGenerator();

		/**
		 * Initializes the visualizer.
		 */
		function init()
		{
			// TODO make init optional (Jmol, JSmol, 3Dmol, etc.)
			// init html5 version (Jsmol)
			//_3dApp = new JmolWrapper(false);

			// init framed JSmol version
			//_3dApp = new JSmolWrapper();

			// init app (with frames)
			//_3dApp.init(name, _options.appOptions, _options.frame);

			// init app (without frames frames)
			//_3dApp.init(name, _options.appOptions);

			_3dApp = new Mol3DWrapper();
			_3dApp.init(name, _options.appOptions);
			_scriptGen.setViewer(_3dApp.getViewer());
			_scriptGen.setPdbUri(_options.pdbUri);

			// TODO memory leak -- eventually crashes the browser
	//		if (_options.addGlowEffect)
	//		{
	//			addGlowEffect();
	//		}
		}

		/**
		 * Updates visualizer container.
		 *
		 * @param container html element
		 */
		function updateContainer(container)
		{
			// update reference
			_container = $(container);

			var appContainer = _container.find(".mutation-3d-vis-container");

			// set width
			appContainer.css("width", _options.appOptions.width);
			// set height (should be slightly bigger than the app height)
			appContainer.css("height", _options.appOptions.height + _options.containerPadding);
			// update app container
			_3dApp.updateContainer(appContainer);
		}

		/**
		 * Toggles the spin.
		 */
		function toggleSpin()
		{
			_spin == "ON" ? _spin = "OFF" : _spin = "ON";

			var script = _scriptGen.spin(_spin);

			_3dApp.script(script);
		}

		/**
		 * Reapply the visual style for the current options.
		 */
		function reapplyStyle()
		{
	//		var script = "select all;" +
	//		             _styleScripts[style];
			// regenerate visual style script
			var script = _scriptGen.generateVisualStyleScript(_selection, _chain, _options);

			// regenerate highlight script
			script = script.concat(generateHighlightScript(_highlighted));

			// convert array to a single string
			script = script.join(" ");
			_3dApp.script(script);
		}

		/**
		 * Shows the visualizer panel.
		 */
		function show()
		{
			if (_container != null)
			{
				_container.show();
			}
		}

		/**
		 * Hides the visualizer panel.
		 */
		function hide()
		{
			if (_container != null)
			{
				_container.hide();
			}
		}

		/**
		 * Minimizes the container (only title will be shown)
		 */
		function minimize()
		{
			// minimize container
			if (_container != null)
			{
				_container.css({"overflow": "hidden",
					"height": _options.minimizedHeight});
				_minimized = true;
			}
		}

		/**
		 * Maximizes the container to its full height
		 */
		function maximize()
		{
			if (_container != null)
			{
				_container.css({"overflow": "", "height": ""});
				_minimized = false;
			}
		}

		function toggleSize()
		{
			if (_container != null)
			{
				if(_minimized)
				{
					maximize();
				}
				else
				{
					minimize();
				}
			}
		}

		function isVisible()
		{
			var top = parseInt(_container.css("top"));

			var hidden = (top == -9999) || _container.is(":hidden");

			return !hidden;
		}

		/**
		 * Reloads the protein view for the given PDB id and the chain.
		 *
		 * This function returns an array of mapping mutations (residues).
		 * If there is no mapping residue for currently visible mutations on
		 * the diagram, then function returns false. Note that this function
		 * returns without waiting the callback function to be invoked.
		 *
		 * @param pdbId     PDB id
		 * @param chain     PdbChainModel instance
		 * @param callback  function to call after reload
		 * @return  {Array} array of mapped mutation ids
		 */
		function reload(pdbId, chain, callback)
		{
			var mappedMutations = [];

			// reset highlights
			_highlighted = {};

			// pdbId and/or chainId may be null
			if (!pdbId || !chain)
			{
				// nothing to load
				return mappedMutations;
			}

			// save current pdb id & chain for a possible future access
			_chain = chain;
			_pdbId = pdbId;

			// update selection map
			mappedMutations = updateSelectionMap(pdbId, chain);

			// construct Jmol script string
			var script = [];

			// this callback is required for 3Dmol, since loadPdb function is async!
			var loadCallback = function() {
				script.push(loadPdb); // load the corresponding pdb

				script = script.concat(
					_scriptGen.generateVisualStyleScript(_selection, _chain, _options));

				// TODO spin is currently disabled...
				//script.push("spin " + _spin + ";");

				// convert array into a string (to pass to Jmol)
				script = script.join(" ");

				// run script
				_3dApp.script(script, callback);

				// workaround to fix the problem where canvas is initially invisible
				resizeViewer();

				//if (_container != null)
				//{
				//	$(_container).resize();
				//}
			};

			var loadPdb = _scriptGen.loadPdb(pdbId, loadCallback);

			// any other script generator should return the actual script value,
			// so this means callback function is NOT called within the script generator
			// we need to call it explicitly
			if (loadPdb != "$3Dmol")
			{
				loadCallback();
			}

			return mappedMutations;
		}

		/**
		 * Refreshes the view without reloading the pdb structure.
		 * Using this function instead of reload makes things
		 * a lot faster for filtering operations.
		 *
		 * @return  {Array} array of mapped mutation ids
		 */
		function refresh()
		{
			var mappedMutations = [];

			// reset highlights
			_highlighted = {};

			// pdbId and/or chainId may be null
			if (_pdbId == null || _chain == null)
			{
				// nothing to refresh
				return mappedMutations;
			}

			// update selection map
			mappedMutations = updateSelectionMap(_pdbId, _chain);

			var script = [];

			// update visual style by using the updated selection map
			script = script.concat(
				_scriptGen.generateVisualStyleScript(_selection, _chain, _options));

			// convert array into a string (to pass to Jmol)
			script = script.join(" ");

			// run script
			_3dApp.script(script);

			return mappedMutations;
		}

		/**
		 * Updates the selection map for the current pdbId and chain
		 * by using the corresponding color mapper function.
		 *
		 * @param pdbId     PDB id
		 * @param chain     PdbChainModel instance
		 * @return {Array}  array of mapped mutation ids
		 */
		function updateSelectionMap(pdbId, chain)
		{
			// update selection for a possible future restore
			var result = generateColorMap(pdbId, chain, _options, _scriptGen);

			_selection = result.colorMap;

			return result.mappedMutations;
		}

		/**
		 * Generates color mapping for the mutations within the position map
		 * of the given chain.
		 *
		 * @param pdbId     pdb id as a string
		 * @param chain     a PdbChainModel instance
		 * @param options   visual style options
		 * @param scriptGen a MolScriptGenerator instance
		 * @returns {Object} map of <color, script position array> and mapped mutations
		 */
		function generateColorMap (pdbId, chain, options, scriptGen)
		{
			var mappedMutations = [];
			var colorMap = {};
			var color = options.mutationColor;

			// update the residue selection map wrt mutation color mapper
			_.each(_.keys(chain.positionMap), function(mutationId) {
				var position = chain.positionMap[mutationId];

				if (_.isFunction(options.mutationColorMapper))
				{
					color = options.mutationColorMapper(mutationId, pdbId, chain);
				}

				// do not color at all if the color is null,
				// this automatically hides user-filtered mutations
				// TODO but this also hides unmapped mutations (if any)
				if (color != null)
				{
					if (colorMap[color] == null)
					{
						// using an object instead of an array (to avoid duplicates)
						colorMap[color] = {};
					}

					var scriptPos = scriptGen.scriptPosition(position);
					colorMap[color][scriptPos] = scriptPos;
					mappedMutations.push(mutationId);
				}
				//else
				//{
				//	color = defaultOpts.mutationColor;
				//}
			});

			// convert maps to arrays
			_.each(colorMap, function(value, key, list) {
				// key is a "color"
				// value is a "position script string" map
				list[key] = _.values(value);
			});

			return {
				colorMap: colorMap,
				mappedMutations: mappedMutations
			};
		}

		/**
		 * Centers the view onto the currently highlighted residue.
		 *
		 * @return {boolean} true if center successful, false otherwise
		 */
		function centerOnHighlighted()
		{
			// perform action if there is only one highlighted position
			if (_.size(_highlighted) != 1)
			{
				return false;
			}

			var script = [];

			_.each(_highlighted, function (position) {
				script = script.concat(generateCenterScript(position));
			});

			// convert array to a single string
			script = script.join(" ");

			// send script string to the app
			_3dApp.script(script);

			return true;
		}

		/**
		 * Resets the current center to the default position.
		 */
		function resetCenter()
		{
			var script = [];

			// center to default position
			script.push(_scriptGen.defaultCenter());

			// convert array to a single string
			script = script.join(" ");

			// send script string to the app
			_3dApp.script(script);
		}

		function resizeViewer()
		{
			if (_3dApp.getViewer)
			{
				_3dApp.getViewer().resize();
			}
		}

		/**
		 * Focuses on the residue corresponding to the given pileup. If there is
		 * no corresponding residue for the given pileup, this function does not
		 * perform a focus operation, and returns false.
		 *
		 * @param pileup    Pileup instance
		 * @return {boolean}    true if there there a matching residue, false o.w.
		 */
		function focus(pileup)
		{
			// no chain selected yet, terminate
			if (_chain == null)
			{
				return false;
			}

			// assuming all other mutations in the same pileup have
			// the same (or very close) mutation position.
			var id = pileup.mutations[0].get("mutationId");

			// get script
			var script = generateFocusScript(id);
			//script = script.concat(generateHighlightScript(id));

			// check if the script is valid
			if (script.length > 0)
			{
				// convert array to a single string
				script = script.join(" ");

				// send script string to the app
				_3dApp.script(script);
			}
			// no mapping position for this mutation on this chain
			else
			{
				// just reset focus
				resetFocus();
				return false;
			}

			return true;
		}

		/**
		 * Resets the current focus to the default position and zoom level.
		 */
		function resetFocus()
		{
			// zoom out to default zoom level, center to default position,
			// and remove all selection highlights
			var script = [];
			script.push(_scriptGen.zoom(_options.defaultZoom)); // zoom to default zoom level
			script.push(_scriptGen.defaultCenter()); // center to default position

			// convert array to a single string
			script = script.join(" ");

			// send script string to the app
			_3dApp.script(script);
		}

		/**
		 * Highlights the residue corresponding to the given pileups. This
		 * function returns the number of successfully mapped residues
		 * for the given pileups (returns zero if no mapping at all).
		 *
		 * @param pileups   an array of Pileup instances
		 * @param reset     indicates whether to reset previous highlights
		 * @return {Number} number of mapped pileups (residues)
		 */
		function highlight(pileups, reset)
		{
			// no chain selected yet, terminate
			if (_chain == null)
			{
				return 0;
			}

			if (reset)
			{
				// reset all previous highlights
				_highlighted = {};
			}

			// init script generation
			var script = _scriptGen.generateVisualStyleScript(_selection, _chain, _options);

			var numMapped = 0;

			_.each(pileups, function(pileup, i) {
				// assuming all other mutations in the same pileup have
				// the same (or very close) mutation position.
				var id = pileup.mutations[0].get("mutationId");
				var position = _chain.positionMap[id];

				if (position != null)
				{
					// add position to the highlighted ones
					_highlighted[id] = position;
					numMapped++;
				}
			});

			// add highlight script string
			script = script.concat(generateHighlightScript(_highlighted));

			// convert array to a single string
			script = script.join(" ");

			// send script string to the app
			_3dApp.script(script);

			// return number of mapped residues for the given pileups
			return numMapped;
		}

		/**
		 * Refreshes the current highlights.
		 */
		function refreshHighlight()
		{
			var script = generateHighlightScript(_highlighted);

			// convert array to a single string
			script = script.join(" ");

			// send script string to the app
			_3dApp.script(script);
		}

		/**
		 * Remove all highlights.
		 */
		function resetHighlight()
		{
			// reset highlight map
			_highlighted = {};

			// remove all selection highlights
			var script = _scriptGen.generateVisualStyleScript(_selection, _chain, _options);

			// convert array to a single string
			script = script.join(" ");

			_3dApp.script(script);
		}

		/**
		 * Generates the highlight script to be sent to the 3D app.
		 *
		 * @param positions mutation positions to highlight
		 * @return {Array}  script lines as an array
		 */
		function generateHighlightScript(positions)
		{
			return _scriptGen.generateHighlightScript(
				positions, _options.highlightColor, _options, _chain);
		}

		/**
		 * Generates the center script to be sent to the 3D app.
		 *
		 * @param position  position to center onto
		 * @return {Array}  script lines as an array
		 */
		function generateCenterScript(position)
		{
			var script = [];

			// center to the selection
			script.push(_scriptGen.center(position, _chain.chainId));

			return script;
		}

		/**
		 * Generates the focus script to be sent to the 3D app.
		 *
		 * @param mutationId    id of the mutation to highlight
		 * @return {Array}      script lines as an array
		 */
		function generateFocusScript(mutationId)
		{
			var script = [];
			var position = _chain.positionMap[mutationId];

			// check if the mutation maps on this chain
			if (position != null)
			{
				// center and zoom to the selection
				script.push(_scriptGen.zoom(_options.focusZoom));
				script.push(_scriptGen.center(position, _chain.chainId));
			}

			return script;
		}

		/**
		 * Performs the default zoom in operation.
		 * (Uses default zoom level defined by the underlying 3D visualizer)
		 */
		function zoomIn()
		{
			_3dApp.script(_scriptGen.defaultZoomIn());
		}

		/**
		 * Performs the default zoom out operation.
		 * (Uses default zoom value defined by the underlying 3D visualizer)
		 */
		function zoomOut()
		{
			_3dApp.script(_scriptGen.defaultZoomOut());
		}

		/**
		 * Zooms to default zoom level.
		 */
		function zoomActual()
		{
			_3dApp.script(_scriptGen.zoom(_options.defaultZoom));
		}

		/**
		 * Zooms to the given zoom level.
		 *
		 * @param value desired zoom level
		 */
		function zoomTo(value)
		{
			_3dApp.script(_scriptGen.zoom(value));
		}

		/**
		 * Updates the options of the 3D visualizer.
		 *
		 * @param options   new options object
		 */
		function updateOptions(options)
		{
			_options = jQuery.extend(true, {}, _options, options);
		}

		/**
		 * Adds glow effect to the user selected (highlighted) mutations.
		 */
		function addGlowEffect()
		{
			// clear previous glow interval (if any)
			if (_glowInterval != null)
			{
				clearInterval(_glowInterval);
			}

			// create gradient color generator
			var gradient = new Rainbow();
			var range = 16;
			var index = 0;
			gradient.setNumberRange(0, range - 1);
			gradient.setSpectrum(_options.highlightGradient[0].replace("#", ""),
			                     _options.highlightGradient[1].replace("#", ""));

			// convert positions to script positions
			var scriptPositions = null;

			// set new interval
			_glowInterval = setInterval(function() {
				var highlightCount = _.size(_highlighted);

				if (highlightCount > 0)
				{
					// TODO update script position each time _highlighted is updated
					if (scriptPositions == null ||
					    scriptPositions.length != highlightCount)
					{
						scriptPositions = _scriptGen.highlightScriptPositions(_highlighted);
					}
				}

				if (scriptPositions != null &&
				    scriptPositions.length > 0)
				{
					var color = "#" + gradient.colorAt(index);
					var script = _scriptGen.highlightScript(
						scriptPositions, color, _options, _chain);

					// convert array to a single string
					script = script.join(" ");

					// send script string to the app
					_3dApp.script(script);

					index = (index + 1) % range;
				}
			}, 50);
		}

		/**
		 * Generates a PymolScript from the current state of the 3D visualizer.
		 */
		function generatePymolScript()
		{
			var scriptGen = new PymolScriptGenerator();
			var script = [];

			// reinitialize
			script.push(scriptGen.reinitialize());

			// set background color
			script.push(scriptGen.bgColor(_options.appOptions.color));

			// load current pdb
			script.push(scriptGen.loadPdb(_pdbId));

			// generate visual style from current options
			script = script.concat(
				scriptGen.generateVisualStyleScript(
					_selection, _chain, _options));

			// generate highlight script from current highlights
			script = script.concat(
				scriptGen.generateHighlightScript(
					_highlighted, _options.highlightColor, _options, _chain));

			script.push(scriptGen.selectNone());

			// convert array to line of scripts
			script = script.join("\n");

			return script;
		}

		// return public functions
		return {
			init: init,
			show: show,
			hide: hide,
			minimize: minimize,
			maximize: maximize,
			toggleSize: toggleSize,
			isVisible: isVisible,
			reload: reload,
			refresh: refresh,
			resizeViewer: resizeViewer,
			focusOn: focus,
			center: centerOnHighlighted,
			resetCenter: resetCenter,
			highlight: highlight,
			resetHighlight: resetHighlight,
			refreshHighlight: refreshHighlight,
			zoomIn: zoomIn,
			zoomOut: zoomOut,
			zoomActual: zoomActual,
			zoomTo: zoomTo,
			resetFocus: resetFocus,
			updateContainer: updateContainer,
			toggleSpin: toggleSpin,
			reapplyStyle : reapplyStyle,
			updateOptions: updateOptions,
			generatePymolScript: generatePymolScript
		};
	}

	module.exports = Mutation3dVis;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MolScriptGenerator = __webpack_require__(133);

	var _ = __webpack_require__(5);
	var $3Dmol = __webpack_require__(134);

	/**
	 * Mol3DScriptGenerator class (extends MolScriptGenerator)
	 *
	 * Script generator for 3Dmol.js applications.
	 *
	 * @author Selcuk Onur Sumer
	 */
	function Mol3DScriptGenerator()
	{
		// PDB URI to use to download PDB data
		var _pdbUri = null;

		// reference to the 3Dmol viewer.
		var _viewer = null;

		// latest selection
		var _selected = null;

		// latest style
		var _style = null;

		// latest color
		var _color = null;

		var _styleSpecs = {
			ballAndStick: {stick: {}, sphere: {scale: 0.25}},
			spaceFilling: {sphere: {scale: 0.6}},
			cartoon: {cartoon: {}},
			ribbon: {cartoon: {style: "ribbon"}},
			trace: {cartoon: {style: "trace"}}
		};

		/**
		 * Loads the pdb file for the given pdb ID.
		 *
		 * @param pdbId     pdb ID to load
		 * @param callback  to be invoked after the model is loaded
		 * @returns {string}
		 */
		function loadPdb(pdbId, callback)
		{
			// clear current content
			_viewer.clear();

			var options = {
				doAssembly: true,
				pdbUri: _pdbUri
			};
			// reload with the given pdbId
			$3Dmol.download("pdb:" + pdbId, _viewer, options, callback);
			return "$3Dmol";
		}

		function selectAll()
		{
			_selected = {};
			return "";
		}

		function setScheme(schemeName)
		{
			_style = _.extend({}, _styleSpecs[schemeName]);
			_viewer.setStyle(_selected, _style);
			return "";
		}

		function setColor(color)
		{
			// save the color selection
			_color = formatColor(color);

			// update current style with color information
			_.each(_style, function(ele) {
				ele.color = _color;
			});

			_viewer.setStyle(_selected, _style);
			return "";
		}

		function selectChain(chainId)
		{
			_selected = {chain: chainId};
			return "";
		}

		function selectAlphaHelix(chainId)
		{
			_selected = {chain: chainId, ss: "h"};
			return "";
		}

		function selectBetaSheet(chainId)
		{
			_selected = {chain: chainId, ss: "s"};
			return "";
		}

		/**
		 * Generates a position array for 3Dmol.js.
		 *
		 * @position object containing PDB position info
		 * @return {Array} residue code (rescode) array for 3Dmol.js
		 */
		function scriptPosition(position)
		{
			var residues = [];
			var startPdbPos = position.start.pdbPos || position.start.pdbPosition;
			var endPdbPos = position.end.pdbPos || position.end.pdbPosition;

			var start = parseInt(startPdbPos);
			var end = parseInt(endPdbPos);

			for (var i=start; i <= end; i++)
			{
				residues.push(i);
			}

			// TODO this may not be accurate if residues.length > 2

			if (position.start.insertion)
			{
				residues[0] += "^" + position.start.insertion;
			}

			if (residues.length > 1 &&
			    position.end.insertion)
			{
				residues[residues.length - 1] += "^" + position.end.insertion;
			}

			return residues;
		}

		function selectPositions(scriptPositions, chainId)
		{
			_selected = {rescode: scriptPositions, chain: chainId};
			return "";
		}

		function selectSideChains(scriptPositions, chainId)
		{
			// TODO determine side chain atoms!
			_selected = {
				rescode: scriptPositions,
				chain: chainId/*,
				atom: ["CA"]*/
			};
			return "";
		}

		/**
		 * Generates highlight script by using the converted highlight positions.
		 *
		 * @param scriptPositions   script positions
		 * @param color             highlight color
		 * @param options           visual style options
		 * @param chain             a PdbChainModel instance
		 * @return {Array} script lines as an array
		 */
		function highlightScript(scriptPositions, color, options, chain)
		{
			var self = this;
			var script = [""];

			// add highlight color
			self.selectPositions(scriptPositions, chain.chainId);
			self.setColor(color);

			var displaySideChain = options.displaySideChain != "none";

			// show/hide side chains
			self.generateSideChainScript(scriptPositions, displaySideChain, options, chain);

			return script;
		}

		function enableBallAndStick()
		{
			// extend current style with ball and stick
			var style = _.extend({}, _style, _styleSpecs.ballAndStick);
			// use the latest defined color
			// (this is not the best function to set the side chain color, it should be set
			// in a method like generateSideChainScript or generateVisualStyleScript)
			style.sphere.color = _color;
			style.stick.color = _color;
			// update style of the selection
			_viewer.setStyle(_selected, style);
			return "";
		}

		function disableBallAndStick()
		{
			// looks like this method is obsolete for 3Dmol.js
			//return "wireframe OFF; spacefill OFF;";
			return "";
		}

		function rainbowColor(chainId)
		{
			_selected = {chain: chainId};
			setColor("spectrum");
			return "";
		}

		function cpkColor(chainId)
		{
			_selected = {chain: chainId};

			_.each(_style, function(ele) {
				// remove previous single color
				delete ele.color;

				// add default color scheme
				ele.colors = $3Dmol.elementColors.defaultColors;
			});

			_viewer.setStyle(_selected, _style);
			return "";
		}

		function formatColor(color)
		{
			// this is for 3Dmol.js compatibility
			// (colors should start with an "0x" instead of "#")
			return color.replace("#", "0x");
		}

		function setViewer(viewer)
		{
			_viewer = viewer;
		}

		function setPdbUri(pdbUri)
		{
			_pdbUri = pdbUri;
		}

		function hideBoundMolecules()
		{
			// since there is no built-in "restrict protein" command,
			// we need to select all non-protein structure...
			var selected = {
				resn: [
					"asp", "glu", "arg", "lys", "his", "asn", "thr", "cys", "gln", "tyr", "ser",
					"gly", "ala", "leu", "val", "ile", "met", "trp", "phe", "pro",
					"ASP", "GLU", "ARG", "LYS", "HIS", "ASN", "THR", "CYS", "GLN", "TYR", "SER",
					"GLY", "ALA", "LEU", "VAL", "ILE", "MET", "TRP", "PHE", "PRO"
				],
				invert: true
			};

			var style = {sphere: {hidden: true}};
			_viewer.setStyle(selected, style);
		}

		function setTransparency(transparency)
		{
			_.each(_style, function(ele) {
				ele.opacity = (10 - transparency) / 10;
			});

			_viewer.setStyle(_selected, _style);
		}

		// class specific functions
		this.setViewer = setViewer;
		this.setPdbUri = setPdbUri;

		// override required functions
		this.loadPdb = loadPdb;
		this.selectAll = selectAll;
		this.setScheme = setScheme;
		this.setColor = setColor;
		this.selectChain = selectChain;
		this.selectAlphaHelix = selectAlphaHelix;
		this.selectBetaSheet = selectBetaSheet;
		this.scriptPosition = scriptPosition;
		this.selectPositions = selectPositions;
		this.selectSideChains = selectSideChains;
		this.highlightScript = highlightScript;
		this.rainbowColor = rainbowColor;
		this.cpkColor = cpkColor;
		this.enableBallAndStick = enableBallAndStick;
		this.disableBallAndStick = disableBallAndStick;
		this.hideBoundMolecules = hideBoundMolecules;
		this.setTransparency = setTransparency;
	}

	// JmolScriptGenerator extends MolScriptGenerator...
	Mol3DScriptGenerator.prototype = new MolScriptGenerator();
	Mol3DScriptGenerator.prototype.constructor = Mol3DScriptGenerator;

	module.exports = Mol3DScriptGenerator;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var _ = __webpack_require__(5);

	/**
	 * Base (abstract) script generator class for molecular structure visualizers
	 * such as Jmol and Pymol.
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MolScriptGenerator()
	{
		this.loadPdb = function(pdbId) {
			return "";
		};

		this.selectAll = function() {
			return "";
		};

		this.selectNone = function() {
			return "";
		};

		this.setScheme = function(schemeName) {
			return "";
		};

		this.setColor = function(color) {
			return "";
		};

		this.selectChain = function(chainId) {
			return "";
		};

		this.selectAlphaHelix = function(chainId) {
			return "";
		};

		this.selectBetaSheet = function(chainId) {
			return "";
		};

		this.rainbowColor = function(chainId) {
			return "";
		};

		this.cpkColor = function(chainId) {
			return "";
		};

		this.hideBoundMolecules = function() {
			return "";
		};

		this.setTransparency = function(transparency) {
			return "";
		};

		this.scriptPosition = function(position) {
			return "";
		};

		this.selectPositions = function(scriptPositions, chainId) {
			return "";
		};

		this.selectSideChains = function(scriptPositions, chainId) {
			return "";
		};

		this.enableBallAndStick = function() {
			return "";
		};

		this.disableBallAndStick = function() {
			return "";
		};

		this.center = function(position, chainId) {
			return "";
		};

		this.zoom = function(zoomValue) {
			return "";
		};

		this.defaultZoomIn = function() {
			return "";
		};

		this.defaultZoomOut = function() {
			return "";
		};

		this.defaultCenter = function() {
			return "";
		};

		this.spin = function(value) {
			return "";
		};

		/**
		 * Generates highlight script by using the converted highlight positions.
		 *
		 * @param scriptPositions   script positions
		 * @param color             highlight color
		 * @param options           visual style options
		 * @param chain             a PdbChainModel instance
		 * @return {Array} script lines as an array
		 */
		this.highlightScript = function(scriptPositions, color, options, chain)
		{
			return [];
		};

		/**
		 * Generates the visual style (scheme, coloring, selection, etc.) script
		 * to be sent to the 3D app.
		 *
		 * @param selection map of script positions
		 * @param chain     a PdbChainModel instance
		 * @param options   visual style options
		 *
		 * @return {Array}  script lines as an array
		 */
		this.generateVisualStyleScript = function(selection, chain, options)
		{
			var self = this;
			var script = [];

			script.push(self.selectAll()); // select everything
			script.push(self.setScheme(options.proteinScheme)); // show selected style view

			// do the initial (uniform) coloring

			script.push(self.setColor(options.defaultColor)); // set default color
			//script.push("translucent [" + _options.defaultTranslucency + "];"); // set default opacity
			script.push(self.setTransparency(options.defaultTranslucency));
			script.push(self.selectChain(chain.chainId)); // select the chain
			script.push(self.setColor(options.chainColor)); // set chain color
			//script.push("translucent [" + _options.chainTranslucency + "];"); // set chain opacity
			script.push(self.setTransparency(options.chainTranslucency));

			// additional coloring for the selected chain
			script.push(self.selectChain(chain.chainId));

			if (options.colorProteins == "byAtomType")
			{
				script.push(self.cpkColor(chain.chainId));
			}
			else if (options.colorProteins == "bySecondaryStructure")
			{
				// color secondary structure (for the selected chain)
				script.push(self.selectAlphaHelix(chain.chainId)); // select alpha helices
				script.push(self.setColor(options.structureColors.alphaHelix)); // set color
				script.push(self.selectBetaSheet(chain.chainId)); // select beta sheets
				script.push(self.setColor(options.structureColors.betaSheet)); // set color
			}
			else if (options.colorProteins == "byChain")
			{
				// select the chain
				script.push(self.selectChain(chain.chainId));

				// color the chain by rainbow coloring scheme (gradient coloring)
				script.push(self.rainbowColor(chain.chainId));
			}

			// process mapped residues
			_.each(_.keys(selection), function(color) {
				// select positions (mutations)
				script.push(self.selectPositions(selection[color], chain.chainId));

				// color each residue with a mapped color (this is to sync with diagram colors)

				// use the actual mapped color
				if (options.colorMutations == "byMutationType")
				{
					// color with corresponding mutation color
					script.push(self.setColor(color));
				}
				// use a uniform color
				else if (options.colorMutations == "uniform")
				{
					// color with a uniform mutation color
					script.push(self.setColor(options.mutationColor));
				}

				// show/hide side chains
				script = script.concat(
					self.generateSideChainScript(selection[color],
						options.displaySideChain == "all",
						options,
						chain));
			});

			if (options.restrictProtein)
			{
				script.push(self.hideBoundMolecules());
			}

			return script;
		};

		/**
		 * Generates the script to show/hide the side chain for the given positions.
		 * Positions can be in the form of "666" or "666:C", both are fine.
		 *
		 * @param scriptPositions   an array of already generated script positions
		 * @param displaySideChain  flag to indicate to show/hide the side chain
		 * @param options           visual style options
		 * @param chain             a PdbChainModel instance
		 */
		this.generateSideChainScript = function(scriptPositions, displaySideChain, options, chain)
		{
			var self = this;
			var script = [];

			// display side chain (no effect for space-filling)
			if (!(options.proteinScheme == "spaceFilling"))
			{
				// select the corresponding side chain and also the CA atom on the backbone
				script.push(self.selectSideChains(scriptPositions, chain.chainId));

				if (displaySideChain)
				{
					// display the side chain with ball&stick style
					script.push(self.enableBallAndStick());

					// TODO also color side chain wrt atom type (CPK)?
				}
				else
				{
					// hide the side chain
					script.push(self.disableBallAndStick());
				}
			}

			return script;
		};

		/**
		 * Generates the highlight script to be sent to the 3D app.
		 *
		 * @param positions mutation positions to highlight
		 * @param color     highlight color
		 * @param options   visual style options
		 * @param chain     a PdbChainModel instance
		 * @return {Array}  script lines as an array
		 */
		this.generateHighlightScript = function(positions, color, options, chain)
		{
			var self = this;
			var script = [];

			// highlight the selected positions
			if (!_.isEmpty(positions))
			{
				// convert positions to script positions
				var scriptPositions = self.highlightScriptPositions(positions);

				script = script.concat(self.highlightScript(
					scriptPositions, color, options, chain));
			}

			return script;
		};

		this.highlightScriptPositions = function(positions)
		{
			var self = this;
			var scriptPositions = [];

			// convert positions to script positions
			_.each(positions, function(position) {
				scriptPositions.push(self.scriptPosition(position));
			});

			return scriptPositions;
		};
	}

	module.exports = MolScriptGenerator;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function($) {!function(r,t){ true?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(r.MMTF=r.MMTF||{})}(this,function(r){"use strict";function t(r){function t(r){for(var t={},e=0;r>e;e++){var n=a();t[n]=a()}return t}function e(t){var e=r.subarray(i,i+t);return i+=t,e}function n(t){var e=r.subarray(i,i+t);i+=t;var n=65535;if(t>n){for(var o=[],a=0;a<e.length;a+=n)o.push(String.fromCharCode.apply(null,e.subarray(a,a+n)));return o.join("")}return String.fromCharCode.apply(null,e)}function o(r){for(var t=new Array(r),e=0;r>e;e++)t[e]=a();return t}function a(){var a,s,c,d=r[i];if(0===(128&d))return i++,d;if(128===(240&d))return s=15&d,i++,t(s);if(144===(240&d))return s=15&d,i++,o(s);if(160===(224&d))return s=31&d,i++,n(s);if(224===(224&d))return a=u.getInt8(i),i++,a;switch(d){case 192:return i++,null;case 194:return i++,!1;case 195:return i++,!0;case 196:return s=u.getUint8(i+1),i+=2,e(s);case 197:return s=u.getUint16(i+1),i+=3,e(s);case 198:return s=u.getUint32(i+1),i+=5,e(s);case 199:return s=u.getUint8(i+1),c=u.getUint8(i+2),i+=3,[c,e(s)];case 200:return s=u.getUint16(i+1),c=u.getUint8(i+3),i+=4,[c,e(s)];case 201:return s=u.getUint32(i+1),c=u.getUint8(i+5),i+=6,[c,e(s)];case 202:return a=u.getFloat32(i+1),i+=5,a;case 203:return a=u.getFloat64(i+1),i+=9,a;case 204:return a=r[i+1],i+=2,a;case 205:return a=u.getUint16(i+1),i+=3,a;case 206:return a=u.getUint32(i+1),i+=5,a;case 207:return i+=9,0;case 208:return a=u.getInt8(i+1),i+=2,a;case 209:return a=u.getInt16(i+1),i+=3,a;case 210:return a=u.getInt32(i+1),i+=5,a;case 211:return i+=9,0;case 212:return c=u.getUint8(i+1),i+=2,[c,e(1)];case 213:return c=u.getUint8(i+1),i+=2,[c,e(2)];case 214:return c=u.getUint8(i+1),i+=2,[c,e(4)];case 215:return c=u.getUint8(i+1),i+=2,[c,e(8)];case 216:return c=u.getUint8(i+1),i+=2,[c,e(16)];case 217:return s=u.getUint8(i+1),i+=2,n(s);case 218:return s=u.getUint16(i+1),i+=3,n(s);case 219:return s=u.getUint32(i+1),i+=5,n(s);case 220:return s=u.getUint16(i+1),i+=3,o(s);case 221:return s=u.getUint32(i+1),i+=5,o(s);case 222:return s=u.getUint16(i+1),i+=3,t(s);case 223:return s=u.getUint32(i+1),i+=5,t(s)}throw new Error("Unknown type 0x"+d.toString(16))}var i=0,u=new DataView(r.buffer);return a()}function e(r){return new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}function n(r){return new Int8Array(r.buffer,r.byteOffset,r.byteLength)}function o(r,t){var e,n,o,a=(r.byteOffset,r.byteLength);for(t||(t=new Int16Array(a/2)),e=0,n=0,o=a/2;o>e;++e,n+=2)t[e]=r[n]<<8^r[n+1]<<0;return t}function a(r,t){var e,n,o,a=(r.byteOffset,r.byteLength);for(t||(t=new Int32Array(a/4)),e=0,n=0,o=a/4;o>e;++e,n+=4)t[e]=r[n]<<24^r[n+1]<<16^r[n+2]<<8^r[n+3]<<0;return t}function i(r){return new Int32Array(r.buffer,r.byteOffset,r.byteLength/4)}function u(r,t,e){var n=r.length,o=1/t;e||(e=new Float32Array(n));for(var a=0;n>a;++a)e[a]=r[a]*o;return e}function s(r,t){var e,n;if(!t){var o=0;for(e=0,n=r.length;n>e;e+=2)o+=r[e+1];t=new r.constructor(o)}var a=0;for(e=0,n=r.length;n>e;e+=2)for(var i=r[e],u=r[e+1],s=0;u>s;++s)t[a]=i,a+=1;return t}function c(r){for(var t=1,e=r.length;e>t;++t)r[t]+=r[t-1];return r}function d(r,t,e){var n=r.length/2+t.length;e||(e=new Int32Array(n));for(var o=0,a=0,i=0,u=r.length;u>i;i+=2){var s=r[i],c=r[i+1];e[o]=s,0!==i&&(e[o]+=e[o-1]),o+=1;for(var d=0;c>d;++d)e[o]=e[o-1]+t[a],o+=1,a+=1}return e}function f(r,t,e,n){var s=r.length/4/2+t.length/2;n||(n=new Float32Array(s));var c=i(n),f=d(a(r),o(t),c);return u(f,e,n)}function g(r,t,e){var n=e?i(e):void 0,o=s(a(r),n);return u(o,t,e)}function l(r,t){function o(r){return i?-1===i.indexOf(r):!0}t=t||{};var i=t.ignoreFields,u=(r.numBonds||0,r.numAtoms||0),d=r.groupTypeList.length/4,l=r.chainIdList.length/4,m=r.chainsPerModel.length,L={numGroups:d,numChains:l,numModels:m};["mmtfVersion","mmtfProducer","unitCell","spaceGroup","structureId","title","depositionDate","releaseDate","experimentalMethods","resolution","rFree","rWork","bioAssemblyList","entityList","groupList","numBonds","numAtoms","groupsPerChain","chainsPerModel"].forEach(function(t){void 0!==r[t]&&(L[t]=r[t])});var h="bondAtomList";r[h]&&o(h)&&(L[h]=a(r[h]));var y="bondOrderList";r[y]&&o(y)&&(L[y]=e(r[y])),L.xCoordList=f(r.xCoordBig,r.xCoordSmall,1e3),L.yCoordList=f(r.yCoordBig,r.yCoordSmall,1e3),L.zCoordList=f(r.zCoordBig,r.zCoordSmall,1e3);var p="bFactorList",v="bFactorBig",C="bFactorSmall";r[v]&&r[C]&&o(p)&&(L[p]=f(r[v],r[C],100));var I="atomIdList";r[I]&&o(I)&&(L[I]=c(s(a(r[I]))));var b="altLocList";r[b]&&o(b)&&(L[b]=s(a(r[b]),new Uint8Array(u)));var U="occupancyList";r[U]&&o(U)&&(L[U]=g(r[U],100)),L.groupIdList=c(s(a(r.groupIdList))),L.groupTypeList=a(r.groupTypeList);var x="secStructList";r[x]&&o(x)&&(L[x]=n(r[x]));var A="insCodeList";r[A]&&o(A)&&(L[A]=s(a(r[A]),new Uint8Array(d)));var w="sequenceIndexList";r[w]&&o(w)&&(L[w]=c(s(a(r[w])))),L.chainIdList=e(r.chainIdList);var F="chainNameList";return r[F]&&o(F)&&(L[F]=e(r[F])),L}function m(r){return String.fromCharCode.apply(null,r).replace(/\0/g,"")}function L(r,t){var e,n,o,a,i=t.onModel,u=t.onChain,s=t.onGroup,c=t.onAtom,d=t.onBond,f=0,g=0,l=0,L=0,h=r.chainNameList,y=r.secStructList,p=r.insCodeList,v=r.sequenceIndexList,C=r.bFactorList,I=r.altLocList,b=r.occupancyList,U=r.bondAtomList,x=r.bondOrderList;if(r.chainsPerModel.forEach(function(t){for(i&&i({chainCount:t,modelIndex:f}),e=0;t>e;++e){var U=r.groupsPerChain[g];if(u){var x=m(r.chainIdList.subarray(4*g,4*g+4)),A=null;h&&(A=m(h.subarray(4*g,4*g+4))),u({groupCount:U,chainIndex:g,modelIndex:f,chainId:x,chainName:A})}for(n=0;U>n;++n){var w=r.groupList[r.groupTypeList[l]],F=w.atomNameList.length;if(s){var S=null;y&&(S=y[l]);var O=null;r.insCodeList&&(O=String.fromCharCode(p[l]));var M=null;v&&(M=v[l]),s({atomCount:F,groupIndex:l,chainIndex:g,modelIndex:f,groupId:r.groupIdList[l],groupType:r.groupTypeList[l],groupName:w.groupName,singleLetterCode:w.singleLetterCode,chemCompType:w.chemCompType,secStruct:S,insCode:O,sequenceIndex:M})}if(d){var T=w.bondAtomList;for(o=0,a=w.bondOrderList.length;a>o;++o)d({atomIndex1:L+T[2*o],atomIndex2:L+T[2*o+1],bondOrder:w.bondOrderList[o]})}for(o=0;F>o;++o){if(c){var B=null;C&&(B=C[L]);var N=null;I&&(N=String.fromCharCode(I[L]));var P=null;b&&(P=b[L]),c({atomIndex:L,groupIndex:l,chainIndex:g,modelIndex:f,atomId:r.atomIdList[L],element:w.elementList[o],atomName:w.atomNameList[o],atomCharge:w.atomChargeList[o],xCoord:r.xCoordList[L],yCoord:r.yCoordList[L],zCoord:r.zCoordList[L],bFactor:B,altLoc:N,occupancy:P})}L+=1}l+=1}g+=1}f+=1}),d&&U)for(o=0,a=U.length;a>o;o+=2)d({atomIndex1:U[o],atomIndex2:U[o+1],bondOrder:x?x[o/2]:null})}function h(r,e){r instanceof ArrayBuffer&&(r=new Uint8Array(r));var n;return n=r instanceof Uint8Array?t(r):r,l(n,e)}var y=L;r.decode=h,r.traverse=y});/* pako 0.2.7 nodeca/pako */(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.pako = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
	'use strict';


	var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
	                (typeof Uint16Array !== 'undefined') &&
	                (typeof Int32Array !== 'undefined');


	exports.assign = function (obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);
	  while (sources.length) {
	    var source = sources.shift();
	    if (!source) { continue; }

	    if (typeof source !== 'object') {
	      throw new TypeError(source + 'must be non-object');
	    }

	    for (var p in source) {
	      if (source.hasOwnProperty(p)) {
	        obj[p] = source[p];
	      }
	    }
	  }

	  return obj;
	};


	// reduce buffer size, avoiding mem copy
	exports.shrinkBuf = function (buf, size) {
	  if (buf.length === size) { return buf; }
	  if (buf.subarray) { return buf.subarray(0, size); }
	  buf.length = size;
	  return buf;
	};


	var fnTyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    if (src.subarray && dest.subarray) {
	      dest.set(src.subarray(src_offs, src_offs+len), dest_offs);
	      return;
	    }
	    // Fallback to ordinary array
	    for (var i=0; i<len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function(chunks) {
	    var i, l, len, pos, chunk, result;

	    // calculate data length
	    len = 0;
	    for (i=0, l=chunks.length; i<l; i++) {
	      len += chunks[i].length;
	    }

	    // join chunks
	    result = new Uint8Array(len);
	    pos = 0;
	    for (i=0, l=chunks.length; i<l; i++) {
	      chunk = chunks[i];
	      result.set(chunk, pos);
	      pos += chunk.length;
	    }

	    return result;
	  }
	};

	var fnUntyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    for (var i=0; i<len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function(chunks) {
	    return [].concat.apply([], chunks);
	  }
	};


	// Enable/Disable typed arrays use, for testing
	//
	exports.setTyped = function (on) {
	  if (on) {
	    exports.Buf8  = Uint8Array;
	    exports.Buf16 = Uint16Array;
	    exports.Buf32 = Int32Array;
	    exports.assign(exports, fnTyped);
	  } else {
	    exports.Buf8  = Array;
	    exports.Buf16 = Array;
	    exports.Buf32 = Array;
	    exports.assign(exports, fnUntyped);
	  }
	};

	exports.setTyped(TYPED_OK);

	},{}],2:[function(require,module,exports){
	// String encode/decode helpers
	'use strict';


	var utils = require('./common');


	// Quick check if we can use fast array to bin string conversion
	//
	// - apply(Array) can fail on Android 2.2
	// - apply(Uint8Array) can fail on iOS 5.1 Safary
	//
	var STR_APPLY_OK = true;
	var STR_APPLY_UIA_OK = true;

	try { String.fromCharCode.apply(null, [0]); } catch(__) { STR_APPLY_OK = false; }
	try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch(__) { STR_APPLY_UIA_OK = false; }


	// Table with utf8 lengths (calculated by first byte of sequence)
	// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
	// because max possible codepoint is 0x10ffff
	var _utf8len = new utils.Buf8(256);
	for (var q=0; q<256; q++) {
	  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
	}
	_utf8len[254]=_utf8len[254]=1; // Invalid sequence start


	// convert string to array (typed, when possible)
	exports.string2buf = function (str) {
	  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

	  // count binary size
	  for (m_pos = 0; m_pos < str_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
	      c2 = str.charCodeAt(m_pos+1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
	  }

	  // allocate buffer
	  buf = new utils.Buf8(buf_len);

	  // convert
	  for (i=0, m_pos = 0; i < buf_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
	      c2 = str.charCodeAt(m_pos+1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    if (c < 0x80) {
	      /* one byte */
	      buf[i++] = c;
	    } else if (c < 0x800) {
	      /* two bytes */
	      buf[i++] = 0xC0 | (c >>> 6);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else if (c < 0x10000) {
	      /* three bytes */
	      buf[i++] = 0xE0 | (c >>> 12);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else {
	      /* four bytes */
	      buf[i++] = 0xf0 | (c >>> 18);
	      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    }
	  }

	  return buf;
	};

	// Helper (used in 2 places)
	function buf2binstring(buf, len) {
	  // use fallback for big arrays to avoid stack overflow
	  if (len < 65537) {
	    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
	      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
	    }
	  }

	  var result = '';
	  for (var i=0; i < len; i++) {
	    result += String.fromCharCode(buf[i]);
	  }
	  return result;
	}


	// Convert byte array to binary string
	exports.buf2binstring = function(buf) {
	  return buf2binstring(buf, buf.length);
	};


	// Convert binary string (typed, when possible)
	exports.binstring2buf = function(str) {
	  var buf = new utils.Buf8(str.length);
	  for (var i=0, len=buf.length; i < len; i++) {
	    buf[i] = str.charCodeAt(i);
	  }
	  return buf;
	};


	// convert array to string
	exports.buf2string = function (buf, max) {
	  var i, out, c, c_len;
	  var len = max || buf.length;

	  // Reserve max possible length (2 words per char)
	  // NB: by unknown reasons, Array is significantly faster for
	  //     String.fromCharCode.apply than Uint16Array.
	  var utf16buf = new Array(len*2);

	  for (out=0, i=0; i<len;) {
	    c = buf[i++];
	    // quick process ascii
	    if (c < 0x80) { utf16buf[out++] = c; continue; }

	    c_len = _utf8len[c];
	    // skip 5 & 6 byte codes
	    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }

	    // apply mask on first byte
	    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
	    // join the rest
	    while (c_len > 1 && i < len) {
	      c = (c << 6) | (buf[i++] & 0x3f);
	      c_len--;
	    }

	    // terminated by end of string?
	    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

	    if (c < 0x10000) {
	      utf16buf[out++] = c;
	    } else {
	      c -= 0x10000;
	      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
	      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
	    }
	  }

	  return buf2binstring(utf16buf, out);
	};


	// Calculate max possible position in utf8 buffer,
	// that will not break sequence. If that's not possible
	// - (very small limits) return max size as is.
	//
	// buf[] - utf8 bytes array
	// max   - length limit (mandatory);
	exports.utf8border = function(buf, max) {
	  var pos;

	  max = max || buf.length;
	  if (max > buf.length) { max = buf.length; }

	  // go back from last position, until start of sequence found
	  pos = max-1;
	  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

	  // Fuckup - very small and broken sequence,
	  // return max, because we should return something anyway.
	  if (pos < 0) { return max; }

	  // If we came to start of buffer - that means vuffer is too small,
	  // return max too.
	  if (pos === 0) { return max; }

	  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
	};

	},{"./common":1}],3:[function(require,module,exports){
	'use strict';

	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It doesn't worth to make additional optimizationa as in original.
	// Small size is preferable.

	function adler32(adler, buf, len, pos) {
	  var s1 = (adler & 0xffff) |0,
	      s2 = ((adler >>> 16) & 0xffff) |0,
	      n = 0;

	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;

	    do {
	      s1 = (s1 + buf[pos++]) |0;
	      s2 = (s2 + s1) |0;
	    } while (--n);

	    s1 %= 65521;
	    s2 %= 65521;
	  }

	  return (s1 | (s2 << 16)) |0;
	}


	module.exports = adler32;

	},{}],4:[function(require,module,exports){
	module.exports = {

	  /* Allowed flush values; see deflate() and inflate() below for details */
	  Z_NO_FLUSH:         0,
	  Z_PARTIAL_FLUSH:    1,
	  Z_SYNC_FLUSH:       2,
	  Z_FULL_FLUSH:       3,
	  Z_FINISH:           4,
	  Z_BLOCK:            5,
	  Z_TREES:            6,

	  /* Return codes for the compression/decompression functions. Negative values
	  * are errors, positive values are used for special but normal events.
	  */
	  Z_OK:               0,
	  Z_STREAM_END:       1,
	  Z_NEED_DICT:        2,
	  Z_ERRNO:           -1,
	  Z_STREAM_ERROR:    -2,
	  Z_DATA_ERROR:      -3,
	  //Z_MEM_ERROR:     -4,
	  Z_BUF_ERROR:       -5,
	  //Z_VERSION_ERROR: -6,

	  /* compression levels */
	  Z_NO_COMPRESSION:         0,
	  Z_BEST_SPEED:             1,
	  Z_BEST_COMPRESSION:       9,
	  Z_DEFAULT_COMPRESSION:   -1,


	  Z_FILTERED:               1,
	  Z_HUFFMAN_ONLY:           2,
	  Z_RLE:                    3,
	  Z_FIXED:                  4,
	  Z_DEFAULT_STRATEGY:       0,

	  /* Possible values of the data_type field (though see inflate()) */
	  Z_BINARY:                 0,
	  Z_TEXT:                   1,
	  //Z_ASCII:                1, // = Z_TEXT (deprecated)
	  Z_UNKNOWN:                2,

	  /* The deflate compression method */
	  Z_DEFLATED:               8
	  //Z_NULL:                 null // Use -1 or null inline, depending on var type
	};

	},{}],5:[function(require,module,exports){
	'use strict';

	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.


	// Use ordinary array, since untyped makes no boost here
	function makeTable() {
	  var c, table = [];

	  for (var n =0; n < 256; n++) {
	    c = n;
	    for (var k =0; k < 8; k++) {
	      c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
	    }
	    table[n] = c;
	  }

	  return table;
	}

	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = makeTable();


	function crc32(crc, buf, len, pos) {
	  var t = crcTable,
	      end = pos + len;

	  crc = crc ^ (-1);

	  for (var i = pos; i < end; i++) {
	    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
	  }

	  return (crc ^ (-1)); // >>> 0;
	}


	module.exports = crc32;

	},{}],6:[function(require,module,exports){
	'use strict';


	function GZheader() {
	  /* true if compressed data believed to be text */
	  this.text       = 0;
	  /* modification time */
	  this.time       = 0;
	  /* extra flags (not used when writing a gzip file) */
	  this.xflags     = 0;
	  /* operating system */
	  this.os         = 0;
	  /* pointer to extra field or Z_NULL if none */
	  this.extra      = null;
	  /* extra field length (valid if extra != Z_NULL) */
	  this.extra_len  = 0; // Actually, we don't need it in JS,
	                       // but leave for few code modifications

	  //
	  // Setup limits is not necessary because in js we should not preallocate memory
	  // for inflate use constant limit in 65536 bytes
	  //

	  /* space at extra (only when reading header) */
	  // this.extra_max  = 0;
	  /* pointer to zero-terminated file name or Z_NULL */
	  this.name       = '';
	  /* space at name (only when reading header) */
	  // this.name_max   = 0;
	  /* pointer to zero-terminated comment or Z_NULL */
	  this.comment    = '';
	  /* space at comment (only when reading header) */
	  // this.comm_max   = 0;
	  /* true if there was or will be a header crc */
	  this.hcrc       = 0;
	  /* true when done reading gzip header (not used when writing a gzip file) */
	  this.done       = false;
	}

	module.exports = GZheader;

	},{}],7:[function(require,module,exports){
	'use strict';

	// See state defs from inflate.js
	var BAD = 30;       /* got a data error -- remain here until reset */
	var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.

	   Entry assumptions:

	        state.mode === LEN
	        strm.avail_in >= 6
	        strm.avail_out >= 258
	        start >= strm.avail_out
	        state.bits < 8

	   On return, state.mode is one of:

	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data

	   Notes:

	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm.avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.

	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm.avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	module.exports = function inflate_fast(strm, start) {
	  var state;
	  var _in;                    /* local strm.input */
	  var last;                   /* have enough input while in < last */
	  var _out;                   /* local strm.output */
	  var beg;                    /* inflate()'s initial strm.output */
	  var end;                    /* while out < end, enough space available */
	//#ifdef INFLATE_STRICT
	  var dmax;                   /* maximum distance from zlib header */
	//#endif
	  var wsize;                  /* window size or zero if not using window */
	  var whave;                  /* valid bytes in the window */
	  var wnext;                  /* window write index */
	  var window;                 /* allocated sliding window, if wsize != 0 */
	  var hold;                   /* local strm.hold */
	  var bits;                   /* local strm.bits */
	  var lcode;                  /* local strm.lencode */
	  var dcode;                  /* local strm.distcode */
	  var lmask;                  /* mask for first level of length codes */
	  var dmask;                  /* mask for first level of distance codes */
	  var here;                   /* retrieved table entry */
	  var op;                     /* code bits, operation, extra bits, or */
	                              /*  window position, window bytes to copy */
	  var len;                    /* match length, unused bytes */
	  var dist;                   /* match distance */
	  var from;                   /* where to copy match from */
	  var from_source;


	  var input, output; // JS specific, because we have no pointers

	  /* copy state to local variables */
	  state = strm.state;
	  //here = state.here;
	  _in = strm.next_in;
	  input = strm.input;
	  last = _in + (strm.avail_in - 5);
	  _out = strm.next_out;
	  output = strm.output;
	  beg = _out - (start - strm.avail_out);
	  end = _out + (strm.avail_out - 257);
	//#ifdef INFLATE_STRICT
	  dmax = state.dmax;
	//#endif
	  wsize = state.wsize;
	  whave = state.whave;
	  wnext = state.wnext;
	  window = state.window;
	  hold = state.hold;
	  bits = state.bits;
	  lcode = state.lencode;
	  dcode = state.distcode;
	  lmask = (1 << state.lenbits) - 1;
	  dmask = (1 << state.distbits) - 1;


	  /* decode literals and length/distances until end-of-block or not enough
	     input data or output space */

	  top:
	  do {
	    if (bits < 15) {
	      hold += input[_in++] << bits;
	      bits += 8;
	      hold += input[_in++] << bits;
	      bits += 8;
	    }

	    here = lcode[hold & lmask];

	    dolen:
	    for (;;) { // Goto emulation
	      op = here >>> 24/*here.bits*/;
	      hold >>>= op;
	      bits -= op;
	      op = (here >>> 16) & 0xff/*here.op*/;
	      if (op === 0) {                          /* literal */
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        output[_out++] = here & 0xffff/*here.val*/;
	      }
	      else if (op & 16) {                     /* length base */
	        len = here & 0xffff/*here.val*/;
	        op &= 15;                           /* number of extra bits */
	        if (op) {
	          if (bits < op) {
	            hold += input[_in++] << bits;
	            bits += 8;
	          }
	          len += hold & ((1 << op) - 1);
	          hold >>>= op;
	          bits -= op;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", len));
	        if (bits < 15) {
	          hold += input[_in++] << bits;
	          bits += 8;
	          hold += input[_in++] << bits;
	          bits += 8;
	        }
	        here = dcode[hold & dmask];

	        dodist:
	        for (;;) { // goto emulation
	          op = here >>> 24/*here.bits*/;
	          hold >>>= op;
	          bits -= op;
	          op = (here >>> 16) & 0xff/*here.op*/;

	          if (op & 16) {                      /* distance base */
	            dist = here & 0xffff/*here.val*/;
	            op &= 15;                       /* number of extra bits */
	            if (bits < op) {
	              hold += input[_in++] << bits;
	              bits += 8;
	              if (bits < op) {
	                hold += input[_in++] << bits;
	                bits += 8;
	              }
	            }
	            dist += hold & ((1 << op) - 1);
	//#ifdef INFLATE_STRICT
	            if (dist > dmax) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break top;
	            }
	//#endif
	            hold >>>= op;
	            bits -= op;
	            //Tracevv((stderr, "inflate:         distance %u\n", dist));
	            op = _out - beg;                /* max distance in output */
	            if (dist > op) {                /* see if copy from window */
	              op = dist - op;               /* distance back in window */
	              if (op > whave) {
	                if (state.sane) {
	                  strm.msg = 'invalid distance too far back';
	                  state.mode = BAD;
	                  break top;
	                }

	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//                if (len <= op - whave) {
	//                  do {
	//                    output[_out++] = 0;
	//                  } while (--len);
	//                  continue top;
	//                }
	//                len -= op - whave;
	//                do {
	//                  output[_out++] = 0;
	//                } while (--op > whave);
	//                if (op === 0) {
	//                  from = _out - dist;
	//                  do {
	//                    output[_out++] = output[from++];
	//                  } while (--len);
	//                  continue top;
	//                }
	//#endif
	              }
	              from = 0; // window index
	              from_source = window;
	              if (wnext === 0) {           /* very common case */
	                from += wsize - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              else if (wnext < op) {      /* wrap around window */
	                from += wsize + wnext - op;
	                op -= wnext;
	                if (op < len) {         /* some from end of window */
	                  len -= op;
	                  do {
	                    output[_out++] = window[from++];
	                  } while (--op);
	                  from = 0;
	                  if (wnext < len) {  /* some from start of window */
	                    op = wnext;
	                    len -= op;
	                    do {
	                      output[_out++] = window[from++];
	                    } while (--op);
	                    from = _out - dist;      /* rest from output */
	                    from_source = output;
	                  }
	                }
	              }
	              else {                      /* contiguous in window */
	                from += wnext - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              while (len > 2) {
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                len -= 3;
	              }
	              if (len) {
	                output[_out++] = from_source[from++];
	                if (len > 1) {
	                  output[_out++] = from_source[from++];
	                }
	              }
	            }
	            else {
	              from = _out - dist;          /* copy direct from output */
	              do {                        /* minimum length is three */
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                len -= 3;
	              } while (len > 2);
	              if (len) {
	                output[_out++] = output[from++];
	                if (len > 1) {
	                  output[_out++] = output[from++];
	                }
	              }
	            }
	          }
	          else if ((op & 64) === 0) {          /* 2nd level distance code */
	            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	            continue dodist;
	          }
	          else {
	            strm.msg = 'invalid distance code';
	            state.mode = BAD;
	            break top;
	          }

	          break; // need to emulate goto via "continue"
	        }
	      }
	      else if ((op & 64) === 0) {              /* 2nd level length code */
	        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	        continue dolen;
	      }
	      else if (op & 32) {                     /* end-of-block */
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.mode = TYPE;
	        break top;
	      }
	      else {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break top;
	      }

	      break; // need to emulate goto via "continue"
	    }
	  } while (_in < last && _out < end);

	  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
	  len = bits >> 3;
	  _in -= len;
	  bits -= len << 3;
	  hold &= (1 << bits) - 1;

	  /* update state and return */
	  strm.next_in = _in;
	  strm.next_out = _out;
	  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
	  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
	  state.hold = hold;
	  state.bits = bits;
	  return;
	};

	},{}],8:[function(require,module,exports){
	'use strict';


	var utils = require('../utils/common');
	var adler32 = require('./adler32');
	var crc32   = require('./crc32');
	var inflate_fast = require('./inffast');
	var inflate_table = require('./inftrees');

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	/* Allowed flush values; see deflate() and inflate() below for details */
	//var Z_NO_FLUSH      = 0;
	//var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	//var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;

	/* The deflate compression method */
	var Z_DEFLATED  = 8;


	/* STATES ====================================================================*/
	/* ===========================================================================*/


	var    HEAD = 1;       /* i: waiting for magic header */
	var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
	var    TIME = 3;       /* i: waiting for modification time (gzip) */
	var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
	var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
	var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
	var    NAME = 7;       /* i: waiting for end of file name (gzip) */
	var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
	var    HCRC = 9;       /* i: waiting for header crc (gzip) */
	var    DICTID = 10;    /* i: waiting for dictionary check value */
	var    DICT = 11;      /* waiting for inflateSetDictionary() call */
	var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
	var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
	var        STORED = 14;    /* i: waiting for stored size (length and complement) */
	var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
	var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
	var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
	var        LENLENS = 18;   /* i: waiting for code length code lengths */
	var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
	var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
	var            LEN = 21;       /* i: waiting for length/lit/eob code */
	var            LENEXT = 22;    /* i: waiting for length extra bits */
	var            DIST = 23;      /* i: waiting for distance code */
	var            DISTEXT = 24;   /* i: waiting for distance extra bits */
	var            MATCH = 25;     /* o: waiting for output space to copy string */
	var            LIT = 26;       /* o: waiting for output space to write literal */
	var    CHECK = 27;     /* i: waiting for 32-bit check value */
	var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
	var    DONE = 29;      /* finished check, done -- remain here until reset */
	var    BAD = 30;       /* got a data error -- remain here until reset */
	var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
	var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

	/* ===========================================================================*/



	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_WBITS = MAX_WBITS;


	function ZSWAP32(q) {
	  return  (((q >>> 24) & 0xff) +
	          ((q >>> 8) & 0xff00) +
	          ((q & 0xff00) << 8) +
	          ((q & 0xff) << 24));
	}


	function InflateState() {
	  this.mode = 0;             /* current inflate mode */
	  this.last = false;          /* true if processing last block */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.havedict = false;      /* true if dictionary provided */
	  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
	  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
	  this.check = 0;             /* protected copy of check value */
	  this.total = 0;             /* protected copy of output count */
	  // TODO: may be {}
	  this.head = null;           /* where to save gzip header information */

	  /* sliding window */
	  this.wbits = 0;             /* log base 2 of requested window size */
	  this.wsize = 0;             /* window size or zero if not using window */
	  this.whave = 0;             /* valid bytes in the window */
	  this.wnext = 0;             /* window write index */
	  this.window = null;         /* allocated sliding window, if needed */

	  /* bit accumulator */
	  this.hold = 0;              /* input bit accumulator */
	  this.bits = 0;              /* number of bits in "in" */

	  /* for string and stored block copying */
	  this.length = 0;            /* literal or length of data to copy */
	  this.offset = 0;            /* distance back to copy string from */

	  /* for table and code decoding */
	  this.extra = 0;             /* extra bits needed */

	  /* fixed and dynamic code tables */
	  this.lencode = null;          /* starting table for length/literal codes */
	  this.distcode = null;         /* starting table for distance codes */
	  this.lenbits = 0;           /* index bits for lencode */
	  this.distbits = 0;          /* index bits for distcode */

	  /* dynamic table building */
	  this.ncode = 0;             /* number of code length code lengths */
	  this.nlen = 0;              /* number of length code lengths */
	  this.ndist = 0;             /* number of distance code lengths */
	  this.have = 0;              /* number of code lengths in lens[] */
	  this.next = null;              /* next available space in codes[] */

	  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
	  this.work = new utils.Buf16(288); /* work area for code table building */

	  /*
	   because we don't have pointers in js, we use lencode and distcode directly
	   as buffers so we don't need codes
	  */
	  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
	  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
	  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
	  this.sane = 0;                   /* if false, allow invalid distance too far */
	  this.back = 0;                   /* bits back of last unprocessed length/lit */
	  this.was = 0;                    /* initial length of match */
	}

	function inflateResetKeep(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  strm.total_in = strm.total_out = state.total = 0;
	  strm.msg = ''; /*Z_NULL*/
	  if (state.wrap) {       /* to support ill-conceived Java test suite */
	    strm.adler = state.wrap & 1;
	  }
	  state.mode = HEAD;
	  state.last = 0;
	  state.havedict = 0;
	  state.dmax = 32768;
	  state.head = null/*Z_NULL*/;
	  state.hold = 0;
	  state.bits = 0;
	  //state.lencode = state.distcode = state.next = state.codes;
	  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
	  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

	  state.sane = 1;
	  state.back = -1;
	  //Tracev((stderr, "inflate: reset\n"));
	  return Z_OK;
	}

	function inflateReset(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  state.wsize = 0;
	  state.whave = 0;
	  state.wnext = 0;
	  return inflateResetKeep(strm);

	}

	function inflateReset2(strm, windowBits) {
	  var wrap;
	  var state;

	  /* get the state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;

	  /* extract wrap request from windowBits parameter */
	  if (windowBits < 0) {
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	  else {
	    wrap = (windowBits >> 4) + 1;
	    if (windowBits < 48) {
	      windowBits &= 15;
	    }
	  }

	  /* set number of window bits, free window if different */
	  if (windowBits && (windowBits < 8 || windowBits > 15)) {
	    return Z_STREAM_ERROR;
	  }
	  if (state.window !== null && state.wbits !== windowBits) {
	    state.window = null;
	  }

	  /* update state and reset the rest of it */
	  state.wrap = wrap;
	  state.wbits = windowBits;
	  return inflateReset(strm);
	}

	function inflateInit2(strm, windowBits) {
	  var ret;
	  var state;

	  if (!strm) { return Z_STREAM_ERROR; }
	  //strm.msg = Z_NULL;                 /* in case we return an error */

	  state = new InflateState();

	  //if (state === Z_NULL) return Z_MEM_ERROR;
	  //Tracev((stderr, "inflate: allocated\n"));
	  strm.state = state;
	  state.window = null/*Z_NULL*/;
	  ret = inflateReset2(strm, windowBits);
	  if (ret !== Z_OK) {
	    strm.state = null/*Z_NULL*/;
	  }
	  return ret;
	}

	function inflateInit(strm) {
	  return inflateInit2(strm, DEF_WBITS);
	}


	/*
	 Return state with length and distance decoding tables and index sizes set to
	 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
	 If BUILDFIXED is defined, then instead this routine builds the tables the
	 first time it's called, and returns those tables the first time and
	 thereafter.  This reduces the size of the code by about 2K bytes, in
	 exchange for a little execution time.  However, BUILDFIXED should not be
	 used for threaded applications, since the rewriting of the tables and virgin
	 may not be thread-safe.
	 */
	var virgin = true;

	var lenfix, distfix; // We have no pointers in JS, so keep tables separate

	function fixedtables(state) {
	  /* build fixed huffman tables if first call (may not be thread safe) */
	  if (virgin) {
	    var sym;

	    lenfix = new utils.Buf32(512);
	    distfix = new utils.Buf32(32);

	    /* literal/length table */
	    sym = 0;
	    while (sym < 144) { state.lens[sym++] = 8; }
	    while (sym < 256) { state.lens[sym++] = 9; }
	    while (sym < 280) { state.lens[sym++] = 7; }
	    while (sym < 288) { state.lens[sym++] = 8; }

	    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, {bits: 9});

	    /* distance table */
	    sym = 0;
	    while (sym < 32) { state.lens[sym++] = 5; }

	    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, {bits: 5});

	    /* do this just once */
	    virgin = false;
	  }

	  state.lencode = lenfix;
	  state.lenbits = 9;
	  state.distcode = distfix;
	  state.distbits = 5;
	}


	/*
	 Update the window with the last wsize (normally 32K) bytes written before
	 returning.  If window does not exist yet, create it.  This is only called
	 when a window is already in use, or when output has been written during this
	 inflate call, but the end of the deflate stream has not been reached yet.
	 It is also called to create a window for dictionary data when a dictionary
	 is loaded.

	 Providing output buffers larger than 32K to inflate() should provide a speed
	 advantage, since only the last 32K of output is copied to the sliding window
	 upon return from inflate(), and since all distances after the first 32K of
	 output will fall in the output data, making match copies simpler and faster.
	 The advantage may be dependent on the size of the processor's data caches.
	 */
	function updatewindow(strm, src, end, copy) {
	  var dist;
	  var state = strm.state;

	  /* if it hasn't been done already, allocate space for the window */
	  if (state.window === null) {
	    state.wsize = 1 << state.wbits;
	    state.wnext = 0;
	    state.whave = 0;

	    state.window = new utils.Buf8(state.wsize);
	  }

	  /* copy state->wsize or less output bytes into the circular window */
	  if (copy >= state.wsize) {
	    utils.arraySet(state.window,src, end - state.wsize, state.wsize, 0);
	    state.wnext = 0;
	    state.whave = state.wsize;
	  }
	  else {
	    dist = state.wsize - state.wnext;
	    if (dist > copy) {
	      dist = copy;
	    }
	    //zmemcpy(state->window + state->wnext, end - copy, dist);
	    utils.arraySet(state.window,src, end - copy, dist, state.wnext);
	    copy -= dist;
	    if (copy) {
	      //zmemcpy(state->window, end - copy, copy);
	      utils.arraySet(state.window,src, end - copy, copy, 0);
	      state.wnext = copy;
	      state.whave = state.wsize;
	    }
	    else {
	      state.wnext += dist;
	      if (state.wnext === state.wsize) { state.wnext = 0; }
	      if (state.whave < state.wsize) { state.whave += dist; }
	    }
	  }
	  return 0;
	}

	function inflate(strm, flush) {
	  var state;
	  var input, output;          // input/output buffers
	  var next;                   /* next input INDEX */
	  var put;                    /* next output INDEX */
	  var have, left;             /* available input and output */
	  var hold;                   /* bit buffer */
	  var bits;                   /* bits in bit buffer */
	  var _in, _out;              /* save starting available input and output */
	  var copy;                   /* number of stored or match bytes to copy */
	  var from;                   /* where to copy match bytes from */
	  var from_source;
	  var here = 0;               /* current decoding table entry */
	  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
	  //var last;                   /* parent table entry */
	  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
	  var len;                    /* length to copy for repeats, bits to drop */
	  var ret;                    /* return code */
	  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
	  var opts;

	  var n; // temporary var for NEED_BITS

	  var order = /* permutation of code lengths */
	    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];


	  if (!strm || !strm.state || !strm.output ||
	      (!strm.input && strm.avail_in !== 0)) {
	    return Z_STREAM_ERROR;
	  }

	  state = strm.state;
	  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


	  //--- LOAD() ---
	  put = strm.next_out;
	  output = strm.output;
	  left = strm.avail_out;
	  next = strm.next_in;
	  input = strm.input;
	  have = strm.avail_in;
	  hold = state.hold;
	  bits = state.bits;
	  //---

	  _in = have;
	  _out = left;
	  ret = Z_OK;

	  inf_leave: // goto emulation
	  for (;;) {
	    switch (state.mode) {
	    case HEAD:
	      if (state.wrap === 0) {
	        state.mode = TYPEDO;
	        break;
	      }
	      //=== NEEDBITS(16);
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
	        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//

	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = FLAGS;
	        break;
	      }
	      state.flags = 0;           /* expect zlib header */
	      if (state.head) {
	        state.head.done = false;
	      }
	      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
	        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
	        strm.msg = 'incorrect header check';
	        state.mode = BAD;
	        break;
	      }
	      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	      len = (hold & 0x0f)/*BITS(4)*/ + 8;
	      if (state.wbits === 0) {
	        state.wbits = len;
	      }
	      else if (len > state.wbits) {
	        strm.msg = 'invalid window size';
	        state.mode = BAD;
	        break;
	      }
	      state.dmax = 1 << len;
	      //Tracev((stderr, "inflate:   zlib header ok\n"));
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = hold & 0x200 ? DICTID : TYPE;
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      break;
	    case FLAGS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.flags = hold;
	      if ((state.flags & 0xff) !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      if (state.flags & 0xe000) {
	        strm.msg = 'unknown header flags set';
	        state.mode = BAD;
	        break;
	      }
	      if (state.head) {
	        state.head.text = ((hold >> 8) & 1);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = TIME;
	      /* falls through */
	    case TIME:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.time = hold;
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC4(state.check, hold)
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        hbuf[2] = (hold >>> 16) & 0xff;
	        hbuf[3] = (hold >>> 24) & 0xff;
	        state.check = crc32(state.check, hbuf, 4, 0);
	        //===
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = OS;
	      /* falls through */
	    case OS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.xflags = (hold & 0xff);
	        state.head.os = (hold >> 8);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = EXLEN;
	      /* falls through */
	    case EXLEN:
	      if (state.flags & 0x0400) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length = hold;
	        if (state.head) {
	          state.head.extra_len = hold;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      else if (state.head) {
	        state.head.extra = null/*Z_NULL*/;
	      }
	      state.mode = EXTRA;
	      /* falls through */
	    case EXTRA:
	      if (state.flags & 0x0400) {
	        copy = state.length;
	        if (copy > have) { copy = have; }
	        if (copy) {
	          if (state.head) {
	            len = state.head.extra_len - state.length;
	            if (!state.head.extra) {
	              // Use untyped array for more conveniend processing later
	              state.head.extra = new Array(state.head.extra_len);
	            }
	            utils.arraySet(
	              state.head.extra,
	              input,
	              next,
	              // extra field is limited to 65536 bytes
	              // - no need for additional size check
	              copy,
	              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
	              len
	            );
	            //zmemcpy(state.head.extra + len, next,
	            //        len + copy > state.head.extra_max ?
	            //        state.head.extra_max - len : copy);
	          }
	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          state.length -= copy;
	        }
	        if (state.length) { break inf_leave; }
	      }
	      state.length = 0;
	      state.mode = NAME;
	      /* falls through */
	    case NAME:
	      if (state.flags & 0x0800) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          // TODO: 2 or 1 bytes?
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.name_max*/)) {
	            state.head.name += String.fromCharCode(len);
	          }
	        } while (len && copy < have);

	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.name = null;
	      }
	      state.length = 0;
	      state.mode = COMMENT;
	      /* falls through */
	    case COMMENT:
	      if (state.flags & 0x1000) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.comm_max*/)) {
	            state.head.comment += String.fromCharCode(len);
	          }
	        } while (len && copy < have);
	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.comment = null;
	      }
	      state.mode = HCRC;
	      /* falls through */
	    case HCRC:
	      if (state.flags & 0x0200) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.check & 0xffff)) {
	          strm.msg = 'header crc mismatch';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      if (state.head) {
	        state.head.hcrc = ((state.flags >> 9) & 1);
	        state.head.done = true;
	      }
	      strm.adler = state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
	      state.mode = TYPE;
	      break;
	    case DICTID:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      strm.adler = state.check = ZSWAP32(hold);
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = DICT;
	      /* falls through */
	    case DICT:
	      if (state.havedict === 0) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        return Z_NEED_DICT;
	      }
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = TYPE;
	      /* falls through */
	    case TYPE:
	      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case TYPEDO:
	      if (state.last) {
	        //--- BYTEBITS() ---//
	        hold >>>= bits & 7;
	        bits -= bits & 7;
	        //---//
	        state.mode = CHECK;
	        break;
	      }
	      //=== NEEDBITS(3); */
	      while (bits < 3) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.last = (hold & 0x01)/*BITS(1)*/;
	      //--- DROPBITS(1) ---//
	      hold >>>= 1;
	      bits -= 1;
	      //---//

	      switch ((hold & 0x03)/*BITS(2)*/) {
	      case 0:                             /* stored block */
	        //Tracev((stderr, "inflate:     stored block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = STORED;
	        break;
	      case 1:                             /* fixed block */
	        fixedtables(state);
	        //Tracev((stderr, "inflate:     fixed codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = LEN_;             /* decode codes */
	        if (flush === Z_TREES) {
	          //--- DROPBITS(2) ---//
	          hold >>>= 2;
	          bits -= 2;
	          //---//
	          break inf_leave;
	        }
	        break;
	      case 2:                             /* dynamic block */
	        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = TABLE;
	        break;
	      case 3:
	        strm.msg = 'invalid block type';
	        state.mode = BAD;
	      }
	      //--- DROPBITS(2) ---//
	      hold >>>= 2;
	      bits -= 2;
	      //---//
	      break;
	    case STORED:
	      //--- BYTEBITS() ---// /* go to byte boundary */
	      hold >>>= bits & 7;
	      bits -= bits & 7;
	      //---//
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
	        strm.msg = 'invalid stored block lengths';
	        state.mode = BAD;
	        break;
	      }
	      state.length = hold & 0xffff;
	      //Tracev((stderr, "inflate:       stored length %u\n",
	      //        state.length));
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = COPY_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case COPY_:
	      state.mode = COPY;
	      /* falls through */
	    case COPY:
	      copy = state.length;
	      if (copy) {
	        if (copy > have) { copy = have; }
	        if (copy > left) { copy = left; }
	        if (copy === 0) { break inf_leave; }
	        //--- zmemcpy(put, next, copy); ---
	        utils.arraySet(output, input, next, copy, put);
	        //---//
	        have -= copy;
	        next += copy;
	        left -= copy;
	        put += copy;
	        state.length -= copy;
	        break;
	      }
	      //Tracev((stderr, "inflate:       stored end\n"));
	      state.mode = TYPE;
	      break;
	    case TABLE:
	      //=== NEEDBITS(14); */
	      while (bits < 14) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	//#ifndef PKZIP_BUG_WORKAROUND
	      if (state.nlen > 286 || state.ndist > 30) {
	        strm.msg = 'too many length or distance symbols';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracev((stderr, "inflate:       table sizes ok\n"));
	      state.have = 0;
	      state.mode = LENLENS;
	      /* falls through */
	    case LENLENS:
	      while (state.have < state.ncode) {
	        //=== NEEDBITS(3);
	        while (bits < 3) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
	        //--- DROPBITS(3) ---//
	        hold >>>= 3;
	        bits -= 3;
	        //---//
	      }
	      while (state.have < 19) {
	        state.lens[order[state.have++]] = 0;
	      }
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      //state.next = state.codes;
	      //state.lencode = state.next;
	      // Switch to use dynamic table
	      state.lencode = state.lendyn;
	      state.lenbits = 7;

	      opts = {bits: state.lenbits};
	      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	      state.lenbits = opts.bits;

	      if (ret) {
	        strm.msg = 'invalid code lengths set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, "inflate:       code lengths ok\n"));
	      state.have = 0;
	      state.mode = CODELENS;
	      /* falls through */
	    case CODELENS:
	      while (state.have < state.nlen + state.ndist) {
	        for (;;) {
	          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if (here_val < 16) {
	          //--- DROPBITS(here.bits) ---//
	          hold >>>= here_bits;
	          bits -= here_bits;
	          //---//
	          state.lens[state.have++] = here_val;
	        }
	        else {
	          if (here_val === 16) {
	            //=== NEEDBITS(here.bits + 2);
	            n = here_bits + 2;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            if (state.have === 0) {
	              strm.msg = 'invalid bit length repeat';
	              state.mode = BAD;
	              break;
	            }
	            len = state.lens[state.have - 1];
	            copy = 3 + (hold & 0x03);//BITS(2);
	            //--- DROPBITS(2) ---//
	            hold >>>= 2;
	            bits -= 2;
	            //---//
	          }
	          else if (here_val === 17) {
	            //=== NEEDBITS(here.bits + 3);
	            n = here_bits + 3;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 3 + (hold & 0x07);//BITS(3);
	            //--- DROPBITS(3) ---//
	            hold >>>= 3;
	            bits -= 3;
	            //---//
	          }
	          else {
	            //=== NEEDBITS(here.bits + 7);
	            n = here_bits + 7;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 11 + (hold & 0x7f);//BITS(7);
	            //--- DROPBITS(7) ---//
	            hold >>>= 7;
	            bits -= 7;
	            //---//
	          }
	          if (state.have + copy > state.nlen + state.ndist) {
	            strm.msg = 'invalid bit length repeat';
	            state.mode = BAD;
	            break;
	          }
	          while (copy--) {
	            state.lens[state.have++] = len;
	          }
	        }
	      }

	      /* handle error breaks in while */
	      if (state.mode === BAD) { break; }

	      /* check for end-of-block code (better have one) */
	      if (state.lens[256] === 0) {
	        strm.msg = 'invalid code -- missing end-of-block';
	        state.mode = BAD;
	        break;
	      }

	      /* build code tables -- note: do not change the lenbits or distbits
	         values here (9 and 6) without reading the comments in inftrees.h
	         concerning the ENOUGH constants, which depend on those values */
	      state.lenbits = 9;

	      opts = {bits: state.lenbits};
	      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.lenbits = opts.bits;
	      // state.lencode = state.next;

	      if (ret) {
	        strm.msg = 'invalid literal/lengths set';
	        state.mode = BAD;
	        break;
	      }

	      state.distbits = 6;
	      //state.distcode.copy(state.codes);
	      // Switch to use dynamic table
	      state.distcode = state.distdyn;
	      opts = {bits: state.distbits};
	      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.distbits = opts.bits;
	      // state.distcode = state.next;

	      if (ret) {
	        strm.msg = 'invalid distances set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, 'inflate:       codes ok\n'));
	      state.mode = LEN_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case LEN_:
	      state.mode = LEN;
	      /* falls through */
	    case LEN:
	      if (have >= 6 && left >= 258) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        inflate_fast(strm, _out);
	        //--- LOAD() ---
	        put = strm.next_out;
	        output = strm.output;
	        left = strm.avail_out;
	        next = strm.next_in;
	        input = strm.input;
	        have = strm.avail_in;
	        hold = state.hold;
	        bits = state.bits;
	        //---

	        if (state.mode === TYPE) {
	          state.back = -1;
	        }
	        break;
	      }
	      state.back = 0;
	      for (;;) {
	        here = state.lencode[hold & ((1 << state.lenbits) -1)];  /*BITS(state.lenbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;

	        if (here_bits <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if (here_op && (here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.lencode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      state.length = here_val;
	      if (here_op === 0) {
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        state.mode = LIT;
	        break;
	      }
	      if (here_op & 32) {
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.back = -1;
	        state.mode = TYPE;
	        break;
	      }
	      if (here_op & 64) {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break;
	      }
	      state.extra = here_op & 15;
	      state.mode = LENEXT;
	      /* falls through */
	    case LENEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	      //Tracevv((stderr, "inflate:         length %u\n", state.length));
	      state.was = state.length;
	      state.mode = DIST;
	      /* falls through */
	    case DIST:
	      for (;;) {
	        here = state.distcode[hold & ((1 << state.distbits) -1)];/*BITS(state.distbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;

	        if ((here_bits) <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if ((here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.distcode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      if (here_op & 64) {
	        strm.msg = 'invalid distance code';
	        state.mode = BAD;
	        break;
	      }
	      state.offset = here_val;
	      state.extra = (here_op) & 15;
	      state.mode = DISTEXT;
	      /* falls through */
	    case DISTEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.offset += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	//#ifdef INFLATE_STRICT
	      if (state.offset > state.dmax) {
	        strm.msg = 'invalid distance too far back';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
	      state.mode = MATCH;
	      /* falls through */
	    case MATCH:
	      if (left === 0) { break inf_leave; }
	      copy = _out - left;
	      if (state.offset > copy) {         /* copy from window */
	        copy = state.offset - copy;
	        if (copy > state.whave) {
	          if (state.sane) {
	            strm.msg = 'invalid distance too far back';
	            state.mode = BAD;
	            break;
	          }
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//          Trace((stderr, "inflate.c too far\n"));
	//          copy -= state.whave;
	//          if (copy > state.length) { copy = state.length; }
	//          if (copy > left) { copy = left; }
	//          left -= copy;
	//          state.length -= copy;
	//          do {
	//            output[put++] = 0;
	//          } while (--copy);
	//          if (state.length === 0) { state.mode = LEN; }
	//          break;
	//#endif
	        }
	        if (copy > state.wnext) {
	          copy -= state.wnext;
	          from = state.wsize - copy;
	        }
	        else {
	          from = state.wnext - copy;
	        }
	        if (copy > state.length) { copy = state.length; }
	        from_source = state.window;
	      }
	      else {                              /* copy from output */
	        from_source = output;
	        from = put - state.offset;
	        copy = state.length;
	      }
	      if (copy > left) { copy = left; }
	      left -= copy;
	      state.length -= copy;
	      do {
	        output[put++] = from_source[from++];
	      } while (--copy);
	      if (state.length === 0) { state.mode = LEN; }
	      break;
	    case LIT:
	      if (left === 0) { break inf_leave; }
	      output[put++] = state.length;
	      left--;
	      state.mode = LEN;
	      break;
	    case CHECK:
	      if (state.wrap) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          // Use '|' insdead of '+' to make sure that result is signed
	          hold |= input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        _out -= left;
	        strm.total_out += _out;
	        state.total += _out;
	        if (_out) {
	          strm.adler = state.check =
	              /*UPDATE(state.check, put - _out, _out);*/
	              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

	        }
	        _out = left;
	        // NB: crc32 stored as signed 32-bit int, ZSWAP32 returns signed too
	        if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
	          strm.msg = 'incorrect data check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   check matches trailer\n"));
	      }
	      state.mode = LENGTH;
	      /* falls through */
	    case LENGTH:
	      if (state.wrap && state.flags) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.total & 0xffffffff)) {
	          strm.msg = 'incorrect length check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   length matches trailer\n"));
	      }
	      state.mode = DONE;
	      /* falls through */
	    case DONE:
	      ret = Z_STREAM_END;
	      break inf_leave;
	    case BAD:
	      ret = Z_DATA_ERROR;
	      break inf_leave;
	    case MEM:
	      return Z_MEM_ERROR;
	    case SYNC:
	      /* falls through */
	    default:
	      return Z_STREAM_ERROR;
	    }
	  }

	  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

	  /*
	     Return from inflate(), updating the total counts and the check value.
	     If there was no progress during the inflate() call, return a buffer
	     error.  Call updatewindow() to create and/or update the window state.
	     Note: a memory error from inflate() is non-recoverable.
	   */

	  //--- RESTORE() ---
	  strm.next_out = put;
	  strm.avail_out = left;
	  strm.next_in = next;
	  strm.avail_in = have;
	  state.hold = hold;
	  state.bits = bits;
	  //---

	  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
	                      (state.mode < CHECK || flush !== Z_FINISH))) {
	    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
	      state.mode = MEM;
	      return Z_MEM_ERROR;
	    }
	  }
	  _in -= strm.avail_in;
	  _out -= strm.avail_out;
	  strm.total_in += _in;
	  strm.total_out += _out;
	  state.total += _out;
	  if (state.wrap && _out) {
	    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
	      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
	  }
	  strm.data_type = state.bits + (state.last ? 64 : 0) +
	                    (state.mode === TYPE ? 128 : 0) +
	                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
	    ret = Z_BUF_ERROR;
	  }
	  return ret;
	}

	function inflateEnd(strm) {

	  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
	    return Z_STREAM_ERROR;
	  }

	  var state = strm.state;
	  if (state.window) {
	    state.window = null;
	  }
	  strm.state = null;
	  return Z_OK;
	}

	function inflateGetHeader(strm, head) {
	  var state;

	  /* check state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

	  /* save header structure */
	  state.head = head;
	  head.done = false;
	  return Z_OK;
	}


	exports.inflateReset = inflateReset;
	exports.inflateReset2 = inflateReset2;
	exports.inflateResetKeep = inflateResetKeep;
	exports.inflateInit = inflateInit;
	exports.inflateInit2 = inflateInit2;
	exports.inflate = inflate;
	exports.inflateEnd = inflateEnd;
	exports.inflateGetHeader = inflateGetHeader;
	exports.inflateInfo = 'pako inflate (from Nodeca project)';

	/* Not implemented
	exports.inflateCopy = inflateCopy;
	exports.inflateGetDictionary = inflateGetDictionary;
	exports.inflateMark = inflateMark;
	exports.inflatePrime = inflatePrime;
	exports.inflateSetDictionary = inflateSetDictionary;
	exports.inflateSync = inflateSync;
	exports.inflateSyncPoint = inflateSyncPoint;
	exports.inflateUndermine = inflateUndermine;
	*/

	},{"../utils/common":1,"./adler32":3,"./crc32":5,"./inffast":7,"./inftrees":9}],9:[function(require,module,exports){
	'use strict';


	var utils = require('../utils/common');

	var MAXBITS = 15;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	var lbase = [ /* Length codes 257..285 base */
	  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
	];

	var lext = [ /* Length codes 257..285 extra */
	  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
	  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
	];

	var dbase = [ /* Distance codes 0..29 base */
	  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	  8193, 12289, 16385, 24577, 0, 0
	];

	var dext = [ /* Distance codes 0..29 extra */
	  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
	  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
	  28, 28, 29, 29, 64, 64
	];

	module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
	{
	  var bits = opts.bits;
	      //here = opts.here; /* table entry for duplication */

	  var len = 0;               /* a code's length in bits */
	  var sym = 0;               /* index of code symbols */
	  var min = 0, max = 0;          /* minimum and maximum code lengths */
	  var root = 0;              /* number of index bits for root table */
	  var curr = 0;              /* number of index bits for current table */
	  var drop = 0;              /* code bits to drop for sub-table */
	  var left = 0;                   /* number of prefix codes available */
	  var used = 0;              /* code entries in table used */
	  var huff = 0;              /* Huffman code */
	  var incr;              /* for incrementing code, index */
	  var fill;              /* index for replicating entries */
	  var low;               /* low bits for current root entry */
	  var mask;              /* mask for low root bits */
	  var next;             /* next available space in table */
	  var base = null;     /* base value table to use */
	  var base_index = 0;
	//  var shoextra;    /* extra bits table to use */
	  var end;                    /* use base and extra for symbol > end */
	  var count = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];    /* number of codes of each length */
	  var offs = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];     /* offsets in table for each length */
	  var extra = null;
	  var extra_index = 0;

	  var here_bits, here_op, here_val;

	  /*
	   Process a set of code lengths to create a canonical Huffman code.  The
	   code lengths are lens[0..codes-1].  Each length corresponds to the
	   symbols 0..codes-1.  The Huffman code is generated by first sorting the
	   symbols by length from short to long, and retaining the symbol order
	   for codes with equal lengths.  Then the code starts with all zero bits
	   for the first code of the shortest length, and the codes are integer
	   increments for the same length, and zeros are appended as the length
	   increases.  For the deflate format, these bits are stored backwards
	   from their more natural integer increment ordering, and so when the
	   decoding tables are built in the large loop below, the integer codes
	   are incremented backwards.

	   This routine assumes, but does not check, that all of the entries in
	   lens[] are in the range 0..MAXBITS.  The caller must assure this.
	   1..MAXBITS is interpreted as that code length.  zero means that that
	   symbol does not occur in this code.

	   The codes are sorted by computing a count of codes for each length,
	   creating from that a table of starting indices for each length in the
	   sorted table, and then entering the symbols in order in the sorted
	   table.  The sorted table is work[], with that space being provided by
	   the caller.

	   The length counts are used for other purposes as well, i.e. finding
	   the minimum and maximum length codes, determining if there are any
	   codes at all, checking for a valid set of lengths, and looking ahead
	   at length counts to determine sub-table sizes when building the
	   decoding tables.
	   */

	  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
	  for (len = 0; len <= MAXBITS; len++) {
	    count[len] = 0;
	  }
	  for (sym = 0; sym < codes; sym++) {
	    count[lens[lens_index + sym]]++;
	  }

	  /* bound code lengths, force root to be within code lengths */
	  root = bits;
	  for (max = MAXBITS; max >= 1; max--) {
	    if (count[max] !== 0) { break; }
	  }
	  if (root > max) {
	    root = max;
	  }
	  if (max === 0) {                     /* no symbols to code at all */
	    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
	    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
	    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;


	    //table.op[opts.table_index] = 64;
	    //table.bits[opts.table_index] = 1;
	    //table.val[opts.table_index++] = 0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;

	    opts.bits = 1;
	    return 0;     /* no symbols, but wait for decoding to report error */
	  }
	  for (min = 1; min < max; min++) {
	    if (count[min] !== 0) { break; }
	  }
	  if (root < min) {
	    root = min;
	  }

	  /* check for an over-subscribed or incomplete set of lengths */
	  left = 1;
	  for (len = 1; len <= MAXBITS; len++) {
	    left <<= 1;
	    left -= count[len];
	    if (left < 0) {
	      return -1;
	    }        /* over-subscribed */
	  }
	  if (left > 0 && (type === CODES || max !== 1)) {
	    return -1;                      /* incomplete set */
	  }

	  /* generate offsets into symbol table for each length for sorting */
	  offs[1] = 0;
	  for (len = 1; len < MAXBITS; len++) {
	    offs[len + 1] = offs[len] + count[len];
	  }

	  /* sort symbols by length, by symbol order within each length */
	  for (sym = 0; sym < codes; sym++) {
	    if (lens[lens_index + sym] !== 0) {
	      work[offs[lens[lens_index + sym]]++] = sym;
	    }
	  }

	  /*
	   Create and fill in decoding tables.  In this loop, the table being
	   filled is at next and has curr index bits.  The code being used is huff
	   with length len.  That code is converted to an index by dropping drop
	   bits off of the bottom.  For codes where len is less than drop + curr,
	   those top drop + curr - len bits are incremented through all values to
	   fill the table with replicated entries.

	   root is the number of index bits for the root table.  When len exceeds
	   root, sub-tables are created pointed to by the root entry with an index
	   of the low root bits of huff.  This is saved in low to check for when a
	   new sub-table should be started.  drop is zero when the root table is
	   being filled, and drop is root when sub-tables are being filled.

	   When a new sub-table is needed, it is necessary to look ahead in the
	   code lengths to determine what size sub-table is needed.  The length
	   counts are used for this, and so count[] is decremented as codes are
	   entered in the tables.

	   used keeps track of how many table entries have been allocated from the
	   provided *table space.  It is checked for LENS and DIST tables against
	   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	   the initial root table size constants.  See the comments in inftrees.h
	   for more information.

	   sym increments through all symbols, and the loop terminates when
	   all codes of length max, i.e. all codes, have been processed.  This
	   routine permits incomplete codes, so another loop after this one fills
	   in the rest of the decoding tables with invalid code markers.
	   */

	  /* set up for code type */
	  // poor man optimization - use if-else instead of switch,
	  // to avoid deopts in old v8
	  if (type === CODES) {
	    base = extra = work;    /* dummy value--not used */
	    end = 19;

	  } else if (type === LENS) {
	    base = lbase;
	    base_index -= 257;
	    extra = lext;
	    extra_index -= 257;
	    end = 256;

	  } else {                    /* DISTS */
	    base = dbase;
	    extra = dext;
	    end = -1;
	  }

	  /* initialize opts for loop */
	  huff = 0;                   /* starting code */
	  sym = 0;                    /* starting code symbol */
	  len = min;                  /* starting code length */
	  next = table_index;              /* current table to fill in */
	  curr = root;                /* current table index bits */
	  drop = 0;                   /* current bits to drop from code for index */
	  low = -1;                   /* trigger new sub-table when len > root */
	  used = 1 << root;          /* use root table entries */
	  mask = used - 1;            /* mask for comparing low */

	  /* check available table space */
	  if ((type === LENS && used > ENOUGH_LENS) ||
	    (type === DISTS && used > ENOUGH_DISTS)) {
	    return 1;
	  }

	  var i=0;
	  /* process all codes and make table entries */
	  for (;;) {
	    i++;
	    /* create table entry */
	    here_bits = len - drop;
	    if (work[sym] < end) {
	      here_op = 0;
	      here_val = work[sym];
	    }
	    else if (work[sym] > end) {
	      here_op = extra[extra_index + work[sym]];
	      here_val = base[base_index + work[sym]];
	    }
	    else {
	      here_op = 32 + 64;         /* end of block */
	      here_val = 0;
	    }

	    /* replicate for those indices with low len bits equal to huff */
	    incr = 1 << (len - drop);
	    fill = 1 << curr;
	    min = fill;                 /* save offset to next table */
	    do {
	      fill -= incr;
	      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
	    } while (fill !== 0);

	    /* backwards increment the len-bit code huff */
	    incr = 1 << (len - 1);
	    while (huff & incr) {
	      incr >>= 1;
	    }
	    if (incr !== 0) {
	      huff &= incr - 1;
	      huff += incr;
	    } else {
	      huff = 0;
	    }

	    /* go to next symbol, update count, len */
	    sym++;
	    if (--count[len] === 0) {
	      if (len === max) { break; }
	      len = lens[lens_index + work[sym]];
	    }

	    /* create new sub-table if needed */
	    if (len > root && (huff & mask) !== low) {
	      /* if first time, transition to sub-tables */
	      if (drop === 0) {
	        drop = root;
	      }

	      /* increment past last table */
	      next += min;            /* here min is 1 << curr */

	      /* determine length of next table */
	      curr = len - drop;
	      left = 1 << curr;
	      while (curr + drop < max) {
	        left -= count[curr + drop];
	        if (left <= 0) { break; }
	        curr++;
	        left <<= 1;
	      }

	      /* check for enough space */
	      used += 1 << curr;
	      if ((type === LENS && used > ENOUGH_LENS) ||
	        (type === DISTS && used > ENOUGH_DISTS)) {
	        return 1;
	      }

	      /* point entry in root table to sub-table */
	      low = huff & mask;
	      /*table.op[low] = curr;
	      table.bits[low] = root;
	      table.val[low] = next - opts.table_index;*/
	      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
	    }
	  }

	  /* fill in remaining table entry if code is incomplete (guaranteed to have
	   at most one remaining entry, since if the code is incomplete, the
	   maximum code length that was allowed to get this far is one bit) */
	  if (huff !== 0) {
	    //table.op[next + huff] = 64;            /* invalid code marker */
	    //table.bits[next + huff] = len - drop;
	    //table.val[next + huff] = 0;
	    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
	  }

	  /* set return parameters */
	  //opts.table_index += used;
	  opts.bits = root;
	  return 0;
	};

	},{"../utils/common":1}],10:[function(require,module,exports){
	'use strict';

	module.exports = {
	  '2':    'need dictionary',     /* Z_NEED_DICT       2  */
	  '1':    'stream end',          /* Z_STREAM_END      1  */
	  '0':    '',                    /* Z_OK              0  */
	  '-1':   'file error',          /* Z_ERRNO         (-1) */
	  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
	  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
	  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
	  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
	  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
	};

	},{}],11:[function(require,module,exports){
	'use strict';


	function ZStream() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = ''/*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2/*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}

	module.exports = ZStream;

	},{}],"/lib/inflate.js":[function(require,module,exports){
	'use strict';


	var zlib_inflate = require('./zlib/inflate.js');
	var utils = require('./utils/common');
	var strings = require('./utils/strings');
	var c = require('./zlib/constants');
	var msg = require('./zlib/messages');
	var zstream = require('./zlib/zstream');
	var gzheader = require('./zlib/gzheader');

	var toString = Object.prototype.toString;

	/**
	 * class Inflate
	 *
	 * Generic JS-style wrapper for zlib calls. If you don't need
	 * streaming behaviour - use more simple functions: [[inflate]]
	 * and [[inflateRaw]].
	 **/

	/* internal
	 * inflate.chunks -> Array
	 *
	 * Chunks of output data, if [[Inflate#onData]] not overriden.
	 **/

	/**
	 * Inflate.result -> Uint8Array|Array|String
	 *
	 * Uncompressed result, generated by default [[Inflate#onData]]
	 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
	 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
	 * push a chunk with explicit flush (call [[Inflate#push]] with
	 * `Z_SYNC_FLUSH` param).
	 **/

	/**
	 * Inflate.err -> Number
	 *
	 * Error code after inflate finished. 0 (Z_OK) on success.
	 * Should be checked if broken data possible.
	 **/

	/**
	 * Inflate.msg -> String
	 *
	 * Error message, if [[Inflate.err]] != 0
	 **/


	/**
	 * new Inflate(options)
	 * - options (Object): zlib inflate options.
	 *
	 * Creates new inflator instance with specified params. Throws exception
	 * on bad params. Supported options:
	 *
	 * - `windowBits`
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Additional options, for internal needs:
	 *
	 * - `chunkSize` - size of generated data chunks (16K by default)
	 * - `raw` (Boolean) - do raw inflate
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 * By default, when no options set, autodetect deflate/gzip data format via
	 * wrapper header.
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	 *
	 * var inflate = new pako.Inflate({ level: 3});
	 *
	 * inflate.push(chunk1, false);
	 * inflate.push(chunk2, true);  // true -> last chunk
	 *
	 * if (inflate.err) { throw new Error(inflate.err); }
	 *
	 * console.log(inflate.result);
	 * ```
	 **/
	var Inflate = function(options) {

	  this.options = utils.assign({
	    chunkSize: 16384,
	    windowBits: 0,
	    to: ''
	  }, options || {});

	  var opt = this.options;

	  // Force window size for `raw` data, if not set directly,
	  // because we have no header for autodetect.
	  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
	    opt.windowBits = -opt.windowBits;
	    if (opt.windowBits === 0) { opt.windowBits = -15; }
	  }

	  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
	  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
	      !(options && options.windowBits)) {
	    opt.windowBits += 32;
	  }

	  // Gzip header has no info about windows size, we can do autodetect only
	  // for deflate. So, if window size not set, force it to max when gzip possible
	  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
	    // bit 3 (16) -> gzipped data
	    // bit 4 (32) -> autodetect gzip/deflate
	    if ((opt.windowBits & 15) === 0) {
	      opt.windowBits |= 15;
	    }
	  }

	  this.err    = 0;      // error code, if happens (0 = Z_OK)
	  this.msg    = '';     // error message
	  this.ended  = false;  // used to avoid multiple onEnd() calls
	  this.chunks = [];     // chunks of compressed data

	  this.strm   = new zstream();
	  this.strm.avail_out = 0;

	  var status  = zlib_inflate.inflateInit2(
	    this.strm,
	    opt.windowBits
	  );

	  if (status !== c.Z_OK) {
	    throw new Error(msg[status]);
	  }

	  this.header = new gzheader();

	  zlib_inflate.inflateGetHeader(this.strm, this.header);
	};

	/**
	 * Inflate#push(data[, mode]) -> Boolean
	 * - data (Uint8Array|Array|ArrayBuffer|String): input data
	 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
	 *
	 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
	 * new output chunks. Returns `true` on success. The last data block must have
	 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
	 *
	 * On fail call [[Inflate#onEnd]] with error code and return false.
	 *
	 * We strongly recommend to use `Uint8Array` on input for best speed (output
	 * format is detected automatically). Also, don't skip last param and always
	 * use the same type in your code (boolean or number). That will improve JS speed.
	 *
	 * For regular `Array`-s make sure all elements are [0..255].
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * push(chunk, false); // push one of data chunks
	 * ...
	 * push(chunk, true);  // push last chunk
	 * ```
	 **/
	Inflate.prototype.push = function(data, mode) {
	  var strm = this.strm;
	  var chunkSize = this.options.chunkSize;
	  var status, _mode;
	  var next_out_utf8, tail, utf8str;

	  if (this.ended) { return false; }
	  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

	  // Convert data if needed
	  if (typeof data === 'string') {
	    // Only binary strings can be decompressed on practice
	    strm.input = strings.binstring2buf(data);
	  } else if (toString.call(data) === '[object ArrayBuffer]') {
	    strm.input = new Uint8Array(data);
	  } else {
	    strm.input = data;
	  }

	  strm.next_in = 0;
	  strm.avail_in = strm.input.length;

	  do {
	    if (strm.avail_out === 0) {
	      strm.output = new utils.Buf8(chunkSize);
	      strm.next_out = 0;
	      strm.avail_out = chunkSize;
	    }

	    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

	    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
	      this.onEnd(status);
	      this.ended = true;
	      return false;
	    }

	    if (strm.next_out) {
	      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

	        if (this.options.to === 'string') {

	          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

	          tail = strm.next_out - next_out_utf8;
	          utf8str = strings.buf2string(strm.output, next_out_utf8);

	          // move tail
	          strm.next_out = tail;
	          strm.avail_out = chunkSize - tail;
	          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

	          this.onData(utf8str);

	        } else {
	          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
	        }
	      }
	    }
	  } while ((strm.avail_in > 0) && status !== c.Z_STREAM_END);

	  if (status === c.Z_STREAM_END) {
	    _mode = c.Z_FINISH;
	  }

	  // Finalize on the last chunk.
	  if (_mode === c.Z_FINISH) {
	    status = zlib_inflate.inflateEnd(this.strm);
	    this.onEnd(status);
	    this.ended = true;
	    return status === c.Z_OK;
	  }

	  // callback interim results if Z_SYNC_FLUSH.
	  if (_mode === c.Z_SYNC_FLUSH) {
	    this.onEnd(c.Z_OK);
	    strm.avail_out = 0;
	    return true;
	  }

	  return true;
	};


	/**
	 * Inflate#onData(chunk) -> Void
	 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
	 *   on js engine support. When string output requested, each chunk
	 *   will be string.
	 *
	 * By default, stores data blocks in `chunks[]` property and glue
	 * those in `onEnd`. Override this handler, if you need another behaviour.
	 **/
	Inflate.prototype.onData = function(chunk) {
	  this.chunks.push(chunk);
	};


	/**
	 * Inflate#onEnd(status) -> Void
	 * - status (Number): inflate status. 0 (Z_OK) on success,
	 *   other if not.
	 *
	 * Called either after you tell inflate that the input stream is
	 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	 * or if an error happened. By default - join collected chunks,
	 * free memory and fill `results` / `err` properties.
	 **/
	Inflate.prototype.onEnd = function(status) {
	  // On success - join
	  if (status === c.Z_OK) {
	    if (this.options.to === 'string') {
	      // Glue & convert here, until we teach pako to send
	      // utf8 alligned strings to onData
	      this.result = this.chunks.join('');
	    } else {
	      this.result = utils.flattenChunks(this.chunks);
	    }
	  }
	  this.chunks = [];
	  this.err = status;
	  this.msg = this.strm.msg;
	};


	/**
	 * inflate(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Decompress `data` with inflate/ungzip and `options`. Autodetect
	 * format via wrapper header by default. That's why we don't provide
	 * separate `ungzip` method.
	 *
	 * Supported options are:
	 *
	 * - windowBits
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information.
	 *
	 * Sugar (options):
	 *
	 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	 *   negative windowBits implicitly.
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
	 *   , output;
	 *
	 * try {
	 *   output = pako.inflate(input);
	 * } catch (err)
	 *   console.log(err);
	 * }
	 * ```
	 **/
	function inflate(input, options) {
	  var inflator = new Inflate(options);

	  inflator.push(input, true);

	  // That will never happens, if you don't cheat with options :)
	  if (inflator.err) { throw inflator.msg; }

	  return inflator.result;
	}


	/**
	 * inflateRaw(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * The same as [[inflate]], but creates raw data, without wrapper
	 * (header and adler32 crc).
	 **/
	function inflateRaw(input, options) {
	  options = options || {};
	  options.raw = true;
	  return inflate(input, options);
	}


	/**
	 * ungzip(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Just shortcut to [[inflate]], because it autodetects format
	 * by header.content. Done for convenience.
	 **/


	exports.Inflate = Inflate;
	exports.inflate = inflate;
	exports.inflateRaw = inflateRaw;
	exports.ungzip  = inflate;

	},{"./utils/common":1,"./utils/strings":2,"./zlib/constants":4,"./zlib/gzheader":6,"./zlib/inflate.js":8,"./zlib/messages":10,"./zlib/zstream":11}]},{},[])("/lib/inflate.js")
	});
	//This defines the $3Dmol object which is used to create viewers
	//and configure system-wide settings

	/** 
	 * All of the functionality of $3Dmol.js is contained within the
	 * $3Dmol global namespace
	 * @namespace */
	$3Dmol = (function(window) {
	    
	    var my = window['$3Dmol'] || {};
	    //var $ = window['jQuery'];
	    
	    return my;

	})(window);

	/* The following code "phones home" to register that an ip 
	   address has loaded 3Dmol.js.  Being able track this usage
	   is very helpful when reporting to funding agencies.  Please
	   leave this code in if you would like to increase the 
	   likelihood of 3Dmol.js remaining supported.
	*/
	if('https:' != document.location.protocol) { //not willing to pay for ssl cert
	    $.get("http://3dmol.csb.pitt.edu/track/report.cgi");
	}

	/* shims for IE */
	/*
	IE Doesn't have a .startsWith 
	*/
	if (!String.prototype.startsWith) {
	    String.prototype.startsWith = function (str){
	        return this.lastIndexOf(str, 0) === 0;
	    };
	}

	// or endsWith
	if (!String.prototype.endsWith) {
	    String.prototype.endsWith = function(suffix) {
	        return this.indexOf(suffix, this.length - suffix.length) !== -1;
	    };
	}

	/**
	*
	* jquery.binarytransport.js
	*
	* @description. jQuery ajax transport for making binary data type requests.
	* @version 1.0 
	* @author Henry Algus <henryalgus@gmail.com>
	*
	*/

	// use this transport for "binary" data type
	$.ajaxTransport(
	               "+binary",
	               function(options, originalOptions, jqXHR) {
	                   // check for conditions and support for blob / arraybuffer response type
	                   if (window.FormData
	                           && ((options.dataType && (options.dataType == 'binary')) || (options.data && ((window.ArrayBuffer && options.data instanceof ArrayBuffer) || (window.Blob && options.data instanceof Blob))))) {
	                       return {
	                           // create new XMLHttpRequest
	                           send : function(headers, callback) {
	                               // setup all variables
	                               var xhr = new XMLHttpRequest(), url = options.url, type = options.type, async = options.async || true,
	                               // blob or arraybuffer. Default is blob
	                               dataType = options.responseType || "blob", data = options.data
	                                       || null, username = options.username
	                                       || null, password = options.password
	                                       || null;

	                               xhr.addEventListener('load', function() {
	                                   var data = {};
	                                   data[options.dataType] = xhr.response;
	                                   // make callback and send data
	                                   callback(xhr.status, xhr.statusText,
	                                           data,
	                                           xhr.getAllResponseHeaders());
	                               });

	                               xhr.open(type, url, async, username,
	                                       password);

	                               // setup custom headers
	                               for ( var i in headers) {
	                                   xhr.setRequestHeader(i, headers[i]);
	                               }

	                               xhr.responseType = dataType;
	                               xhr.send(data);
	                           },
	                           abort : function() {
	                               jqXHR.abort();
	                           }
	                       };
	                   }
	               });

	    
	/**
	 * Create and initialize an appropriate viewer at supplied HTML element using specification in config
	 * @param {Object | string} element - Either HTML element or string identifier
	 * @param {ViewerSpec} config Viewer specification
	 * @return {$3Dmol.GLViewer} GLViewer, null if unable to instantiate WebGL
	 * 
	 * @example
	 * // Assume there exists an HTML div with id "gldiv"
	 * var element = $("#gldiv");
	 * 
	 * // Viewer config - properties 'defaultcolors' and 'callback'
	 * var config = {defaultcolors: $3Dmol.rasmolElementColors };
	 * 
	 * // Create GLViewer within 'gldiv' 
	 * var myviewer = $3Dmol.createViewer(element, config);
	 * //'data' is a string containing molecule data in pdb format  
	 * myviewer.addModel(data, "pdb");
	 * myviewer.zoomTo();
	 * myviewer.render();                        
	 *                        
	 */
	$3Dmol.createViewer = function(element, config)
	{
	    if($.type(element) === "string")
	        element = $("#"+element);
	    if(!element) return;

	    config = config || {}; 

	    //try to create the  viewer
	    try {
	        return new $3Dmol.GLViewer(element, config);
	    }
	    catch(e) {
	        throw "error creating viewer: "+e;
	    }
	    
	    return null;
	};
	   
	/**
	 * Contains a dictionary of embedded viewers created from HTML elements
	 * with a the viewer_3Dmoljs css class indexed by their id (or numerically
	 * if they do not have an id).
	*/
	$3Dmol.viewers = {};

	/**
	 * Load a PDB/PubChem structure into existing viewer. Automatically calls 'zoomTo' and 'render' on viewer after loading model
	 * 
	 * @function $3Dmol.download
	 * @param {string} query - String specifying pdb or pubchem id; must be prefaced with "pdb: " or "cid: ", respectively
	 * @param {$3Dmol.GLViewer} viewer - Add new model to existing viewer
	 * @param {Object} options - Specify additional options
	 *                           format: file format to download, if multiple are available, default format is pdb
	 *                           pdbUri: URI to retrieve PDB files, default URI is http://www.rcsb.org/pdb/files/
	 * @param {Function} callback - Function to call with model as argument after data is loaded.

	 * @example
	 * var myviewer = $3Dmol.createViewer(gldiv);
	 * 
	 * // GLModel 'm' created and loaded into glviewer for PDB id 2POR
	 * // Note that m will not contain the atomic data until after the network request is completed
	 * var m = $3Dmol.download('pdb: 2POR', myviewer, {format:'cif'});
	 * 
	 * @return {$3Dmol.GLModel} GLModel
	 */ 
	$3Dmol.download = function(query, viewer, options, callback) {
	    var baseURL = '';
	    var type = "";
	    var pdbUri = "";
	    var m = viewer.addModel();
	    
	    if (query.substr(0, 5) === 'mmtf:') {
	        pdbUri = options && options.pdbUri ? options.pdbUri : "http://mmtf.rcsb.org/full/";
	        query = query.substr(5).toUpperCase();
	        var uri = pdbUri + query + ".mmtf";        
	        
	        $.ajax({url:uri, 
	            type: "GET",
	            dataType: "binary",
	            responseType: "arraybuffer",
	            processData: false}).done(
	                function(ret, txt, response) {
	                    m.addMolData(ret, 'mmtf');
	                    viewer.zoomTo();
	                    viewer.render();
	                    if(callback) callback(m);
	                }).fail(function(e,txt) { 
	                    console.log(txt);
	                    });
	    }
	    else {
	        if (query.substr(0, 4) === 'pdb:') {
	            pdbUri = options && options.pdbUri ? options.pdbUri : "http://www.rcsb.org/pdb/files/";
	            type = options && options.format ? options.format : "pdb";
	            query = query.substr(4).toUpperCase();
	            if (!query.match(/^[1-9][A-Za-z0-9]{3}$/)) {
	               alert("Wrong PDB ID"); return;
	            }
	            if (options && options.format)
	                uri = pdbUri + query + "." + options.format;
	            else
	                uri = pdbUri + query + ".pdb";
	    
	        } else if (query.substr(0, 4) == 'cid:') {
	            type = "sdf";
	            query = query.substr(4);
	            if (!query.match(/^[0-9]+$/)) {
	               alert("Wrong Compound ID"); return;
	            }
	            uri = "http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + query + 
	              "/SDF?record_type=3d";
	        }
	    
	       $.get(uri, function(ret) {
	          m.addMolData(ret, type, options);
	          viewer.zoomTo();
	          viewer.render();
	          if(callback) callback(m);
	    
	       });
	   }
	   
	   return m;
	};
	       

	/**
	 * $3Dmol surface types
	 * @enum {number}
	 */
	$3Dmol.SurfaceType = {
	    VDW : 1,
	    MS : 2,
	    SAS : 3,
	    SES  : 4
	};


	//Miscellaneous functions and classes - to be incorporated into $3Dmol proper
	/**
	 * 
	 * @param {$3Dmol.Geometry} geometry
	 * @param {$3Dmol.Mesh} mesh
	 * @returns {undefined}
	 */
	$3Dmol.mergeGeos = function(geometry, mesh) {
	    
	    var meshGeo = mesh.geometry;
	    
	    if (meshGeo === undefined) 
	        return;
	    
	    geometry.geometryGroups.push( meshGeo.geometryGroups[0] );
	    
	};

	$3Dmol.multiLineString = function(f) {
	    return f.toString()
	            .replace(/^[^\/]+\/\*!?/, '')
	            .replace(/\*\/[^\/]+$/, '');
	            
	};

	/** 
	 * Render surface synchronously if true
	 * @param {boolean} [$3Dmol.SyncSurface=false]
	 * @type {boolean} */
	$3Dmol.syncSurface = false;

	// Internet Explorer refuses to allow webworkers in data blobs.  I can find
	// no way of checking for this feature directly, so must do a brower check
	if(window.navigator.userAgent.indexOf('MSIE ') >= 0 ||
	        window.navigator.userAgent.indexOf('Trident/') >= 0) {
	    $3Dmol.syncSurface = true; // can't use webworkers
	}

	/**
	 * Parse a string that represents a style or atom selection and convert it
	 * into an object.  The goal is to make it easier to write out these specifications
	 * without resorting to json. Objects cannot be defined recursively.
	 * ; - delineates fields of the object 
	 * : - if the field has a value other than an empty object, it comes after a colon
	 * , - delineates key/value pairs of a value object
	 *     If the value object consists of ONLY keys (no = present) the keys are 
	 *     converted to a list.  Otherwise a object of key/value pairs is created with
	 *     any missing values set to null
	 * = OR ~ - separates key/value pairs of a value object, if not provided value is null
	 *     twiddle is supported since = has special meaning in URLs
	 * @param (String) str
	 * @returns {Object}
	 */
	$3Dmol.specStringToObject = function(str) {
	    if(typeof(str) === "object") {
	        return str; //not string, assume was converted already
	    }
	    else if(typeof(str) === "undefined" || str == null) {
	        return str; 
	    }
	    
	    str = str.replace(/%7E/,'~'); //copy/pasting urls sometimes does this
	    //convert things that look like numbers into numbers
	    var massage = function(val) {
	        if($.isNumeric(val)) {
	           //hexadecimal does not parse as float
	           if(Math.floor(parseFloat(val)) == parseInt(val)) {
	              return parseFloat(val);
	           }
	           else if(val.indexOf('.') >= 0) {
	               return parseFloat(val); // ".7" for example, does not parseInt
	           }
	           else {
	               return parseInt(val);
	           }
	        }
	        //boolean conversions
	        else if(val === 'true') {
	            return true;
	        }
	        else if(val === 'false') {
	            return false;
	        }
	        return val;
	    }
	    
	    var ret = {};
	    if(str === 'all') return ret;
	    var fields = str.split(';');
	    for(var i = 0; i < fields.length; i++) {
	        var fv = fields[i].split(':');
	        var f = fv[0];
	        var val = {};
	        var vstr = fv[1];
	        if(vstr) {
	            vstr = vstr.replace(/~/g,"=");
	            if(vstr.indexOf('=') !== -1) {
	                //has key=value pairs, must be object
	                var kvs = vstr.split(',');
	                for(var j = 0; j < kvs.length; j++) {
	                    var kv = kvs[j].split('=',2);
	                    val[kv[0]] = massage(kv[1]);
	                }
	            }
	            else if(vstr.indexOf(',') !== -1) {
	                //has multiple values, must list
	                val = vstr.split(',');
	            }
	            else {
	                val = massage(vstr); //value itself
	            }
	        }
	        ret[f] = val;
	    }

	return ret;
	}


	/**
	 * computes the bounding box around the provided atoms
	 * @param {AtomSpec[]} atomlist
	 * @return {Array}
	 */
	$3Dmol.getExtent = function(atomlist, ignoreSymmetries) {
	    var xmin, ymin, zmin, xmax, ymax, zmax, xsum, ysum, zsum, cnt;
	    var includeSym = !ignoreSymmetries;

	    xmin = ymin = zmin = 9999;
	    xmax = ymax = zmax = -9999;
	    xsum = ysum = zsum = cnt = 0;
	    
	    if (atomlist.length === 0)
	        return [ [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ];
	    for (var i = 0; i < atomlist.length; i++) {
	        var atom = atomlist[i];
	        if (typeof atom === 'undefined' || !isFinite(atom.x) ||
	                !isFinite(atom.y) || !isFinite(atom.z))
	            continue;
	        cnt++;
	        xsum += atom.x;
	        ysum += atom.y;
	        zsum += atom.z;
	        
	        xmin = (xmin < atom.x) ? xmin : atom.x;
	        ymin = (ymin < atom.y) ? ymin : atom.y;
	        zmin = (zmin < atom.z) ? zmin : atom.z;
	        xmax = (xmax > atom.x) ? xmax : atom.x;
	        ymax = (ymax > atom.y) ? ymax : atom.y;
	        zmax = (zmax > atom.z) ? zmax : atom.z;
	        
	        if (atom.symmetries && includeSym) {
	            for (var n = 0; n < atom.symmetries.length; n++) {
	                cnt++;
	                xsum += atom.symmetries[n].x;
	                ysum += atom.symmetries[n].y;
	                zsum += atom.symmetries[n].z;
	                xmin = (xmin < atom.symmetries[n].x) ? xmin : atom.symmetries[n].x;
	                ymin = (ymin < atom.symmetries[n].y) ? ymin : atom.symmetries[n].y;
	                zmin = (zmin < atom.symmetries[n].z) ? zmin : atom.symmetries[n].z;
	                xmax = (xmax > atom.symmetries[n].x) ? xmax : atom.symmetries[n].x;
	                ymax = (ymax > atom.symmetries[n].y) ? ymax : atom.symmetries[n].y;
	                zmax = (zmax > atom.symmetries[n].z) ? zmax : atom.symmetries[n].z; 
	            }
	        }  
	    }

	    return [ [ xmin, ymin, zmin ], [ xmax, ymax, zmax ],
	            [ xsum / cnt, ysum / cnt, zsum / cnt ] ];
	};


	//return the value of an atom property prop, or null if non existent
	//looks first in properties, then in the atom itself
	$3Dmol.getAtomProperty = function(atom, prop) {
	    var val = null;
	    if (atom.properties
	            && typeof (atom.properties[prop]) != "undefined") {
	        val = atom.properties[prop];
	    } else if(typeof(atom[prop]) != 'undefined') {
	        val = atom[prop];
	    }
	    return val;
	};

	/* get the min and max values of the specified property in the provided
	* @function $3Dmol.getPropertyRange
	* @param {AtomSpec[]} atomlist - list of atoms to evaluate
	* @param {string} prop - name of property 
	* @return {Array} - [min, max] values
	*/
	$3Dmol.getPropertyRange = function (atomlist, prop) {
	    var min = Number.POSITIVE_INFINITY;
	    var max = Number.NEGATIVE_INFINITY;

	    for (var i = 0, n = atomlist.length; i < n; i++) {
	        var atom = atomlist[i];
	        var val = $3Dmol.getAtomProperty(atom, prop);
	        
	        if(val != null) {
	            if (val < min)
	                min = val;
	            if (val > max)
	                max = val;                
	        }
	    }

	    if (!isFinite(min) && !isFinite(max))
	        min = max = 0;
	    else if (!isFinite(min))
	        min = max;
	    else if (!isFinite(max))
	        max = min;

	    return [ min, max ];
	}

	//hackish way to work with requirejs - doesn't actually work yet
	//since we doing use the require optimizer to combine modules
	if( true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = ($3Dmol), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}

	/*
	* math-like functionality
	* quaternion, vector, matrix
	*/

	var $3Dmol = $3Dmol || {};
	$3Dmol.Math = {

	    clamp : function(x, min, max) {
	        return Math.min( Math.max( x, min ), max );
	    },

	    degToRad : function() {
	       var degreeToRadiansFactor = Math.PI / 180;
	       
	       return function(deg) {
	           return deg * degreeToRadiansFactor;
	       };
	    
	    }()
	    
	};


	// Quaternion
	/** @constructor */
	$3Dmol.Quaternion = function(x, y, z, w) {

	    this.x = x || 0;
	    this.y = y || 0;
	    this.z = z || 0;
	    this.w = (w !== undefined) ? w : 1;

	};

	$3Dmol.Quaternion.prototype = {

	    constructor : $3Dmol.Quaternion,

	    set : function(x, y, z, w) {
	        
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;

	        return this;
	    },

	    copy : function(q) {
	        
	        this.x = q.x;
	        this.y = q.y;
	        this.z = q.z;
	        this.w = q.w;

	        return this;
	    },

	    conjugate : function() {
	        
	        this.x *= -1;
	        this.y *= -1;
	        this.z *= -1;

	        return this;
	    },

	    inverse : function() {
	        
	        return this.conjugate().normalize();
	    },

	    length : function() {
	        
	        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	    },

	    normalize : function() {
	        
	        var l = this.length();

	        if (l === 0) {
	            this.x = 0;
	            this.y = 0;
	            this.z = 0;
	            this.w = 1;
	        } else {
	            l = 1 / l;

	            this.x *= l;
	            this.y *= l;
	            this.z *= l;
	            this.w *= l;
	        }

	        return this;

	    },

	    multiply : function(q) {
	        
	        return this.multiplyQuaternions(this, q);
	    },

	    multiplyQuaternions : function(a, b) {

	        var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
	        var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;

	        this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
	        this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
	        this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
	        this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

	    }
	};

	//A 2 Vector
	/** @constructor */
	$3Dmol.Vector2 = function(x, y) {
	    
	    this.x = x || 0.0;
	    this.y = y || 0.0;
	};

	$3Dmol.Vector2.prototype = {
	    
	    constructor : $3Dmol.Vector2,
	   
	    set : function(x, y) {
	       
	        this.x = x;
	        this.y = y;
	       
	        return this;
	    },
	    
	    subVectors : function(a, b) {
	        
	      this.x = a.x - b.x;
	      this.y = a.y - b.y;
	      
	      return this;
	    },
	   
	    copy : function(v) {
	       
	        this.x = v.x;
	        this.y = v.y;
	       
	        return this;
	    },
	   
	    clone : function() {
	        
	        return new $3Dmol.Vector2(this.x, this.y);
	    }    
	   
	};

	//A 3 Vector

	$3Dmol.Vector3 = function(x, y, z) {
	    this.x = x || 0.0;
	    this.y = y || 0.0;
	    this.z = z || 0.0;
	};
	/** @this {$3Dmol.Vector3} */
	$3Dmol.Vector3.prototype =  {
	    
	    constructor : $3Dmol.Vector3,
	    
	    set : function(x, y, z) {
	        
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        
	        return this;
	    },
	    
	    copy : function(v) {
	        
	        this.x = v.x;
	        this.y = v.y;
	        this.z = v.z;
	        
	        return this;  
	    },
	    
	    add : function(v) {
	        
	        this.x += v.x;
	        this.y += v.y;
	        this.z += v.z;  
	        
	        return this;
	    },
	    
	    addVectors : function(a, b) {
	        
	        this.x = a.x + b.x;
	        this.y = a.y + b.y;
	        this.z = a.z + b.z;
	        
	        return this;
	    },
	    
	    sub : function(v) {
	        
	        this.x -= v.x;
	        this.y -= v.y;
	        this.z -= v.z;
	        
	        return this;
	    },
	    
	    subVectors : function(a, b) {
	        
	        this.x = a.x - b.x;
	        this.y = a.y - b.y;
	        this.z = a.z - b.z;
	        
	        return this;
	    },
	    
	    multiplyScalar : function(s) {
	        
	        this.x *= s;
	        this.y *= s;
	        this.z *= s;
	        
	        return this;
	    },
	    
	    divideScalar : function(s) {
	        
	        if (s !== 0) {
	            this.x /= s;
	            this.y /= s;
	            this.z /= s;
	        }
	        
	        else {
	            this.x = 0;
	            this.y = 0;
	            this.z = 0;
	        }
	        
	        return this;
	    },
	    
	    //accumulate maximum
	    max : function(s) {
	        
	        this.x = Math.max(this.x,s.x);
	        this.y = Math.max(this.y,s.y);
	        this.z = Math.max(this.z,s.z);
	        
	        return this;
	    },
	    
	    //accumulate min
	    min : function(s) {
	        
	        this.x = Math.min(this.x,s.x);
	        this.y = Math.min(this.y,s.y);
	        this.z = Math.min(this.z,s.z);
	        
	        return this;
	    },
	    distanceTo: function(v) {
	        return Math.sqrt(this.distanceToSquared(v));
	    },

	    distanceToSquared: function(v) {
	        var dx = this.x - v.x;
	        var dy = this.y - v.y;
	        var dz = this.z - v.z;

	        return dx * dx + dy * dy + dz * dz;
	    },
	    
	    applyMatrix4 : function(m) {
	    
	        var x = this.x, y = this.y, z = this.z;
	        
	        var e = m.elements;
	        
	        this.x = e[0]*x + e[4]*y + e[8]*z + e[12];
	        this.y = e[1]*x + e[5]*y + e[9]*z + e[13];
	        this.z = e[2]*x + e[6]*y + e[10]*z + e[14];
	        
	        return this;
	    },
	    
	    applyProjection : function(m) {
	        
	        //input: $3Dmol.Matrix4 projection matrix
	        
	        var x = this.x, y = this.y, z = this.z;
	        
	        var e = m.elements;
	        var d = ( e[3]*x + e[7]*y + e[11]*z + e[15]);
	        
	        this.x = (e[0]*x + e[4]*y + e[8]*z + e[12]) / d;
	        this.y = (e[1]*x + e[5]*y + e[9]*z + e[13]) / d;
	        this.z = (e[2]*x + e[6]*y + e[10]*z + e[14]) / d;
	        
	        return this;
	    },
	    
	    applyQuaternion : function(q) { 
	        
	        //save values
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        
	        var qx = q.x;
	        var qy = q.y;
	        var qz = q.z;
	        var qw = q.w;
	        
	        //compute this as
	        //t = 2 * cross(q.xyz, v)
	        //newv = v + q.w * t + cross(q.xyz, t)
	        //this from molecularmusings
	        //http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/
	        var t = {};
	        t.x = 2*(y * qz - z * qy);
	        t.y = 2*(z * qx - x * qz);
	        t.z = 2*(x * qy - y * qx);
	        
	        //cross t with q
	        var t2 = {};
	        t2.x = t.y * qz - t.z * qy;
	        t2.y = t.z * qx - t.x * qz;
	        t2.z = t.x * qy - t.y * qx;
	        
	        this.x = x + q.w*t.x + t2.x;
	        this.y = y + q.w*t.y + t2.y;
	        this.z = z + q.w*t.z + t2.z;
	        
	        return this;
	    },
	    
	    negate : function() {
	        
	        return this.multiplyScalar(-1);
	    },
	    
	    dot : function(v) {
	        
	        return this.x * v.x + this.y * v.y + this.z * v.z;
	    },
	    
	    length : function() {
	        
	        return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
	    },
	    
	    lengthSq : function() {
	    
	        return (this.x*this.x + this.y*this.y + this.z*this.z);
	    },
	    
	    normalize : function() {
	        
	        return this.divideScalar( this.length() );
	    },
	    
	    cross : function (v) {
	        
	        var x = this.x, y = this.y, z = this.z;
	        
	        this.x = y * v.z - z * v.y;
	        this.y = z * v.x - x * v.z;
	        this.z = x * v.y - y * v.x;
	        
	        return this;
	    },
	    
	    crossVectors : function(a, b) {
	        
	        this.x = a.y * b.z - a.z * b.y;
	        this.y = a.z * b.x - a.x * b.z;
	        this.z = a.x * b.y - a.y * b.x;
	        
	        return this;
	    },
	    
	    getPositionFromMatrix : function(m) {
	        
	        this.x = m.elements[12];
	        this.y = m.elements[13];
	        this.z = m.elements[14];
	        
	        return this;
	    },

	    setEulerFromRotationMatrix : function (m, order) {

	        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

	        var te = m.elements;
	        var m11 = te[0], m12 = te[4], m13 = te[8];
	        var m21 = te[1], m22 = te[5], m23 = te[9];
	        var m31 = te[2], m32 = te[6], m33 = te[10];

	        if ( order === undefined || order === 'XYZ' ) {

	            this.y = Math.asin( $3Dmol.Math.clamp( m13, -1, 1 ) );

	            if ( Math.abs( m13 ) < 0.99999 ) {

	                this.x = Math.atan2( - m23, m33 );
	                this.z = Math.atan2( - m12, m11 );

	            } else {

	                this.x = Math.atan2( m32, m22 );
	                this.z = 0;

	            }
	        }
	        
	        else {
	            console.error("Error with vector's setEulerFromRotationMatrix: Unknown order: " + order);
	        }
	        
	        return this;

	    },

	    rotateAboutVector : function(axis, ang) {

	        axis.normalize();
	        var cosang = Math.cos(ang);
	        var sinang = Math.sin(ang); 
	        // Rodrigues' rotation formula, from wikipedia

	        var term1 = this.clone().multiplyScalar(cosang);
	        var term2 = (axis.clone().cross(this)).multiplyScalar(sinang)
	        var term3 = axis.clone().multiplyScalar(axis.clone().dot(this)).multiplyScalar(1-cosang);

	        var rot = term1.add(term2).add(term3);
	    
	        this.x = rot.x;
	        this.y = rot.y;
	        this.z = rot.z;

	        return this;
	    },
	    
	    clone : function() {
	        return new $3Dmol.Vector3(this.x, this.y, this.z);
	    }
	    
	};

	//Matrices

	//Matrix3
	/** @constructor */
	$3Dmol.Matrix3 = function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
	    
	    this.elements = new Float32Array(9);
	    
	    this.set(
	        (n11 !== undefined) ? n11 : 1, n12 || 0, n13 || 0,
	        n21 || 0, (n22 !== undefined) ? n22 : 1, n23 || 0,
	        n31 || 0, n32 || 0, (n33 !== undefined) ? n33 : 1
	    );
	    
	};

	$3Dmol.Matrix3.prototype = {
	    
	    constructor : $3Dmol.Matrix3,    
	   
	    set : function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
	        var te = this.elements;
	        
	        te[0] = n11; te[3] = n12; te[6] = n13;
	        te[1] = n21; te[4] = n22; te[7] = n23;
	        te[2] = n31; te[5] = n32; te[8] = n33;
	        
	        return this;
	    },
	    
	    identity : function() {   
	        this.set(
	            1,0,0,
	            0,1,0,
	            0,0,1
	        );
	        
	        return this;
	    },
	   
	    copy : function(m) {
	        var me = m.elements;
	       
	        this.set(
	            me[0], me[3], me[6],
	            me[1], me[4], me[7],
	            me[2], me[5], me[8]
	        );
	    },
	    
	    multiplyScalar: function ( s ) {
	        var te = this.elements;

	        te[0] *= s; te[3] *= s; te[6] *= s;
	        te[1] *= s; te[4] *= s; te[7] *= s;
	        te[2] *= s; te[5] *= s; te[8] *= s;

	        return this;
	    },

	    getInverse: function ( matrix, throwOnInvertible ) {
	        // input: Matrix4

	        var me = matrix.elements;
	        var te = this.elements;

	        te[ 0 ] =   me[10] * me[5] - me[6] * me[9];
	        te[ 1 ] = - me[10] * me[1] + me[2] * me[9];
	        te[ 2 ] =   me[6] * me[1] - me[2] * me[5];
	        te[ 3 ] = - me[10] * me[4] + me[6] * me[8];
	        te[ 4 ] =   me[10] * me[0] - me[2] * me[8];
	        te[ 5 ] = - me[6] * me[0] + me[2] * me[4];
	        te[ 6 ] =   me[9] * me[4] - me[5] * me[8];
	        te[ 7 ] = - me[9] * me[0] + me[1] * me[8];
	        te[ 8 ] =   me[5] * me[0] - me[1] * me[4];

	        var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

	        // no inverse

	        if ( det === 0 ) {

	            var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

	            if ( throwOnInvertible || false ) {

	                throw new Error( msg ); 

	            } else {

	                console.warn( msg );

	            }

	            this.identity();

	            return this;

	        }

	        this.multiplyScalar( 1.0 / det );

	        return this;
	    },

	    //https://en.wikipedia.org/wiki/Determinant
	    getDeterminant: function() {
	        var m = this.elements;

	        /*|a b c|
	          |d e f|
	          |g h i|*/

	        var determinant
	            = m[0] * m[4] * m[8] //+aei
	            + m[1] * m[5] * m[6] //+bfg
	            + m[2] * m[3] * m[7] //+cdh
	            - m[2] * m[4] * m[6] //-ceg
	            - m[1] * m[3] * m[8] //-bdi
	            - m[0] * m[5] * m[7];//-afh
	        return determinant;
	    },
	    
	    transpose: function () {
	        var tmp, m = this.elements;

	        tmp = m[1]; m[1] = m[3]; m[3] = tmp;
	        tmp = m[2]; m[2] = m[6]; m[6] = tmp;
	        tmp = m[5]; m[5] = m[7]; m[7] = tmp;

	        return this;
	    },
	    
	    clone: function () {
	        var te = this.elements;

	        return new $3Dmol.Matrix3(

	            te[0], te[3], te[6],
	            te[1], te[4], te[7],
	            te[2], te[5], te[8]

	        );
	    }
	   
	};

	//Matrix 4
	/** @constructor */
	$3Dmol.Matrix4 = function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {

	    if(typeof(n12) === 'undefined' && typeof(n11) !== 'undefined') {
	        //passing list like initialization
	        this.elements = new Float32Array(n11);
	    } else {
	        var te = this.elements = new Float32Array( 16 );
	        
	        te[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;
	        te[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;
	        te[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;
	        te[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;
	    }
	};

	$3Dmol.Matrix4.prototype = {

	    constructor : $3Dmol.Matrix4,

	    set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	        var te = this.elements;

	        te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
	        te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
	        te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
	        te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;

	        return this;
	    },

	    identity: function () {
	        this.set(

	            1, 0, 0, 0,
	            0, 1, 0, 0,
	            0, 0, 1, 0,
	            0, 0, 0, 1

	        );

	        return this;
	    },

	    copy: function ( m ) {
	        var me = m.elements;

	        this.set(

	            me[0], me[4], me[8], me[12],
	            me[1], me[5], me[9], me[13],
	            me[2], me[6], me[10], me[14],
	            me[3], me[7], me[11], me[15]

	        );

	        return this;
	    },

	    matrix3FromTopLeft: function () {
	        var te = this.elements;
	        return new $3Dmol.Matrix3(te[0],te[4],te[8],te[1],te[5],te[9],te[2],te[6],te[10]);
	    },

	    setRotationFromEuler: function ( v, order ) {

	        var te = this.elements;

	        var x = v.x, y = v.y, z = v.z;
	        var a = Math.cos( x ), b = Math.sin( x );
	        var c = Math.cos( y ), d = Math.sin( y );
	        var e = Math.cos( z ), f = Math.sin( z );

	        if ( order === undefined || order === 'XYZ' ) {

	            var ae = a * e, af = a * f, be = b * e, bf = b * f;

	            te[0] = c * e;
	            te[4] = - c * f;
	            te[8] = d;

	            te[1] = af + be * d;
	            te[5] = ae - bf * d;
	            te[9] = - b * c;

	            te[2] = bf - ae * d;
	            te[6] = be + af * d;
	            te[10] = a * c;

	        } 
	        
	        else
	            console.error("Error with matrix4 setRotationFromEuler. Order: " + order);

	        return this;

	    },

	    setRotationFromQuaternion: function ( q ) {
	        var te = this.elements;

	        var x = q.x, y = q.y, z = q.z, w = q.w;
	        var x2 = x + x, y2 = y + y, z2 = z + z;
	        var xx = x * x2, xy = x * y2, xz = x * z2;
	        var yy = y * y2, yz = y * z2, zz = z * z2;
	        var wx = w * x2, wy = w * y2, wz = w * z2;

	        te[0] = 1 - ( yy + zz );
	        te[4] = xy - wz;
	        te[8] = xz + wy;

	        te[1] = xy + wz;
	        te[5] = 1 - ( xx + zz );
	        te[9] = yz - wx;

	        te[2] = xz - wy;
	        te[6] = yz + wx;
	        te[10] = 1 - ( xx + yy );

	        return this;
	    },

	    lookAt: function() {
	        var x = new $3Dmol.Vector3();
	        var y = new $3Dmol.Vector3();
	        var z = new $3Dmol.Vector3();

	        return function ( eye, target, up ) {

	            var te = this.elements;

	            z.subVectors( eye, target ).normalize();

	            if ( z.length() === 0 ) {

	                z.z = 1;

	            }

	            x.crossVectors( up, z ).normalize();

	            if ( x.length() === 0 ) {

	                z.x += 0.0001;
	                x.crossVectors( up, z ).normalize();

	            }

	            y.crossVectors( z, x );


	            te[0] = x.x; te[4] = y.x; te[8] = z.x;
	            te[1] = x.y; te[5] = y.y; te[9] = z.y;
	            te[2] = x.z; te[6] = y.z; te[10] = z.z;

	            return this;
	        };

	    }(),

	    multiplyMatrices: function ( a, b ) {
	        var ae = a.elements;
	        var be = b.elements;
	        var te = this.elements;

	        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
	        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
	        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
	        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];

	        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
	        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
	        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
	        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];

	        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
	        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
	        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
	        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

	        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
	        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
	        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
	        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

	        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
	        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
	        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
	        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

	        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
	        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
	        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
	        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

	        return this;
	    },
	    
	    multiplyScalar: function ( s ) {
	        var te = this.elements;
	    
	        te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;
	        te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;
	        te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;
	        te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;
	    
	        return this;
	    },
	    
	    makeTranslation: function ( x, y, z ) {

	        this.set(

	            1, 0, 0, x,
	            0, 1, 0, y,
	            0, 0, 1, z,
	            0, 0, 0, 1

	        );

	        return this;

	    },
	    
	    transpose: function () {
	        var te = this.elements;
	        var tmp;

	        tmp = te[1]; te[1] = te[4]; te[4] = tmp;
	        tmp = te[2]; te[2] = te[8]; te[8] = tmp;
	        tmp = te[6]; te[6] = te[9]; te[9] = tmp;

	        tmp = te[3]; te[3] = te[12]; te[12] = tmp;
	        tmp = te[7]; te[7] = te[13]; te[13] = tmp;
	        tmp = te[11]; te[11] = te[14]; te[14] = tmp;

	        return this;
	    },

	    getPosition: function() {
	        var v1 = new $3Dmol.Vector3();

	        return function () {

	            console.warn( 'DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.' );

	            var te = this.elements;
	            return v1.set( te[12], te[13], te[14] );
	        };

	    }(),

	    setPosition: function ( v ) {
	        var te = this.elements;

	        te[12] = v.x;
	        te[13] = v.y;
	        te[14] = v.z;

	        return this;
	    },

	    getInverse: function ( m, throwOnInvertible ) {
	        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	        var te = this.elements;
	        var me = m.elements;

	        var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
	        var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
	        var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
	        var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];

	        te[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;
	        te[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;
	        te[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;
	        te[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;
	        te[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;
	        te[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;
	        te[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;
	        te[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;
	        te[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;
	        te[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;
	        te[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;
	        te[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;
	        te[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;
	        te[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;
	        te[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;
	        te[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;

	        var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 4 ] + me[ 2 ] * te[ 8 ] + me[ 3 ] * te[ 12 ];

	        if ( det === 0 ) {

	            var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

	            if ( throwOnInvertible || false ) {

	                throw new Error( msg ); 

	            } else {

	                console.warn( msg );

	            }

	            this.identity();

	            return this;
	        }

	        this.multiplyScalar( 1 / det );

	        return this;
	    },

	    isReflected: function() {
	        return this.matrix3FromTopLeft().getDeterminant() < 0;
	    },

	    compose: function() {
	        var mRotation = new $3Dmol.Matrix4(),
	            mScale = new $3Dmol.Matrix4();
	        
	        return function ( translation, rotation, scale ) {

	            var te = this.elements;

	            mRotation.identity();
	            mRotation.setRotationFromQuaternion( rotation );

	            mScale.makeScale( scale.x, scale.y, scale.z );

	            this.multiplyMatrices( mRotation, mScale );

	            te[12] = translation.x;
	            te[13] = translation.y;
	            te[14] = translation.z;

	            return this;

	        };
	    }(),

	    decompose: function() {
	        var x = new $3Dmol.Vector3(),
	            y = new $3Dmol.Vector3(),
	            z = new $3Dmol.Vector3(),
	            matrix = new $3Dmol.Matrix4();

	        return function ( translation, rotation, scale ) {

	            var te = this.elements;

	            // grab the axis vectors
	            x.set( te[0], te[1], te[2] );
	            y.set( te[4], te[5], te[6] );
	            z.set( te[8], te[9], te[10] );

	            translation = ( translation instanceof $3Dmol.Vector3 ) ? translation : new $3Dmol.Vector3();
	            rotation = ( rotation instanceof $3Dmol.Quaternion ) ? rotation : new $3Dmol.Quaternion();
	            scale = ( scale instanceof $3Dmol.Vector3 ) ? scale : new $3Dmol.Vector3();

	            scale.x = x.length();
	            scale.y = y.length();
	            scale.z = z.length();

	            translation.x = te[12];
	            translation.y = te[13];
	            translation.z = te[14];

	            // scale the rotation part

	            matrix.copy( this );

	            matrix.elements[0] /= scale.x;
	            matrix.elements[1] /= scale.x;
	            matrix.elements[2] /= scale.x;

	            matrix.elements[4] /= scale.y;
	            matrix.elements[5] /= scale.y;
	            matrix.elements[6] /= scale.y;

	            matrix.elements[8] /= scale.z;
	            matrix.elements[9] /= scale.z;
	            matrix.elements[10] /= scale.z;

	            rotation.setFromRotationMatrix( matrix );

	            return [ translation, rotation, scale ];

	        };
	    }(),

	    scale: function ( v ) {
	        var te = this.elements;
	        var x = v.x, y = v.y, z = v.z;

	        te[0] *= x; te[4] *= y; te[8] *= z;
	        te[1] *= x; te[5] *= y; te[9] *= z;
	        te[2] *= x; te[6] *= y; te[10] *= z;
	        te[3] *= x; te[7] *= y; te[11] *= z;

	        return this;
	    },
	    
	    getMaxScaleOnAxis : function() {
	        
	        var te = this.elements;
	        
	        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
	        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
	        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
	        
	        return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));
	        
	    },

	    makeFrustum: function ( left, right, bottom, top, near, far ) {
	        var te = this.elements;
	              
	        var x = 2 * near / ( right - left );
	        var y = 2 * near / ( top - bottom );

	        var a = ( right + left ) / ( right - left );
	        var b = ( top + bottom ) / ( top - bottom );
	        var c = - ( far + near ) / ( far - near );
	        var d = - 2 * far * near / ( far - near );

	        te[0] = x;  te[4] = 0;  te[8] = a;  te[12] = 0;
	        te[1] = 0;  te[5] = y;  te[9] = b;  te[13] = 0;
	        te[2] = 0;  te[6] = 0;  te[10] = c; te[14] = d;
	        te[3] = 0;  te[7] = 0;  te[11] = - 1;   te[15] = 0;

	        return this;
	    },

	    makePerspective: function ( fov, aspect, near, far ) {
	        var ymax = near * Math.tan( $3Dmol.Math.degToRad( fov * 0.5 ) );
	        var ymin = - ymax;
	        var xmin = ymin * aspect;
	        var xmax = ymax * aspect;

	        return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );
	    },
	    

	    makeOrthographic: function ( left, right, top, bottom, near, far ) {

	        var te = this.elements;
	        var w = 1.0 / ( right - left );
	        var h = 1.0 / ( top - bottom );
	        var p = 1.0 / ( far - near );

	        var x = ( right + left ) * w;
	        var y = ( top + bottom ) * h;
	        var z = ( far + near ) * p;

	        te[ 0 ] = 2 * w;    te[ 4 ] = 0;    te[ 8 ] = 0;    te[ 12 ] = - x;
	        te[ 1 ] = 0;    te[ 5 ] = 2 * h;    te[ 9 ] = 0;    te[ 13 ] = - y;
	        te[ 2 ] = 0;    te[ 6 ] = 0;    te[ 10 ] = - 2 * p; te[ 14 ] = - z;
	        te[ 3 ] = 0;    te[ 7 ] = 0;    te[ 11 ] = 0;   te[ 15 ] = 1;

	        return this;

	    },
	    
	    isEqual : function (m) {
	        var me = m.elements;
	        var te = this.elements;
	        
	        if (te[0] == me[0] && te[4] == me[4] && te[8] == me[8] && te[12] == me[12] &&
	            te[1] == me[1] && te[5] == me[5] && te[9] == me[9] && te[13] == me[13] &&
	            te[2] == me[2] && te[6] == me[6] && te[10] == me[10] && te[14] == me[14] &&
	            te[3] == me[3] && te[7] == me[7] && te[11] == me[11] && te[15] == me[15]) {
	            return true;
	        }
	        else {
	            return false;
	        }
	    },

	    clone: function () {
	        var te = this.elements;

	        return new $3Dmol.Matrix4(

	            te[0], te[4], te[8], te[12],
	            te[1], te[5], te[9], te[13],
	            te[2], te[6], te[10], te[14],
	            te[3], te[7], te[11], te[15]

	        );
	    },
	    
	    isIdentity: function () {
	        var te = this.elements;
	        
	        if (te[0] == 1 && te[4] == 0 && te[8] == 0 && te[12] == 0 &&
	            te[1] == 0 && te[5] == 1 && te[9] == 0 && te[13] == 0 &&
	            te[2] == 0 && te[6] == 0 && te[10] == 1 && te[14] == 0 &&
	            te[3] == 0 && te[7] == 0 && te[11] == 0 && te[15] == 1) {
	            return true;
	        }
	        else {
	            return false;
	        }
	    }
	    
	};
	/** @constructor */
	$3Dmol.Ray = function(origin, direction) {
	    
	    this.origin = (origin !== undefined) ? 
	        origin : new $3Dmol.Vector3();
	        
	    this.direction = (direction !== undefined) ?
	        direction : new $3Dmol.Vector3();
	      
	};

	//TODO: Remove methods we don't need (intersectPlane ??)
	$3Dmol.Ray.prototype = {
	    
	    constructor : $3Dmol.Ray,
	     
	    set : function(origin, direction){
	        
	        this.origin.copy(origin);
	        this.direction.copy(direction);
	        
	        return this;
	    
	    },
	    
	    copy : function(ray) {
	        
	        this.origin.copy(ray.origin);
	        this.direction.copy(ray.direction);
	        
	        return this;
	        
	    },
	    
	    at : function(t, optionalTarget) {
	        
	        var result = optionalTarget || new $3Dmol.Vector3();
	        
	        return result.copy(this.direction).multiplyScalar(t).add(this.origin);
	        
	    },
	    
	    recast : function() {
	        
	        var v1 = new $3Dmol.Vector3();
	        
	        return function(t) {
	            this.origin.copy(this.at(t, v1));
	            
	            return this;
	        };
	        
	    }(),
	    
	    closestPointToPoint : function(point, optionalTarget) {
	        
	        var result = optionalTarget || new $3Dmol.Vector3();
	        result.subVectors(point, this.origin);
	        var directionDistance = result.dot(this.direction);
	        
	        //returns a point on this ray
	        return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
	        
	    },
	    
	    distanceToPoint : function(point) {
	        
	        var v1 = new $3Dmol.Vector3();
	        
	        return function(point) {
	            var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
	            v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
	            return v1.distanceTo(point);
	        };
	        
	    }(),
	    
	    isIntersectionCylinder : function() {
	        
	    },
	    
	    isIntersectionSphere : function(sphere) {
	       return (this.distanceToPoint(sphere.center) <= sphere.radius);
	          
	    },
	    
	    isIntersectionPlane : function(plane) {
	        
	        var denominator = plane.normal.dot(this.direction);
	        
	        //plane and ray are not perpendicular
	        if (denominator !== 0) 
	            return true;
	        
	        if (plane.distanceToPoint(this.origin) === 0) 
	            return true;
	        
	        return false;
	        
	    },
	    
	    distanceToPlane : function(plane) {
	       
	       var denominator = plane.normal.dot(this.direction);
	       if (denominator === 0) {
	           
	           //line is coplanar
	       if (plane.distanceToPoint(this.origin) === 0)
	           return 0;
	       
	       //ray is parallel
	           return undefined;
	       }
	       
	       var t = - (this.origin.dot(plane.normal) + plane.constant) / denominator;
	       
	       return t;
	       
	    },
	    
	    intersectPlane : function(plane, optionalTarget) {
	       
	       var t = this.distanceToPlane(plane);
	       
	       if (t === undefined)
	           return undefined;
	       
	       return this.at(t, optionalTarget);
	       
	    },
	    
	    applyMatrix4 : function(matrix4) {
	       
	       this.direction.add(this.origin).applyMatrix4(matrix4);
	       this.origin.applyMatrix4(matrix4);
	       this.direction.sub(this.origin);
	       
	       return this;
	       
	    },
	    
	    equals : function(ray) {
	       
	       return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
	       
	    },
	    
	    clone : function() {
	    
	       return new $3Dmol.Ray().copy(this);
	    
	    }
	 
	     
	};

	//Intersection sphere and box shapes.  


	//Intersection sphere for sphere, stick render
	/** @constructor */
	$3Dmol.Sphere = function(center, radius) {

	    this.center = (center !== undefined) ? 
	        center : new $3Dmol.Vector3();
	        
	    this.radius = (radius !== undefined) ?
	        radius : 0;
	        
	};

	$3Dmol.Sphere.prototype = {
	    
	    constructor : $3Dmol.Sphere,
	    
	    set : function(center, radius) {
	        
	        this.center.copy(center);
	        this.radius = radius;
	        
	        return this;
	        
	    },
	    
	    copy : function(sphere) {
	        
	        this.center.copy(sphere.center);
	        this.radius = sphere.radius;
	        
	        return this;
	        
	    },
	    
	    applyMatrix4 : function(matrix) {
	        
	        this.center.applyMatrix4(matrix);
	        this.radius = this.radius * matrix.getMaxScaleOnAxis();
	        
	        return this;
	        
	    },
	    
	    translate : function(offset) {
	        
	        this.center.add(offset);
	        
	        return this;
	        
	    },
	    
	    equals : function(sphere) {
	        
	        return sphere.center.equals(this.center) && (sphere.radius === this.radius);
	        
	    },
	       
	    clone : function() {
	        
	        return new $3Dmol.Sphere().copy(this);
	        
	    }

	};


	//Bounding cylinder for stick render  
	/** @constructor */
	$3Dmol.Cylinder = function(c1, c2, radius) {

	    this.c1 = (c1 !== undefined) ?
	        c1 : new $3Dmol.Vector3();

	    this.c2 = (c2 !== undefined) ?
	        c2 : new $3Dmol.Vector3();
	        
	    this.direction = new $3Dmol.Vector3().subVectors(this.c2, this.c1).normalize();

	    this.radius = (radius !== undefined) ?
	        radius : 0;
	    
	};

	$3Dmol.Cylinder.prototype = {

	    constructor : $3Dmol.Cylinder,

	    copy : function(cylinder) {

	        this.c1.copy(cylinder.c1);
	        this.c2.copy(cylinder.c2);
	        this.direction.copy(cylinder.direction);
	        this.radius = cylinder.radius;

	        return this;

	    },
	    
	    lengthSq : function() {
	    
	        var vector = new $3Dmol.Vector3();
	        
	        return function(){
	            return vector.subVectors(this.c2, this.c1).lengthSq();
	        };
	        
	    }(),

	    applyMatrix4 : function(matrix) {
	        
	        this.direction.add(this.c1).applyMatrix4(matrix);
	        this.c1.applyMatrix4(matrix);
	        this.c2.applyMatrix4(matrix);
	        this.direction.sub(this.c1).normalize();
	        this.radius = this.radius * matrix.getMaxScaleOnAxis();

	        return this;

	    }

	};


	//plane specified by three points
	/** @constructor */
	$3Dmol.Triangle = function(a, b, c){
	   
	    this.a = (a !== undefined) ?
	        a : new $3Dmol.Vector3();

	    this.b = (b !== undefined) ?
	        b : new $3Dmol.Vector3();
	    
	    this.c = (c !== undefined) ?
	        c : new $3Dmol.Vector3();   
	  
	};

	$3Dmol.Triangle.prototype = {

	    constructor : $3Dmol.Triangle,
	    
	    copy : function(triangle) {
	        
	        this.a.copy(triangle.a);
	        this.b.copy(triangle.b);
	        this.c.copy(triangle.c);
	        
	        return this;
	        
	    },
	    
	    applyMatrix4 : function(matrix) {
	        
	        this.a.applyMatrix4(matrix);
	        this.b.applyMatrix4(matrix);
	        this.c.applyMatrix4(matrix);
	        
	        return this;
	        
	    },
	    
	    getNormal : function() {
	        
	        var v1 = new $3Dmol.Vector3();
	        
	        return function() {
	            
	            var norm = this.a.clone();
	            norm.sub(this.b);
	            v1.subVectors(this.c, this.b);
	            
	            norm.cross(v1);
	            norm.normalize();
	            
	            return norm;
	            
	        };
	        
	    }()

	};


	/* core Object3D
	 * Base class for Scene, Camera, Geometry
	 * Geometry class
	 */

	//Event Handling
	/** @this {$3Dmol.EventDispatcher} */
	$3Dmol.EventDispatcher = function() {
	  
	    var listeners = {};
	    
	    this.addEventListener = function(type, listener) {
	        if (listeners[type] === undefined)
	            listeners[type] = [];
	        
	        if (listeners[type].indexOf(listener) === -1)
	            listeners[type].push(listener);
	    };  
	    
	    this.removeEventListener = function(type, listener) {
	        
	        var index = listeners[type].indexOf(listener);
	        
	        if (index !== -1)
	            listeners[type].splice(index, 1);
	              
	    };
	    
	    this.dispatchEvent = function(event) {
	        
	        var listenerArray = listeners[event.type];
	        
	        if (listenerArray !== undefined) {
	            event.target = this;
	            
	            for (var i = 0, l = listenerArray.length; i < l; i++)
	                listenerArray[i].call(this, event);
	                
	        }
	            
	    };
	    
	};

	$3Dmol.Color = function( color ){
	    
	    if ( arguments.length > 1) {
	            this.r = arguments[0] || 0.0;
	            this.g = arguments[1] || 0.0;
	            this.b = arguments[2] || 0.0;

	            return this;
	    }
	    
	    return this.set(color);
	                
	};

	$3Dmol.Color.prototype = {
	    
	    constructor: $3Dmol.Color,
	    
	    r: 0.0, g: 0.0, b: 0.0,
	    
	    set : function(val) {
	        
	            if (val instanceof $3Dmol.Color) 
	                return val.clone();

	            else if (typeof val === 'number')
	                this.setHex(val);
	            
	            else if (typeof val === 'object' && "r" in val && "g" in val && "b" in val) {
	                this.r = val.r;
	                this.g = val.g;
	                this.b = val.b;
	            }
	    },
	    
	    setHex: function(hex) {
	        
	            hex = Math.floor(hex);

	            this.r = (hex >> 16 & 255) / 255;
	            this.g = (hex >> 8 & 255) / 255;
	            this.b = (hex & 255) / 255;                                                                                     
	        
	            return this;
	    },
	    
	    getHex: function() {
	        var R = Math.round(this.r*255);
	        var G = Math.round(this.g*255);
	        var B = Math.round(this.b*255);
	        return R<<16 | G << 8 | B;
	    },
	    
	    clone : function() {
	            return new $3Dmol.Color(this.r, this.g, this.b);
	    },
	        
	    copy : function(color) {
	        this.r = color.r;
	        this.g = color.g;
	        this.b = color.b;
	        
	        return this;
	    },
	    
	    //return object that represents color components from 0 to 255
	    scaled : function() {
	        var ret = {};
	        ret.r = Math.round(this.r*255);
	        ret.g = Math.round(this.g*255);
	        ret.b = Math.round(this.b*255);
	        ret.a = 1.0;
	        return ret;
	    }
	    
	};

	//Object3D base constructor function
	/** @this {$3Dmol.Object3D} */
	$3Dmol.Object3D = function() {
	    
	    this.id = $3Dmol.Object3DIDCount++;
	    
	    this.name = "";
	    
	    this.parent = undefined;
	    this.children = [];
	    
	    this.position = new $3Dmol.Vector3();
	    this.rotation = new $3Dmol.Vector3();
	    this.matrix = new $3Dmol.Matrix4();
	    this.matrixWorld = new $3Dmol.Matrix4();
	    this.quaternion = new $3Dmol.Quaternion();
	    this.eulerOrder = 'XYZ';
	    
	    this.up = new $3Dmol.Vector3(0, 1, 0);
	    this.scale = new $3Dmol.Vector3(1, 1, 1);
	    
	    this.matrixAutoUpdate = true;
	    this.matrixWorldNeedsUpdate = true;
	    this.rotationAutoUpdate = true;
	    this.useQuaternion = false;
	    
	    this.visible = true;
	    
	};

	$3Dmol.Object3D.prototype = {
	    
	    constructor : $3Dmol.Object3D,
	    
	    lookAt : function(vector) {
	        
	        this.matrix.lookAt(vector, this.position, this.up);
	        
	        if (this.rotationAutoUpdate) {
	            
	            if (this.useQuaternion === true) 
	                this.quaternion.copy(this.matrix.decompose()[1]);
	            else
	                this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder);
	        }
	    },
	    
	    //add child object
	    add : function(object) {
	        if (object === this){
	            console.error("Can't add $3Dmol.Object3D to itself");
	            return;
	        }
	        
	        object.parent = this;
	        this.children.push(object);
	        
	        //add to the scene (i.e. follow up this instance's parents until reach the top)
	        
	        var scene = this;
	        
	        while (scene.parent !== undefined)
	            scene = scene.parent;
	            
	        if (scene !== undefined && scene instanceof $3Dmol.Scene) 
	            scene.__addObject(object);
	        
	    },
	    
	    remove : function(object) {
	        
	        var index = this.children.indexOf(object);
	        
	        if (index !== -1) {
	            
	            object.parent = undefined;
	            this.children.splice(index, 1);
	            
	            //Remove from scene
	            
	            var scene = this;
	            
	            while (scene.parent !== undefined)
	                scene = scene.parent;
	                
	            if (scene !== undefined && scene instanceof $3Dmol.Scene)
	                scene.__removeObject(object);
	                
	        }
	    },
	    
	    updateMatrix : function() {
	        
	        this.matrix.setPosition(this.position);
	        
	        if (this.useQuaternion === false) 
	            this.matrix.setRotationFromEuler(this.rotation, this.eulerOrder);
	        else
	            this.matrix.setRotationFromQuaternion(this.quaternion);
	        
	        //TODO: Do I need this??
	        if (this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1)
	            this.matrix.scale(this.scale);
	            
	        this.matrixWorldNeedsUpdate = true;
	        
	    },
	    
	    updateMatrixWorld : function(force) {
	        
	        if (this.matrixAutoUpdate === true) 
	            this.updateMatrix();
	        
	        if (this.matrixWorldNeedsUpdate === true || force === true) {
	            
	            if (this.parent === undefined)
	                this.matrixWorld.copy(this.matrix);
	            else
	                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
	                
	        }
	        
	        this.matrixWorldNeedsUpdate = false;
	        
	        //Update matrices of all children
	        for (var i = 0; i < this.children.length; i++) {
	            this.children[i].updateMatrixWorld(true);
	        }
	    },
	    
	    clone : function(object) {
	        
	        if (object === undefined)
	            object = new $3Dmol.Object3D();
	            
	        object.name = this.name;
	        
	        object.up.copy(this.up);
	        object.position.copy(this.position);
	        object.rotation.copy(this.rotation);
	        object.eulerOrder = this.eulerOrder;
	        object.scale.copy(this.scale);

	        object.rotationAutoUpdate = this.rotationAutoUpdate;
	        object.matrix.copy(this.matrix);
	        object.matrixWorld.copy(this.matrixWorld);
	        object.quaternion.copy(this.quaternion);
	        object.matrixAutoUpdate = this.matrixAutoUpdate;
	        object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
	        
	        object.useQuaternion = this.useQuaternion;
	        
	        object.visible = this.visible;
	        
	        for (var i = 0; i < this.children.length; i++) {
	            var child = this.children[i];
	            object.add(child.clone());
	        }
	        
	        return object;
	        
	    },
	    
	    setVisible: function(val) { //recursively set visibility
	        this.visible = val;
	        for (var i = 0; i < this.children.length; i++) {
	            var child = this.children[i];
	            child.setVisible(val);
	        }
	    }
	};

	$3Dmol.Object3DIDCount = 0;

	//Geometry class
	//TODO: What can I remove - how can I optimize ?
	$3Dmol.Geometry = (function() {
	   
	    var BUFFERSIZE = 65535; //limited to 16bit indices
	    
	    
	    /** @constructor */
	    var geometryGroup = function(id) {
	        this.id = id || 0;
	        //for performance reasons, callers must directly modify these
	        this.vertexArray = null;
	        this.colorArray = null;
	        this.normalArray = null;
	        this.faceArray = null;
	        this.radiusArray = null;
	        //this.adjFaceArray=null;
	        this.lineArray = null;
	        this.vertices = 0;
	        this.faceidx = 0;
	        this.lineidx = 0;
	        
	    };
	    
	    geometryGroup.prototype.getNumVertices = function() {
	        return this.vertices;
	    };
	    
	    geometryGroup.prototype.getVertices = function() {
	        return this.vertexArray;
	    };
	    
	    
	    geometryGroup.prototype.getCentroid = function() {
	        
	        var centroid = new $3Dmol.Vector3();
	        var offset, x, y, z;
	        
	        for (var i = 0; i < this.vertices; ++i) {
	            offset = i*3;
	            
	            x = this.vertexArray[offset]; y = this.vertexArray[offset+1]; z = this.vertexArray[offset+2];
	            
	            centroid.x += x; centroid.y += y; centroid.z += z;
	        }
	        
	        //divideScalar checks for 0 denom
	        centroid.divideScalar(this.vertices);
	        
	        return centroid;
	    };
	    
	    //setup normals - vertex and face array must exist
	    geometryGroup.prototype.setNormals = function() {        
	        
	        var faces = this.faceArray;
	        var verts = this.vertexArray;
	        var norms = this.normalArray;
	        
	        if (! this.vertices || ! this.faceidx) 
	            return;
	        
	        //vertex indices
	        var a, b, c, d,
	        //and actual vertices
	        vA, vB, vC, norm;
	            
	        for (var i = 0; i < faces.length / 3; ++i) {
	            
	            a = faces[i * 3] * 3;
	            b = faces[i * 3 + 1] * 3;
	            c = faces[i * 3 + 2] * 3;
	            
	            vA = new $3Dmol.Vector3(verts[a], verts[a+1], verts[a+2]);
	            vB = new $3Dmol.Vector3(verts[b], verts[b+1], verts[b+2]);
	            vC = new $3Dmol.Vector3(verts[c], verts[c+1], verts[c+2]);
	            
	            vA.subVectors(vA, vB);
	            vC.subVectors(vC, vB);
	            vC.cross(vA);
	            
	            //face normal
	            norm = vC;
	            norm.normalize();
	            
	            norms[a] += norm.x; norms[b] += norm.x; norms[c] += norm.x;
	            norms[a + 1] += norm.y; norms[b + 1] += norm.y; norms[c + 1] += norm.y;
	            norms[a + 2] += norm.z; norms[b + 2] += norm.z; norms[c + 2] += norm.z;
	            
	        }             
	                
	    };
	    
	    //sets line index array from face arr
	    //Note - assumes all faces are triangles (i.e. there will
	    //be an extra diagonal for four-sided faces - user should 
	    //specify linearr for custom shape generation to show wireframe squares
	    //as rectangles rather than two triangles)
	    geometryGroup.prototype.setLineIndices = function() {
	        
	        if (! this.faceidx)
	            return;
	                    
	        var faceArr = this.faceArray, lineArr = this.lineArray = new Uint16Array(this.faceidx*2);      
	        this.lineidx = this.faceidx*2;         
	        var faceoffset;
	            
	        for (var i = 0; i < this.faceidx / 3; ++i) {
	            
	            faceoffset = i*3; lineoffset = faceoffset*2;          
	            var a = faceArr[faceoffset], b = faceArr[faceoffset+1], c = faceArr[faceoffset+2];
	            
	            lineArr[lineoffset] = a; lineArr[lineoffset+1] = b;
	            lineArr[lineoffset+2] = a; lineArr[lineoffset+3] = c;
	            lineArr[lineoffset+4] = b; lineArr[lineoffset+5] = c;
	            
	        }
	    };
	    
	    geometryGroup.prototype.truncateArrayBuffers = function(mesh, reallocatemem) {
	        
	        mesh = (mesh === true) ? true : false;
	        
	        var vertexArr = this.vertexArray,
	            colorArr = this.colorArray,
	            normalArr = this.normalArray,
	            faceArr = this.faceArray,
	            lineArr = this.lineArray,
	            radiusArr = this.radiusArray;

	        //subarray to avoid copying and reallocating memory
	        this.vertexArray = vertexArr.subarray(0,this.vertices*3);
	        this.colorArray = colorArr.subarray(0,this.vertices*3);
	        
	        if (mesh) {
	            this.normalArray = normalArr.subarray(0,this.vertices*3);
	            this.faceArray = faceArr.subarray(0,this.faceidx); 
	            
	            if(this.lineidx > 0) //not always set so reclaim memory
	                this.lineArray = lineArr.subarray(0,this.lineidx); 
	            else
	                this.lineArray = new Uint16Array();
	                        
	        }        
	        else {
	            this.normalArray = new Float32Array(); 
	            this.faceArray = new Uint16Array(); 
	            this.lineArray = new Uint16Array(); 
	        }
	        if (radiusArr) {
	            this.radiusArray = radiusArr.subarray(0, this.vertices);
	        }
	        
	        if(reallocatemem) { 
	            //actually copy smaller arrays to save memory
	            if(this.normalArray) this.normalArray = new Float32Array(this.normalArray);
	            if(this.faceArray) this.faceArray = new Uint16Array(this.faceArray);
	            if(this.lineArray) this.lineArray = new Uint16Array(this.lineArray);
	            if(this.vertexArray) this.vertexArray = new Float32Array(this.vertexArray);
	            if(this.colorArray) this.colorArray = new Float32Array(this.colorArray);
	            if(this.radiusArray) this.radiusArray = new Float32Array(this.radiusArray);
	        }
	        this.__inittedArrays = true;        
	        
	    };
	    
	    var addGroup = function(geo) {
	        var ret = new geometryGroup(geo.geometryGroups.length);
	        geo.geometryGroups.push(ret);
	        geo.groups = geo.geometryGroups.length;
	        
	        ret.vertexArray = new Float32Array(BUFFERSIZE*3);
	        ret.colorArray = new Float32Array(BUFFERSIZE*3);
	        
	        //TODO: instantiating uint arrays according to max number of vertices
	        // is dangerous, since there exists the possibility that there will be 
	        // more face or line indices than vertex points - but so far that doesn't
	        // seem to be the case for any of the renders 
	        if (geo.mesh) {
	            ret.normalArray = new Float32Array(BUFFERSIZE*3);
	            ret.faceArray = new Uint16Array(BUFFERSIZE*6);
	            ret.lineArray = new Uint16Array(BUFFERSIZE*6);
	        }
	        if (geo.radii) {
	            ret.radiusArray = new Float32Array(BUFFERSIZE);
	        }
	        ret.useOffset = geo.offset;
	        
	        
	        return ret;
	    };
	    /** @constructor */
	    var Geometry = function(mesh, radii,offset) {
	        
	        $3Dmol.EventDispatcher.call(this);
	        
	        this.id = $3Dmol.GeometryIDCount++;
	    
	        this.name = '';
	    
	        this.hasTangents = false;
	    
	        this.dynamic = true; // the intermediate typed arrays will be deleted when set to false
	        this.mesh = (mesh === true) ? true : false; // Does this geometry represent a mesh (i.e. do we need Face/Line index buffers?)
	        this.radii = radii || false;
	        this.offset = offset || false; //offset buffer used for instancing
	        // update flags
	    
	        this.verticesNeedUpdate = false;
	        this.elementsNeedUpdate = false;
	        this.normalsNeedUpdate = false;
	        this.colorsNeedUpdate = false;
	    
	        this.buffersNeedUpdate = false;
	        
	        this.geometryGroups = [];
	        this.groups = 0;
	        
	    };
	    
	    Geometry.prototype = {
	        
	        constructor : Geometry,

	        //Get geometry group to accomodate addVertices new vertices - create 
	        // new group if necessary       
	        updateGeoGroup : function(addVertices) {
	        
	            addVertices = addVertices || 0;
	            
	            var retGroup = this.groups > 0 ? this.geometryGroups[ this.groups - 1 ] : null;
	            
	            if (!retGroup || retGroup.vertices + addVertices > retGroup.vertexArray.length/3) 
	                retGroup = addGroup(this);
	                
	            return retGroup;
	            
	        },
	        
	        addGeoGroup : function() {
	            return addGroup(this);  
	        },
	        
	        setUpNormals : function(three) {
	            
	            three = three || false;
	            
	            for (var g = 0; g < this.groups; g++) {
	            
	                var geoGroup = this.geometryGroups[g];            
	                
	                geoGroup.setNormals(three);
	                
	            }  
	                      
	        },
	        
	        setUpWireframe : function() {
	            for (var g = 0; g < this.groups; g++) {
	                var geoGroup = this.geometryGroups[g];
	                
	                geoGroup.setLineIndices();
	            }
	        },
	        
	        //After vertices, colors, etc are collected in regular or typed arrays,
	        //  create typed arrays from regular arrays if they don't already exist,
	        initTypedArrays : function() {
	                
	            for (var g = 0; g < this.groups; g++) {
	                
	                var group = this.geometryGroups[g];
	                
	                if (group.__inittedArrays === true)
	                    continue;
	                
	                //do not actually reallocate smaller memory here because
	                //of the performance hit - if you know your geometry is small,
	                //truncate manually with the second parameter true
	                group.truncateArrayBuffers(this.mesh, false);
	            }
	            
	        
	        },
	        
	        dispose : function() {
	            this.dispatchEvent( {type : 'dispose'} );
	        }
	    };

	    
	    return Geometry;
	    
	})();

	Object.defineProperty($3Dmol.Geometry.prototype, "vertices", {
	    
	    /** @this {$3Dmol.Geometry} */
	    get : function() {
	        var vertices = 0;
	        for (var g = 0; g < this.groups; g++)
	            vertices += this.geometryGroups[g].vertices;
	            
	        return vertices;
	    } 
	        
	});

	$3Dmol.GeometryIDCount = 0;


	//Raycaster
	/** @constructor */
	$3Dmol.Raycaster = (function() {
	    
	    var Raycaster = function(origin, direction, far, near) {
	        
	        this.ray = new $3Dmol.Ray(origin, direction);
	        
	        if (this.ray.direction.lengthSq() > 0) 
	            this.ray.direction.normalize();
	        
	        this.near = near || 0;
	        this.far = far || Infinity;
	    
	    };
	    
	    var sphere = new $3Dmol.Sphere();
	    var cylinder = new $3Dmol.Cylinder();
	    var triangle = new $3Dmol.Triangle();
	    var w_0 = new $3Dmol.Vector3(); // for cylinders, cylinder.c1 - ray.origin
	    var v1 = new $3Dmol.Vector3(); // all purpose local vector
	    var v2 = new $3Dmol.Vector3();
	    var v3 = new $3Dmol.Vector3();
	    //var facePlane = new $3Dmol.Plane();
	    var localRay = new $3Dmol.Ray();
	    var intersectPoint = new $3Dmol.Vector3();
	    var matrixPosition = new $3Dmol.Vector3();
	    
	    var inverseMatrix = new $3Dmol.Matrix4();
	        
	    var descSort = function(a, b) {
	        return a.distance - b.distance;
	    };

	    // [-1, 1]
	    var clamp = function(x) {
	        return Math.min(Math.max(x, -1), 1);
	    };
	    
	    //object is a Sphere or (Bounding) Box
	    var intersectObject = function(group, clickable, raycaster, intersects) {
	        
	        matrixPosition.getPositionFromMatrix(group.matrixWorld);
	        
	        if ((clickable.clickable !== true) || (clickable.intersectionShape === undefined))
	            return intersects;       
	        var intersectionShape = clickable.intersectionShape;
	        var precision = raycaster.linePrecision;
	        precision *= group.matrixWorld.getMaxScaleOnAxis();
	        var precisionSq = precision*precision;

	        //Check for intersection with clickable's bounding sphere, if it exists
	        if (clickable.boundingSphere !== undefined && clickable.boundingSphere instanceof $3Dmol.Sphere) {
	            sphere.copy(clickable.boundingSphere);
	            sphere.applyMatrix4(group.matrixWorld);          
	            if (!raycaster.ray.isIntersectionSphere(sphere)) {             
					return intersects;
	            }
	        }      
	        //Iterate through intersection objects
	        var i, il,
	            norm, normProj, cylProj, rayProj,
	            distance, closestDistSq, denom, discriminant,
	            s, t, s_c, t_c;
	        //triangle faces
	        for (i = 0, il = intersectionShape.triangle.length; i < il; i++) {
	            
	            if (intersectionShape.triangle[i] instanceof $3Dmol.Triangle) {
	                
	                triangle.copy(intersectionShape.triangle[i]);
	                triangle.applyMatrix4(group.matrixWorld);
	                
	                norm = triangle.getNormal();
	                
	                normProj = raycaster.ray.direction.dot(norm);
	                
	                //face culling
	                if (normProj >= 0)
	                    continue;
	                
	                w_0.subVectors(triangle.a, raycaster.ray.origin);
	                
	                distance = (norm.dot(w_0)) / normProj;
	                
	                if (distance < 0)
	                    continue;
	                    
	                //intersects with plane, check if P inside triangle
	                v1.copy(raycaster.ray.direction).multiplyScalar(distance).add(raycaster.ray.origin);
	                v1.sub(triangle.a); // from pt a to intersection point P
	                
	                v2.copy(triangle.b).sub(triangle.a); // from pt a to b
	                v3.copy(triangle.c).sub(triangle.a); // from pt a to c
	                var b_dot_c = v2.dot(v3);
	                var b_sq = v2.lengthSq();
	                var c_sq = v3.lengthSq();
	                
	                // P = A + s(v2) + t(v3), inside trianle if 0 <= s, t <=1  and (s + t) <=0
	                
	                t = ( b_sq*v1.dot(v3) - b_dot_c*v1.dot(v2) ) / ( b_sq*c_sq - b_dot_c*b_dot_c );
	                
	                if (t < 0 || t > 1)
	                    continue;
	                
	                s = ( v1.dot(v2) - t*b_dot_c ) / b_sq;
	                
	                if ( (s < 0 || s > 1) || s + t > 1)
	                    continue;
	                    
	                else{
	                    intersects.push({clickable : clickable,
	                                     distance : distance});
					}  
	            }
	        }    
	        //cylinders
	        for (i = 0, il = intersectionShape.cylinder.length; i < il; i++) {
	            
	            if (intersectionShape.cylinder[i] instanceof $3Dmol.Cylinder){
	                
	                cylinder.copy(intersectionShape.cylinder[i]);
	                cylinder.applyMatrix4(group.matrixWorld);
	                
	                w_0.subVectors(cylinder.c1, raycaster.ray.origin); 
	                
	                cylProj = w_0.dot(cylinder.direction); // Dela
	                rayProj = w_0.dot(raycaster.ray.direction); // Epsilon
	                
	                normProj = clamp(raycaster.ray.direction.dot(cylinder.direction)); // Beta
	                
	                denom = 1 - normProj*normProj;
	                
	                if (denom === 0.0)
	                    continue;
	                
	                s_c = (normProj*rayProj - cylProj) / denom;
	                t_c = (rayProj - normProj*cylProj) / denom;
	                
	                v1.copy(cylinder.direction).multiplyScalar(s_c).add(cylinder.c1);  // Q_c
	                v2.copy(raycaster.ray.direction).multiplyScalar(t_c).add(raycaster.ray.origin); // P_c
	                
	                closestDistSq = v3.subVectors(v1, v2).lengthSq();
	                var radiusSq = cylinder.radius*cylinder.radius;
	                
	                //Smoothing?
	                //if (closestDistSq > radiusSq) radiusSq += precisionSq;
	                
	                // closest distance between ray and cylinder axis not greater than cylinder radius;
	                // might intersect this cylinder between atom and bond midpoint
	                if (closestDistSq <= radiusSq){

	                    //Find points where ray intersects sides of cylinder
	                    discriminant = (normProj*cylProj - rayProj)*(normProj*cylProj - rayProj) - 
	                            denom*(w_0.lengthSq() - cylProj*cylProj - radiusSq);
	                    
	                    // ray tangent to cylinder?
	                    if (discriminant <= 0)
	                        t = distance = Math.sqrt(closestDistSq);
	                    else
	                        t = distance = ( (rayProj - normProj*cylProj) - Math.sqrt(discriminant) ) / denom; 
	                    
	                    //find closest intersection point; make sure it's between atom's position and cylinder midpoint
	                    
	                    s = normProj*t - cylProj;
	                    
	                    //does not intersect cylinder between atom and midpoint,
	                    // or intersects cylinder behind camera
	                    if (s < 0 || s*s > cylinder.lengthSq() || t < 0)
	                        continue;
	                    
	                    else
	                        intersects.push({clickable : clickable,
	                                         distance : distance});
	                    
	                }
	                    
	                
	            }
	            
	        }       
	        //lines
	        for (i = 0, il = intersectionShape.line.length; i < il; i += 2) {
	            
	            v1.copy(intersectionShape.line[i]);
	            v1.applyMatrix4(group.matrixWorld);
	            v2.copy(intersectionShape.line[i+1]);
	            v2.applyMatrix4(group.matrixWorld);
	            
	            v3.subVectors(v2, v1);
	            var bondLengthSq = v3.lengthSq();
	            v3.normalize();
	            
	            w_0.subVectors(v1, raycaster.ray.origin);
	            
	            lineProj = w_0.dot(v3);
	            rayProj = w_0.dot(raycaster.ray.direction);
	            
	            normProj = clamp(raycaster.ray.direction.dot(v3));
	            
	            denom = 1 - normProj*normProj;
	            
	            if (denom === 0.0)
	                continue;
	            
	            s_c = (normProj*rayProj - lineProj) / denom;
	            t_c = (rayProj - normProj*lineProj) / denom;
	            
	            v1.add(v3.multiplyScalar(s_c)); // Q_c
	            v2.copy(raycaster.ray.direction).multiplyScalar(t_c).add(raycaster.ray.origin); // P_c
	            
	            closestDistSq = v3.subVectors(v2, v1).lengthSq();
	            
	            if (closestDistSq < precisionSq && s_c*s_c < bondLengthSq)
	                intersects.push({clickable : clickable,
	                                 distance : t_c
	                                });
	            
	        }
	        for (i = 0, il = intersectionShape.sphere.length; i < il; i++) {
	            //sphere
	            if (intersectionShape.sphere[i] instanceof $3Dmol.Sphere) {
	                
	                sphere.copy(intersectionShape.sphere[i]);
	                sphere.applyMatrix4(group.matrixWorld);
	                
	                if (raycaster.ray.isIntersectionSphere(sphere)) {
	                    
	                    v1.subVectors(sphere.center, raycaster.ray.origin);
	                    
	                    //distance from ray origin to point on the ray normal to sphere's center
	                    //must be less than sphere's radius (since ray intersects sphere)
	                    var distanceToCenter = v1.dot(raycaster.ray.direction);
	                    
	                    discriminant = distanceToCenter*distanceToCenter - (v1.lengthSq() - sphere.radius*sphere.radius);
	                    
	                    //Don't select if sphere center behind camera
	                    if (distanceToCenter < 0) 
	                        return intersects;
	                    
	                    //ray tangent to sphere?
	                    if (discriminant <= 0)
	                        distance = distanceToCenter;
	                    
	                    //This is reversed if sphere is closer than ray origin.  Do we have 
	                    //to worry about handling that case?
	                    else 
	                        distance = distanceToCenter - Math.sqrt(discriminant);
	    
	                    intersects.push({clickable : clickable, 
	                                     distance : distance});
	                    return intersects;
	                }
	            }        
	       }
	        
	    };   
	       
	    Raycaster.prototype.precision = 0.0001;
	    Raycaster.prototype.linePrecision = 0.2;
	    
	    Raycaster.prototype.set = function(origin, direction) {
	        
	        this.ray.set(origin, direction);
	          
	    };
	    
	    Raycaster.prototype.intersectObjects = function(group, objects) {     
	        var intersects = [];
	        
	        for (var i = 0, l = objects.length; i < l; i++)            
	            intersectObject(group, objects[i], this, intersects);
	            
	        intersects.sort(descSort);
	        
	        return intersects;
	        
	    };
	    
	    return Raycaster;
	    
	})();


	//$3Dmol Projecion 
	//TODO: can probably strip this down a lot (only used for selection handling)
	/** @constructor */
	$3Dmol.Projector = function () {

	    var _viewMatrix = new $3Dmol.Matrix4(),
	    _viewProjectionMatrix = new $3Dmol.Matrix4();

	    this.projectVector = function ( vector, camera ) {

	        camera.matrixWorldInverse.getInverse( camera.matrixWorld );

	        _viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );

	        return vector.applyProjection( _viewProjectionMatrix );

	    };

	    this.unprojectVector = function ( vector, camera ) {

	        camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);

	        _viewProjectionMatrix.multiplyMatrices(camera.matrixWorld, camera.projectionMatrixInverse);

	        return vector.applyProjection( _viewProjectionMatrix );

	    };

	};
	/*
	 * Simplified Perspective Camera
	 */

	/** @constructor */
	$3Dmol.Camera = function(fov, aspect, near, far, ortho) {
	    
	    $3Dmol.Object3D.call(this);
	    
	    this.fov = fov !== undefined ? fov : 50;
	    this.aspect = aspect !== undefined ? aspect : 1;
	    this.near = near !== undefined ? near : 0.1;
	    this.far = far !== undefined ? far : 2000;

	    this.projectionMatrix = new $3Dmol.Matrix4();
	    this.projectionMatrixInverse = new $3Dmol.Matrix4();
	    this.matrixWorldInverse = new $3Dmol.Matrix4();
	    
	    var center = this.position.z;
	    this.right = center * Math.tan(Math.PI / 180 * fov);
	    this.left = -this.right;
	    this.top = this.right / this.aspect;
	    this.bottom = -this.top;
	    
	    this.ortho = !!ortho;
	    
	    this.updateProjectionMatrix();
	        
	};

	//Inherit Object3D's prototyped methods
	$3Dmol.Camera.prototype = Object.create($3Dmol.Object3D.prototype);

	$3Dmol.Camera.prototype.lookAt = function(vector){
	    
	    //Why is the parameter order switched (compared to Object3D)?
	    this.matrix.lookAt(this.position, vector, this.up);
	    
	    if (this.rotationAutoUpdate) {    
	        
	        if (this.useQuaternion === false) 
	            this.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );
	        else
	            this.quaternion.copy( this.matrix.decompose()[ 1 ] );    
	            
	    }
	    
	};

	$3Dmol.Camera.prototype.updateProjectionMatrix = function () {

	    if(this.ortho) {
	        this.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );
	    } else {
	        this.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );
	    }
	    
	    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
	};


	//Render plugins go here

	/**
	 * Sprite render plugin
	 * @this {$3Dmol.SpritePlugin}
	 */

	$3Dmol.SpritePlugin = function () {

	    var _gl, _renderer, _precision, _sprite = {};

	    this.init = function ( renderer ) {

	        _gl = renderer.context;
	        _renderer = renderer;

	        _precision = renderer.getPrecision();

	        _sprite.vertices = new Float32Array( 8 + 8 );
	        _sprite.faces    = new Uint16Array( 6 );

	        var i = 0;

	        _sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = -1; // vertex 0
	        _sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 0;  // uv 0

	        _sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = -1; // vertex 1
	        _sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 0;  // uv 1

	        _sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;  // vertex 2
	        _sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;  // uv 2

	        _sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = 1;  // vertex 3
	        _sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 1;  // uv 3

	        i = 0;

	        _sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 1; _sprite.faces[ i++ ] = 2;
	        _sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 2; _sprite.faces[ i++ ] = 3;

	        _sprite.vertexBuffer  = _gl.createBuffer();
	        _sprite.elementBuffer = _gl.createBuffer();

	        _gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );
	        _gl.bufferData( _gl.ARRAY_BUFFER, _sprite.vertices, _gl.STATIC_DRAW );

	        _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );
	        _gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _sprite.faces, _gl.STATIC_DRAW );

	        _sprite.program = createProgram( $3Dmol.ShaderLib.sprite, _precision );

	        _sprite.attributes = {};
	        _sprite.uniforms = {};

	        _sprite.attributes.position           = _gl.getAttribLocation ( _sprite.program, "position" );
	        _sprite.attributes.uv                 = _gl.getAttribLocation ( _sprite.program, "uv" );

	        _sprite.uniforms.uvOffset             = _gl.getUniformLocation( _sprite.program, "uvOffset" );
	        _sprite.uniforms.uvScale              = _gl.getUniformLocation( _sprite.program, "uvScale" );

	        _sprite.uniforms.rotation             = _gl.getUniformLocation( _sprite.program, "rotation" );
	        _sprite.uniforms.scale                = _gl.getUniformLocation( _sprite.program, "scale" );
	        _sprite.uniforms.alignment            = _gl.getUniformLocation( _sprite.program, "alignment" );

	        _sprite.uniforms.color                = _gl.getUniformLocation( _sprite.program, "color" );
	        _sprite.uniforms.map                  = _gl.getUniformLocation( _sprite.program, "map" );
	        _sprite.uniforms.opacity              = _gl.getUniformLocation( _sprite.program, "opacity" );

	        _sprite.uniforms.useScreenCoordinates = _gl.getUniformLocation( _sprite.program, "useScreenCoordinates" );
	        _sprite.uniforms.screenPosition       = _gl.getUniformLocation( _sprite.program, "screenPosition" );
	        _sprite.uniforms.modelViewMatrix      = _gl.getUniformLocation( _sprite.program, "modelViewMatrix" );
	        _sprite.uniforms.projectionMatrix     = _gl.getUniformLocation( _sprite.program, "projectionMatrix" );

	        _sprite.uniforms.fogType              = _gl.getUniformLocation( _sprite.program, "fogType" );
	        _sprite.uniforms.fogDensity           = _gl.getUniformLocation( _sprite.program, "fogDensity" );
	        _sprite.uniforms.fogNear              = _gl.getUniformLocation( _sprite.program, "fogNear" );
	        _sprite.uniforms.fogFar               = _gl.getUniformLocation( _sprite.program, "fogFar" );
	        _sprite.uniforms.fogColor             = _gl.getUniformLocation( _sprite.program, "fogColor" );

	        _sprite.uniforms.alphaTest            = _gl.getUniformLocation( _sprite.program, "alphaTest" );

	    };

	    this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

	        var sprites = scene.__webglSprites,
	            nSprites = sprites.length;

	        if ( ! nSprites ) return;

	        var attributes = _sprite.attributes,
	            uniforms = _sprite.uniforms;

	        var invAspect = viewportHeight / viewportWidth;

	        var halfViewportWidth = viewportWidth * 0.5,
	            halfViewportHeight = viewportHeight * 0.5;

	        // setup gl

	        _gl.useProgram( _sprite.program );

	        _gl.enableVertexAttribArray( attributes.position );
	        _gl.enableVertexAttribArray( attributes.uv );

	        _gl.disable( _gl.CULL_FACE );
	        _gl.enable( _gl.BLEND );

	        _gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );
	        _gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );
	        _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

	        _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );

	        _gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

	        _gl.activeTexture( _gl.TEXTURE0 );
	        _gl.uniform1i( uniforms.map, 0 );

	        var oldFogType = 0;
	        var sceneFogType = 0;
	        var fog = scene.fog;

	        if ( fog ) {

	            _gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

	            _gl.uniform1f( uniforms.fogNear, fog.near );
	            _gl.uniform1f( uniforms.fogFar, fog.far );

	            _gl.uniform1i( uniforms.fogType, 1 );
	            oldFogType = 1;
	            sceneFogType = 1;


	        } 
	        
	        else {

	            _gl.uniform1i( uniforms.fogType, 0 );
	            oldFogType = 0;
	            sceneFogType = 0;

	        }


	        // update positions and sort

	        var i, sprite, material, screenPosition, size, fogType, scale = [];

	        for( i = 0; i < nSprites; i ++ ) {

	            sprite = sprites[ i ];
	            material = sprite.material;

	            if ( ! sprite.visible || material.opacity === 0 ) continue;

	            if ( ! material.useScreenCoordinates ) {

	                sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
	                sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

	            } else {

	                sprite.z = - sprite.position.z;

	            }

	        }

	        sprites.sort( painterSortStable );

	        // render all sprites

	        for( i = 0; i < nSprites; i ++ ) {

	            sprite = sprites[ i ];
	            material = sprite.material;

	            if ( ! sprite.visible || material.opacity === 0 ) continue;

	            if ( material.map && material.map.image && material.map.image.width ) {

	                _gl.uniform1f( uniforms.alphaTest, material.alphaTest );
	                var w = material.map.image.width;
	                var h = material.map.image.height;
	                
	                scale[ 0 ] = w*_renderer.devicePixelRatio/viewportWidth;
	                scale[ 1 ] = h*_renderer.devicePixelRatio/viewportHeight;
	                
	                if ( material.useScreenCoordinates === true ) {

	                    _gl.uniform1i( uniforms.useScreenCoordinates, 1 );
	                    _gl.uniform3f(
	                        uniforms.screenPosition,
	                        ( ( sprite.position.x * _renderer.devicePixelRatio ) - halfViewportWidth  ) / halfViewportWidth,
	                        ( halfViewportHeight - ( sprite.position.y * _renderer.devicePixelRatio ) ) / halfViewportHeight,
	                        Math.max( 0, Math.min( 1, sprite.position.z ) )
	                    );

	                } else {

	                    _gl.uniform1i( uniforms.useScreenCoordinates, 0 );
	                    _gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );
	                }

	                if ( scene.fog && material.fog ) {

	                    fogType = sceneFogType;

	                } else {

	                    fogType = 0;

	                }

	                if ( oldFogType !== fogType ) {

	                    _gl.uniform1i( uniforms.fogType, fogType );
	                    oldFogType = fogType;

	                }

	                size = 1 / ( material.scaleByViewport ? viewportHeight : 1 );

	                scale[ 0 ] *= size * sprite.scale.x;
	                scale[ 1 ] *= size * sprite.scale.y;

	                _gl.uniform2f( uniforms.uvScale, material.uvScale.x, material.uvScale.y );
	                _gl.uniform2f( uniforms.uvOffset, material.uvOffset.x, material.uvOffset.y );
	                _gl.uniform2f( uniforms.alignment, material.alignment.x, material.alignment.y );

	                _gl.uniform1f( uniforms.opacity, material.opacity );
	                _gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

	                _gl.uniform1f( uniforms.rotation, sprite.rotation );
	                _gl.uniform2fv( uniforms.scale, scale );

	                //_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
	                _renderer.setDepthTest( material.depthTest );
	                _renderer.setDepthWrite( material.depthWrite );
	                _renderer.setTexture( material.map, 0 );

	                _gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

	            }

	        }

	        // restore gl

	        _gl.enable( _gl.CULL_FACE );

	    };

	    function createProgram ( shader, precision ) {

	        var program = _gl.createProgram();

	        var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );
	        var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );

	        var prefix = "precision " + precision + " float;\n";

	        _gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
	        _gl.shaderSource( vertexShader, prefix + shader.vertexShader );

	        _gl.compileShader( fragmentShader );
	        _gl.compileShader( vertexShader );
	        
	        if ( ! _gl.getShaderParameter(fragmentShader, _gl.COMPILE_STATUS) || ! _gl.getShaderParameter(vertexShader,_gl.COMPILE_STATUS) ) {

	                console.error(_gl.getShaderInfoLog(fragmentShader));
	                console.error("could not initialize shader");
	                return null;
	        }

	        _gl.attachShader( program, fragmentShader );
	        _gl.attachShader( program, vertexShader );

	        _gl.linkProgram( program );

	        if (! _gl.getProgramParameter(program, _gl.LINK_STATUS) )
	                console.error("Could not initialize shader");

	        return program;

	    }

	    function painterSortStable ( a, b ) {

	        if ( a.z !== b.z ) {

	            return b.z - a.z;

	        } else {

	            return b.id - a.id;

	        }

	    }

	};

	$3Dmol.Light = function(hex, intensity) {
	    
	    $3Dmol.Object3D.call(this);
	    
	    this.color = new $3Dmol.Color(hex);
	    this.position = new $3Dmol.Vector3( 0, 1, 0 );
	    this.target = new $3Dmol.Object3D();

	    this.intensity = ( intensity !== undefined ) ? intensity : 1;

	    this.castShadow = false;
	    this.onlyShadow = false;
	    
	};

	$3Dmol.Light.prototype = Object.create($3Dmol.Object3D.prototype);
	/**
	 * Line and Mesh material types
	 * @constructor
	 */
	$3Dmol.Material = function () {

	    $3Dmol.EventDispatcher.call( this );

	    this.id = $3Dmol.MaterialIdCount ++;

	    this.name = '';
	    
	    //TODO: Which of these instance variables can I remove??
	    this.side = $3Dmol.FrontSide;

	    this.opacity = 1;
	    this.transparent = false;

	    this.depthTest = true;
	    this.depthWrite = true;
	    
	    this.stencilTest = true;

	    this.polygonOffset = false;
	    this.polygonOffsetFactor = 0;
	    this.polygonOffsetUnits = 0;

	    this.alphaTest = 0;

	    this.visible = true;

	    this.needsUpdate = true;

	};


	$3Dmol.Material.prototype.setValues = function ( values ) {

	    if ( values === undefined ) return;

	    for ( var key in values ) {

	        var newValue = values[ key ];

	        if ( newValue === undefined ) {

	            console.warn( '$3Dmol.Material: \'' + key + '\' parameter is undefined.' );
	            continue;

	        }

	        if ( key in this ) {

	            var currentValue = this[ key ];

	            if ( currentValue instanceof $3Dmol.Color && newValue instanceof $3Dmol.Color ) {

	                currentValue.copy( newValue );

	            } else if ( currentValue instanceof $3Dmol.Color ) {

	                currentValue.set( newValue );

	            } else if ( currentValue instanceof $3Dmol.Vector3 && newValue instanceof $3Dmol.Vector3 ) {

	                currentValue.copy( newValue );

	            } else {

	                this[ key ] = newValue;

	            }

	        }

	    }

	};
	//TODO: might want to look into blending equations
	$3Dmol.Material.prototype.clone = function ( material ) {

	    if ( material === undefined ) material = new $3Dmol.Material();

	    material.name = this.name;

	    material.side = this.side;

	    material.opacity = this.opacity;
	    material.transparent = this.transparent;

	    material.depthTest = this.depthTest;
	    material.depthWrite = this.depthWrite;
	    material.stencilTest = this.stencilTest;

	    material.polygonOffset = this.polygonOffset;
	    material.polygonOffsetFactor = this.polygonOffsetFactor;
	    material.polygonOffsetUnits = this.polygonOffsetUnits;

	    material.alphaTest = this.alphaTest;

	    material.overdraw = this.overdraw;

	    material.visible = this.visible;

	    return material;

	};

	$3Dmol.Material.prototype.dispose = function () {

	    this.dispatchEvent( { type: 'dispose' } );

	};

	$3Dmol.MaterialIdCount = 0;

	//Line basic material
	/** @constructor */
	$3Dmol.LineBasicMaterial = function(parameters) {
	    
	    $3Dmol.Material.call(this);
	    
	    this.color = new $3Dmol.Color(0xffffff);
	    
	    this.linewidth = 1;
	    this.linecap = 'round';
	    this.linejoin = 'round';
	    
	    this.vertexColors = false;
	    
	    this.fog = true;
	    this.shaderID = "basic";
	    this.setValues(parameters);
	    
	};

	$3Dmol.LineBasicMaterial.prototype = Object.create($3Dmol.Material.prototype);

	$3Dmol.LineBasicMaterial.prototype.clone = function() {
	  
	    var material = new $3Dmol.LineBasicMaterial();
	    
	    $3Dmol.Material.prototype.clone.call(this, material);
	    
	    material.color.copy(this.color);
	    return material;
	};

	//Mesh Lambert material
	/** @constructor */
	$3Dmol.MeshLambertMaterial = function(parameters) {
	    
	    $3Dmol.Material.call(this);
	    
	    this.color = new $3Dmol.Color(0xffffff);
	    this.ambient = new $3Dmol.Color(0xfffff);
	    this.emissive = new $3Dmol.Color(0x000000);
	    
	    //TODO: Which of these instance variables do I really need?
	    this.wrapAround = false;
	    this.wrapRGB = new $3Dmol.Vector3(1,1,1);
	    
	    this.map = null;
	    
	    this.lightMap = null;
	    
	    this.specularMap = null;
	    
	    this.envMap = null;
	    this.reflectivity = 1;
	    this.refractionRatio = 0.98;
	    
	    this.fog = true;
	    
	    this.wireframe = false;
	    this.wireframeLinewidth = 1;
	    this.wireframeLinecap = 'round';
	    this.wireframeLinejoin = 'round';
	    
	    this.shading = $3Dmol.SmoothShading;
	    this.shaderID = "lambert";
	    this.vertexColors = $3Dmol.NoColors;
	    
	    this.skinning = false;
	    
	    this.setValues(parameters);
	    
	};

	$3Dmol.MeshLambertMaterial.prototype = Object.create($3Dmol.Material.prototype);

	$3Dmol.MeshLambertMaterial.prototype.clone = function(material) {
	  
	    if ( typeof material === "undefined" ) material = new $3Dmol.MeshLambertMaterial();
	    
	    $3Dmol.Material.prototype.clone.call(this, material);
	    
	    material.color.copy(this.color);
	    material.ambient.copy(this.ambient);
	    material.emissive.copy(this.emissive);
	    
	    material.wrapAround = this.wrapAround;
	    material.wrapRGB.copy(this.wrapRGB);
	    
	    material.map = this.map;
	    
	    material.lightMap = this.lightMap;
	    
	    material.specularMap = this.specularMap;
	    
	    material.envMap = this.envMap;
	    material.combine = this.combine;
	    material.reflectivity = this.reflectivity;
	    material.refractionRatio = this.refractionRatio;
	    
	    material.fog = this.fog;
	    
	    material.shading = this.shading;
	    material.shaderID = this.shaderID;
	    material.vertexColors = this.vertexColors;
	    
	    material.skinning = this.skinning;
	    material.morphTargets = this.morphTargets;
	    material.morphNormals = this.morphNormals;
	    
	    return material;
	    
	};

	//Double sided Mesh Lambert material
	/** @constructor */
	$3Dmol.MeshDoubleLambertMaterial = function(parameters) {
	    
	    $3Dmol.MeshLambertMaterial.call(this, parameters);

	    this.shaderID = "lambertdouble";
	    this.side = $3Dmol.DoubleSide;    
	    
	};

	$3Dmol.MeshDoubleLambertMaterial.prototype = Object.create($3Dmol.MeshLambertMaterial.prototype);

	$3Dmol.MeshDoubleLambertMaterial.prototype.clone = function() {
	  
	    var material = new $3Dmol.MeshDoubleLambertMaterial();
	    
	    $3Dmol.MeshLambertMaterial.prototype.clone.call(this, material);
	        
	    return material;
	    
	};

	//Outlined Mesh Lamert material
	/** @constructor */
	$3Dmol.MeshOutlineMaterial = function(parameters) {
	    $3Dmol.Material.call(this);
	    parameters = parameters || {};
	    this.fog = true;
	    this.shaderID = "outline";
	    this.wireframe=false;
	    this.outlineColor= parameters.color || new $3Dmol.Color(0.0,0.0,0.0);
	    this.outlineWidth= parameters.width || 0.1;
	    this.outlinePushback= parameters.pushback || 1.0;
	    
	};

	$3Dmol.MeshOutlineMaterial.prototype = Object.create($3Dmol.Material.prototype);

	$3Dmol.MeshOutlineMaterial.prototype.clone = function(material) {
	    if ( typeof material === "undefined" ) material = new $3Dmol.MeshOutlineMaterial();
	    $3Dmol.Material.prototype.clone.call(this, material);
	    material.fog = this.fog;
	    material.shaderID = this.shaderID;
	    material.wireframe = this.wireframe;
	    return material;
	};


	//Imposter material
	/** @constructor */
	$3Dmol.ImposterMaterial = function(parameters) {
	  
	  $3Dmol.Material.call(this);
	  
	  this.color = new $3Dmol.Color(0xffffff);
	  this.ambient = new $3Dmol.Color(0xfffff);
	  this.emissive = new $3Dmol.Color(0x000000);
	  this.imposter = true;
	  
	  //TODO: Which of these instance variables do I really need?
	  this.wrapAround = false;
	  this.wrapRGB = new $3Dmol.Vector3(1,1,1);
	  
	  this.map = null;
	  
	  this.lightMap = null;
	  
	  this.specularMap = null;
	  
	  this.envMap = null;
	  this.reflectivity = 1;
	  this.refractionRatio = 0.98;
	  
	  this.fog = true;
	  
	  this.wireframe = false;
	  this.wireframeLinewidth = 1;
	  this.wireframeLinecap = 'round';
	  this.wireframeLinejoin = 'round';
	  
	  this.shading = $3Dmol.SmoothShading;
	  this.shaderID = null;
	  this.vertexColors = $3Dmol.NoColors;
	  
	  this.skinning = false;
	  
	  this.setValues(parameters);
	  
	};

	$3Dmol.ImposterMaterial.prototype = Object.create($3Dmol.Material.prototype);

	$3Dmol.ImposterMaterial.prototype.clone = function() {

	  var material = new $3Dmol.ImposterMaterial();
	  
	  $3Dmol.Material.prototype.clone.call(this, material);
	  
	  material.color.copy(this.color);
	  material.ambient.copy(this.ambient);
	  material.emissive.copy(this.emissive);
	  
	  material.wrapAround = this.wrapAround;
	  material.wrapRGB.copy(this.wrapRGB);
	  
	  material.map = this.map;
	  
	  material.lightMap = this.lightMap;
	  
	  material.specularMap = this.specularMap;
	  
	  material.envMap = this.envMap;
	  material.combine = this.combine;
	  material.reflectivity = this.reflectivity;
	  material.refractionRatio = this.refractionRatio;
	  
	  material.fog = this.fog;
	  
	  material.shading = this.shading;
	  material.shaderID = this.shaderID;
	  material.vertexColors = this.vertexColors;
	  
	  material.skinning = this.skinning;
	  material.morphTargets = this.morphTargets;
	  material.morphNormals = this.morphNormals;
	  
	  return material;
	  
	};


	$3Dmol.SphereImposterMaterial = function(parameters) {
	    
	    $3Dmol.ImposterMaterial.call(this);

	    this.shaderID = "sphereimposter";    
	    this.setValues(parameters);
	    
	};

	$3Dmol.SphereImposterMaterial.prototype = Object.create($3Dmol.ImposterMaterial.prototype);

	$3Dmol.SphereImposterMaterial.prototype.clone = function() {

	    var material = new $3Dmol.SphereImposterMaterial();
	    $3Dmol.ImposterMaterial.prototype.clone.call(this, material);
	    return material;
	};


	$3Dmol.SphereImposterOutlineMaterial = function(parameters) {
	    
	    $3Dmol.ImposterMaterial.call(this);

	    this.shaderID = "sphereimposteroutline";
	    this.outlineColor= parameters.color || new $3Dmol.Color(0.0,0.0,0.0);
	    this.outlineWidth= parameters.width || 0.1;
	    this.outlinePushback= parameters.pushback || 1.0;
	    
	    this.setValues(parameters);
	    
	};

	$3Dmol.SphereImposterOutlineMaterial.prototype = Object.create($3Dmol.ImposterMaterial.prototype);

	$3Dmol.SphereImposterOutlineMaterial.prototype.clone = function() {

	    var material = new $3Dmol.SphereImposterOutlineMaterial();
	    $3Dmol.ImposterMaterial.prototype.clone.call(this, material);
	    material.outlineColor = this.outlineColor;
	    material.outlineWidth = this.outlineWidth;
	    material.outlinePushback = this.outlinePushback;
	    return material;
	};


	$3Dmol.StickImposterMaterial = function(parameters) {
	    
	    $3Dmol.ImposterMaterial.call(this);

	    this.shaderID = "stickimposter";    
	    this.setValues(parameters);
	    
	};

	$3Dmol.StickImposterMaterial.prototype = Object.create($3Dmol.ImposterMaterial.prototype);

	$3Dmol.StickImposterMaterial.prototype.clone = function() {

	    var material = new $3Dmol.StickImposterOutlineMaterial();
	    $3Dmol.ImposterMaterial.prototype.clone.call(this, material);
	    return material;
	};


	$3Dmol.StickImposterOutlineMaterial = function(parameters) {
	    
	    $3Dmol.ImposterMaterial.call(this);

	    this.shaderID = "stickimposteroutline";
	    this.outlineColor= parameters.color || new $3Dmol.Color(0.0,0.0,0.0);
	    this.outlineWidth= parameters.width || 0.1;
	    this.outlinePushback= parameters.pushback || 1.0;
	    
	    this.setValues(parameters);
	    
	};

	$3Dmol.StickImposterOutlineMaterial.prototype = Object.create($3Dmol.ImposterMaterial.prototype);

	$3Dmol.StickImposterOutlineMaterial.prototype.clone = function() {

	    var material = new $3Dmol.StickImposterOutlineMaterial();
	    $3Dmol.ImposterMaterial.prototype.clone.call(this, material);
	    material.outlineColor = this.outlineColor;
	    material.outlineWidth = this.outlineWidth;
	    material.outlinePushback = this.outlinePushback;
	    return material;
	};


	$3Dmol.InstancedMaterial = function(parameters) {

	    $3Dmol.Material.call(this);

	    this.color = new $3Dmol.Color(0xffffff);
	    this.ambient = new $3Dmol.Color(0xfffff);
	    this.emissive = new $3Dmol.Color(0x000000);

	    //TODO: Which of these instance variables do I really need?
	    this.wrapAround = false;
	    this.wrapRGB = new $3Dmol.Vector3(1,1,1);

	    this.map = null;

	    this.lightMap = null;

	    this.specularMap = null;

	    this.envMap = null;
	    this.reflectivity = 1;
	    this.refractionRatio = 0.98;

	    this.fog = true;

	    this.wireframe = false;
	    this.wireframeLinewidth = 1;
	    this.wireframeLinecap = 'round';
	    this.wireframeLinejoin = 'round';

	    this.shading = $3Dmol.SmoothShading;
	    this.shaderID = "instanced";
	    this.vertexColors = $3Dmol.NoColors;

	    this.skinning = false;

	    this.sphere = null;

	    this.setValues(parameters);

	};

	$3Dmol.InstancedMaterial.prototype = Object.create($3Dmol.Material.prototype);

	$3Dmol.InstancedMaterial.prototype.clone = function() {

	    var material = new $3Dmol.InstancedMaterial();

	    $3Dmol.Material.prototype.clone.call(this, material);

	    material.color.copy(this.color);
	    material.ambient.copy(this.ambient);
	    material.emissive.copy(this.emissive);

	    material.wrapAround = this.wrapAround;
	    material.wrapRGB.copy(this.wrapRGB);

	    material.map = this.map;

	    material.lightMap = this.lightMap;

	    material.specularMap = this.specularMap;

	    material.envMap = this.envMap;
	    material.combine = this.combine;
	    material.reflectivity = this.reflectivity;
	    material.refractionRatio = this.refractionRatio;

	    material.fog = this.fog;

	    material.shading = this.shading;
	    material.shaderID = this.shaderID;
	    material.vertexColors = this.vertexColors;

	    material.skinning = this.skinning;
	    material.morphTargets = this.morphTargets;
	    material.morphNormals = this.morphNormals;

	    material.sphere = this.sphere;

	  return material;

	};


	//Sprite material
	/** @constructor */
	$3Dmol.SpriteMaterial = function(parameters) {
	    
	    $3Dmol.Material.call(this);
	    
	    this.color = new $3Dmol.Color(0xffffff);
	    this.map = new $3Dmol.Texture();
	    
	    this.useScreenCoordinates = true;
	    this.depthTest = !this.useScreenCoordinates;
	    this.sizeAttenuation = !this.useScreenCoordinates;
	    this.scaleByViewPort = !this.sizeAttenuation;
	    this.alignment = $3Dmol.SpriteAlignment.center.clone();
	    
	    this.fog = false; // use scene fog
	    
	    this.uvOffset = new $3Dmol.Vector2(0, 0);
	    this.uvScale = new $3Dmol.Vector2(1, 1);
	    
	    this.setValues(parameters);
	    
	    parameters = parameters || {};
	    
	    if (parameters.depthTest === undefined)
	        this.depthTest = !this.useScreenCoordinates;
	    if (parameters.sizeAttenuation === undefined)
	        this.sizeAttenuation = !this.useScreenCoordinates;
	    if (parameters.scaleByViewPort === undefined)
	        this.scaleByViewPort = !this.sizeAttenuation;
	    
	};

	$3Dmol.SpriteMaterial.prototype = Object.create($3Dmol.Material.prototype);

	$3Dmol.SpriteMaterial.prototype.clone = function() {
	    
	    var material = new $3Dmol.SpriteMaterial();
	    
	    $3Dmol.Material.prototype.clone.call(this, material);
	    
	    material.color.copy(this.color);
	    material.map = this.map;
	    
	    material.useScreenCoordinates = useScreenCoordinates;
	    material.sizeAttenuation = this.sizeAttenuation;
	    material.scaleByViewport = this.scaleByViewPort;
	    material.alignment.copy(this.alignment);
	    
	    material.uvOffset.copy(this.uvOffset);
	    
	    return material;
	    
	};

	//Alignment for Sprites

	$3Dmol.SpriteAlignment = {};
	$3Dmol.SpriteAlignment.topLeft = new $3Dmol.Vector2(1, -1);
	$3Dmol.SpriteAlignment.topCenter = new $3Dmol.Vector2(0, -1);
	$3Dmol.SpriteAlignment.topRight = new $3Dmol.Vector2(-1, -1);
	$3Dmol.SpriteAlignment.centerLeft = new $3Dmol.Vector2(1, 0);
	$3Dmol.SpriteAlignment.center = new $3Dmol.Vector2(0, 0);
	$3Dmol.SpriteAlignment.centerRight = new $3Dmol.Vector2(-1, 0);
	$3Dmol.SpriteAlignment.bottomLeft = new $3Dmol.Vector2(1, 1);
	$3Dmol.SpriteAlignment.bottomCenter = new $3Dmol.Vector2(0, 1);
	$3Dmol.SpriteAlignment.bottomRight = new $3Dmol.Vector2(-1, 1);


	//Texture
	//We really only create textures from 2d rendering contexts (to display text labels)
	/** @constructor */
	$3Dmol.Texture = function(image) {

	    $3Dmol.EventDispatcher.call(this);
	    
	    this.id = $3Dmol.TextureIdCount++;
	    
	    this.name = "";
	    
	    this.image = image;
	    this.mipmaps = [];
	    
	    this.mapping = new $3Dmol.UVMapping();
	    
	    this.wrapS = $3Dmol.ClampToEdgeWrapping;
	    this.wrapT = $3Dmol.ClampToEdgeWrapping;
	    
	    this.magFilter = $3Dmol.LinearFilter;
	    this.minFilter = $3Dmol.LinearMipMapLinearFilter;
	    
	    this.anisotropy = 1;
	    
	    this.format = $3Dmol.RGBAFormat;
	    this.type = $3Dmol.UnsignedByteType;
	    
	    this.offset = new $3Dmol.Vector2(0, 0);
	    this.repeat = new $3Dmol.Vector2(1, 1);
	    
	    this.generateMipmaps = true;
	    this.premultiplyAlpha = false;
	    this.flipY = true;
	    this.unpackAlignment = 4;
	    
	    this.needsUpdate = false;
	    this.onUpdate = null;
	    
	};

	$3Dmol.Texture.prototype = {

	    constructor : $3Dmol.Texture,
	    
	    clone : function(texture) {
	        
	        if (texture === undefined)
	            texture = new $3Dmol.Texture();
	        
	        texture.image = this.image;
	        texture.mipmaps = this.mipmaps.slice(0);
	        
	        texture.mapping = this.mapping;
	        
	        texture.wrapS = this.wrapS;
	        texture.wrapT = this.wrapT;
	        
	        texture.magFilter = this.magFilter;
	        texture.minFilter = this.minFilter;
	        
	        texture.anisotropy = this.anisotropy;
	        
	        texture.format = this.format;
	        texture.type = this.type;
	        
	        texture.offset.copy(this.offset);
	        texture.repeat.copy(this.repeat);
	        
	        texture.generateMipmaps = this.generateMipmaps;
	        texture.premultiplyAlpha = this.premultiplyAlpha;
	        texture.flipY = this.flipY;
	        texture.unpackAlignment = this.unpackAlignment;
	        
	        return texture;
	        
	    },
	    
	    dispose : function() {
	        
	        this.dispatchEvent( {type: 'dispose'});
	        
	    }    
	    
	};

	$3Dmol.TextureIdCount = 0;


	// sides
	$3Dmol.FrontSide = 0;
	$3Dmol.BackSide = 1;
	$3Dmol.DoubleSide = 2;

	// shading
	$3Dmol.NoShading = 0;
	$3Dmol.FlatShading = 1;
	$3Dmol.SmoothShading = 2;

	// colors
	$3Dmol.NoColors = 0;
	$3Dmol.FaceColors = 1;
	$3Dmol.VertexColors = 2;

	//Texture constants
	//TODO: Which of these do I need (since I only use textures to display label sprites) ?
	$3Dmol.MultiplyOperation = 0;
	$3Dmol.MixOperation = 1;
	$3Dmol.AddOperation = 2;

	// mapping modes

	$3Dmol.UVMapping = function() {};

	// wrapping modes
	$3Dmol.ClampToEdgeWrapping = 1001;

	//Filters
	$3Dmol.LinearFilter = 1006;
	$3Dmol.LinearMipMapLinearFilter = 1008;

	//Data types
	$3Dmol.UnsignedByteType = 1009;

	//Pixel formats
	$3Dmol.RGBAFormat = 1021;
	/* 
	 * $3Dmol Mesh and Line objects
	 */


	//Line Object
	/** @constructor */
	$3Dmol.Line = function (geometry, material, type) {

	    $3Dmol.Object3D.call(this);

	    this.geometry = geometry;
	        //TODO: update material and type to webgl
	    this.material = (material !== undefined) ? material : new $3Dmol.LineBasicMaterial( { color: Math.random() * 0xffffff } );
	    this.type = (type !== undefined) ? type : $3Dmol.LineStrip;

	};

	$3Dmol.LineStrip = 0;
	$3Dmol.LinePieces = 1;

	$3Dmol.Line.prototype = Object.create($3Dmol.Object3D.prototype);

	$3Dmol.Line.prototype.clone = function (object) {

	    if (object === undefined) object = new $3Dmol.Line(this.geometry, this.material, this.type);

	    $3Dmol.Object3D.prototype.clone.call(this, object);

	    return object;

	};


	//Mesh Object
	/** @constructor */
	$3Dmol.Mesh = function(geometry, material) {

	    $3Dmol.Object3D.call(this);

	    this.geometry = geometry;
	    this.material = (material !== undefined) ? material : new $3Dmol.MeshBasicMaterial( { color: Math.random() * 0xffffff, wireframe: true } );

	};

	$3Dmol.Mesh.prototype = Object.create($3Dmol.Object3D.prototype);

	$3Dmol.Mesh.prototype.clone = function (object) {

	    if (object === undefined) object = new $3Dmol.Mesh(this.geometry, this.material);

	    $3Dmol.Object3D.prototype.clone.call(this, object);

	    return object;

	};


	//Sprite object
	/** @constructor */
	$3Dmol.Sprite = function(material) {
	    
	    $3Dmol.Object3D.call(this);
	    
	    this.material = (material !== undefined) ? material : new $3Dmol.SpriteMaterial();

	    this.rotation3d = this.rotation;
	    this.rotation = 0;
	    
	};

	$3Dmol.Sprite.prototype = Object.create($3Dmol.Object3D.prototype);

	$3Dmol.Sprite.prototype.updateMatrix = function() {
	    
	    this.matrix.setPosition(this.position);
	    
	    this.rotation3d.set(0, 0, this.rotation);
	    this.matrix.setRotationFromEuler(this.rotation3d);
	    
	    if (this.scale.x !== 1 || this.scale.y !== 1)
	        this.matrix.scale(this.scale);
	    
	    this.matrixWorldNeedsUpdate = true;
	    
	};

	$3Dmol.Sprite.prototype.clone = function(object) {
	    
	    if (object === undefined)
	        object = new $3Dmol.Sprite(this.material);
	    
	    $3Dmol.Object3D.prototype.clone.call(this, object);
	    
	    return object;
	    
	};
	/**
	 * Simplified webGL renderer
	 */

	$3Dmol.Renderer = function(parameters) {

	    parameters = parameters || {};

	    var _canvas = parameters.canvas !== undefined ? parameters.canvas
	            : document.createElement('canvas'),

	    _precision = parameters.precision !== undefined ? parameters.precision
	            : 'highp', _alpha = parameters.alpha !== undefined ? parameters.alpha
	            : true, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha
	            : true, _antialias = parameters.antialias !== undefined ? parameters.antialias
	            : false, _stencil = parameters.stencil !== undefined ? parameters.stencil
	            : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer
	            : false, _clearColor = parameters.clearColor !== undefined ? new $3Dmol.Color(
	            parameters.clearColor)
	            : new $3Dmol.Color(0x000000), _clearAlpha = parameters.clearAlpha !== undefined ? parameters.clearAlpha
	            : 0, _outlineMaterial = parameters.outline !== undefined ? new $3Dmol.MeshOutlineMaterial(
	            parameters.outline)
	            : null;

	    this.domElement = _canvas;
	    this.context = null;
	    this.devicePixelRatio = parameters.devicePixelRatio !== undefined ? parameters.devicePixelRatio
	            : (self.devicePixelRatio !== undefined) ? self.devicePixelRatio : 1;

	    // clearing

	    this.autoClear = true;
	    this.autoClearColor = true;
	    this.autoClearDepth = true;
	    this.autoClearStencil = true;

	    // scene graph

	    this.sortObjects = true;

	    this.autoUpdateObjects = true;
	    this.autoUpdateScene = true;

	    this.renderPluginsPost = [];

	    // info

	    this.info = {
	        memory : {

	            programs : 0,
	            geometries : 0,
	            textures : 0

	        },
	        render : {

	            calls : 0,
	            vertices : 0,
	            faces : 0,
	            points : 0

	        }
	    };

	    // internal properties
	    var _this = this,
	    _programs = [], _programs_counter = 0,
	    
	    // internal state cache
	    _currentProgram = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryGroupHash = null, _currentCamera = null, _geometryGroupCounter = 0,
	    _usedTextureUnits = 0,

	    // GL state cache
	    _oldDoubleSided = -1, _oldFlipSided = -1,
	    _oldBlending = -1,
	    _oldBlendEquation = -1, _oldBlendSrc = -1, _oldBlendDst = -1,
	    _oldDepthTest = -1, _oldDepthWrite = -1,
	    _oldPolygonOffset = null, _oldPolygonOffsetFactor = null, _oldPolygonOffsetUnits = null,
	    _oldLineWidth = null,

	    _viewportWidth = 0, _viewportHeight = 0, _currentWidth = 0, _currentHeight = 0,
	    _enabledAttributes = {},

	    // camera matrices cache
	    _projScreenMatrix = new $3Dmol.Matrix4(),
	    _vector3 = new $3Dmol.Vector3(),

	    // light arrays cache
	    _direction = new $3Dmol.Vector3(),
	    _lightsNeedUpdate = true,

	    _lights = {
	        ambient : [ 0, 0, 0 ],
	        directional : {
	            length : 0,
	            colors : [],
	            positions : []
	        },
	        point : {
	            length : 0,
	            colors : [],
	            positions : [],
	            distances : []
	        },
	        spot : {
	            length : 0,
	            colors : [],
	            positions : [],
	            distances : [],
	            directions : [],
	            anglesCos : [],
	            exponents : []
	        },
	        hemi : {
	            length : 0,
	            skyColors : [],
	            groundColors : [],
	            positions : []
	        }

	    };

	    // initialize
	    var _gl;

	    initGL();
	    setDefaultGLState();

	    this.context = _gl;
	    var _extInstanced = _gl.getExtension("ANGLE_instanced_arrays");
	    var _extFragDepth = _gl.getExtension("EXT_frag_depth");

	    // API
	    
	    this.supportedExtensions = function() {
	        return {supportsAIA: Boolean(_extInstanced),
	            supportsImposters:  Boolean(_extFragDepth)
	            };
	    };
	    
	    this.getContext = function() {
	        return _gl;
	    };

	    this.getPrecision = function() {
	        return _precision;
	    };

	    this.setClearColorHex = function(hex, alpha) {
	        _clearColor.setHex(hex);
	        _clearAlpha = alpha;

	        _gl.clearColor(_clearColor.r, _clearColor.g, _clearColor.b,
	                        _clearAlpha);
	    };

	    this.enableOutline = function(parameters) {
	        _outlineMaterial = new $3Dmol.MeshOutlineMaterial(parameters);
	        _outlineSphereImposterMaterial = new $3Dmol.SphereImposterOutlineMaterial(parameters);
	        _outlineStickImposterMaterial = new $3Dmol.StickImposterOutlineMaterial(parameters);
	    };

	    this.disableOutline = function() {
	        _outlineMaterial = null;
	        _outlineSphereImposterMaterial = null;
	        _outlineStickImposterMaterial = null;
	    };

	    this.setSize = function(width, height) {

	        _viewportWidth = _canvas.width = width * this.devicePixelRatio;
	        _viewportHeight =  _canvas.height = height * this.devicePixelRatio;

	        _canvas.style.width = width + 'px';
	        _canvas.style.height = height + 'px';

	        _gl.viewport(0, 0, _gl.drawingBufferWidth, _gl.drawingBufferHeight);
	    };

	    this.clear = function(color, depth, stencil) {

	        var bits = 0;

	        if (color === undefined || color)
	            bits |= _gl.COLOR_BUFFER_BIT;
	        if (depth === undefined || depth)
	            bits |= _gl.DEPTH_BUFFER_BIT;
	        if (stencil === undefined || stencil)
	            bits |= _gl.STENCIL_BUFFER_BIT;
	        _gl.clear(bits);

	    };

	    this.clearTarget = function(color, depth, stencil) {

	        this.clear(color, depth, stencil);

	    };

	    this.setMaterialFaces = function(material, reflected) {

	        var doubleSided = material.side === $3Dmol.DoubleSide;
	        var flipSided = material.side === $3Dmol.BackSide;
	        flipSided = reflected ? !flipSided : flipSided;

	        if (_oldDoubleSided !== doubleSided) {

	            if (doubleSided) {

	                _gl.disable(_gl.CULL_FACE);

	            } else {

	                _gl.enable(_gl.CULL_FACE);

	            }

	            _oldDoubleSided = doubleSided;

	        }

	        if (_oldFlipSided !== flipSided) {

	            if (flipSided) {

	                _gl.frontFace(_gl.CW);

	            } else {

	                _gl.frontFace(_gl.CCW);

	            }

	            _oldFlipSided = flipSided;

	        }

	    };

	    this.setDepthTest = function(depthTest) {

	        if (_oldDepthTest !== depthTest) {

	            if (depthTest) {

	                _gl.enable(_gl.DEPTH_TEST);

	            } else {

	                _gl.disable(_gl.DEPTH_TEST);

	            }

	            _oldDepthTest = depthTest;

	        }

	    };

	    this.setDepthWrite = function(depthWrite) {

	        if (_oldDepthWrite !== depthWrite) {

	            _gl.depthMask(depthWrite);
	            _oldDepthWrite = depthWrite;

	        }

	    };

	    this.setBlending = function(blending) {

	        if (!blending) {
	            _gl.disable(_gl.BLEND);

	        } else {
	            _gl.enable(_gl.BLEND);
	            _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);
	            _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA,
	                    _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);

	        }

	        _oldBlending = blending;
	    };

	    // Plugins

	    this.addPostPlugin = function(plugin) {

	        plugin.init(this);
	        this.renderPluginsPost.push(plugin);

	    };

	    // Sorting

	    function numericalSort(a, b) {

	        return b[0] - a[0];

	    }

	    function enableAttribute(attribute) {

	        if (!_enabledAttributes[attribute]) {

	            _gl.enableVertexAttribArray(attribute);
	            _enabledAttributes[attribute] = true;

	        }

	    }

	    function disableAttributes() {

	        for ( var attribute in _enabledAttributes) {

	            if (_enabledAttributes[attribute]) {

	                _gl.disableVertexAttribArray(attribute);
	                _enabledAttributes[attribute] = false;

	            }

	        }

	    }

	    function setPolygonOffset(polygonOffset, factor, units) {

	        if (_oldPolygonOffset !== polygonOffset) {

	            if (polygonOffset)
	                _gl.enable(_gl.POLYGON_OFFSET_FILL);
	            else
	                _gl.disable(_gl.POLYGON_OFFSET_FILL);
	        }
	    }

	    function setLineWidth(width) {

	        if (width !== _oldLineWidth) {
	            _gl.lineWidth(width);
	            _oldLineWidth = width;
	        }

	    }

	    var onGeometryDispose = function(event) {

	        var geometry = event.target;
	        geometry.removeEventListener('dispose', onGeometryDispose);

	        deallocateGeometry(geometry);

	        _this.info.memory.geometries--;

	    };

	    var onTextureDispose = function(event) {

	        var texture = event.target;

	        texture.removeEventListener('dispose', onTextureDispose);

	        deallocateTexture(texture);

	        _this.info.memory.textures--;

	    };

	    var onMaterialDispose = function(event) {

	        var material = event.target;
	        material.removeEventListener('dispose', onMaterialDispose);

	        deallocateMaterial(material);

	    };

	    var deallocateGeometry = function(geometry) {

	        geometry.__webglInit = undefined;

	        if (geometry.__webglVertexBuffer !== undefined)
	            _gl.deleteBuffer(geometry.__webglVertexBuffer);

	        if (geometry.__webglColorBuffer !== undefined)
	            _gl.deleteBuffer(geometry.__webglColorBuffer);

	        if (geometry.geometryGroups !== undefined) {

	            for (var g = 0, gl = geometry.groups; g < gl; g++) {

	                var geometryGroup = geometry.geometryGroups[g];

	                if (geometryGroup.__webglVertexBuffer !== undefined)
	                    _gl.deleteBuffer(geometryGroup.__webglVertexBuffer);

	                if (geometryGroup.__webglColorBuffer !== undefined)
	                    _gl.deleteBuffer(geometryGroup.__webglColorBuffer);

	                if (geometryGroup.__webglNormalBuffer !== undefined)
	                    _gl.deleteBuffer(geometryGroup.__webglNormalBuffer);

	                if (geometryGroup.__webglFaceBuffer !== undefined)
	                    _gl.deleteBuffer(geometryGroup.__webglFaceBuffer);

	                if (geometryGroup.__webglLineBuffer !== undefined)
	                    _gl.deleteBuffer(geometryGroup.__webglLineBuffer);

	            }
	        }
	    };

	    var deallocateMaterial = function(material) {

	        var program = material.program;

	        if (program === undefined)
	            return;

	        material.program = undefined;

	        // only deallocate GL program if this was the last use of shared program
	        // assumed there is only single copy of any program in the _programs
	        // list
	        // (that's how it's constructed)

	        var i, il, programInfo;
	        var deleteProgram = false;

	        for (i = 0, il = _programs.length; i < il; i++) {

	            programInfo = _programs[i];

	            if (programInfo.program === program) {

	                programInfo.usedTimes--;

	                if (programInfo.usedTimes === 0) {

	                    deleteProgram = true;

	                }

	                break;

	            }

	        }

	        if (deleteProgram === true) {

	            // avoid using array.splice, this is costlier than creating new
	            // array from scratch

	            var newPrograms = [];

	            for (i = 0, il = _programs.length; i < il; i++) {

	                programInfo = _programs[i];

	                if (programInfo.program !== program) {

	                    newPrograms.push(programInfo);

	                }

	            }

	            _programs = newPrograms;

	            _gl.deleteProgram(program);

	            _this.info.memory.programs--;

	        }

	    };

	    var deallocateTexture = function(texture) {

	        if (texture.image && texture.image.__webglTextureCube) {

	            // cube texture

	            _gl.deleteTexture(texture.image.__webglTextureCube);

	        }

	        else {

	            // 2D texture

	            if (!texture.__webglInit)
	                return;

	            texture.__webglInit = false;
	            _gl.deleteTexture(texture.__webglTexture);

	        }

	    };

	    // Compile and return shader
	    function getShader(type, str) {

	        var shader;

	        if (type === "fragment")
	            shader = _gl.createShader(_gl.FRAGMENT_SHADER);
	        else if (type === "vertex")
	            shader = _gl.createShader(_gl.VERTEX_SHADER);

	        _gl.shaderSource(shader, str);
	        _gl.compileShader(shader);

	        if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {

	            console.error(_gl.getShaderInfoLog(shader));
	            console.error("could not initialize shader");
	            return null;

	        }

	        return shader;

	    }

	    // Compile appropriate shaders (if necessary) from source code and attach to
	    // gl program.
	    function buildProgram(fragmentShader, vertexShader, uniforms, parameters) {

	        var p, pl, d, program, code;
	        var chunks = [];

	        chunks.push(fragmentShader);
	        chunks.push(vertexShader);

	        for (p in parameters) {
	            chunks.push(p);
	            chunks.push(parameters[p]);
	        }

	        code = chunks.join();

	        // check if program has already been compiled

	        for (p = 0, pl = _programs.length; p < pl; p++) {

	            var programInfo = _programs[p];

	            if (programInfo.code === code) {

	                programInfo.usedTimes++;

	                return programInfo.program;
	            }
	        }

	        // Set up new program and compile shaders

	        program = _gl.createProgram();

	        // set up precision
	        var precision = _precision;
	        var prefix = "precision " + precision + " float;";

	        var prefix_vertex = [ prefix ].join("\n");

	        var prefix_fragment = [
	                parameters.fragdepth ? "#extension GL_EXT_frag_depth: enable"
	                        : "",
	                parameters.wireframe ? "#define WIREFRAME 1" : "", prefix ]
	                .join("\n");

	        var glFragmentShader = getShader("fragment", prefix_fragment
	                + fragmentShader);
	        var glVertexShader = getShader("vertex", prefix_vertex + vertexShader);

	        _gl.attachShader(program, glVertexShader);
	        _gl.attachShader(program, glFragmentShader);

	        _gl.linkProgram(program);

	        if (!_gl.getProgramParameter(program, _gl.LINK_STATUS))
	            console.error("Could not initialize shader");

	        // gather and cache uniform variables and attributes

	        program.uniforms = {};
	        program.attributes = {};

	        var identifiers, u, a, i;

	        // uniform vars
	        identifiers = [ 'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 
	                'normalMatrix'];

	        // custom uniform vars
	        for (u in uniforms)
	            identifiers.push(u);

	        for (i = 0; i < identifiers.length; i++) {

	            var uniformVar = identifiers[i];
	            program.uniforms[uniformVar] = _gl.getUniformLocation(program,
	                    uniformVar);

	        }

	        // attributes
	        identifiers = [ 'position', 'normal', 'color', 'lineDistance',
	                'offset', 'radius' ];

	        /*
	         * for (a in attributes) identifiers.push(a);
	         */

	        for (i = 0; i < identifiers.length; i++) {

	            var attributeVar = identifiers[i];
	            program.attributes[attributeVar] = _gl.getAttribLocation(program,
	                    attributeVar);
	        }

	        program.id = _programs_counter++;
	        _programs.push({
	            program : program,
	            code : code,
	            usedTimes : 1
	        });
	        _this.info.memory.programs = _programs.length;

	        return program;
	    }

	    // TODO: need to set up shader attributes and uniforms as attributes on
	    // material object after attaching prgm
	    // We need to attach appropriate uniform variables to material after shaders
	    // have been chosen
	    this.initMaterial = function(material, lights, fog, object) {

	        material.addEventListener('dispose', onMaterialDispose);

	        var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;

	        shaderID = material.shaderID;

	        if (shaderID) {

	            var shader = $3Dmol.ShaderLib[shaderID];
	            material.vertexShader = shader.vertexShader;
	            material.fragmentShader = shader.fragmentShader;
	            material.uniforms = $3Dmol.ShaderUtils.clone(shader.uniforms);
	            // TODO: set material uniforms to shader uniform variables

	        }

	        parameters = {
	            wireframe : material.wireframe,
	            fragdepth : material.imposter
	        };

	        material.program = buildProgram(material.fragmentShader,
	                material.vertexShader, material.uniforms, parameters);

	    };

	    function setProgram(camera, lights, fog, material, object) {

	        if (material.needsUpdate) {

	            if (material.program)
	                deallocateMaterial(material);

	            _this.initMaterial(material, lights, fog, object);
	            material.needsUpdate = false;
	        }

	        var refreshMaterial = false;

	        // p_uniforms: uniformVarName => uniformLocation
	        // m_uniforms: uniformVarName => uniformJsVal
	        var program = material.program, p_uniforms = program.uniforms, m_uniforms = material.uniforms;

	        if (program != _currentProgram) {
	            _gl.useProgram(program);
	            _currentProgram = program;

	            refreshMaterial = true;
	        }

	        if (material.id != _currentMaterialId) {
	            _currentMaterialId = material.id;
	            refreshMaterial = true;
	        }

	        if (camera != _currentCamera) {
	            _currentCamera = camera;
	            refreshMaterial = true;
	        }

	        _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false,
	                camera.projectionMatrix.elements);
	        _gl.uniformMatrix4fv(p_uniforms.modelViewMatrix, false,
	                object._modelViewMatrix.elements);
	        _gl.uniformMatrix3fv(p_uniforms.normalMatrix, false,
	                object._normalMatrix.elements);

	        // Send projection matrix to uniform variable in shader
	        if (refreshMaterial) {

	            // Load projection, model-view matrices for perspective

	            // Set up correct fog uniform vals
	            m_uniforms.fogColor.value = fog.color;
	            m_uniforms.fogNear.value = fog.near;
	            m_uniforms.fogFar.value = fog.far;

	            // Set up lights for lambert shader
	            if (material.shaderID.startsWith("lambert")
	                    || material.shaderID === "instanced"
	                    || material.shaderID.endsWith("imposter")) {

	                // load view and normal matrices for directional and object
	                // lighting
	                _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false,
	                        camera.matrixWorldInverse.elements);

	                if (_lightsNeedUpdate) {
	                    setupLights(program, lights);
	                    _lightsNeedUpdate = false;
	                }

	                // Set up correct light uniform var vals
	                m_uniforms.directionalLightColor.value = _lights.directional.colors;
	                m_uniforms.directionalLightDirection.value = _lights.directional.positions;

	            } else if (material.shaderID.endsWith("outline")) {
	                m_uniforms.outlineColor.value = material.outlineColor;
	                m_uniforms.outlineWidth.value = material.outlineWidth;
	                m_uniforms.outlinePushback.value = material.outlinePushback;
	            } else if (material.shaderID === "sphereimposter") {
	                _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false,
	                        camera.matrixWorldInverse.elements);
	                _gl.uniformMatrix3fv(p_uniforms.normalMatrix, false,
	                        object._normalMatrix.elements);
	                m_uniforms.directionalLightColor.value = _lights.directional.colors;
	                m_uniforms.directionalLightDirection.value = _lights.directional.positions;
	            }

	            // opacity, diffuse, emissive, etc
	            m_uniforms.opacity.value = material.opacity;

	            // Load any other material specific uniform variables to gl shaders
	            loadMaterialUniforms(p_uniforms, m_uniforms);

	        }

	        return program;

	    }

	    function loadMaterialUniforms(p_uniforms, m_uniforms) {
	        var uniformVar, type, uniformVal, uniformLoc;

	        for (uniformVar in m_uniforms) {
	            if (!p_uniforms[uniformVar])
	                continue;

	            type = m_uniforms[uniformVar].type;
	            uniformVal = m_uniforms[uniformVar].value;
	            uniformLoc = p_uniforms[uniformVar];

	            // single float
	            if (type === 'f')
	                _gl.uniform1f(uniformLoc, uniformVal);
	            // array of floats
	            else if (type === 'fv')
	                _gl.uniform3fv(uniformLoc, uniformVal);
	            // color - r,g,b floats
	            else if (type === 'c')
	                _gl.uniform3f(uniformLoc, uniformVal.r, uniformVal.g,
	                        uniformVal.b);
	            else if (type === 'f4')
	                _gl.uniform4f(uniformLoc, uniformVal[0], uniformVal[1],
	                        uniformVal[2],uniformVal[3]);

	        }

	    }

	    this.renderBuffer = function(camera, lights, fog, material, geometryGroup,
	            object) {

	        if (!material.visible)
	            return;

	        var program, attributes, linewidth, primitives, a, attribute, i, il;

	        // Sets up proper vertex and fragment shaders and attaches them to webGL
	        // program
	        // Also sets appropriate uniform variables
	        program = setProgram(camera, lights, fog, material, object);

	        attributes = program.attributes;

	        var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryGroupHash = (geometryGroup.id * 0xffffff)
	                + (program.id * 2) + wireframeBit;

	        if (geometryGroupHash !== _currentGeometryGroupHash) {
	            _currentGeometryGroupHash = geometryGroupHash;
	            updateBuffers = true;
	        }

	        // rebind shader attributes to appropriate (and already initialized) gl
	        // buffers
	        if (updateBuffers) {

	            disableAttributes();

	            // Vertices
	            if (attributes.position >= 0) {
	                _gl.bindBuffer(_gl.ARRAY_BUFFER,
	                        geometryGroup.__webglVertexBuffer);
	                enableAttribute(attributes.position);
	                _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT,
	                        false, 0, 0);
	            }

	            // Colors
	            if (attributes.color >= 0) {
	                _gl.bindBuffer(_gl.ARRAY_BUFFER,
	                        geometryGroup.__webglColorBuffer);
	                enableAttribute(attributes.color);
	                _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false,
	                        0, 0);
	            }

	            // Normals
	            if (attributes.normal >= 0) {
	                _gl.bindBuffer(_gl.ARRAY_BUFFER,
	                        geometryGroup.__webglNormalBuffer);
	                enableAttribute(attributes.normal);
	                _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false,
	                        0, 0);
	            }

	            // Offsets (Instanced only)
	            if (attributes.offset >= 0) {
	                _gl.bindBuffer(_gl.ARRAY_BUFFER,
	                        geometryGroup.__webglOffsetBuffer);
	                enableAttribute(attributes.offset);
	                _gl.vertexAttribPointer(attributes.offset, 3, _gl.FLOAT, false,
	                        0, 0);
	            }

	            // Radii (Instanced only)
	            if (attributes.radius >= 0) {
	                _gl.bindBuffer(_gl.ARRAY_BUFFER,
	                        geometryGroup.__webglRadiusBuffer);
	                enableAttribute(attributes.radius);
	                _gl.vertexAttribPointer(attributes.radius, 1, _gl.FLOAT, false,
	                        0, 0);
	            }

	        }

	        // Render
	        var faceCount, lineCount;
	        // lambert shaders - draw triangles
	        // TODO: make sure geometryGroup's face count is setup correctly
	        if (object instanceof $3Dmol.Mesh) {

	            if (material.shaderID === "instanced") {
	                var sphereGeometryGroup = material.sphere.geometryGroups[0];
	                if (updateBuffers) {
	                    _gl.bindBuffer(_gl.ARRAY_BUFFER,
	                            geometryGroup.__webglVertexBuffer);
	                    _gl.bufferData(_gl.ARRAY_BUFFER,
	                            sphereGeometryGroup.vertexArray, _gl.STATIC_DRAW);
	                    _gl.bindBuffer(_gl.ARRAY_BUFFER,
	                            geometryGroup.__webglNormalBuffer);
	                    _gl.bufferData(_gl.ARRAY_BUFFER,
	                            sphereGeometryGroup.normalArray, _gl.STATIC_DRAW);
	                    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER,
	                            geometryGroup.__webglFaceBuffer);
	                    _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER,
	                            sphereGeometryGroup.faceArray, _gl.STATIC_DRAW);
	                }

	                faceCount = sphereGeometryGroup.faceidx;

	                _extInstanced.vertexAttribDivisorANGLE(attributes.offset, 1);
	                _extInstanced.vertexAttribDivisorANGLE(attributes.radius, 1);
	                _extInstanced.vertexAttribDivisorANGLE(attributes.color, 1);

	                _extInstanced.drawElementsInstancedANGLE(_gl.TRIANGLES,
	                        faceCount, _gl.UNSIGNED_SHORT, 0,
	                        geometryGroup.radiusArray.length);

	                _extInstanced.vertexAttribDivisorANGLE(attributes.offset, 0);
	                _extInstanced.vertexAttribDivisorANGLE(attributes.radius, 0);
	                _extInstanced.vertexAttribDivisorANGLE(attributes.color, 0);

	            }

	            else if (material.wireframe) {
	                lineCount = geometryGroup.lineidx;
	                setLineWidth(material.wireframeLinewidth);

	                if (updateBuffers)
	                    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER,
	                            geometryGroup.__webglLineBuffer);

	                _gl.drawElements(_gl.LINES, lineCount, _gl.UNSIGNED_SHORT, 0);
	            }

	            else {
	                faceCount = geometryGroup.faceidx;

	                if (updateBuffers)
	                    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER,
	                            geometryGroup.__webglFaceBuffer);
	                _gl.drawElements(_gl.TRIANGLES, faceCount, _gl.UNSIGNED_SHORT,
	                        0);

	            }

	            _this.info.render.calls++;
	            _this.info.render.vertices += faceCount;
	            _this.info.render.faces += faceCount / 3;
	        }

	        // basic shaders - draw lines
	        else if (object instanceof $3Dmol.Line) {
	            lineCount = geometryGroup.vertices;

	            setLineWidth(material.linewidth);
	            _gl.drawArrays(_gl.LINES, 0, lineCount);

	            _this.info.render.calls++;
	        }

	    };

	    // rendering
	    function renderObjects(renderList, reverse, materialType, camera, lights,
	            fog, useBlending, overrideMaterial) {

	        var webglObject, object, buffer, material, start, end, delta;

	        // Forward or backward render

	        if (reverse) {
	            start = renderList.length - 1;
	            end = -1;
	            delta = -1;
	        }

	        else {
	            start = 0;
	            end = renderList.length;
	            delta = 1;
	        }

	        for (var i = start; i !== end; i += delta) {

	            webglObject = renderList[i];

	            if (webglObject.render) {

	                object = webglObject.object;
	                buffer = webglObject.buffer;
	                material = webglObject[materialType];

	                if (!material)
	                    continue;

	                if (useBlending)
	                    _this.setBlending(true);

	                _this.setDepthTest(material.depthTest);
	                _this.setDepthWrite(material.depthWrite);
	                setPolygonOffset(material.polygonOffset,
	                        material.polygonOffsetFactor,
	                        material.polygonOffsetUnits);

	                var reflected = object._modelViewMatrix.isReflected();

	                _this.setMaterialFaces(material, reflected);

	                _this.renderBuffer(camera, lights, fog, material, buffer,
	                        object);
	                if (_outlineMaterial) {                  
	                    if(material.shaderID == 'sphereimposter') {
	                        _this.renderBuffer(camera, lights, fog, _outlineSphereImposterMaterial,
	                                buffer, object);                        
	                    }
	                    else if(material.shaderID == 'stickimposter') {
	                        _this.renderBuffer(camera, lights, fog, _outlineStickImposterMaterial,
	                                buffer, object);                        
	                    }
	                    else if(!material.wireframe                
	                        && material.shaderID !== 'basic'
	                        && material.opacity !== 0.0) {
	                        _this.renderBuffer(camera, lights, fog, _outlineMaterial,
	                            buffer, object);
	                    }
	                }
	            }
	        }

	    }

	    this.render = function(scene, camera, forceClear) {

	        if (camera instanceof $3Dmol.Camera === false) {

	            console
	                    .error('$3Dmol.Renderer.render: camera is not an instance of $3Dmol.Camera.');
	            return;

	        }

	        var i, il,

	        webglObject, object, renderList,

	        lights = scene.__lights, fog = scene.fog;

	        // reset caching for this frame

	        _currentMaterialId = -1;
	        _lightsNeedUpdate = true;

	        // update scene graph

	        if (this.autoUpdateScene)
	            scene.updateMatrixWorld();

	        // update camera matrices
	        // Pretty sure camera's parent is always going to be undefined for our
	        // purposes...
	        if (camera.parent === undefined)
	            camera.updateMatrixWorld();

	        camera.matrixWorldInverse.getInverse(camera.matrixWorld);

	        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix,
	                camera.matrixWorldInverse);

	        // update WebGL objects

	        if (this.autoUpdateObjects)
	            this.initWebGLObjects(scene);

	        _this.info.render.calls = 0;
	        _this.info.render.vertices = 0;
	        _this.info.render.faces = 0;
	        _this.info.render.points = 0;

	        _currentWidth = _viewportWidth;
	        _currentHeight = _viewportHeight;

	        if (this.autoClear || forceClear) {
	            this.clear(this.autoClearColor, this.autoClearDepth,
	                    this.autoClearStencil);

	        }

	        // set matrices for regular objects (frustum culled)

	        renderList = scene.__webglObjects;

	        for (i = 0, il = renderList.length; i < il; i++) {

	            webglObject = renderList[i];
	            object = webglObject.object;

	            webglObject.render = false;

	            if (object.visible) {
	                setupMatrices(object, camera);
	                unrollBufferMaterial(webglObject);
	                webglObject.render = true;
	            }
	        }

	        // set matrices for immediate objects

	        var material = null;

	        // opaque pass (front-to-back order)

	        this.setBlending(false);

	        renderObjects(scene.__webglObjects, true, "opaque", camera, lights,
	                fog, false, material);

	        // prime depth buffer
	        renderObjects(scene.__webglObjects, true, "blank", camera, lights, fog,
	                true, material);

	        // transparent pass (back-to-front order)

	        renderObjects(scene.__webglObjects, false, "transparent", camera,
	                lights, fog, true, material);

	        // Render plugins (e.g. sprites), and reset state

	        renderPlugins(this.renderPluginsPost, scene, camera);

	        // Ensure depth buffer writing is enabled so it can be cleared on next
	        // render

	        this.setDepthTest(true);
	        this.setDepthWrite(true);

	        // _gl.finish();

	    };

	    function renderPlugins(plugins, scene, camera) {

	        // Reset state once regardless
	        // This should also fix cartoon render bug (after transparent surface
	        // render)

	        _currentGeometryGroupHash = -1;
	        _currentProgram = null;
	        _currentCamera = null;
	        _oldBlending = -1;
	        _oldDepthWrite = -1;
	        _oldDepthTest = -1;
	        _oldDoubleSided = -1;
	        _currentMaterialId = -1;
	        _oldFlipSided = -1;

	        if (!plugins.length)
	            return;

	        for (var i = 0, il = plugins.length; i < il; i++) {

	            _lightsNeedUpdate = true;

	            plugins[i].render(scene, camera, _currentWidth, _currentHeight);

	            // Reset state after plugin render
	            _currentGeometryGroupHash = -1;
	            _currentProgram = null;
	            _currentCamera = null;
	            _oldBlending = -1;
	            _oldDepthWrite = -1;
	            _oldDepthTest = -1;
	            _oldDoubleSided = -1;
	            _currentMaterialId = -1;
	            _oldFlipSided = -1;

	        }

	    }

	    this.initWebGLObjects = function(scene) {

	        if (!scene.__webglObjects) {

	            scene.__webglObjects = [];
	            scene.__webglObjectsImmediate = [];
	            scene.__webglSprites = [];
	            scene.__webglFlares = [];

	        }

	        // Add objects; this sets up buffers for each geometryGroup
	        if (scene.__objectsAdded.length) {

	            while (scene.__objectsAdded.length) {
	                addObject(scene.__objectsAdded[0], scene);
	                scene.__objectsAdded.splice(0, 1);
	            }

	            // Force buffer update during render
	            // Hackish fix for initial cartoon-render-then-transparent-surface
	            // bug
	            _currentGeometryGroupHash = -1;

	        }

	        while (scene.__objectsRemoved.length) {

	            removeObject(scene.__objectsRemoved[0], scene);
	            scene.__objectsRemoved.splice(0, 1);

	        }

	        // update must be called after objects adding / removal
	        // This sends typed arrays to GL buffers for each geometryGroup
	        for (var o = 0, ol = scene.__webglObjects.length; o < ol; o++) {

	            updateObject(scene.__webglObjects[o].object);

	        }

	    };

	    // Objects adding

	    function addObject(object, scene) {

	        var g, gl, geometry, material, geometryGroup;

	        if (!object.__webglInit) {

	            object.__webglInit = true;

	            object._modelViewMatrix = new $3Dmol.Matrix4();
	            object._normalMatrix = new $3Dmol.Matrix3();

	            if (object.geometry !== undefined
	                    && object.geometry.__webglInit === undefined) {

	                object.geometry.__webglInit = true;
	                object.geometry.addEventListener('dispose', onGeometryDispose);

	            }

	            if (object instanceof $3Dmol.Mesh || object instanceof $3Dmol.Line) {
	                geometry = object.geometry;
	                material = object.material;

	                for (g = 0, gl = geometry.geometryGroups.length; g < gl; g++) {

	                    geometryGroup = geometry.geometryGroups[g];

	                    geometryGroup.id = _geometryGroupCounter++;

	                    // initialise VBO on the first access

	                    if (!geometryGroup.__webglVertexBuffer) {

	                        if (object instanceof $3Dmol.Mesh) {
	                            createMeshBuffers(geometryGroup);
	                            geometry.elementsNeedUpdate = true;
	                            geometry.normalsNeedUpdate = true;
	                        }

	                        else if (object instanceof $3Dmol.Line)
	                            createLineBuffers(geometryGroup);

	                        geometry.verticesNeedUpdate = true;
	                        geometry.colorsNeedUpdate = true;

	                    }

	                }

	            }

	        }

	        if (!object.__webglActive) {

	            if (object instanceof $3Dmol.Mesh || object instanceof $3Dmol.Line) {

	                geometry = object.geometry;

	                for (g = 0, gl = geometry.geometryGroups.length; g < gl; g++) {
	                    geometryGroup = geometry.geometryGroups[g];

	                    addBuffer(scene.__webglObjects, geometryGroup, object);
	                }

	            }

	            // Sprite
	            else if (object instanceof $3Dmol.Sprite)
	                scene.__webglSprites.push(object);

	            object.__webglActive = true;

	        }

	    }

	    function updateObject(object) {

	        var geometry = object.geometry, material = object.material, geometryGroup, customAttributesDirty;

	        if (object instanceof $3Dmol.Mesh || object instanceof $3Dmol.Line) {

	            for (var g = 0, gl = geometry.geometryGroups.length; g < gl; g++) {

	                geometryGroup = geometry.geometryGroups[g];

	                if (geometry.verticesNeedUpdate || geometry.elementsNeedUpdate
	                        || geometry.colorsNeedUpdate
	                        || geometry.normalsNeedUpdate) {
	                    setBuffers(geometryGroup, _gl.STATIC_DRAW);
	                }
	            }

	            geometry.verticesNeedUpdate = false;
	            geometry.elementsNeedUpdate = false;
	            geometry.normalsNeedUpdate = false;
	            geometry.colorsNeedUpdate = false;

	            geometry.buffersNeedUpdate = false;

	        }

	    }

	    function removeObject(object, scene) {

	        if (object instanceof $3Dmol.Mesh || object instanceof $3Dmol.Line)
	            removeInstances(scene.__webglObjects, object);

	        else if (object instanceof $3Dmol.Sprite)
	            removeInstancesDirect(scene.__webglSprites, object);

	        object.__webglActive = false;

	    }

	    function removeInstances(objList, object) {

	        for (var o = objList.length - 1; o >= 0; --o) {

	            if (objList[o].object === object)
	                objList.splice(o, 1);

	        }
	    }

	    function removeInstancesDirect(objList, object) {

	        for (var o = objList.length - 1; o >= 0; --o) {

	            if (objList[o] === object)
	                objList.splice(o, 1);

	        }
	    }

	    function unrollBufferMaterial(globject) {

	        var object = globject.object;
	        var material = object.material;

	        if (material.transparent) {
	            globject.opaque = null;
	            globject.transparent = material;
	            if (!material.wireframe) {
	                var blankMaterial = material.clone();
	                blankMaterial.opacity = 0.0;
	                globject.blank = blankMaterial;
	            }
	        }

	        else {
	            globject.opaque = material;
	            globject.transparent = null;

	        }

	    }

	    function setBuffers(geometryGroup, hint, line) {

	        var vertexArray = geometryGroup.vertexArray;
	        var colorArray = geometryGroup.colorArray;

	        // offset buffers
	        if (geometryGroup.__webglOffsetBuffer !== undefined ) {
	            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglOffsetBuffer);
	            _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
	        }
	        else {
	            //normal, non-instanced case
	            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
	            _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);            
	        }
	        // color buffers
	        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
	        _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);

	        // normal buffers
	        if (geometryGroup.normalArray
	                && geometryGroup.__webglNormalBuffer !== undefined) {
	            var normalArray = geometryGroup.normalArray;
	            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
	            _gl.bufferData(_gl.ARRAY_BUFFER, normalArray, hint);

	        }



	        // radius buffers
	        if (geometryGroup.radiusArray
	                && geometryGroup.__webglRadiusBuffer !== undefined) {
	            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglRadiusBuffer);
	            _gl.bufferData(_gl.ARRAY_BUFFER, geometryGroup.radiusArray, hint);
	        }

	        // face (index) buffers
	        if (geometryGroup.faceArray
	                && geometryGroup.__webglFaceBuffer !== undefined) {
	            var faceArray = geometryGroup.faceArray;
	            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER,
	                    geometryGroup.__webglFaceBuffer);
	            _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, faceArray, hint);

	        }

	        // line (index) buffers (for wireframe)
	        if (geometryGroup.lineArray
	                && geometryGroup.__webglLineBuffer !== undefined) {
	            var lineArray = geometryGroup.lineArray;
	            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER,
	                    geometryGroup.__webglLineBuffer);
	            _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, lineArray, hint);
	        }

	    }

	    // Creates appropriate gl buffers for geometry chunk
	    // TODO: do we need line buffer for mesh objects?
	    // Also, can we integrate this with createLineBuffers?
	    function createMeshBuffers(geometryGroup) {

	        if (geometryGroup.radiusArray) {
	            geometryGroup.__webglRadiusBuffer = _gl.createBuffer();
	        }
	        if(geometryGroup.useOffset) {
	            geometryGroup.__webglOffsetBuffer = _gl.createBuffer();
	        }
	        geometryGroup.__webglVertexBuffer = _gl.createBuffer();
	        geometryGroup.__webglNormalBuffer = _gl.createBuffer();
	        geometryGroup.__webglColorBuffer = _gl.createBuffer();

	        geometryGroup.__webglFaceBuffer = _gl.createBuffer();
	        geometryGroup.__webglLineBuffer = _gl.createBuffer();

	        _this.info.memory.geometries++;
	    }

	    function createLineBuffers(geometry) {

	        geometry.__webglVertexBuffer = _gl.createBuffer();
	        geometry.__webglColorBuffer = _gl.createBuffer();

	        _this.info.memory.geometries++;
	    }

	    function addBuffer(objlist, buffer, object) {

	        objlist.push({
	            buffer : buffer,
	            object : object,
	            opaque : null,
	            transparent : null
	        });

	    }

	    function setupMatrices(object, camera) {

	        object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,
	                object.matrixWorld);

	        object._normalMatrix.getInverse(object._modelViewMatrix);
	        object._normalMatrix.transpose();

	    }

	    function isPowerOfTwo(value) {

	        return (value & (value - 1)) === 0;

	    }

	    // Fallback filters for non-power-of-2 textures

	    function filterFallback(f) {

	        return _gl.LINEAR;

	    }

	    function setTextureParameters(textureType, texture, isImagePowerOfTwo) {

	        if (isImagePowerOfTwo) {

	            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S,
	                    paramToGL(texture.wrapS));
	            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T,
	                    paramToGL(texture.wrapT));

	            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER,
	                    paramToGL(texture.magFilter));
	            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER,
	                    paramToGL(texture.minFilter));

	        } else {

	            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S,
	                    _gl.CLAMP_TO_EDGE);
	            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T,
	                    _gl.CLAMP_TO_EDGE);

	            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER,
	                    filterFallback(texture.magFilter));
	            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER,
	                    filterFallback(texture.minFilter));

	        }

	    }

	    this.setTexture = function(texture, slot) {

	        if (texture.needsUpdate) {

	            if (!texture.__webglInit) {

	                texture.__webglInit = true;

	                texture.addEventListener('dispose', onTextureDispose);

	                texture.__webglTexture = _gl.createTexture();

	                _this.info.memory.textures++;

	            }

	            _gl.activeTexture(_gl.TEXTURE0 + slot);
	            _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);

	            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
	            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
	                    texture.premultiplyAlpha);
	            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

	            var image = texture.image, isImagePowerOfTwo = isPowerOfTwo(image.width)
	                    && isPowerOfTwo(image.height), glFormat = paramToGL(texture.format), glType = paramToGL(texture.type);

	            setTextureParameters(_gl.TEXTURE_2D, texture, isImagePowerOfTwo);

	            var mipmap, mipmaps = texture.mipmaps;

	            // regular Texture (image, video, canvas)

	            // use manually created mipmaps if available
	            // if there are no manual mipmaps
	            // set 0 level mipmap and then use GL to generate other mipmap
	            // levels

	            if (mipmaps.length > 0 && isImagePowerOfTwo) {

	                for (var i = 0, il = mipmaps.length; i < il; i++) {
	                    mipmap = mipmaps[i];
	                    _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat,
	                            glType, mipmap);
	                }

	                texture.generateMipmaps = false;
	            }

	            else
	                _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType,
	                        texture.image);

	            if (texture.generateMipmaps && isImagePowerOfTwo)
	                _gl.generateMipmap(_gl.TEXTURE_2D);

	            texture.needsUpdate = false;

	            if (texture.onUpdate)
	                texture.onUpdate();

	        } else {

	            _gl.activeTexture(_gl.TEXTURE0 + slot);
	            _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);

	        }

	    };

	    // Map constants to WebGL constants

	    function paramToGL(p) {

	        if (p === $3Dmol.UnsignedByteType)
	            return _gl.UNSIGNED_BYTE;
	        if (p === $3Dmol.RGBAFormat)
	            return _gl.RGBA;

	        return 0;

	    }

	    function setupLights(program, lights) {
	        var l, ll, light, n, r = 0, g = 0, b = 0, color, position, intensity, distance,

	        zlights = _lights,

	        dirColors = zlights.directional.colors, dirPositions = zlights.directional.positions,

	        dirCount = 0, dirLength = 0, dirOffset = 0;

	        for (l = 0, ll = lights.length; l < ll; l++) {

	            light = lights[l];

	            color = light.color;
	            intensity = light.intensity;
	            distance = light.distance;

	            if (light instanceof $3Dmol.Light) {

	                dirCount++;

	                _direction.getPositionFromMatrix(light.matrixWorld);
	                _vector3.getPositionFromMatrix(light.target.matrixWorld);
	                _direction.sub(_vector3);
	                _direction.normalize();

	                if (_direction.x === 0 && _direction.y === 0
	                        && _direction.z === 0)
	                    continue;

	                dirPositions[dirOffset] = _direction.x;
	                dirPositions[dirOffset + 1] = _direction.y;
	                dirPositions[dirOffset + 2] = _direction.z;

	                dirColors[dirOffset] = color.r * intensity;
	                dirColors[dirOffset + 1] = color.g * intensity;
	                dirColors[dirOffset + 2] = color.b * intensity;

	                dirOffset += 3;

	                dirLength++;
	            }

	        }

	        zlights.ambient[0] = r;
	        zlights.ambient[1] = g;
	        zlights.ambient[2] = b;
	        zlights.directional.length = dirLength;
	    }

	    function initGL() {

	        try {

	            if (!(_gl = _canvas.getContext('experimental-webgl', {
	                alpha : _alpha,
	                premultipliedAlpha : _premultipliedAlpha,
	                antialias : _antialias,
	                stencil : _stencil,
	                preserveDrawingBuffer : _preserveDrawingBuffer
	            }))) {
	                if (!(_gl = _canvas.getContext('webgl', {
	                    alpha : _alpha,
	                    premultipliedAlpha : _premultipliedAlpha,
	                    antialias : _antialias,
	                    stencil : _stencil,
	                    preserveDrawingBuffer : _preserveDrawingBuffer
	                }))) {
	                    throw 'Error creating WebGL context.';
	                }
	            }

	        } catch (error) {

	            console.error(error);
	        }
	    }

	    function setDefaultGLState() {

	        _gl.clearColor(0, 0, 0, 1);
	        _gl.clearDepth(1);
	        _gl.clearStencil(0);

	        _gl.enable(_gl.DEPTH_TEST);
	        _gl.depthFunc(_gl.LEQUAL);

	        _gl.frontFace(_gl.CCW);
	        _gl.cullFace(_gl.BACK);
	        _gl.enable(_gl.CULL_FACE);

	        _gl.enable(_gl.BLEND);
	        _gl.blendEquation(_gl.FUNC_ADD);
	        _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);

	        _gl.clearColor(_clearColor.r, _clearColor.g, _clearColor.b,
	                        _clearAlpha);
	    }

	    this.addPostPlugin(new $3Dmol.SpritePlugin());

	};
	/*
	 * Scene class
	 */
	/** @constructor */
	$3Dmol.Scene = function() {
	    
	    $3Dmol.Object3D.call(this);
	    
	    this.fog = null;
	    
	    //May not need...
	    this.overrideMaterial = null;
	    
	    this.matrixAutoUpdate = false;
	    
	    this.__objects = [];
	    this.__lights = [];
	    
	    this.__objectsAdded = [];
	    this.__objectsRemoved = [];
	    
	};

	$3Dmol.Scene.prototype = Object.create($3Dmol.Object3D.prototype);

	$3Dmol.Scene.prototype.__addObject = function(object) {
	    
	    //Directional Lighting
	    if (object instanceof $3Dmol.Light) {
	        
	        if (this.__lights.indexOf(object) === -1)
	            this.__lights.push(object);
	        
	        //TODO: Do I need this??
	        if (object.target && object.target.parent === undefined)
	            this.add(object.target);
	            
	    }
	    
	    //Rotation group
	    else {
	        
	        if (this.__objects.indexOf(object) === -1) {
	            
	            this.__objects.push(object);
	            this.__objectsAdded.push(object);
	            
	            //Check if previously removed
	            
	            var idx = this.__objectsRemoved.indexOf(object);
	            
	            if (idx !== -1)
	                this.__objectsRemoved.splice(i, 1);
	                
	        }
	    }
	    
	    //Add object's children
	    
	    for (var i = 0; i < object.children.length; i++) 
	        this.__addObject(object.children[i]);
	    
	};

	$3Dmol.Scene.prototype.__removeObject = function(object) {
	    
	    var idx;
	    if (object instanceof $3Dmol.Light) {
	        
	        idx = this.__lights.indexOf(object);
	        
	        if (idx !== -1)
	            this.__lights.splice(idx, 1);
	            
	    }
	    
	    //Object3D
	    else {
	        
	        idx = this.__objects.indexOf(object);
	        
	        if (idx !== -1) {
	            
	            this.__objects.splice(idx, 1);
	            this.__objectsRemoved.push(object);
	            
	            //Check if previously added
	            
	            var ai = this.__objectsAdded.indexOf(object);
	            
	            if (ai !== -1) 
	                this.__objectsAdded.splice(idx, 1);
	                
	        }
	    
	    }
	    
	    //Remove object's children
	    for (var i = 0; i < object.children.length; i++)
	        this.__removeObject(object.children[i]);
	    
	};


	/*
	 * Fog Class
	 */

	/** @constructor */
	$3Dmol.Fog = function ( hex, near, far ) {

	    this.name = '';

	    this.color = new $3Dmol.Color( hex );

	    this.near = ( near !== undefined ) ? near : 1;
	    this.far = ( far !== undefined ) ? far : 1000;

	};

	$3Dmol.Fog.prototype.clone = function () {

	    return new $3Dmol.Fog( this.color.getHex(), this.near, this.far );

	};

	$3Dmol.ShaderUtils = {
	    
	    clone: function ( uniforms_src ) {
	        
	        var u, p, parameter, parameter_src, uniforms_clone = {};
	        
	        for (u in uniforms_src) {
	            uniforms_clone[u] = {};
	            uniforms_clone[u].type = uniforms_src[u].type;
	            
	            var srcValue = uniforms_src[u].value;
	            
	            if (srcValue instanceof $3Dmol.Color)
	                uniforms_clone[u].value = srcValue.clone();
	            else if (typeof srcValue === "number")
	                uniforms_clone[u].value = srcValue;
	            else if (srcValue instanceof Array) 
	                uniforms_clone[u].value = [];
	            else
	                console.error("Error copying shader uniforms from ShaderLib: unknown type for uniform");
	            
	        }
	        
	        return uniforms_clone;
	    },
	    //fragment shader reused by outline shader
	    stickimposterFragmentShader: [
	     "uniform float opacity;",
	     "uniform mat4 projectionMatrix;",

	     "uniform vec3 fogColor;",
	     "uniform float fogNear;",
	     "uniform float fogFar;",

	     "varying vec3 vLight;",
	     "varying vec3 vColor;",
	     "varying vec3 cposition;",
	     "varying vec3 p1;",
	     "varying vec3 p2;",
	     "varying float r;",


	     //cylinder-ray intersection testing taken from http://mrl.nyu.edu/~dzorin/cg05/lecture12.pdf
	     //also useful: http://stackoverflow.com/questions/9595300/cylinder-impostor-in-glsl
	     //with a bit more care (caps) this could be a general cylinder imposter (see also outline)
	     "void main() {",   
	     "    vec3 color = abs(vColor);",
	     "    vec3 pos = cposition;",
	     "    vec3 p = pos;", //ray point
	     "    vec3 v = normalize(pos);", //ray normal
	     "    vec3 pa = p1;", //cyl start
	     "    vec3 va = normalize(p2-p1);", //cyl norm
	     "    vec3 tmp1 = v-(dot(v,va)*va);",
	     "    vec3 deltap = p-pa;",
	     "    float A = dot(tmp1,tmp1);",
	     "    if(A == 0.0) discard;",
	     "    vec3 tmp2 = deltap-(dot(deltap,va)*va);",
	     "    float B = 2.0*dot(tmp1, tmp2);",
	     "    float C = dot(tmp2,tmp2)-r*r;",
	     //quadratic equation!
	     "    float det = (B*B) - (4.0*A*C);",
	     "    if(det < 0.0) discard;",
	     "    float sqrtDet = sqrt(det);",
	     "    float posT = (-B+sqrtDet)/(2.0*A);",
	     "    float negT = (-B-sqrtDet)/(2.0*A);",
	     "    float intersectionT = min(posT,negT);",
	     "    vec3 qi = p+v*intersectionT;", 
	     "    float dotp1 = dot(va,qi-p1);",
	     "    float dotp2 = dot(va,qi-p2);",
	     "    vec3 norm;",
	     "    if( dotp1 < 0.0 || dotp2 > 0.0) {", //(p-c)^2 + 2(p-c)vt +v^2+t^2 - r^2 = 0
	     "       vec3 cp;",
	     "       if( dotp1 < 0.0) {" +
	     //"        if(vColor.x < 0.0 ) discard;", //color sign bit indicates if we should cap or not
	     "        cp = p1;",
	     "       } else {",
	     //"          if(vColor.y < 0.0 ) discard;",
	     "          cp = p2;",
	     "       }",
	     "       vec3 diff = p-cp;",
	     "       A = dot(v,v);",
	     "       B = dot(diff,v)*2.0;",
	     "       C = dot(diff,diff)-r*r;",
	     "       det = (B*B) - (4.0*C);",
	     "       if(det < 0.0) discard;",
	     "       sqrtDet = sqrt(det);",
	     "       posT = (-B+sqrtDet)/(2.0);",
	     "       negT = (-B-sqrtDet)/(2.0);",
	     "       float t = min(posT,negT);",
	     "       qi = p+v*t;",
	     "       norm = normalize(qi-cp);",
	     "    } else {",
	     "       norm = normalize(qi-(dotp1*va + p1));",
	     "    }",
	     "    vec4 clipPos = projectionMatrix * vec4(qi, 1.0);",
	     "    float ndcDepth = clipPos.z / clipPos.w;",
	     "    float depth = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;",
	     "    gl_FragDepthEXT = depth;",
	    ].join("\n")  
	};

	$3Dmol.ShaderLib = { 
	    'basic' : {
	        fragmentShader : [                    
	"uniform mat4 viewMatrix;",
	"uniform float opacity;",

	"uniform vec3 fogColor;",
	"uniform float fogNear;",
	"uniform float fogFar;",

	"varying vec3 vColor;",

	"void main() {",
	    
	"    gl_FragColor = vec4( vColor, opacity );",
	    
	"    float depth = gl_FragCoord.z / gl_FragCoord.w;",    
	"    float fogFactor = smoothstep( fogNear, fogFar, depth );",
	    
	"    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

	"}"
	                                                     
	].join("\n"),
	        
	        vertexShader : [

	"uniform mat4 modelViewMatrix;",
	"uniform mat4 projectionMatrix;",
	"uniform mat4 viewMatrix;",
	"uniform mat3 normalMatrix;",

	"attribute vec3 position;",
	"attribute vec3 color;",

	"varying vec3 vColor;",

	"void main() {",

	"    vColor = color;",
	"    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	"    gl_Position = projectionMatrix * mvPosition;",

	"}"
	        
	].join("\n"),
	    
	        uniforms : {
	            opacity: { type: 'f', value: 1.0 },
	            fogColor: { type: 'c', value: new $3Dmol.Color(1.0, 1.0, 1.0) },
	            fogNear: { type: 'f', value: 1.0 },
	            fogFar: { type: 'f', value: 2000}
	        }

	    },
	    
	 'sphereimposter' : {
	        fragmentShader : [
	"uniform mat4 viewMatrix;",
	"uniform float opacity;",
	"uniform mat4 projectionMatrix;",

	"uniform vec3 fogColor;",
	"uniform float fogNear;",
	"uniform float fogFar;",
	"uniform float uDepth;",
	"uniform vec3 directionalLightColor[ 1 ];",

	"varying vec3 vColor;",
	"varying vec2 mapping;",
	"varying float rval;",
	"varying vec3 vLight;",
	"varying vec3 center;",


	"void main() {",
	"    float lensqr = dot(mapping,mapping);",
	"    float rsqr = rval*rval;",
	"    if(lensqr > rsqr)",
	"       discard;",
	"    float z = sqrt(rsqr-lensqr);",
	"    vec3 cameraPos = center+ vec3(mapping.x,mapping.y,z);",
	"    vec4 clipPos = projectionMatrix * vec4(cameraPos, 1.0);",
	"    float ndcDepth = clipPos.z / clipPos.w;",
	"    gl_FragDepthEXT = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;",
	"    vec3 norm = normalize(vec3(mapping.x,mapping.y,z));",
	"    float dotProduct = dot( norm, vLight );",
	"    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",    
	"    vec3 vLight = directionalLightColor[ 0 ] * directionalLightWeighting;",
	"    gl_FragColor = vec4(vLight*vColor, opacity*opacity );", 
	"    float fogFactor = smoothstep( fogNear, fogFar, gl_FragDepthEXT/gl_FragCoord.w );",
	"    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",


	"}"
	                                                     
	].join("\n"),
	        
	        vertexShader : [

	"uniform mat4 modelViewMatrix;",
	"uniform mat4 projectionMatrix;",
	"uniform mat4 viewMatrix;",
	"uniform mat3 normalMatrix;",
	"uniform vec3 directionalLightColor[ 1 ];",
	"uniform vec3 directionalLightDirection[ 1 ];",

	"attribute vec3 position;",
	"attribute vec3 normal;",
	"attribute vec3 color;",

	"varying vec2 mapping;",
	"varying vec3 vColor;",
	"varying float rval;",
	"varying vec3 vLight;",
	"varying vec3 center;",

	"void main() {",

	"    vColor = color;",
	"    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	"    center = mvPosition.xyz;",
	"    vec4 projPosition = projectionMatrix * mvPosition;",
	"    vec4 adjust = projectionMatrix* vec4(normal,0.0); adjust.z = 0.0; adjust.w = 0.0;",
	"    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );",
	"    vLight = normalize( lDirection.xyz );",
	"    mapping = normal.xy;",
	"    rval = abs(normal.x);",
	"    gl_Position = projPosition+adjust;",

	"}"
	        
	].join("\n"),
	    
	        uniforms : {
	            opacity: { type: 'f', value: 1.0 },
	            fogColor: { type: 'c', value: new $3Dmol.Color(1.0, 1.0, 1.0) },
	            fogNear: { type: 'f', value: 1.0 },
	            fogFar: { type: 'f', value: 2000},
	            directionalLightColor: { type: 'fv', value: [] },
	            directionalLightDirection: { type: 'fv', value: [] }
	        }

	    },
	    
	    
	    'lambert' : { 
	        fragmentShader : [

	"uniform mat4 viewMatrix;",
	"uniform float opacity;",

	"uniform vec3 fogColor;",
	"uniform float fogNear;",
	"uniform float fogFar;",

	"varying vec3 vLightFront;",
	"varying vec3 vColor;",

	"void main() {",
	    
	"    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
	    
	"    #ifndef WIREFRAME",
	"    gl_FragColor.xyz *= vLightFront;",
	"    #endif",
	    
	"    gl_FragColor = gl_FragColor * vec4( vColor, opacity );",
	"    float depth = gl_FragCoord.z / gl_FragCoord.w;",
	    
	"    float fogFactor = smoothstep( fogNear, fogFar, depth );",
	    
	"    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

	"}"


	].join("\n"),
	       
	       vertexShader : [

	"uniform mat4 modelViewMatrix;",
	"uniform mat4 projectionMatrix;",
	"uniform mat4 viewMatrix;",
	"uniform mat3 normalMatrix;",
	"uniform vec3 directionalLightColor[ 1 ];",
	"uniform vec3 directionalLightDirection[ 1 ];",

	"attribute vec3 position;",
	"attribute vec3 normal;",
	"attribute vec3 color;",

	"varying vec3 vColor;",
	"varying vec3 vLightFront;",

	"void main() {",
	    
	"    vColor = color;",
	    
	"    vec3 objectNormal = normal;",  
	"    vec3 transformedNormal = normalMatrix * objectNormal;",    
	"    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	    
	"    vLightFront = vec3( 0.0 );",
	    
	"    transformedNormal = normalize( transformedNormal );",
	    
	"    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );",
	"    vec3 dirVector = normalize( lDirection.xyz );",
	"    float dotProduct = dot( transformedNormal, dirVector );",
	"    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",
	    
	"    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;",
	    
	"    gl_Position = projectionMatrix * mvPosition;",
	"}"
	           
	].join("\n"),

	        uniforms : {
	            opacity: { type: 'f', value: 1.0 },
	            fogColor: { type: 'c', value: new $3Dmol.Color(1.0, 1.0, 1.0) },
	            fogNear: { type: 'f', value: 1.0 },
	            fogFar: { type: 'f', value: 2000},
	            directionalLightColor: { type: 'fv', value: [] },
	            directionalLightDirection: { type: 'fv', value: [] }
	        }

	    },


	    'instanced' : {
	        fragmentShader : [

	"uniform mat4 viewMatrix;",
	"uniform float opacity;",

	"uniform vec3 fogColor;",
	"uniform float fogNear;",
	"uniform float fogFar;",

	"varying vec3 vLightFront;",
	"varying vec3 vColor;",

	"void main() {",

	"    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

	"    #ifndef WIREFRAME",
	"    gl_FragColor.xyz *= vLightFront;",
	"    #endif",

	"    gl_FragColor = gl_FragColor * vec4( vColor, opacity );",
	"    float depth = gl_FragCoord.z / gl_FragCoord.w;",

	"    float fogFactor = smoothstep( fogNear, fogFar, depth );",

	"    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

	"}"


	].join("\n"),

	       vertexShader : [

	"uniform mat4 modelViewMatrix;",
	"uniform mat4 projectionMatrix;",
	"uniform mat4 viewMatrix;",
	"uniform mat3 normalMatrix;",
	"uniform vec3 directionalLightColor[ 1 ];",
	"uniform vec3 directionalLightDirection[ 1 ];",

	"attribute vec3 offset;",
	"attribute vec3 position;",
	"attribute vec3 normal;",
	"attribute vec3 color;",
	"attribute float radius;",

	"varying vec3 vColor;",
	"varying vec3 vLightFront;",

	"void main() {",

	"    vColor = color;",

	"    vec3 objectNormal = normal;",
	"    vec3 transformedNormal = normalMatrix * objectNormal;",
	"    vec4 mvPosition = modelViewMatrix * vec4( position * radius + offset, 1.0 );",

	"    vLightFront = vec3( 0.0 );",

	"    transformedNormal = normalize( transformedNormal );",

	"    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );",
	"    vec3 dirVector = normalize( lDirection.xyz );",
	"    float dotProduct = dot( transformedNormal, dirVector );",
	"    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",

	"    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;",

	"    gl_Position = projectionMatrix * mvPosition;",
	"}"

	].join("\n"),

	        uniforms : {
	            opacity: { type: 'f', value: 1.0 },
	            fogColor: { type: 'c', value: new $3Dmol.Color(1.0, 1.0, 1.0) },
	            fogNear: { type: 'f', value: 1.0 },
	            fogFar: { type: 'f', value: 2000},
	            directionalLightColor: { type: 'fv', value: [] },
	            directionalLightDirection: { type: 'fv', value: [] }
	        }

	    },
	 
	//for outline
	     'outline' : { 
	        fragmentShader : [

	"uniform float opacity;",
	"uniform vec3 outlineColor;",
	"uniform vec3 fogColor;",
	"uniform float fogNear;",
	"uniform float fogFar;",

	"void main() {",
	    
	"    gl_FragColor = vec4( outlineColor, 1 );",
	"}"


	].join("\n"),
	       
	       vertexShader : [

	"uniform mat4 modelViewMatrix;",
	"uniform mat4 projectionMatrix;",
	"uniform float outlineWidth;",
	"uniform float outlinePushback;",

	"attribute vec3 position;",
	"attribute vec3 normal;",
	"attribute vec3 color;",

	"void main() {",

	"    vec4 norm = modelViewMatrix*vec4(normalize(normal),0.0);",
	"    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	"    mvPosition.xy += norm.xy*outlineWidth;",
	"    gl_Position = projectionMatrix * mvPosition;",
	"    mvPosition.z -= outlinePushback;", //go backwards in model space
	"    vec4 pushpos = projectionMatrix*mvPosition;", //project to get z in projection space, I'm probably missing some simple math to do the same thing..
	"    gl_Position.z = gl_Position.w*pushpos.z/pushpos.w;",
	"}"
	           
	].join("\n"),

	        uniforms : {
	            opacity: { type: 'f', value: 1.0 },
	            outlineColor: { type: 'c', value: new $3Dmol.Color(0.0, 0.0, 0.0) },
	            fogColor: { type: 'c', value: new $3Dmol.Color(1.0, 1.0, 1.0) },
	            fogNear: { type: 'f', value: 1.0 },
	            fogFar: { type: 'f', value: 2000},           
	            outlineWidth: { type: 'f', value: 0.1 },
	            outlinePushback: { type: 'f', value: 1.0 },
	        }

	    },
	//for outlining sphere imposter
	    'sphereimposteroutline' : { 
	       fragmentShader : [

	"uniform float opacity;",
	"uniform vec3 outlineColor;",
	"uniform vec3 fogColor;",
	"uniform float fogNear;",
	"uniform float fogFar;",
	"uniform mat4 projectionMatrix;",
	"varying vec2 mapping;",
	"varying float rval;",
	"varying vec3 center;",

	"uniform float outlinePushback;",


	"void main() {",
	"    float lensqr = dot(mapping,mapping);",
	"    float rsqr = rval*rval;",
	"    if(lensqr > rsqr)",
	"       discard;",
	"    float z = sqrt(rsqr-lensqr);",
	"    vec3 cameraPos = center+ vec3(mapping.x,mapping.y,z-outlinePushback);",
	"    vec4 clipPos = projectionMatrix * vec4(cameraPos, 1.0);",
	"    float ndcDepth = clipPos.z / clipPos.w;",
	"    gl_FragDepthEXT = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;",
	"    gl_FragColor = vec4(outlineColor, 1 );",
	"}"


	].join("\n"),
	      
	      vertexShader : [

	"uniform mat4 modelViewMatrix;",
	"uniform mat4 projectionMatrix;",
	"uniform float outlineWidth;",
	"uniform float outlinePushback;",

	"attribute vec3 position;",
	"attribute vec3 normal;",
	"attribute vec3 color;",

	"varying vec2 mapping;",
	"varying float rval;",
	"varying vec3 center;",

	"void main() {",

	"    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	"    center = mvPosition.xyz;",
	"    vec4 projPosition = projectionMatrix * mvPosition;",
	"    vec2 norm = normal.xy + vec2(sign(normal.x)*outlineWidth,sign(normal.y)*outlineWidth);", 
	"    vec4 adjust = projectionMatrix* vec4(norm,normal.z,0.0); adjust.z = 0.0; adjust.w = 0.0;",
	"    mapping = norm.xy;",
	"    rval = abs(norm.x);",
	"    gl_Position = projPosition+adjust;",
	"}"
	          
	].join("\n"),

	       uniforms : {
	           opacity: { type: 'f', value: 1.0 },
	           outlineColor: { type: 'c', value: new $3Dmol.Color(0.0, 0.0, 0.0) },
	           fogColor: { type: 'c', value: new $3Dmol.Color(1.0, 1.0, 1.0) },
	           fogNear: { type: 'f', value: 1.0 },
	           fogFar: { type: 'f', value: 2000},           
	           outlineWidth: { type: 'f', value: 0.1 },
	           outlinePushback: { type: 'f', value: 1.0 },
	       }

	   },
	   //stick imposters
	   'stickimposter' : { 
	      fragmentShader : [$3Dmol.ShaderUtils.stickimposterFragmentShader,
	    "    float dotProduct = dot( norm, vLight );",
	    "    vec3 light = vec3( max( dotProduct, 0.0 ) );",    
	    "    gl_FragColor = vec4(light*color, opacity*opacity );", 
	    "    float fogFactor = smoothstep( fogNear, fogFar, depth );",   
	    "    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",
	    "}"].join("\n"),
	      vertexShader : [

	"uniform mat4 modelViewMatrix;",
	"uniform mat4 projectionMatrix;",
	"uniform mat4 viewMatrix;",
	"uniform mat3 normalMatrix;",
	"uniform vec3 directionalLightColor[ 1 ];",
	"uniform vec3 directionalLightDirection[ 1 ];",

	"attribute vec3 position;",
	"attribute vec3 normal;",
	"attribute vec3 color;",
	"attribute float radius;",

	"varying vec3 vColor;",
	"varying vec3 vLight;",
	"varying vec3 cposition;",
	"varying vec3 p1;",
	"varying vec3 p2;",
	"varying float r;",

	"void main() {",
	   
	"    vColor = color; vColor.z = abs(vColor.z);", //z indicates which vertex and so would vary
	"    r = abs(radius);",
	"    vec4 to = modelViewMatrix*vec4(normal, 1.0);", //normal is other point of cylinder
	"    vec4 pt = modelViewMatrix*vec4(position, 1.0);",
	"    vec4 mvPosition = pt;",
	"    p1 = pt.xyz; p2 = to.xyz;",
	"    vec3 norm = to.xyz-pt.xyz;","" +
	"    float mult = 1.1;", //slop to account for perspective of sphere
	"    if(length(p1) > length(p2)) {", //billboard at level of closest point
	"       mvPosition = to;",
	"    }",
	"    vec3 n = normalize(mvPosition.xyz);",
	//intersect with the plane defined by the camera looking at the billboard point
	"    if(color.z >= 0.0) {", //p1
	"       vec3 pnorm = normalize(p1);",
	"       float t = dot(mvPosition.xyz-p1,n)/dot(pnorm,n);",
	"       mvPosition.xyz = p1+t*pnorm;",
	"    } else {",
	"       vec3 pnorm = normalize(p2);",
	"       float t = dot(mvPosition.xyz-p2,n)/dot(pnorm,n);",
	"       mvPosition.xyz = p2+t*pnorm;",
	"       mult *= -1.0;",
	"    }",
	"    vec3 cr = normalize(cross(mvPosition.xyz,norm))*radius;", 
	"    vec3 doublecr = normalize(cross(mvPosition.xyz,cr))*radius;", 
	"    mvPosition.xy +=  mult*(cr + doublecr).xy;",
	"    cposition = mvPosition.xyz;",
	"    gl_Position = projectionMatrix * mvPosition;",
	"    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );",
	"    vLight = normalize( lDirection.xyz )*directionalLightColor[0];", //not really sure this is right, but color is always white so..
	"}"
	          
	].join("\n"),

	       uniforms : {
	           opacity: { type: 'f', value: 1.0 },
	           fogColor: { type: 'c', value: new $3Dmol.Color(1.0, 1.0, 1.0) },
	           fogNear: { type: 'f', value: 1.0 },
	           fogFar: { type: 'f', value: 2000},         
	           directionalLightColor: { type: 'fv', value: [] },
	           directionalLightDirection: { type: 'fv', value: [] }
	       }

	   },
	   //stick imposter outlines
	   'stickimposteroutline' : { 
	      fragmentShader : $3Dmol.ShaderUtils.stickimposterFragmentShader + 'gl_FragColor = vec4(color,1.0);}',   
	      vertexShader : [

	"uniform mat4 modelViewMatrix;",
	"uniform mat4 projectionMatrix;",
	"uniform mat4 viewMatrix;",
	"uniform mat3 normalMatrix;",
	"uniform vec3 directionalLightColor[ 1 ];",
	"uniform vec3 directionalLightDirection[ 1 ];",
	"uniform vec3 outlineColor;",
	"uniform float outlineWidth;",
	"uniform float outlinePushback;",


	"attribute vec3 position;",
	"attribute vec3 normal;",
	"attribute vec3 color;",
	"attribute float radius;",

	"varying vec3 vColor;",
	"varying vec3 vLight;",
	"varying vec3 cposition;",
	"varying vec3 p1;",
	"varying vec3 p2;",
	"varying float r;",

	"void main() {",
	   
	"    vColor = outlineColor;",
	"    float rad = radius+sign(radius)*outlineWidth;",
	"    r = abs(rad);",
	"    vec4 to = modelViewMatrix*vec4(normal, 1.0);", //normal is other point of cylinder
	"    vec4 pt = modelViewMatrix*vec4(position, 1.0);",
	//pushback
	"    to.xyz += normalize(to.xyz)*outlinePushback;",
	"    pt.xyz += normalize(pt.xyz)*outlinePushback;",

	"    vec4 mvPosition = pt;",
	"    p1 = pt.xyz; p2 = to.xyz;",
	"    vec3 norm = to.xyz-pt.xyz;","" +
	"    float mult = 1.1;", //slop to account for perspective of sphere
	"    if(length(p1) > length(p2)) {", //billboard at level of closest point
	"       mvPosition = to;",
	"    }",
	"    vec3 n = normalize(mvPosition.xyz);",
	//intersect with the plane defined by the camera looking at the billboard point
	"    if(color.z >= 0.0) {", //p1
	"       vec3 pnorm = normalize(p1);",
	"       float t = dot(mvPosition.xyz-p1,n)/dot(pnorm,n);",
	"       mvPosition.xyz = p1+t*pnorm;",
	"    } else {",
	"       vec3 pnorm = normalize(p2);",
	"       float t = dot(mvPosition.xyz-p2,n)/dot(pnorm,n);",
	"       mvPosition.xyz = p2+t*pnorm;",
	"       mult *= -1.0;",
	"    }",
	"    vec3 cr = normalize(cross(mvPosition.xyz,norm))*rad;", 
	"    vec3 doublecr = normalize(cross(mvPosition.xyz,cr))*rad;", 
	"    mvPosition.xy +=  mult*(cr + doublecr).xy;",
	"    cposition = mvPosition.xyz;",
	"    gl_Position = projectionMatrix * mvPosition;",
	"    vLight = vec3(1.0,1.0,1.0);",
	"}"
	          
	].join("\n"),

	       uniforms : {
	           opacity: { type: 'f', value: 1.0 },
	           fogColor: { type: 'c', value: new $3Dmol.Color(1.0, 1.0, 1.0) },
	           fogNear: { type: 'f', value: 1.0 },
	           fogFar: { type: 'f', value: 2000},         
	           outlineColor: { type: 'c', value: new $3Dmol.Color(0.0, 0.0, 0.0) },         
	           outlineWidth: { type: 'f', value: 0.1 },
	           outlinePushback: { type: 'f', value: 1.0 },         
	       }

	   },
	    //for double sided lighting
	    'lambertdouble' : { 
	        fragmentShader : [

	"uniform mat4 viewMatrix;",
	"uniform float opacity;",

	"uniform vec3 fogColor;",
	"uniform float fogNear;",
	"uniform float fogFar;",

	"varying vec3 vLightFront;",
	"varying vec3 vLightBack;",

	"varying vec3 vColor;",

	"void main() {",
	    
	"    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
	    
	"    #ifndef WIREFRAME",
	"    if ( gl_FrontFacing )",
	"       gl_FragColor.xyz *= vLightFront;",
	"    else",
	"       gl_FragColor.xyz *= vLightBack;",
	"    #endif",
	    
	"    gl_FragColor = gl_FragColor * vec4( vColor, opacity );",
	"    float depth = gl_FragCoord.z / gl_FragCoord.w;",
	    
	"    float fogFactor = smoothstep( fogNear, fogFar, depth );",
	    
	"    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

	"}"


	].join("\n"),
	       
	       vertexShader : [

	"uniform mat4 modelViewMatrix;",
	"uniform mat4 projectionMatrix;",
	"uniform mat4 viewMatrix;",
	"uniform mat3 normalMatrix;",
	"uniform vec3 directionalLightColor[ 1 ];",
	"uniform vec3 directionalLightDirection[ 1 ];",

	"attribute vec3 position;",
	"attribute vec3 normal;",
	"attribute vec3 color;",

	"varying vec3 vColor;",
	"varying vec3 vLightFront;",
	"varying vec3 vLightBack;",

	"void main() {",
	    
	"    vColor = color;",
	    
	"    vec3 objectNormal = normal;",  
	"    vec3 transformedNormal = normalMatrix * objectNormal;",    
	"    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	    
	"    vLightFront = vec3( 0.0 );",
	"    vLightBack = vec3( 0.0 );",
	    
	"    transformedNormal = normalize( transformedNormal );",
	    
	"    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );",
	"    vec3 dirVector = normalize( lDirection.xyz );",
	"    float dotProduct = dot( transformedNormal, dirVector );",
	"    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",
	"    vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

	"    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;",
	"    vLightBack += directionalLightColor[ 0 ] * directionalLightWeightingBack;",

	"    gl_Position = projectionMatrix * mvPosition;",
	"}"
	           
	].join("\n"),

	        uniforms : {
	            opacity: { type: 'f', value: 1.0 },
	            fogColor: { type: 'c', value: new $3Dmol.Color(1.0, 1.0, 1.0) },
	            fogNear: { type: 'f', value: 1.0 },
	            fogFar: { type: 'f', value: 2000},           
	            directionalLightColor: { type: 'fv', value: [] },
	            directionalLightDirection: { type: 'fv', value: [] }
	        }

	    },
	    
	    
	    'sprite': {
	        
	        fragmentShader: [
	                                                         
	"uniform vec3 color;",
	"uniform sampler2D map;",
	"uniform float opacity;",

	"uniform int fogType;",
	"uniform vec3 fogColor;",
	"uniform float fogDensity;",
	"uniform float fogNear;",
	"uniform float fogFar;",
	"uniform float alphaTest;",

	"varying vec2 vUV;",

	"void main() {",
	    
	"    vec4 texture = texture2D(map, vUV);",
	    
	"    if (texture.a < alphaTest) discard;",
	    
	"    gl_FragColor = vec4(color * texture.xyz, texture.a * opacity);",
	    
	"    if (fogType > 0) {",
	        
	"        float depth = gl_FragCoord.z / gl_FragCoord.w;",
	"        float fogFactor = 0.0;",
	        
	"        if (fogType == 1) {",
	"            fogFactor = smoothstep(fogNear, fogFar, depth);",
	"        }",
	        
	"        else {",
	"            const float LOG2 = 1.442695;",
	"            float fogFactor = exp2(- fogDensity * fogDensity * depth * depth * LOG2);",
	"            fogFactor = 1.0 - clamp(fogFactor, 0.0, 1.0);",
	"        }",
	        
	"        gl_FragColor = mix(gl_FragColor, vec4(fogColor, gl_FragColor.w), fogFactor);",
	        
	"    }",
	"}"                                              
	            
	].join("\n"),
	        
	        vertexShader: [

	"uniform int useScreenCoordinates;",
	"uniform vec3 screenPosition;",
	"uniform mat4 modelViewMatrix;",
	"uniform mat4 projectionMatrix;",
	"uniform float rotation;",
	"uniform vec2 scale;",
	"uniform vec2 alignment;",
	"uniform vec2 uvOffset;",
	"uniform vec2 uvScale;",

	"attribute vec2 position;",
	"attribute vec2 uv;",

	"varying vec2 vUV;",

	"void main() {",
	    
	"    vUV = uvOffset + uv * uvScale;",
	    
	"    vec2 alignedPosition = position + alignment;",
	    
	"    vec2 rotatedPosition;",
	"    rotatedPosition.x = ( cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y ) * scale.x;",
	"    rotatedPosition.y = ( sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y ) * scale.y;",
	    
	"    vec4 finalPosition;",
	    
	"    if(useScreenCoordinates != 0) {",
	"        finalPosition = vec4(screenPosition.xy + rotatedPosition, screenPosition.z, 1.0);",
	"    }",
	    
	"    else {",
	"        finalPosition = projectionMatrix * modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0); finalPosition /= finalPosition.w;",
	"        finalPosition.xy += rotatedPosition; ",
	"    }",
	    
	"    gl_Position = finalPosition;",
	    
	"}"
	       
	].join("\n"),

	        uniforms : {
	            
	        }
	        
	    }
	    
	};
	/*  ProteinSurface.js by biochem_fan

	Ported and modified for Javascript based on EDTSurf,
	  whose license is as follows.

	Permission to use, copy, modify, and distribute this program for any
	purpose, with or without fee, is hereby granted, provided that this
	copyright notice and the reference information appear in all copies or
	substantial portions of the Software. It is provided "as is" without
	express or implied warranty. 

	Reference:
	http://zhanglab.ccmb.med.umich.edu/EDTSurf/
	D. Xu, Y. Zhang (2009) Generating Triangulated Macromolecular Surfaces
	by Euclidean Distance Transform. PLoS ONE 4(12): e8140.

	=======

	TODO: Improved performance on Firefox
	      Reduce memory consumption
	      Refactor!
	 */


	// dkoes
	// Surface calculations.  This must be safe to use within a web worker.
	if (typeof console === 'undefined') {
	    // this should only be true inside of a webworker
	    console = {
	        log : function() {
	        }
	    };
	}

	$3Dmol.ProteinSurface = function() {

	    // constants for vpbits bitmasks
	    /** @const */
	    var INOUT = 1;
	    /** @const */
	    var ISDONE = 2;
	    /** @const */
	    var ISBOUND = 4;

	    var ptranx = 0, ptrany = 0, ptranz = 0;
	    var probeRadius = 1.4;
	    var defaultScaleFactor = 2;
	    var scaleFactor = defaultScaleFactor; // 2 is .5A grid; if this is made user configurable,
	                            // also have to adjust offset used to find non-shown
	                            // atoms
	    var pHeight = 0, pWidth = 0, pLength = 0;
	    var cutRadius = 0;
	    var vpBits = null; // uint8 array of bitmasks
	    var vpDistance = null; // floatarray of _squared_ distances
	    var vpAtomID = null; // intarray
	    var vertnumber = 0, facenumber = 0;
	    var pminx = 0, pminy = 0, pminz = 0, pmaxx = 0, pmaxy = 0, pmaxz = 0;

	    var vdwRadii = {
	            "H" : 1.2,
	            "Li" : 1.82,
	            "Na" : 2.27,
	            "K" : 2.75,
	            "C" : 1.7,
	            "N" : 1.55,
	            "O" : 1.52,
	            "F" : 1.47,
	            "P" : 1.80,
	            "S" : 1.80,
	            "CL" : 1.75,
	            "BR" : 1.85,
	            "SE" : 1.90,
	            "ZN" : 1.39,
	            "CU" : 1.4,
	            "NI" : 1.63,
	            "X" : 2
	        };
	    
	    /** @param {AtomSpec} atom */
	    var getVDWIndex = function(atom) {
	        if(!atom.elem || typeof(vdwRadii[atom.elem]) == "undefined") {
	            return "X";
	        }
	        return atom.elem;
	    };
	    
	    var depty = {}, widxz = {};
	    var faces, verts;
	    var nb = [ new Int32Array([ 1, 0, 0 ]), new Int32Array([ -1, 0, 0 ]), 
	               new Int32Array([ 0, 1, 0 ]), new Int32Array([ 0, -1, 0 ]),
	               new Int32Array([ 0, 0, 1 ]), 
	               new Int32Array([ 0, 0, -1 ]), 
	               new Int32Array([ 1, 1, 0 ]), 
	               new Int32Array([ 1, -1, 0 ]), 
	               new Int32Array([ -1, 1, 0 ]),
	               new Int32Array([ -1, -1, 0 ]), 
	               new Int32Array([ 1, 0, 1 ]), 
	               new Int32Array([ 1, 0, -1 ]), 
	               new Int32Array([ -1, 0, 1 ]),
	               new Int32Array([ -1, 0, -1 ]), 
	               new Int32Array([ 0, 1, 1 ]), 
	               new Int32Array([ 0, 1, -1 ]), 
	               new Int32Array([ 0, -1, 1 ]),
	               new Int32Array([ 0, -1, -1 ]), 
	               new Int32Array([ 1, 1, 1 ]), 
	               new Int32Array([ 1, 1, -1 ]), 
	               new Int32Array([ 1, -1, 1 ]),
	               new Int32Array([ -1, 1, 1 ]), 
	               new Int32Array([ 1, -1, -1 ]), 
	               new Int32Array([ -1, -1, 1 ]), 
	               new Int32Array([ -1, 1, -1 ]),
	               new Int32Array([ -1, -1, -1 ]) ];

	    var origextent;

	    var inOrigExtent = function(x, y, z) {
	        if (x < origextent[0][0] || x > origextent[1][0])
	            return false;
	        if (y < origextent[0][1] || y > origextent[1][1])
	            return false;
	        if (z < origextent[0][2] || z > origextent[1][2])
	            return false;
	        return true;
	    };

	    this.getFacesAndVertices = function(atomlist) {
	        var atomsToShow = {};
	        var i, il;
	        for (i = 0, il = atomlist.length; i < il; i++)
	            atomsToShow[atomlist[i]] = true;
	        var vertices = verts;
	        for (i = 0, il = vertices.length; i < il; i++) {
	            vertices[i].x = vertices[i].x / scaleFactor - ptranx;
	            vertices[i].y = vertices[i].y / scaleFactor - ptrany;
	            vertices[i].z = vertices[i].z / scaleFactor - ptranz;
	        }

	        var finalfaces = [];
	        for (i = 0, il = faces.length; i < il; i += 3) {
	            //var f = faces[i];
	            var fa = faces[i], fb = faces[i+1], fc = faces[i+2];
	            var a = vertices[fa]['atomid'], b = vertices[fb]['atomid'], c = vertices[fc]['atomid'];

	            // must be a unique face for each atom
	            var which = a;
	            if (b < which)
	                which = b;
	            if (c < which)
	                which = c;
	            if (!atomsToShow[which]) {
	                continue;
	            }
	            var av = vertices[faces[i]];
	            var bv = vertices[faces[i+1]];
	            var cv = vertices[faces[i+2]];

	            if (fa !== fb && fb !== fc && fa !== fc){
	                finalfaces.push(fa); 
	                finalfaces.push(fb); 
	                finalfaces.push(fc); 
	            }
	               
	        }

	        //try to help the garbage collector
	        vpBits = null; // uint8 array of bitmasks
	        vpDistance = null; // floatarray
	        vpAtomID = null; // intarray
	        
	        return {
	            'vertices' : vertices,
	            'faces' : finalfaces
	        };
	    };


	    this.initparm = function(extent, btype, volume) {
	        if(volume > 1000000) //heuristical decrease resolution to avoid large memory consumption
	            scaleFactor = defaultScaleFactor/2;
	        
	        var margin = (1 / scaleFactor) * 5.5; // need margin to avoid
	                                                // boundary/round off effects
	        origextent = extent;
	        pminx = extent[0][0]; pmaxx = extent[1][0];
	        pminy = extent[0][1]; pmaxy = extent[1][1];
	        pminz = extent[0][2]; pmaxz = extent[1][2];

	        if (!btype) {
	            pminx -= margin;
	            pminy -= margin;
	            pminz -= margin;
	            pmaxx += margin;
	            pmaxy += margin;
	            pmaxz += margin;
	        } else {
	            pminx -= probeRadius + margin;
	            pminy -= probeRadius + margin;
	            pminz -= probeRadius + margin;
	            pmaxx += probeRadius + margin;
	            pmaxy += probeRadius + margin;
	            pmaxz += probeRadius + margin;
	        }

	        pminx = Math.floor(pminx * scaleFactor) / scaleFactor;
	        pminy = Math.floor(pminy * scaleFactor) / scaleFactor;
	        pminz = Math.floor(pminz * scaleFactor) / scaleFactor;
	        pmaxx = Math.ceil(pmaxx * scaleFactor) / scaleFactor;
	        pmaxy = Math.ceil(pmaxy * scaleFactor) / scaleFactor;
	        pmaxz = Math.ceil(pmaxz * scaleFactor) / scaleFactor;

	        ptranx = -pminx;
	        ptrany = -pminy;
	        ptranz = -pminz;

	        pLength = Math.ceil(scaleFactor * (pmaxx - pminx)) + 1;
	        pWidth = Math.ceil(scaleFactor * (pmaxy - pminy)) + 1;
	        pHeight = Math.ceil(scaleFactor * (pmaxz - pminz)) + 1;

	        this.boundingatom(btype);
	        cutRadius = probeRadius * scaleFactor;

	        vpBits = new Uint8Array(pLength * pWidth * pHeight);
	        vpDistance = new Float64Array(pLength * pWidth * pHeight); // float 32
	        // doesn't
	        // play
	        // nicely
	        // with
	        // native
	        // floats
	        vpAtomID = new Int32Array(pLength * pWidth * pHeight);
	        //console.log("Box size: ", pLength, pWidth, pHeight, vpBits.length);
	    };

	    this.boundingatom = function(btype) {
	        var tradius = [];
	        var txz, tdept, sradius, idx;
	        flagradius = btype;

	        for ( var i in vdwRadii) {
	            if(!vdwRadii.hasOwnProperty(i))
	                continue;
	            var r = vdwRadii[i];
	            if (!btype)
	                tradius[i] = r * scaleFactor + 0.5;
	            else
	                tradius[i] = (r + probeRadius) * scaleFactor + 0.5;

	            sradius = tradius[i] * tradius[i];
	            widxz[i] = Math.floor(tradius[i]) + 1;
	            depty[i] = new Int32Array(widxz[i] * widxz[i]);
	            indx = 0;
	            for (j = 0; j < widxz[i]; j++) {
	                for (k = 0; k < widxz[i]; k++) {
	                    txz = j * j + k * k;
	                    if (txz > sradius)
	                        depty[i][indx] = -1; // outside
	                    else {
	                        tdept = Math.sqrt(sradius - txz);
	                        depty[i][indx] = Math.floor(tdept);
	                    }
	                    indx++;
	                }
	            }
	        }
	    };

	    this.fillvoxels = function(atoms, atomlist) { // (int seqinit,int
	        // seqterm,bool
	        // atomtype,atom*
	        // proseq,bool bcolor)
	        var i, il;
	        for (i = 0, il = vpBits.length; i < il; i++) {
	            vpBits[i] = 0;
	            vpDistance[i] = -1.0;
	            vpAtomID[i] = -1;
	        }

	        for (i in atomlist) {
	            var atom = atoms[atomlist[i]];
	            if (atom === undefined)
	                continue;
	            this.fillAtom(atom, atoms);
	        }

	        for (i = 0, il = vpBits.length; i < il; i++)
	            if (vpBits[i] & INOUT)
	                vpBits[i] |= ISDONE;

	    };


	    this.fillAtom = function(atom, atoms) {
	        var cx, cy, cz, ox, oy, oz, mi, mj, mk, i, j, k, si, sj, sk;
	        var ii, jj, kk, n;
	        cx = Math.floor(0.5 + scaleFactor * (atom.x + ptranx));
	        cy = Math.floor(0.5 + scaleFactor * (atom.y + ptrany));
	        cz = Math.floor(0.5 + scaleFactor * (atom.z + ptranz));

	        var at = getVDWIndex(atom);
	        var nind = 0;
	        var cnt = 0;
	        var pWH = pWidth*pHeight;
	        
	        for (i = 0, n = widxz[at]; i < n; i++) {
	            for (j = 0; j < n; j++) {
	                if (depty[at][nind] != -1) {
	                    for (ii = -1; ii < 2; ii++) {
	                        for (jj = -1; jj < 2; jj++) {
	                            for (kk = -1; kk < 2; kk++) {
	                                if (ii !== 0 && jj !== 0 && kk !== 0) {
	                                    mi = ii * i;
	                                    mk = kk * j;
	                                    for (k = 0; k <= depty[at][nind]; k++) {
	                                        mj = k * jj;
	                                        si = cx + mi;
	                                        sj = cy + mj;
	                                        sk = cz + mk;
	                                        if (si < 0 || sj < 0 || 
	                                                sk < 0 ||
	                                                si >= pLength || 
	                                                sj >= pWidth || 
	                                                sk >= pHeight)
	                                            continue;
	                                        var index = si * pWH + sj * pHeight + sk;

	                                        if (!(vpBits[index] & INOUT)) {
	                                            vpBits[index] |= INOUT;
	                                            vpAtomID[index] = atom.serial;
	                                        } else {
	                                            var atom2 = atoms[vpAtomID[index]];
	                                            if(atom2.serial != atom.serial) {
	                                                ox = cx + mi - Math.floor(0.5 + scaleFactor *
	                                                        (atom2.x + ptranx));
	                                                oy = cy + mj - Math.floor(0.5 + scaleFactor *
	                                                        (atom2.y + ptrany));
	                                                oz = cz + mk - Math.floor(0.5 + scaleFactor *
	                                                        (atom2.z + ptranz));
	                                                if (mi * mi + mj * mj + mk * mk < ox *
	                                                        ox + oy * oy + oz * oz)
	                                                    vpAtomID[index] = atom.serial;
	                                            }
	                                        }

	                                    }// k
	                                }// if
	                            }// kk
	                        }// jj
	                    }// ii
	                }// if
	                nind++;
	            }// j
	        }// i
	    };

	    this.fillvoxelswaals = function(atoms, atomlist) {
	        var i, il;
	        for (i = 0, il = vpBits.length; i < il; i++)
	            vpBits[i] &= ~ISDONE; // not isdone

	        for (i in atomlist) {
	            var atom = atoms[atomlist[i]];
	            if (atom === undefined)
	                continue;

	            this.fillAtomWaals(atom, atoms);
	        }
	    };

	    this.fillAtomWaals = function(atom, atoms) {
	        var cx, cy, cz, ox, oy, oz, nind = 0;
	        var mi, mj, mk, si, sj, sk, i, j, k, ii, jj, kk, n;
	        cx = Math.floor(0.5 + scaleFactor * (atom.x + ptranx));
	        cy = Math.floor(0.5 + scaleFactor * (atom.y + ptrany));
	        cz = Math.floor(0.5 + scaleFactor * (atom.z + ptranz));

	        var at = getVDWIndex(atom);
	        var pWH = pWidth*pHeight;
	        for (i = 0, n = widxz[at]; i < n; i++) {
	            for (j = 0; j < n; j++) {
	                if (depty[at][nind] != -1) {
	                    for (ii = -1; ii < 2; ii++) {
	                        for (jj = -1; jj < 2; jj++) {
	                            for (kk = -1; kk < 2; kk++) {
	                                if (ii !== 0 && jj !== 0 && kk !== 0) {
	                                    mi = ii * i;
	                                    mk = kk * j;
	                                    for (k = 0; k <= depty[at][nind]; k++) {
	                                        mj = k * jj;
	                                        si = cx + mi;
	                                        sj = cy + mj;
	                                        sk = cz + mk;
	                                        if (si < 0 || sj < 0 || 
	                                                sk < 0 || 
	                                                si >= pLength || 
	                                                sj >= pWidth || 
	                                                sk >= pHeight)
	                                            continue;
	                                        var index = si * pWH + sj * pHeight + sk;
	                                        if (!(vpBits[index] & ISDONE)) {
	                                            vpBits[index] |= ISDONE;
	                                            vpAtomID[index] = atom.serial;
	                                        }  else {
	                                            var atom2 = atoms[vpAtomID[index]];
	                                            if(atom2.serial != atom.serial) {
	                                                ox = cx + mi - Math.floor(0.5 + scaleFactor *
	                                                        (atom2.x + ptranx));
	                                                oy = cy + mj - Math.floor(0.5 + scaleFactor *
	                                                        (atom2.y + ptrany));
	                                                oz = cz + mk - Math.floor(0.5 + scaleFactor *
	                                                        (atom2.z + ptranz));
	                                                if (mi * mi + mj * mj + mk * mk < ox *
	                                                        ox + oy * oy + oz * oz)
	                                                    vpAtomID[index] = atom.serial;
	                                            }
	                                        }
	                                    }// k
	                                }// if
	                            }// kk
	                        }// jj
	                    }// ii
	                }// if
	                nind++;
	            }// j
	        }// i
	    };

	    this.buildboundary = function() {
	        var pWH = pWidth*pHeight;
	        for (i = 0; i < pLength; i++) {
	            for (j = 0; j < pHeight; j++) {
	                for (k = 0; k < pWidth; k++) {
	                    var index = i * pWH + k * pHeight + j;
	                    if (vpBits[index] & INOUT) {
	                        var flagbound = false;
	                        var ii = 0;
	                        while (ii < 26) {
	                            var ti = i + nb[ii][0], tj = j + nb[ii][2], tk = k +
	                                    nb[ii][1];
	                            if (ti > -1 && 
	                                ti < pLength && 
	                                tk > -1 && 
	                                tk < pWidth && 
	                                tj > -1 && 
	                                tj < pHeight && 
	                                !(vpBits[ti * pWH + tk * pHeight + tj] & INOUT)) {
	                                vpBits[index] |= ISBOUND;
	                                break;
	                            } else
	                                ii++;
	                        }
	                    }
	                }
	            }
	        }
	    };

	    // a little class for 3d array, should really generalize this and
	    // use throughout...
	    var PointGrid = function(length, width, height) {
	        // the standard says this is zero initialized
	        var data = new Int32Array(length * width * height * 3);

	        // set position x,y,z to pt, which has ix,iy,and iz
	        this.set = function(x, y, z, pt) {
	            var index = ((((x * width) + y) * height) + z) * 3;
	            data[index] = pt.ix;
	            data[index + 1] = pt.iy;
	            data[index + 2] = pt.iz;
	        };

	        // return point at x,y,z
	        this.get = function(x, y, z) {
	            var index = ((((x * width) + y) * height) + z) * 3;
	            return {
	                ix : data[index],
	                iy : data[index + 1],
	                iz : data[index + 2]
	            };
	        };
	    };

	    this.fastdistancemap = function() {
	        var eliminate = 0;
	        var certificate;
	        var i, j, k, n;

	        var boundPoint = new PointGrid(pLength, pWidth, pHeight);
	        var pWH = pWidth*pHeight;
	        var cutRSq = cutRadius*cutRadius;
	        
	        var inarray = [];
	        var outarray = [];
	        
	        var index;
	        
	        for (i = 0; i < pLength; i++) {
	            for (j = 0; j < pWidth; j++) {
	                for (k = 0; k < pHeight; k++) {
	                    index = i * pWH + j * pHeight + k;
	                    vpBits[index] &= ~ISDONE; // isdone = false
	                    if (vpBits[index] & INOUT) {
	                        if (vpBits[index] & ISBOUND) {
	                            var triple = {
	                                ix : i,
	                                iy : j,
	                                iz : k
	                            };
	                            boundPoint.set(i, j, k, triple);
	                            inarray.push(triple);
	                            vpDistance[index] = 0;
	                            vpBits[index] |= ISDONE;
	                            vpBits[index] &= ~ISBOUND;
	                        } 
	                    }
	                }
	            }
	        }

	        do {
	            outarray = this.fastoneshell(inarray, boundPoint);
	            inarray = [];
	            for (i = 0, n = outarray.length; i < n; i++) {
	                index = pWH * outarray[i].ix + pHeight *
	                    outarray[i].iy + outarray[i].iz;
	                vpBits[index] &= ~ISBOUND;
	                if (vpDistance[index] <= 1.0404 * cutRSq) {
	                    inarray.push({
	                        ix : outarray[i].ix,
	                        iy : outarray[i].iy,
	                        iz : outarray[i].iz
	                    });
	                }
	            }
	        } while (inarray.length !== 0);

	        inarray = [];
	        outarray = [];
	        boundPoint = null;
	        
	        var cutsf = scaleFactor - 0.5;
	        if (cutsf < 0)
	            cutsf = 0;
	        var cutoff = cutRSq - 0.50 / (0.1 + cutsf);
	        for (i = 0; i < pLength; i++) {
	            for (j = 0; j < pWidth; j++) {
	                for (k = 0; k < pHeight; k++) {
	                    index = i * pWH + j * pHeight + k;
	                    vpBits[index] &= ~ISBOUND;
	                    // ses solid
	                    if (vpBits[index] & INOUT) {
	                        if (!(vpBits[index] & ISDONE) ||
	                                ((vpBits[index] & ISDONE) && vpDistance[index] >= cutoff)) {
	                            vpBits[index] |= ISBOUND;
	                        }
	                    }
	                }
	            }
	        }

	    };

	    this.fastoneshell = function(inarray, boundPoint) { // (int* innum,int
	        // *allocout,voxel2
	        // ***boundPoint, int*
	        // outnum, int *elimi)
	        var tx, ty, tz;
	        var dx, dy, dz;
	        var i, j, n;
	        var square;
	        var bp, index;
	        var outarray = [];
	        if (inarray.length === 0)
	            return outarray;

	        tnv = {
	            ix : -1,
	            iy : -1,
	            iz : -1
	        };
	        var pWH = pWidth*pHeight;
	        for ( i = 0, n = inarray.length; i < n; i++) {
	            tx = inarray[i].ix;
	            ty = inarray[i].iy;
	            tz = inarray[i].iz;
	            bp = boundPoint.get(tx, ty, tz);

	            for (j = 0; j < 6; j++) {
	                tnv.ix = tx + nb[j][0];
	                tnv.iy = ty + nb[j][1];
	                tnv.iz = tz + nb[j][2];
	                
	                if (tnv.ix < pLength && tnv.ix > -1 && tnv.iy < pWidth &&
	                        tnv.iy > -1 && tnv.iz < pHeight && tnv.iz > -1) {
	                    index = tnv.ix * pWH + pHeight * tnv.iy + tnv.iz;
	                    
	                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {
	    
	                        boundPoint.set(tnv.ix, tnv.iy, tz + nb[j][2], bp);
	                        dx = tnv.ix - bp.ix;
	                        dy = tnv.iy - bp.iy;
	                        dz = tnv.iz - bp.iz;
	                        square = dx * dx + dy * dy + dz * dz;
	                        vpDistance[index] = square;
	                        vpBits[index] |= ISDONE;
	                        vpBits[index] |= ISBOUND;
	    
	                        outarray.push({
	                            ix : tnv.ix,
	                            iy : tnv.iy,
	                            iz : tnv.iz
	                        });
	                    } else if ((vpBits[index] & INOUT) && (vpBits[index] & ISDONE)) {
	    
	                        dx = tnv.ix - bp.ix;
	                        dy = tnv.iy - bp.iy;
	                        dz = tnv.iz - bp.iz;
	                        square = dx * dx + dy * dy + dz * dz;
	                        if (square < vpDistance[index]) {
	                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);
	    
	                            vpDistance[index] = square;
	                            if (!(vpBits[index] & ISBOUND)) {
	                                vpBits[index] |= ISBOUND;
	                                outarray.push({
	                                    ix : tnv.ix,
	                                    iy : tnv.iy,
	                                    iz : tnv.iz
	                                });
	                            }
	                        }
	                    }
	                }
	            }
	        }

	        // console.log("part1", positout);

	        for (i = 0, n = inarray.length; i < n; i++) {
	            tx = inarray[i].ix;
	            ty = inarray[i].iy;
	            tz = inarray[i].iz;
	            bp = boundPoint.get(tx, ty, tz);

	            for (j = 6; j < 18; j++) {
	                tnv.ix = tx + nb[j][0];
	                tnv.iy = ty + nb[j][1];
	                tnv.iz = tz + nb[j][2];

	                if(tnv.ix < pLength && tnv.ix > -1 && tnv.iy < pWidth &&
	                        tnv.iy > -1 && tnv.iz < pHeight && tnv.iz > -1) {
	                    index = tnv.ix * pWH + pHeight * tnv.iy + tnv.iz;
	                    
	                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {
	                        boundPoint.set(tnv.ix, tnv.iy, tz + nb[j][2], bp);
	    
	                        dx = tnv.ix - bp.ix;
	                        dy = tnv.iy - bp.iy;
	                        dz = tnv.iz - bp.iz;
	                        square = dx * dx + dy * dy + dz * dz;
	                        vpDistance[index] = square;
	                        vpBits[index] |= ISDONE;
	                        vpBits[index] |= ISBOUND;
	    
	                        outarray.push({
	                            ix : tnv.ix,
	                            iy : tnv.iy,
	                            iz : tnv.iz
	                        });
	                    } else if ((vpBits[index] & INOUT) && (vpBits[index] & ISDONE)) {
	                        dx = tnv.ix - bp.ix;
	                        dy = tnv.iy - bp.iy;
	                        dz = tnv.iz - bp.iz;
	                        square = dx * dx + dy * dy + dz * dz;
	                        if (square < vpDistance[index]) {
	                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);
	                            vpDistance[index] = square;
	                            if (!(vpBits[index] & ISBOUND)) {
	                                vpBits[index] |= ISBOUND;
	                                outarray.push({
	                                    ix : tnv.ix,
	                                    iy : tnv.iy,
	                                    iz : tnv.iz
	                                });
	                            }
	                        }
	                    }
	                }
	            }
	        }

	        // console.log("part2", positout);

	        for (i = 0, n = inarray.length; i < n; i++) {
	            tx = inarray[i].ix;
	            ty = inarray[i].iy;
	            tz = inarray[i].iz;
	            bp = boundPoint.get(tx, ty, tz);

	            for (j = 18; j < 26; j++) {
	                tnv.ix = tx + nb[j][0];
	                tnv.iy = ty + nb[j][1];
	                tnv.iz = tz + nb[j][2];

	                if (tnv.ix < pLength && tnv.ix > -1 && tnv.iy < pWidth &&
	                        tnv.iy > -1 && tnv.iz < pHeight && tnv.iz > -1) {
	                    index = tnv.ix * pWH + pHeight * tnv.iy + tnv.iz;

	                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {
	                        boundPoint.set(tnv.ix, tnv.iy, tz + nb[j][2], bp);

	                        dx = tnv.ix - bp.ix;
	                        dy = tnv.iy - bp.iy;
	                        dz = tnv.iz - bp.iz;
	                        square = dx * dx + dy * dy + dz * dz;
	                        vpDistance[index] = square;
	                        vpBits[index] |= ISDONE;
	                        vpBits[index] |= ISBOUND;

	                        outarray.push({
	                            ix : tnv.ix,
	                            iy : tnv.iy,
	                            iz : tnv.iz
	                        });
	                    } else if ((vpBits[index] & INOUT)  && (vpBits[index] & ISDONE)) {
	                        dx = tnv.ix - bp.ix;
	                        dy = tnv.iy - bp.iy;
	                        dz = tnv.iz - bp.iz;
	                        square = dx * dx + dy * dy + dz * dz;
	                        if (square < vpDistance[index]) {
	                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);

	                            vpDistance[index] = square;
	                            if (!(vpBits[index] & ISBOUND)) {
	                                vpBits[index] |= ISBOUND;
	                                outarray.push({
	                                    ix : tnv.ix,
	                                    iy : tnv.iy,
	                                    iz : tnv.iz
	                                });
	                            }
	                        }
	                    }
	                }
	            }
	        }

	        // console.log("part3", positout);
	        return outarray;
	    };

	    this.marchingcubeinit = function(stype) {
	        for ( var i = 0, lim = vpBits.length; i < lim; i++) {
	            if (stype == 1) {// vdw
	                vpBits[i] &= ~ISBOUND;
	            } else if (stype == 4) { // ses
	                vpBits[i] &= ~ISDONE;
	                if (vpBits[i] & ISBOUND)
	                    vpBits[i] |= ISDONE;
	                vpBits[i] &= ~ISBOUND;
	            } else if (stype == 2) {// after vdw
	                if ((vpBits[i] & ISBOUND) && (vpBits[i] & ISDONE))
	                    vpBits[i] &= ~ISBOUND;
	                else if ((vpBits[i] & ISBOUND) && !(vpBits[i] & ISDONE))
	                    vpBits[i] |= ISDONE;
	            } else if (stype == 3) { // sas
	                vpBits[i] &= ~ISBOUND;
	            }
	        }
	    };

	    // this code allows me to empirically prune the marching cubes code tables
	    // to more efficiently handle discrete data
	    var counter = function() {
	        var data = Array(256);
	        for ( var i = 0; i < 256; i++)
	            data[i] = [];

	        this.incrementUsed = function(i, j) {
	            if (typeof data[i][j] === 'undefined')
	                data[i][j] = {
	                    used : 0,
	                    unused : 0
	                };
	            data[i][j].used++;
	        };

	        this.incrementUnused = function(i, j) {
	            if (typeof data[i][j] === 'undefined')
	                data[i][j] = {
	                    used : 0,
	                    unused : 0
	                };
	            data[i][j].unused++;

	        };

	        var redoTable = function(triTable) {
	            var str = "[";
	            for ( var i = 0; i < triTable.length; i++) {
	                var code = 0;
	                var table = triTable[i];
	                for ( var j = 0; j < table.length; j++) {
	                    code |= (1 << (table[j]));
	                }
	                str += "0x" + code.toString(16) + ", ";
	            }
	            str += "]";
	            console.log(str);
	        };

	        this.print = function() {

	            var table = MarchingCube.triTable;
	            var str;
	            var newtable = [];
	            for ( var i = 0; i < table.length; i++) {
	                var newarr = [];
	                for ( var j = 0; j < table[i].length; j += 3) {
	                    var k = j / 3;
	                    if (typeof data[i][k] === 'undefined' || !data[i][k].unused) {
	                        newarr.push(table[i][j]);
	                        newarr.push(table[i][j + 1]);
	                        newarr.push(table[i][j + 2]);
	                    }
	                    if (typeof data[i][k] === 'undefined')
	                        console.log("undef " + i + "," + k);
	                }
	                newtable.push(newarr);
	            }
	            console.log(JSON.stringify(newtable));
	            redoTable(newtable);
	        };
	    };
	    
	    this.marchingcube = function(stype) {
	        this.marchingcubeinit(stype);
	        verts = []; faces = [];   
	        $3Dmol.MarchingCube.march(vpBits, verts, faces, {
	            smooth : 1,
	            nX : pLength,
	            nY : pWidth,
	            nZ : pHeight        
	        });      

	        var pWH = pWidth*pHeight;
	        for (var i = 0, vlen = verts.length; i < vlen; i++) {
	            verts[i]['atomid'] = vpAtomID[verts[i].x * pWH + pHeight *
	                    verts[i].y + verts[i].z];
	        }  

	        $3Dmol.MarchingCube.laplacianSmooth(1, verts, faces);

	    };


	};
	//auto-initialization
	//Create embedded viewer from HTML attributes if true

	$(document).ready(function() {

	    if ($(".viewer_3Dmoljs")[0] !== undefined)
	        $3Dmol.autoinit = true;
	        
	    if ($3Dmol.autoinit) { 
	        $3Dmol.viewers = {};
	        var nviewers = 0;
	        $(".viewer_3Dmoljs").each( function() {
	            var viewerdiv = $(this);
	            var datauri = null;
	            if(viewerdiv.css('position') == 'static') {
	                //slight hack - canvas needs this element to be positioned
	                viewerdiv.css('position','relative');
	            }
	        
	            var callback = (typeof(window[viewerdiv.data("callback")]) === 'function') ? 
	                    window[viewerdiv.data("callback")] : null;
	            
	            var type = null;
	            if (viewerdiv.data("pdb")) {
	                datauri = "http://www.rcsb.org/pdb/files/" + viewerdiv.data("pdb") + ".pdb";
	                type = "pdb";
	            } else if(viewerdiv.data("cid")) {
	                //this doesn't actually work since pubchem does have CORS enabled
	                type = "sdf";
	                datauri = "http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + viewerdiv.data("cid") + 
	                "/SDF?record_type=3d";
	            }
	            else if (viewerdiv.data("href"))
	                datauri = viewerdiv.data("href");
	                
	            var bgcolor = $3Dmol.CC.color(viewerdiv.data("backgroundcolor"));
	            var style = {line:{}};
	            if(viewerdiv.data("style")) style = $3Dmol.specStringToObject(viewerdiv.data("style"));
	            var select = {};
	            if(viewerdiv.data("select")) select = $3Dmol.specStringToObject(viewerdiv.data("select"));
	            var selectstylelist = [];
	            var surfaces = [];
	            var labels = [];
	            var d = viewerdiv.data();
	            
	            //let users specify individual but matching select/style tags, eg.
	            //data-select1 data-style1
	            var stylere = /style(.+)/;
	            var surfre = /surface(.*)/;
	            var reslabre = /labelres(.*)/;
	            var keys = [];
	            for(var dataname in d) {
	                if(d.hasOwnProperty(dataname)) {
	                    keys.push(dataname);
	                }
	            }
	            keys.sort();
	            for(var i = 0; i < keys.length; i++) {
	                var dataname = keys[i];
	                var m = stylere.exec(dataname);
	                if(m) {
	                    var selname = "select"+m[1];
	                    var newsel = $3Dmol.specStringToObject(d[selname]);
	                    var styleobj = $3Dmol.specStringToObject(d[dataname]);
	                    selectstylelist.push([newsel,styleobj]);
	                }         
	                m = surfre.exec(dataname);
	                if(m) {
	                    var selname = "select"+m[1];
	                    var newsel = $3Dmol.specStringToObject(d[selname]);
	                    var styleobj = $3Dmol.specStringToObject(d[dataname]);
	                    surfaces.push([newsel,styleobj]);
	                }
	                m = reslabre.exec(dataname);
	                if(m) {
	                    var selname = "select"+m[1];
	                    var newsel = $3Dmol.specStringToObject(d[selname]);
	                    var styleobj = $3Dmol.specStringToObject(d[dataname]);
	                    labels.push([newsel,styleobj]);
	                }
	            }
	            
	            //apply all the selections/styles parsed out above to the passed viewer
	            var applyStyles = function(glviewer) {
	                glviewer.setStyle(select,style);
	                for(var i = 0; i < selectstylelist.length; i++) {
	                    var sel = selectstylelist[i][0] || {};
	                    var sty = selectstylelist[i][1] || {"line":{}}
	                    glviewer.setStyle(sel, sty);
	                }
	                for(var i = 0; i < surfaces.length; i++) {
	                    var sel = surfaces[i][0] || {};
	                    var sty = surfaces[i][1] || {}
	                    glviewer.addSurface($3Dmol.SurfaceType.VDW, sty, sel, sel);
	                }
	                for(var i = 0; i < labels.length; i++) {
	                    var sel = labels[i][0] || {};
	                    var sty = labels[i][1] || {}
	                    glviewer.addResLabels(sel, sty);
	                }               
	                
	                glviewer.zoomTo();
	                glviewer.render();             
	            }
	            
	            
	            var glviewer = null;
	            try {
	                glviewer = $3Dmol.viewers[this.id || nviewers++] = $3Dmol.createViewer(viewerdiv, {defaultcolors: $3Dmol.rasmolElementColors});
	                glviewer.setBackgroundColor(bgcolor);                            
	            } catch ( error ) {
	                //for autoload, provide a useful error message
	                window.location = "http://get.webgl.org";                    
	            }           
	            
	            if (datauri) {  
	                
	                type = viewerdiv.data("type") || viewerdiv.data("datatype") || type;
	                if(!type) {
	                    type = datauri.substr(datauri.lastIndexOf('.')+1);
	                }
	                                
	                $.get(datauri, function(ret) {
	                    glviewer.addModel(ret, type);
	                    applyStyles(glviewer);       
	                    if (callback) 
	                        callback(glviewer);
	                }, 'text');         
	            }
	            
	            else {
	                
	                if (viewerdiv.data("element")) {
	                    var moldata = $("#" + viewerdiv.data("element")).val() || "";
	                    var type = viewerdiv.data("type") || viewerdiv.data("datatype");

	                    if (!type){

	                        console.log("Warning: No type specified for embedded viewer with moldata from " + viewerdiv.data("element") +
	                                    "\n assuming type 'pdb'")

	                        type = 'pdb';
	                    }

	                    glviewer.addModel(moldata, type);        
	                }

	                applyStyles(glviewer);                
	                if (callback) 
	                    callback(glviewer);
	            }
	            
	        });              
	    }
	});
	    
	//this is only used for create the enum documentation in JSDoc
	(function() {
	/**
	 * Color representation. 
	 * @typedef ColorSpec
	 * @prop {string} 0xAF10AB - any hex number
	 * @prop {string} white   - 0xFFFFFF
	 * @prop {string} silver  - 0xC0C0C0
	 * @prop {string} gray    - 0x808080
	 * @prop {string} grey    - 0x808080
	 * @prop {string} black   - 0x000000
	 * @prop {string} red     - 0xFF0000
	 * @prop {string} maroon  - 0x800000
	 * @prop {string} yellow  - 0xFFFF00
	 * @prop {string} orange  - 0xFF6600
	 * @prop {string} olive   - 0x808000
	 * @prop {string} lime    - 0x00FF00
	 * @prop {string} green   - 0x008000
	 * @prop {string} aqua    - 0x00FFFF
	 * @prop {string} cyan    - 0x00FFFF
	 * @prop {string} teal    - 0x008080
	 * @prop {string} blue    - 0x0000FF
	 * @prop {string} navy    - 0x000080
	 * @prop {string} fuchsia - 0xFF00FF
	 * @prop {string} magenta - 0xFF00FF
	 * @prop {string} purple  - 0x800080
	 */

	$3Dmol.elementColors.greenCarbon['C'] = 0x00ff00;


	$3Dmol.elementColors.cyanCarbon['C'] = 0x00ffff;


	$3Dmol.elementColors.magentaCarbon['C'] = 0xff00ff;


	$3Dmol.elementColors.yellowCarbon['C'] = 0xffff00;


	$3Dmol.elementColors.whiteCarbon['C'] = 0xffffff;


	$3Dmol.elementColors.orangeCarbon['C'] = 0xff6600;


	$3Dmol.elementColors.purpleCarbon['C'] = 0x800080;

	$3Dmol.elementColors.blueCarbon['C'] = 0x0000ff;

	 /**
	 * Color scheme representation. 
	 * @typedef ColorschemeSpec
	 * @prop {string} greenCarbon   - 0x00FF00
	 * @prop {string} cyanCarbon    - 0x00FFFF
	 * @prop {string} magentaCarbon - 0xFF00FF
	 * @prop {string} yellowCarbon  - 0xFFFF00
	 * @prop {string} whiteCarbon   - 0xFFFFFF
	 * @prop {string} orangeCarbon  - 0xFF6600
	 * @prop {string} purpleCarbon  - 0x100080
	 * @prop {string} blueCarbon    - 0x0000FF
	 */
	 
	});

	// in an attempt to reduce memory overhead, cache all $3Dmol.Colors
	// this makes things a little faster
	$3Dmol.CC = {
	    cache : {0:new $3Dmol.Color(0)},
	    color : function color_(hex) {
	        // Undefined values default to black
	        if(!hex)
	            return this.cache[0];
	        // cache hits
	        if(typeof(this.cache[hex]) !== "undefined") {
	            return this.cache[hex];
	        }
	        // arrays
	        else if(hex && hex.constructor === Array) {
	            // parse elements recursively
	            return hex.map(color_,this);
	        }
	        // numbers and hex strings
	        hex = this.getHex(hex);
	        if(typeof hex === 'number') {
	            var c = new $3Dmol.Color(hex);
	            this.cache[hex] = c;
	            return c;
	        } else {
	            // pass through $3Dmol.Color & other objects
	            return hex;
	        }
	    },
	 
	    colorTab : {
	        'white' : 0xFFFFFF,
	        'silver' : 0xC0C0C0,
	        'gray' : 0x808080,
	        'grey' : 0x808080,
	        'black' : 0x000000,
	        'red' : 0xFF0000,
	        'maroon' : 0x800000,
	        'yellow' : 0xFFFF00,
	        'orange' : 0xFF6600,
	        'olive' : 0x808000,
	        'lime' : 0x00FF00,
	        'green' : 0x008000,
	        'aqua' : 0x00FFFF,
	        'cyan' : 0x00FFFF,
	        'teal' : 0x008080,
	        'blue' : 0x0000FF,
	        'navy' : 0x000080,
	        'fuchsia' : 0xFF00FF,
	        'magenta' : 0xFF00FF,
	        'purple' : 0x800080
	    },    
	    getHex : function(hex) {
	        if (!isNaN(parseInt(hex)))
	            return parseInt(hex);
	        
	        else if (typeof(hex) === 'string') {
	            
	            return this.colorTab[hex.trim().toLowerCase()] || 0x000000;
	        }
	        return hex;
	    }
	    
	};


	$3Dmol['CC'] = $3Dmol.CC;
	$3Dmol['CC']['color'] = $3Dmol.CC.color;



	/** Return proper color for atom given style
	 * @param {AtomSpec} atom
	 * @param {AtomStyle} style
	 * @return {$3Dmol.Color}
	 */
	$3Dmol.getColorFromStyle = function(atom, style) {
	    var color = atom.color;
	    if (typeof (style.color) != "undefined" && style.color != "spectrum")
	        color = style.color;
	    if(typeof(style.colorscheme) != "undefined") {
	        if(typeof($3Dmol.elementColors[style.colorscheme]) != "undefined") {
	            //name of builtin colorscheme
	            var scheme = $3Dmol.elementColors[style.colorscheme];
	            if(typeof(scheme[atom.elem]) != "undefined") {
	                color = scheme[atom.elem];
	            }
	        } else if(typeof(style.colorscheme[atom.elem]) != 'undefined') {
	            //actual color scheme provided
	            color = style.colorscheme[atom.elem];
	        } else if(typeof(style.colorscheme.prop) != 'undefined' &&
	                typeof(style.colorscheme.gradient) != 'undefined') {         
	            //apply a property mapping
	            var prop = style.colorscheme.prop;
	            var scheme = style.colorscheme.gradient;
	            var range = scheme.range() || [-1,1]; //sensible default
	            var val = $3Dmol.getAtomProperty(atom, prop);
	            if(val != null) {
	                color = scheme.valueToHex(val, range);
	            }
	        } else if(typeof(style.colorscheme.prop) != 'undefined' &&
	                typeof(style.colorscheme.map) != 'undefined') {         
	            //apply a discrete property mapping
	            var prop = style.colorscheme.prop;
	            var val = $3Dmol.getAtomProperty(atom, prop);
	            if( typeof style.colorscheme.map[val] != 'undefined' ) {
	                color = style.colorscheme.map[val];
	            }
	        }
	    } 
	    else if(typeof(style.colorfunc) != "undefined") {
	    	//this is a user provided function for turning an atom into a color
	    	color = style.colorfunc(atom);
	    }
	    
	    var C = $3Dmol.CC.color(color);
	    return C;
	};

	/** Preset secondary structure color scheme 
	 * @struct
	 */
	$3Dmol.ssColors = $3Dmol.ssColors || {};
	//names are in helix-sheet-coil order
	$3Dmol.ssColors.pyMOL = {'h': 0xff0000, 's':  0xffff00, 'c': 0x00ff00};
	$3Dmol.ssColors.Jmol = {'h': 0xff0080, 's': 0xffc800, 'c': 0xffffff};

	/** Preset element coloring - from individual element colors to entire mappings (e.g. '$3Dmol.elementColors.Jmol' colors atoms with Jmol stylings)
	 * @struct
	 */
	$3Dmol.elementColors = $3Dmol.elementColors || {};

	$3Dmol.elementColors.defaultColor = 0xff1493;

	/** @property Jmol-like element colors*/
	$3Dmol.elementColors.Jmol = {
	        'H': 0xFFFFFF,
	        'He': 0xD9FFFF,
	        'HE': 0xD9FFFF,
	        'Li': 0xCC80FF,
	        'LI': 0xCC80FF,
	        'B': 0xFFB5B5,
	        'C': 0x909090,
	        'N': 0x3050F8,
	        'O': 0xFF0D0D,
	        'F': 0x90E050,
	        'Na': 0xAB5CF2,
	        'NA': 0xAB5CF2,
	        'Mg': 0x8AFF00,
	        'MG': 0x8AFF00,
	        'Al': 0xBFA6A6,
	        'AL': 0xBFA6A6,
	        'Si': 0xF0C8A0,
	        'SI': 0xF0C8A0,
	        'P': 0xFF8000,
	        'S': 0xFFFF30,
	        'Cl': 0x1FF01F,
	        'CL': 0x1FF01F,
	        'Ca': 0x3DFF00,
	        'CA': 0x3DFF00,
	        'Ti': 0xBFC2C7,
	        'TI': 0xBFC2C7,
	        'Cr': 0x8A99C7,
	        'CR': 0x8A99C7,
	        'Mn': 0x9C7AC7,
	        'MN': 0x9C7AC7,
	        'Fe': 0xE06633,
	        'FE': 0xE06633,
	        'Ni': 0x50D050,
	        'NI': 0x50D050,
	        'Cu': 0xC88033,
	        'CU': 0xC88033,
	        'Zn': 0x7D80B0,
	        'ZN': 0x7D80B0,
	        'Br': 0xA62929,
	        'BR': 0xA62929,
	        'Ag': 0xC0C0C0,
	        'AG': 0xC0C0C0,
	        'I': 0x940094,
	        'Ba': 0x00C900,
	        'BA': 0x00C900,
	        'Au': 0xFFD123,
	        'AU': 0xFFD123
	};

	/** @property rasmol-like element colors */
	$3Dmol.elementColors.rasmol = {
	        'H': 0xFFFFFF,
	        'He': 0xFFC0CB,
	        'HE': 0xFFC0CB,
	        'Li': 0xB22222,
	        'LI': 0xB22222,
	        'B': 0x00FF00,
	        'C': 0xC8C8C8,
	        'N': 0x8F8FFF,
	        'O': 0xF00000,
	        'F': 0xDAA520,
	        'Na': 0x0000FF,
	        'NA': 0x0000FF,
	        'Mg': 0x228B22,
	        'MG': 0x228B22,
	        'Al': 0x808090,
	        'AL': 0x808090,
	        'Si': 0xDAA520,
	        'SI': 0xDAA520,
	        'P': 0xFFA500,
	        'S': 0xFFC832,
	        'Cl': 0x00FF00,
	        'CL': 0x00FF00,
	        'Ca': 0x808090,
	        'CA': 0x808090,
	        'Ti': 0x808090,
	        'TI': 0x808090,
	        'Cr': 0x808090,
	        'CR': 0x808090,
	        'Mn': 0x808090,
	        'MN': 0x808090,
	        'Fe': 0xFFA500,
	        'FE': 0xFFA500,
	        'Ni': 0xA52A2A,
	        'NI': 0xA52A2A,
	        'Cu': 0xA52A2A,
	        'CU': 0xA52A2A,
	        'Zn': 0xA52A2A,
	        'ZN': 0xA52A2A,
	        'Br': 0xA52A2A,
	        'BR': 0xA52A2A,
	        'Ag': 0x808090,
	        'AG': 0x808090,
	        'I': 0xA020F0,
	        'Ba': 0xFFA500,
	        'BA': 0xFFA500,
	        'Au': 0xDAA520,
	        'AU': 0xDAA520    
	};

	$3Dmol.elementColors.defaultColors = $3Dmol.elementColors.rasmol;

	$3Dmol.elementColors.greenCarbon = $.extend({},$3Dmol.elementColors.defaultColors);
	$3Dmol.elementColors.greenCarbon['C'] = 0x00ff00;

	$3Dmol.elementColors.cyanCarbon =  $.extend({},$3Dmol.elementColors.defaultColors);
	$3Dmol.elementColors.cyanCarbon['C'] = 0x00ffff;

	$3Dmol.elementColors.magentaCarbon =  $.extend({},$3Dmol.elementColors.defaultColors);
	$3Dmol.elementColors.magentaCarbon['C'] = 0xff00ff;

	$3Dmol.elementColors.yellowCarbon =  $.extend({},$3Dmol.elementColors.defaultColors);
	$3Dmol.elementColors.yellowCarbon['C'] = 0xffff00;

	$3Dmol.elementColors.whiteCarbon =  $.extend({},$3Dmol.elementColors.defaultColors);
	$3Dmol.elementColors.whiteCarbon['C'] = 0xffffff;

	$3Dmol.elementColors.orangeCarbon =  $.extend({},$3Dmol.elementColors.defaultColors);
	$3Dmol.elementColors.orangeCarbon['C'] = 0xff6600;

	$3Dmol.elementColors.purpleCarbon =  $.extend({},$3Dmol.elementColors.defaultColors);
	$3Dmol.elementColors.purpleCarbon['C'] = 0x800080;

	$3Dmol.elementColors.blueCarbon =  $.extend({},$3Dmol.elementColors.defaultColors);
	$3Dmol.elementColors.blueCarbon['C'] = 0x0000ff;
	//glcartoon.js
	//This contains all the routines for rendering a cartoon given a set
	//of atoms with assigned secondary structure

	//TODO: generate normals directly in drawStrip and drawThinStrip

	var $3Dmol = $3Dmol || {};


	/**@typedef CartoonStyleSpec
	 * @prop {ColorSpec} color - strand color, may specify as 'spectrum'
	 * @prop {string} style - style of cartoon rendering (trace, oval, rectangle (default), parabola, edged)
	 * @prop {boolean} ribbon - whether to use constant strand width, disregarding secondary structure; use thickness to adjust radius
	 * @prop {boolean} arrows - whether to add arrows showing beta-sheet directionality; does not apply to trace or ribbon
	 * @prop {boolean} tubes - whether to display alpha helices as simple cylinders; does not apply to trace
	 * @prop {number} thickness - cartoon strand thickness, default is 0.4
	 * @prop {number} width - cartoon strand width, default is secondary structure-dependent; does not apply to trace or ribbon
	 * @prop {number} opacity - set opacity from 0-1; transparency is set per-chain with a warning outputted in the event of ambiguity
	 * @prop {}
	 * In nucleic acids, the base cylinders obtain their color from the atom to which the cylinder is drawn, which
	 * is 'N1' for purines (resn: 'A', 'G', 'DA', 'DG') and 'N3' for pyrimidines (resn: 'C', 'U', 'DC', 'DT').
	 * The different nucleobases can therefore be distinguished as follows:
	 * @example
	 * viewer.setStyle({resn:'DA', atom:'N1'}, {cartoon:{color:'red'}});
	 * viewer.setStyle({resn:'DG', atom:'N1'}, {cartoon:{color:'green'}});
	 * viewer.setStyle({resn:'DC', atom:'N3'}, {cartoon:{color:'blue'}});
	 * viewer.setStyle({resn:'DT', atom:'N3'}, {cartoon:{color:'yellow'}});
	 */

	/**
	 * @ignore
	 * @param {$3Dmol.Object3D} group
	 * @param {AtomSpec} atomlist
	 * @param {$3Dmol.Gradient} gradientscheme
	 */
	$3Dmol.drawCartoon = (function() {

	    var defaultNum = 5; // for cross-sectional shape
	    var defaultDiv = 5; // for length-wise splicing

	    var coilWidth = 0.5;
	    var helixSheetWidth = 1.3;
	    var nucleicAcidWidth = 0.8;
	    var arrowTipWidth = 0.1;
	    var defaultThickness = 0.4; 

	    // helper functions

	    // Catmull-Rom subdivision
	    var subdivide = function(_points, DIV) { // points as Vector3
	        var ret = [];
	        var points = _points;
	        points = []; // Smoothing test
	        points.push(_points[0]);
	        
	        var i, lim, size;
	        var p0, p1, p2, p3, v0, v1;
	        
	        for (i = 1, lim = _points.length - 1; i < lim; i++) {
	            p1 = _points[i]; p2 = _points[i + 1];
	            if (p1.smoothen)
	                points.push(new $3Dmol.Vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2,
	                        (p1.z + p2.z) / 2));
	            else
	                points.push(p1);
	        }
	        points.push(_points[_points.length - 1]);

	        
	        for (i = -1, size = points.length; i <= size - 3; i++) {
	            p0 = points[(i === -1) ? 0 : i];
	            p1 = points[i + 1]; p2 = points[i + 2];
	            p3 = points[(i === size - 3) ? size - 1 : i + 3];
	            v0 = new $3Dmol.Vector3().subVectors(p2, p0).multiplyScalar(0.5);
	            v1 = new $3Dmol.Vector3().subVectors(p3, p1).multiplyScalar(0.5);
	            if (p2.skip) continue;

	            for ( var j = 0; j < DIV; j++) {
	                var t = 1.0 / DIV * j;
	                var x = p1.x + t * v0.x + t * t * 
	                        (-3 * p1.x + 3 * p2.x - 2 * v0.x - v1.x) + t * t * t *
	                        (2 * p1.x - 2 * p2.x + v0.x + v1.x);
	                var y = p1.y + t * v0.y + t * t * 
	                        (-3 * p1.y + 3 * p2.y - 2 * v0.y - v1.y) + t * t * t *
	                        (2 * p1.y - 2 * p2.y + v0.y + v1.y);
	                var z = p1.z + t * v0.z + t * t * 
	                        (-3 * p1.z + 3 * p2.z - 2 * v0.z - v1.z) + t * t * t * 
	                        (2 * p1.z - 2 * p2.z + v0.z + v1.z);
	                        
	                var pt = new $3Dmol.Vector3(x, y, z);
	                
	                var atomIndex = Math.floor( (ret.length+2) / DIV);
	                
	                if (_points[atomIndex] !== undefined && _points[atomIndex].atom !== undefined)
	                    pt.atom = _points[atomIndex].atom;
	                    
	                ret.push(pt);
	            }
	        }
	        ret.push(points[points.length - 1]);
	        return ret;
	    };

	    var drawThinStrip = function(group, p1, p2, colors, div, opacity) {
	    
	        var geo = new $3Dmol.Geometry(true);       
	        var offset, vertoffset;
	        var color, colori;

	        
	        for ( var i = 0, lim = p1.length; i < lim; i++) {
	            
	            colori = Math.round(i*(colors.length-1)/lim);
	            color = $3Dmol.CC.color(colors[colori]);
	           
	            geoGroup = geo.updateGeoGroup(2);
	            var vertexArray = geoGroup.vertexArray;
	            var colorArray = geoGroup.colorArray;
	            var faceArray = geoGroup.faceArray;
	            offset = geoGroup.vertices; vertoffset = offset*3;
	            
	            vertexArray[vertoffset] = p1[i].x;
	            vertexArray[vertoffset+1] = p1[i].y;
	            vertexArray[vertoffset+2] = p1[i].z;
	            
	            vertexArray[vertoffset+3] = p2[i].x;
	            vertexArray[vertoffset+4] = p2[i].y;
	            vertexArray[vertoffset+5] = p2[i].z;
	            
	            for (var j = 0; j < 6; ++j)
	            {
	                colorArray[vertoffset+3*j] = color.r;
	                colorArray[vertoffset+1+3*j] = color.g;
	                colorArray[vertoffset+2+3*j] = color.b;
	            }
	           
	            if (i > 0) {
	                var faces = [offset, offset + 1, offset - 1, offset - 2];
	                var faceoffset = geoGroup.faceidx;
	                
	                faceArray[faceoffset] = faces[0]; faceArray[faceoffset+1] = faces[1]; faceArray[faceoffset+2] = faces[3];
	                faceArray[faceoffset+3] = faces[1]; faceArray[faceoffset+4] = faces[2]; faceArray[faceoffset+5] = faces[3];

	                geoGroup.faceidx += 6;
	            }
	            
	            geoGroup.vertices += 2;
	        }
	        
	        geo.initTypedArrays();
	        geo.setUpNormals();
	        
	        var material = new $3Dmol.MeshDoubleLambertMaterial();
	        if(typeof(opacity) === 'number' && opacity >= 0 && opacity < 1) {
	            material.transparent = true;
	            material.opacity = opacity;
	        }
	        material.vertexColors = $3Dmol.FaceColors;
	        var mesh = new $3Dmol.Mesh(geo, material);

	        group.add(mesh);
	    };

	    var drawShapeStrip = function(group, points, colors, div, thickness, opacity, shape) {

	        // points is a 2D array, dimensionality given by [num = cross-sectional resolution][len = length of strip]
	        var i, j, num, len;
	        num = points.length;
	        if (num < 2 || points[0].length < 2) return;

	        div = div || axisDIV;
	        for (i = 0; i < num; i++) { // spline to generate greater length-wise resolution
	            points[i] = subdivide(points[i], div)
	        }
	        len = points[0].length;

	        if (!thickness) // if thickness is 0, we can use a smaller geometry than this function generates
	            return drawThinStrip(group, points[0], points[num-1], colors, div, opacity);


	        var geo = new $3Dmol.Geometry(true);
	        var axis, cs_shape, cs_bottom, cs_top, last_cs_bottom, last_cs_top;

	        // cache the available cross-sectional shapes
	        var cs_ellipse = [], cs_rectangle = [], cs_parabola = [];
	        for (j=0; j < num; j++) {
	            cs_ellipse.push(0.25 + 1.5*Math.sqrt((num-1)*j - Math.pow(j, 2))/(num-1));
	            cs_rectangle.push(0.5);
	            cs_parabola.push(2*(Math.pow(j/num, 2) - j/num) + 0.6);
	        }

	        /* face_refs array is used to generate faces from vertexArray iteratively.
	           As we move through each cross-sectional segment of points, we draw lateral
	           faces backwards to the previous cross-sectional segment.

	           To correctly identify the points needed to make each face we use this
	           array as a lookup table for the relative indices of each needed point
	           in the vertices array.

	           4 points are used to create 2 faces.
	        */

	        var face_refs = [];
	        for (j = 0; j < num*2-1; j++) {
	            /* [curr vertex in curr cross-section,
	                next vertex in curr cross-section,
	                next vertex in prev cross-section,
	                curr vertex in prev cross-section] */
	            face_refs[j] = [j, j+1, j+1-2*num, j-2*num];
	        }
	        // last face is different. easier to conceptualize this by drawing a diagram
	        face_refs[num*2-1] = [j, j+1-2*num, j+1-4*num, j-2*num];

	                
	        var v_offset, va_offset, f_offset;
	        var currentAtom, lastAtom
	        var color, colori;
	        var geoGroup = geo.updateGeoGroup(2*num*len); // ensure vertex capacity
	        
	        for (i = 0; i < len; i++) {
	        
	            colori = Math.round(i*(colors.length-1)/len);
	            color = $3Dmol.CC.color(colors[colori]);
	            
	            last_cs_bottom = cs_bottom;
	            last_cs_top = cs_top;
	            cs_bottom = [];
	            cs_top = [];
	            axis = [];

	            if (points[0][i].atom !== undefined) // TODO better edge case handling
	            {
	                currentAtom = points[0][i].atom;
	                if (shape === "oval")
	                    cs_shape = cs_ellipse;
	                else if (shape === "rectangle")
	                    cs_shape = cs_rectangle;
	                else if (shape === "parabola")
	                    cs_shape = cs_parabola;
	            }
	            if (!cs_shape) cs_shape = cs_rectangle;

	            
	            // calculate thickness at each width point, from cross-sectional shape
	            var toNext, toSide;
	            for (j = 0; j < num; j++)
	            {
	                if (i < len-1)
	                    toNext = points[j][i+1].clone().sub(points[j][i]);
	                else
	                    toNext = points[j][i-1].clone().sub(points[j][i]).negate();

	                if (j < num-1)
	                    toSide = points[j+1][i].clone().sub(points[j][i]);
	                else
	                    toSide = points[j-1][i].clone().sub(points[j][i]).negate();

	                axis[j] = toSide.cross(toNext).normalize().multiplyScalar(thickness*cs_shape[j]);
	            }

	            // generate vertices by applying cross-sectional shape thickness to input points
	            for (j = 0; j < num; j++)
	                cs_bottom[j] = points[j][i].clone().add(axis[j].clone().negate());
	            for (j = 0; j < num; j++)
	                cs_top[j] = points[j][i].clone().add(axis[j]);
	            

	            /* Until this point the vertices have been dealt with as $3Dmol.Vector3() objects,
	               but we need to serialize them into the geoGroup.vertexArray, where every three
	               indices represents the next vertex. The colorArray is analogous.

	               In the following for-loops, j iterates through VERTICES so we need to index
	               them in vertexArray by 3*j + either 0, 1, or 2 for xyz or rgb component.
	            */

	            var vertexArray = geoGroup.vertexArray;
	            var colorArray = geoGroup.colorArray;
	            var faceArray = geoGroup.faceArray;
	            v_offset = geoGroup.vertices; va_offset = v_offset*3; // in case geoGroup already contains vertices

	            // bottom edge of cross-section, vertices [0, num)
	            for (j = 0; j < num; j++) {
	                vertexArray[va_offset + 3*j + 0] = cs_bottom[j].x;
	                vertexArray[va_offset + 3*j + 1] = cs_bottom[j].y;
	                vertexArray[va_offset + 3*j + 2] = cs_bottom[j].z;
	            }

	            // top edge of cross-section, vertices [num, 2*num)
	            // add these backwards, so that each cross-section's vertices are added sequentially to vertexArray
	            for (j = 0; j < num; j++) {
	                vertexArray[va_offset + 3*j + 0 + 3*num] = cs_top[num-1-j].x;
	                vertexArray[va_offset + 3*j + 1 + 3*num] = cs_top[num-1-j].y;
	                vertexArray[va_offset + 3*j + 2 + 3*num] = cs_top[num-1-j].z;
	            }
	            
	            for (j = 0; j < 2*num; ++j) {
	                colorArray[va_offset + 3*j + 0] = color.r;
	                colorArray[va_offset + 3*j + 1] = color.g;
	                colorArray[va_offset + 3*j + 2] = color.b;
	            }
	            
	            if (i > 0) {
	             
	                for (j = 0; j < num*2; j++) {
	                
	                    // get VERTEX indices of the 4 points of a rectangular face (as opposed to literal vertexArray indices)
	                    var face = [v_offset + face_refs[j][0],
	                                v_offset + face_refs[j][1],
	                                v_offset + face_refs[j][2],
	                                v_offset + face_refs[j][3]];
	                    
	                    f_offset = geoGroup.faceidx;    
	                    
	                    // need 2 triangles to draw a face between 4 points
	                    faceArray[f_offset]   = face[0];
	                    faceArray[f_offset+1] = face[1]; 
	                    faceArray[f_offset+2] = face[3];

	                    faceArray[f_offset+3] = face[1];
	                    faceArray[f_offset+4] = face[2];
	                    faceArray[f_offset+5] = face[3];
	                    
	                    geoGroup.faceidx += 6;

	                    // TODO implement clickable the right way. midpoints of strand between consecutive atoms
	                }
	                    
	                if (currentAtom.clickable)
	                {
	                    var faces = [];

	                    faces.push(new $3Dmol.Triangle(last_cs_bottom[0], cs_bottom[0], cs_bottom[num-1]));
	                    faces.push(new $3Dmol.Triangle(last_cs_bottom[0], cs_bottom[num-1], last_cs_bottom[num-1]));

	                    faces.push(new $3Dmol.Triangle(last_cs_bottom[num-1], cs_bottom[num-1], cs_top[num-1]));
	                    faces.push(new $3Dmol.Triangle(last_cs_bottom[num-1], cs_top[num-1], last_cs_top[num-1]));

	                    faces.push(new $3Dmol.Triangle(cs_top[0], last_cs_top[0], last_cs_top[num-1]));
	                    faces.push(new $3Dmol.Triangle(cs_top[num-1], cs_top[0], last_cs_top[num-1]));

	                    faces.push(new $3Dmol.Triangle(cs_bottom[0], last_cs_bottom[0], last_cs_top[0]));
	                    faces.push(new $3Dmol.Triangle(cs_top[0], cs_bottom[0], last_cs_top[0]));

	                    for (j in faces)
	                    {
	                        currentAtom.intersectionShape.triangle.push(faces[j]);
	                        
	                    }
	                }

	            }
	            
	            geoGroup.vertices += 2*num;
	            lastAtom = currentAtom;
	        }

	        // for terminal faces
	        var vertexArray = geoGroup.vertexArray;
	        var colorArray = geoGroup.colorArray;
	        var faceArray = geoGroup.faceArray;
	        v_offset = geoGroup.vertices; va_offset = v_offset*3; f_offset = geoGroup.faceidx;

	        for (i = 0; i<num-1; i++) // "rear" face
	        {
	            var face = [i, i+1, 2*num-2-i, 2*num-1-i];

	            f_offset = geoGroup.faceidx;

	            faceArray[f_offset]   = face[0];
	            faceArray[f_offset+1] = face[1]; 
	            faceArray[f_offset+2] = face[3];

	            faceArray[f_offset+3] = face[1];
	            faceArray[f_offset+4] = face[2];
	            faceArray[f_offset+5] = face[3];

	            geoGroup.faceidx += 6;
	        }

	        for (i = 0; i<num-1; i++) // "front" face
	        {
	            var face = [v_offset-1-i, v_offset-2-i, v_offset-2*num+i+1, v_offset-2*num+i];

	            f_offset = geoGroup.faceidx;

	            faceArray[f_offset]   = face[0];
	            faceArray[f_offset+1] = face[1]; 
	            faceArray[f_offset+2] = face[3];

	            faceArray[f_offset+3] = face[1];
	            faceArray[f_offset+4] = face[2];
	            faceArray[f_offset+5] = face[3];

	            geoGroup.faceidx += 6;
	        }
	        
	        geo.initTypedArrays();
	        geo.setUpNormals();
	        
	        var material = new $3Dmol.MeshDoubleLambertMaterial();
	        material.vertexColors = $3Dmol.FaceColors;
	        if (typeof(opacity) === 'number' && opacity >= 0 && opacity < 1) {
	            material.transparent = true;
	            material.opacity = opacity;
	        }
	        var mesh = new $3Dmol.Mesh(geo, material);
	        group.add(mesh);
	    };

	    var drawPlainStrip = function(group, points, colors, div, thickness, opacity) {
	        if ((points.length) < 2)
	            return;

	        var p1, p2;
	        p1 = points[0];
	        p2 = points[points.length-1];

	        div = div || axisDIV;
	        p1 = subdivide(p1, div);
	        p2 = subdivide(p2, div);
	        if (!thickness)
	            return drawThinStrip(group, p1, p2, colors, div, opacity);

	        var geo = new $3Dmol.Geometry(true);
	        
	        //var vs = geo.vertices, fs = geo.faces;
	        var vs = [], fs = [];
	        var axis, p1v, p2v, a1v, a2v;
	        
	        var faces = [ [ 0, 2, -6, -8 ],
	                      [ -4, -2, 6, 4 ],
	                      [ 7, -1, -5, 3 ],
	                      [ -3, 5, 1, -7 ] ];
	                
	        var offset, vertoffset, faceoffset;
	        var color, colori;
	        var currentAtom, lastAtom;
	        var i, lim, j;
	        var face1, face2, face3;
	        var geoGroup;
	        
	        for (i = 0, lim = p1.length; i < lim; i++) {
	        
	            colori = Math.round(i*(colors.length-1)/lim);
	            color = $3Dmol.CC.color(colors[colori]);
	            
	            vs.push(p1v = p1[i]); // 0
	            vs.push(p1v);         // 1
	            vs.push(p2v = p2[i]); // 2
	            vs.push(p2v);         // 3
	            if (i < lim - 1) {
	                var toNext = p1[i + 1].clone().sub(p1[i]);
	                var toSide = p2[i].clone().sub(p1[i]);
	                axis = toSide.cross(toNext).normalize().multiplyScalar(
	                        thickness);
	            }
	            vs.push(a1v = p1[i].clone().add(axis)); // 4
	            vs.push(a1v); // 5
	            vs.push(a2v = p2[i].clone().add(axis)); // 6
	            vs.push(a2v); // 7
	            
	            if (p1v.atom !== undefined)
	                currentAtom = p1v.atom;
	            
	            geoGroup = geo.updateGeoGroup(8);
	            var vertexArray = geoGroup.vertexArray;
	            var colorArray = geoGroup.colorArray;
	            var faceArray = geoGroup.faceArray;
	            offset = geoGroup.vertices; vertoffset = offset*3;
	            
	            vertexArray[vertoffset]    = p1v.x; vertexArray[vertoffset+1]  = p1v.y; vertexArray[vertoffset+2]  = p1v.z;
	            vertexArray[vertoffset+3]  = p1v.x; vertexArray[vertoffset+4]  = p1v.y; vertexArray[vertoffset+5]  = p1v.z;
	            vertexArray[vertoffset+6]  = p2v.x; vertexArray[vertoffset+7]  = p2v.y; vertexArray[vertoffset+8]  = p2v.z;
	            vertexArray[vertoffset+9]  = p2v.x; vertexArray[vertoffset+10] = p2v.y; vertexArray[vertoffset+11] = p2v.z;
	            vertexArray[vertoffset+12] = a1v.x; vertexArray[vertoffset+13] = a1v.y; vertexArray[vertoffset+14] = a1v.z;
	            vertexArray[vertoffset+15] = a1v.x; vertexArray[vertoffset+16] = a1v.y; vertexArray[vertoffset+17] = a1v.z;
	            vertexArray[vertoffset+18] = a2v.x; vertexArray[vertoffset+19] = a2v.y; vertexArray[vertoffset+20] = a2v.z;
	            vertexArray[vertoffset+21] = a2v.x; vertexArray[vertoffset+22] = a2v.y; vertexArray[vertoffset+23] = a2v.z;
	            
	            for (j = 0; j < 8; ++j) {                
	                colorArray[vertoffset+3*j] = color.r; colorArray[vertoffset+1+3*j] = color.g; colorArray[vertoffset+2+3*j] = color.b;
	            }
	            
	            if (i > 0) {
	             
	                //both points have distinct atoms
	                var diffAtoms = ((lastAtom !== undefined && currentAtom !== undefined) && lastAtom.serial !== currentAtom.serial);
	                
	                for (j = 0; j < 4; j++ ) {
	                
	                    var face = [offset + faces[j][0], offset + faces[j][1], offset + faces[j][2], offset + faces[j][3]];
	                    
	                    faceoffset = geoGroup.faceidx;    
	                    
	                    faceArray[faceoffset] = face[0]; faceArray[faceoffset+1] = face[1]; faceArray[faceoffset+2] = face[3];
	                    faceArray[faceoffset+3] = face[1]; faceArray[faceoffset+4] = face[2]; faceArray[faceoffset+5] = face[3];
	                    
	                    geoGroup.faceidx += 6;
	                    
	                    if (currentAtom.clickable || lastAtom.clickable) {
	                        
	                        var p1a = vs[face[3]].clone(), p1b = vs[face[0]].clone(),
	                            p2a = vs[face[2]].clone(), p2b = vs[face[1]].clone();
	                        
	                        p1a.atom = vs[face[3]].atom || null; //should be same
	                        p2a.atom = vs[face[2]].atom || null; 
	                        
	                        
	                        p1b.atom = vs[face[0]].atom || null; //should be same                      
	                        p2b.atom = vs[face[1]].atom || null; 
	                        
	                        if (diffAtoms) {
	                            var m1 = p1a.clone().add(p1b).multiplyScalar(0.5);
	                            var m2 = p2a.clone().add(p2b).multiplyScalar(0.5);
	                            var m = p1a.clone().add(p2b).multiplyScalar(0.5);
	                            
	                            if (j % 2 === 0)
	                            {
	                                if (lastAtom.clickable) {
	                                    face1 = new $3Dmol.Triangle(m1, m, p1a);
	                                    face2 = new $3Dmol.Triangle(m2, p2a, m);
	                                    face3 = new $3Dmol.Triangle(m, p2a, p1a);
	                                    lastAtom.intersectionShape.triangle.push(face1);
	                                    lastAtom.intersectionShape.triangle.push(face2);
	                                    lastAtom.intersectionShape.triangle.push(face3);
	                                }
	                                
	                                if (currentAtom.clickable) {
	                                    face1 = new $3Dmol.Triangle(p1b, p2b, m);
	                                    face2 = new $3Dmol.Triangle(p2b, m2, m);
	                                    face3 = new $3Dmol.Triangle(p1b, m, m1);
	                                    currentAtom.intersectionShape.triangle.push(face1);
	                                    currentAtom.intersectionShape.triangle.push(face2);
	                                    currentAtom.intersectionShape.triangle.push(face3);
	                                }
	                            }
	                            else {
	                                if (currentAtom.clickable) {
	                                    face1 = new $3Dmol.Triangle(m1, m, p1a);
	                                    face2 = new $3Dmol.Triangle(m2, p2a, m);
	                                    face3 = new $3Dmol.Triangle(m, p2a, p1a);
	                                    currentAtom.intersectionShape.triangle.push(face1);
	                                    currentAtom.intersectionShape.triangle.push(face2);
	                                    currentAtom.intersectionShape.triangle.push(face3);
	                                }
	                                
	                                if (lastAtom.clickable) {
	                                    face1 = new $3Dmol.Triangle(p1b, p2b, m);
	                                    face2 = new $3Dmol.Triangle(p2b, m2, m);
	                                    face3 = new $3Dmol.Triangle(p1b, m, m1);
	                                    lastAtom.intersectionShape.triangle.push(face1);
	                                    lastAtom.intersectionShape.triangle.push(face2);
	                                    lastAtom.intersectionShape.triangle.push(face3);
	                                }                          
	                            }
	                            
	                        }
	                        
	                        //face for single atom
	                        else if (currentAtom.clickable) {
	                            face1 = new $3Dmol.Triangle(p1b, p2b, p1a);
	                            face2 = new $3Dmol.Triangle(p2b, p2a, p1a);
	                            currentAtom.intersectionShape.triangle.push(face1);
	                            currentAtom.intersectionShape.triangle.push(face2);
	                        }
	                        
	                    }
	                    
	                }
	            }
	            
	            geoGroup.vertices += 8;
	            lastAtom = currentAtom;
	        }
	        

	        var vsize = vs.length - 8; // Cap
	        
	        geoGroup = geo.updateGeoGroup(8);
	        var vertexArray = geoGroup.vertexArray;
	        var colorArray = geoGroup.colorArray;
	        var faceArray = geoGroup.faceArray;
	        offset = geoGroup.vertices; vertoffset = offset*3; faceoffset = geoGroup.faceidx;
	        
	        for (i = 0; i < 4; i++) {
	            vs.push(vs[i * 2]);
	            vs.push(vs[vsize + i * 2]);
	            
	            var v1 = vs[i * 2], v2 = vs[vsize + i * 2];
	            
	            vertexArray[vertoffset+6*i] = v1.x; vertexArray[vertoffset+1+6*i] = v1.y; vertexArray[vertoffset+2+6*i] = v1.z;
	            vertexArray[vertoffset+3+6*i] = v2.x; vertexArray[vertoffset+4+6*i] = v2.y; vertexArray[vertoffset+5+6*i] = v2.z;
	            
	            colorArray[vertoffset+6*i] = color.r; colorArray[vertoffset+1+6*i] = color.g; colorArray[vertoffset+2+6*i] = color.b;
	            colorArray[vertoffset+3+6*i] = color.r; colorArray[vertoffset+4+6*i] = color.g; colorArray[vertoffset+5+6*i] = color.b;

	        }
	        
	        vsize += 8;
	                
	        face1 = [offset, offset + 2, offset + 6, offset + 4];
	        face2 = [offset + 1, offset + 5, offset + 7, offset + 3];
	        
	        faceArray[faceoffset] = face1[0]; faceArray[faceoffset+1] = face1[1]; faceArray[faceoffset+2] = face1[3];
	        faceArray[faceoffset+3] = face1[1]; faceArray[faceoffset+4] = face1[2]; faceArray[faceoffset+5] = face1[3];
	        faceArray[faceoffset+6] = face2[0]; faceArray[faceoffset+7] = face2[1]; faceArray[faceoffset+8] = face2[3];
	        faceArray[faceoffset+9] = face2[1]; faceArray[faceoffset+10] = face2[2]; faceArray[faceoffset+11] = face2[3];
	        
	        geoGroup.faceidx += 12;
	        geoGroup.vertices += 8;
	        
	        //TODO: Add intersection planes for caps
	        
	        geo.initTypedArrays();
	        geo.setUpNormals();
	        
	                // HalfEdgeRec used to store adjacency info of mesh
	        var HalfEdge=function(vertIdx){
	            this.vert=vertIdx; // Vertex index at the end of this half-edge
	            this.twin=null;    // Oppositely oriented adjacent half-edge
	            this.next=null;    //Next half-edge around the face
	        };
	        
	        var computeAdjacency=function(faces,faceCount,vertCount){
	            //all pieces of the half-edge data structure
	            edges=[];
	            
	            // a hash table to hold the adjaceney info
	            // - Keys are pairs of vertex indices
	            // - Values are pointers to half-edge
	            var edgeTable={};
	            var len=0;
	            
	            //Plow through faces and fill all half-edge info except twin pointers:
	            for(var i=0;i<faceCount;i+=3){
	                var A=faces[i];
	                var B=faces[i+1];
	                var C=faces[i+2];
	               // console.log("A="+A+ " B="+ B+ " C="+C);
	                
	                //create the half-edge that goes from C to A
	                var CA=new HalfEdge(A);
	                edges.push(CA);
	                //create the half-edge that goes from A to B
	                var AB=new HalfEdge(B);
	                edges.push(AB);
	                //create the half-edge that goes from B to C
	                var BC=new HalfEdge(C);
	                edges.push(BC);
	                
	                CA.next=AB;
	                AB.next=BC;
	                BC.next=CA;
	                
	                edgeTable[C|(A<<16)]=CA; 
	                edgeTable[A|(B<<16)]=AB; 
	                edgeTable[B|(C<<16)]=BC;
	            }
	            
	            //verify that the mesh is clean
	            for(var key in edgeTable){
	                if(edgeTable.hasOwnProperty(key)){
	                    len++;
	                }
	            }
	            if(len!=faceCount*3){
	                console.warn("Bad mesh: duplicated edges or inconsistent winding.len="+len+" faceCount="+faceCount+" vertCount="+vertCount);
	            }
	            
	            //Populate the twin pointers by iterating over the hash table
	            var boundaryCount=0;
	            for(var key in edgeTable){
	                if(edgeTable.hasOwnProperty(key)){
	                    var twinKey=((key&0xffff)<<16)|(key>>16);
	                    if(edgeTable.hasOwnProperty(twinKey)){
	                        edgeTable[key].twin=edgeTable[twinKey];
	                        edgeTable[twinKey].twin=edgeTable[key];
	                    }else{
	                        boundaryCount+=1;
	                    }
	                }
	            }
	            
	            var ret=new Uint16Array(faceCount*6);
	            // Now that we have a half-edge structure, it's easy to create adjacency info for WebGL
	            if(boundaryCount>0){
	                console.log("Mesh is not watertight. Contains "+boundaryCount +" edges");
	                
	                for(var i=0;i<faceCount;i+=3){
	                    ret[i*2+0]=edges[i+2].vert;
	                    ret[i*2+1]=edges[i+0].twin==null?ret[i*2+0]:edges[i+0].twin.next.vert;
	                    ret[i*2+2]=edges[i+0].vert;
	                    ret[i*2+3]=edges[i+1].twin==null?ret[i*2+1]:edges[i+1].twin.next.vert;                  
	                    ret[i*2+4]=edges[i+1].vert;
	                    ret[i*2+5]=edges[i+2].twin==null?ret[i*2+2]:edges[i+2].twin.next.vert;
	                }
	            }
	            else{
	                for(var i=0;i<faceCount;i+=3){
	                    ret[i*2+0]=edges[i+2].vert;
	                    ret[i*2+1]=edges[i+0].twin.next.vert;
	                    ret[i*2+2]=edges[i+0].vert;
	                    ret[i*2+3]=edges[i+1].twin.next.vert;                   
	                    ret[i*2+4]=edges[i+1].vert;
	                    ret[i*2+5]=edges[i+2].twin.next.vert;
	                } 
	            }
	            
	            return ret;
	        };
	        
	        //geoGroup.adjFaceArray = computeAdjacency(faceArray,faceArray.length,offset);
	        
	        var material = new $3Dmol.MeshDoubleLambertMaterial();
	        material.vertexColors = $3Dmol.FaceColors;
	        if(typeof(opacity) === 'number' && opacity >= 0 && opacity < 1) {
	            material.transparent = true;
	            material.opacity = opacity;
	        }
	        var mesh = new $3Dmol.Mesh(geo, material);
	        group.add(mesh);   
	    };

	    //TODO: Need to update this (will we ever use this?)
	    var drawSmoothCurve = function(group, _points, width, colors, div) {
	        if (_points.length === 0)
	            return;

	        div = (div === undefined) ? 5 : div;

	        var geo = new $3Dmol.Geometry();
	        var points = subdivide(_points, div);
	                /*
	        for ( var i = 0; i < points.length; i++) {
	            geo.vertices.push(points[i]);
	            geo.colors.push($3Dmol.color(colors[(i == 0) ? 0 : Math.round((i - 1)
	                    / div)]));
	        }
	                */
	        var lineMaterial = new $3Dmol.LineBasicMaterial({
	            linewidth : width
	        });
	        lineMaterial.vertexColors = true;
	        var line = new $3Dmol.Line(geo, lineMaterial);
	        line.type = $3Dmol.LineStrip;
	        group.add(line);
	    };

	    var drawStrip = function(group, points, colors, div, thickness, opacity, shape)
	    {    
	        if (!shape || shape === "default")
	            shape = "rectangle";
	        if(shape === 'edged')
	            drawPlainStrip(group, points, colors, div, thickness, opacity);
	        else if (shape === "rectangle" || shape === "oval" || shape === "parabola")
	            drawShapeStrip(group, points, colors, div, thickness, opacity, shape);
	    }

	    // check if given atom is an alpha carbon
	    var isAlphaCarbon = function(atom)
	    {
	        return atom && atom.elem === "C" && atom.atom === "CA"; // note that calcium is also CA
	    }

	    // check whether two atoms are members of the same residue or subsequent, connected residues (a before b)
	    var inConnectedResidues = function(a, b)
	    {
	        if(a && b && a.chain === b.chain) {
	            if((a.reschain === b.reschain) && (a.resi === b.resi || a.resi === b.resi-1))
	                return true;
	            if(a.resi < b.resi) {
	                //some PDBs have gaps in the numbering but the residues are still connected
	                //assume if within 4A they are connected
	                var av = new $3Dmol.Vector3(a.x, a.y, a.z);
	                var bv = new $3Dmol.Vector3(b.x, b.y, b.z);
	                var dist = av.distanceToSquared(bv);
	                if(dist < 16.0) return true; //calpha dist
	            }
	        }

	        return false;

	    }

	    var drawCartoon = function(group, atomList, gradientScheme, fill, doNotSmoothen, num, div)
	    {
	        num = num || defaultNum;
	        div = div || defaultDiv;

	                        //  proteins    na backbone  na terminus                  nucleobases
	        var cartoonAtoms = ["CA", "O",  "P", "OP2", "O2P", "O5'", "O3'", "C5'", "C2'","O5*", "O3*", "C5*", "C2*", "N1", "N3"];
	        var purResns = ["DA", "DG", "A", "G"];
	        var pyrResns = ["DT", "DC", "U", "C", "T"];
	        var naResns  =  purResns.concat(pyrResns);

	        var geo, cartoon, prev, curr, next, currColor, nextColor, thickness, i, nextResAtom, arrow;
	        var backbonePt, orientPt, prevOrientPt, terminalPt, termOrientPt, baseStartPt, baseEndPt;
	        var tubeStart, tubeEnd, drawingTube;
	        var traceGeo = null;
	        var colors = [];
	        var points = [];
	        for (var i = 0; i < num; i++)
	            points[i] = [];

	        // first determine where beta sheet arrows and alpha helix tubes belong
	        var inSheet = false;
	        var inHelix = false;
	        i = 0;
	        for (i in atomList)
	        {
	            next = atomList[i];
	            if (next.elem === 'C' && next.atom === 'CA')
	            {
	                var connected = inConnectedResidues(curr, next);

	                // last two residues in a beta sheet become arrowhead
	                if (connected && next.ss === "s")
	                {
	                    inSheet = true;
	                }
	                else if (inSheet)
	                {   
	                    if (curr && prev && curr.style.cartoon.arrows && prev.style.cartoon.arrows)
	                    {
	                        curr.ss = "arrow end";
	                        prev.ss = "arrow start";
	                    }
	                    inSheet = false; 
	                }

	                // first and last residues in a helix are used to draw tube
	                if (connected && curr.ss === "h")
	                {
	                    if (!inHelix && next.style.cartoon.tubes) next.ss = "tube start";
	                    inHelix = true;
	                }
	                else if (inHelix && curr.ss !== "tube start")
	                {
	                    if (prev && prev.style.cartoon.tubes) prev.ss = "tube end";
	                    inHelix = false;
	                }
	                prev = curr;
	                curr = next;
	            }
	        }

	        // then accumulate points
	        curr = undefined;
	        for (i in atomList)
	        {
	            next = atomList[i];
	            
	            if (next === undefined || $.inArray(next.atom, cartoonAtoms) === -1)
	                continue; // skip array holes, heteroatoms, and atoms not involved in cartoon drawing

	            var inNucleicAcid = ($.inArray(next.resn.trim(), naResns) != -1)

	            // determine cartoon style
	            cartoon = next.style.cartoon;
	            if (cartoon.style === "trace") // draw cylinders connecting consecutive 'backbone' atoms
	            {
	                /* "trace" style just draws cylinders between consecutive 'backbone' atoms,
	                    such as alpha carbon for polypeptides and phosphorus for DNA. */

	                if (!traceGeo) traceGeo = new $3Dmol.Geometry(true);

	                if (next.elem === 'C' && next.atom === 'CA' || inNucleicAcid && next.atom === "P")
	                {
	                    // determine cylinder color
	                    if (gradientScheme && cartoon.color === 'spectrum')
	                        nextColor = gradientScheme.valueToHex(next.resi, gradientScheme.range());
	                    else
	                        nextColor = $3Dmol.getColorFromStyle(next, cartoon).getHex();
	                    colors.push(nextColor);

	                    // determine cylinder thickness
	                    if ($.isNumeric(cartoon.thickness))
	                        thickness = cartoon.thickness;
	                    else
	                        thickness = defaultThickness;

	                    if (inConnectedResidues(curr, next))
	                    {
	                        // if both atoms are same color, draw single cylinder
	                        if (nextColor == currColor)
	                        {
	                            var color = $3Dmol.CC.color(nextColor);
	                            $3Dmol.GLDraw.drawCylinder(traceGeo, curr, next, thickness, color, 2, 2);
	                        }

	                        else // otherwise draw cylinders for each color (split down the middle)
	                        {
	                            var midpoint = new $3Dmol.Vector3().addVectors(curr, next).multiplyScalar(0.5);
	                            var color1 = $3Dmol.CC.color(currColor);
	                            var color2 = $3Dmol.CC.color(nextColor);
	                            $3Dmol.GLDraw.drawCylinder(traceGeo, curr, midpoint, thickness, color1, 2, 0);
	                            $3Dmol.GLDraw.drawCylinder(traceGeo, midpoint, next, thickness, color2, 0, 2);
	                        } // note that an atom object can be duck-typed as a $3Dmol.Vector3 in this case
	                    }

	                    if (curr && traceGeo && (curr.style.cartoon && curr.style.cartoon.style != "trace"
	                        || curr.chain != next.chain))
	                    {
	                        var traceMaterial = new $3Dmol.MeshDoubleLambertMaterial();
	                        traceMaterial.vertexColors = $3Dmol.FaceColors;
	                        if ( typeof(traceGeo.opacity) === "number" && traceGeo.opacity >= 0 && traceGeo.opacity < 1) {
	                            traceMaterial.transparent = true;
	                            traceMaterial.opacity = traceGeo.opacity;
	                            delete traceGeo.opacity;
	                        }
	                        var traceMesh = new $3Dmol.Mesh(traceGeo, traceMaterial);
	                        group.add(traceMesh);
	                        traceGeo = null;
	                    } else if (curr) // make sure whole chain is same opacity
	                    {
	                        if (traceGeo.opacity && curr.style.cartoon.opacity)
	                        {
	                            if (traceGeo.opacity != curr.style.cartoon.opacity)
	                            {
	                                console.log("Warning: a trace-style chain's opacity is ambiguous");
	                                traceGeo.opacity = 1;
	                            }
	                        }
	                        else traceGeo.opacity = parseFloat(curr.style.cartoon.opacity) || 1;
	                    }

	                    curr = next;
	                    currColor = nextColor;
	                }
	            }

	            else // draw default-style cartoons based on secondary structure
	            {
	                if (!geo) geo = new $3Dmol.Geometry(true);

	                // draw backbone through these atoms
	                if (isAlphaCarbon(next) ||
	                    inNucleicAcid && (next.atom === "P" || next.atom.indexOf('O5') == 0))
	                {
	                    if (drawingTube)
	                    {
	                        if (next.ss === "tube end")
	                        {
	                            drawingTube = false;
	                            tubeEnd = new $3Dmol.Vector3(next.x, next.y, next.z);
	                            $3Dmol.GLDraw.drawCylinder(geo, tubeStart, tubeEnd, 2, $3Dmol.CC.color(currColor), 1, 1);
	                            next.ss = "h";

	                        }
	                        else continue; // don't accumulate strand points while in the middle of drawing a tube
	                    }

	                    // end of a chain of connected residues (of same style)
	                    if (curr && (!inConnectedResidues(curr, next) || curr.style.cartoon.style !== next.style.cartoon.style ||
	                        curr.ss === "tube start"))
	                    { 
	                        if (curr.ss === "tube start")
	                        {
	                            drawingTube = true;
	                            tubeStart = new $3Dmol.Vector3(curr.x, curr.y, curr.z);
	                            curr.ss = "h";
	                        }

	                        if (baseEndPt) // draw the last base if it's a NA chain
	                        {
	                            if (terminalPt)
	                                baseStartPt = new $3Dmol.Vector3().addVectors(curr, terminalPt).multiplyScalar(0.5);
	                            else
	                                baseStartPt = new $3Dmol.Vector3(curr.x, curr.y, curr.z);

	                            $3Dmol.GLDraw.drawCylinder(geo, baseStartPt, baseEndPt, 0.4, $3Dmol.CC.color(baseEndPt.color), 0, 2);
	                            arrow = addBackbonePoints(points, num, !doNotSmoothen, terminalPt, termOrientPt, prevOrientPt, curr, atomList, i);
	                            colors.push(nextColor);
	                            if (arrow) colors.push(nextColor);
	                            
	                            baseStartPt = null;
	                            baseEndPt = null;
	                        }

	                        // draw accumulated strand points
	                        for (i = 0; !thickness && i < num; i++)
	                            drawSmoothCurve(group, points[i], 1, colors, div, points.opacity);
	                        if (fill && points[0].length > 0) 
	                            drawStrip(group, points, colors, div, thickness, points.opacity, points.style);
	                        
	                        if (geo != null && geo.vertices > 0)
	                        {
	                            var cartoonMaterial = new $3Dmol.MeshDoubleLambertMaterial();
	                            cartoonMaterial.vertexColors = $3Dmol.FaceColors;
	                            if (typeof(points.opacity) === "number" && points.opacity >= 0 && points.opacity < 1) {
	                                cartoonMaterial.transparent = true;
	                                cartoonMaterial.opacity = points.opacity;
	                            }
	                            var cartoonMesh = new $3Dmol.Mesh(geo, cartoonMaterial);
	                            group.add(cartoonMesh);
	                            geo = null;
	                        }

	                        // clear arrays for points and colors
	                        points = [];
	                        for (i = 0; i < num; i++)
	                            points[i] = [];
	                        colors = [];
	                    }

	                    // reached next residue (potentially the first residue)
	                    if (curr === undefined || curr.rescode != next.rescode || curr.resi != next.resi)
	                    {
	                        if (baseEndPt) // draw last NA residue's base
	                        {
	                            // start the cylinder at the midpoint between consecutive backbone atoms
	                            baseStartPt = new $3Dmol.Vector3().addVectors(curr, next).multiplyScalar(0.5);
	                            var startFix = baseStartPt.clone().sub(baseEndPt).multiplyScalar(0.02); //TODO: apply this as function of thickness
	                            baseStartPt.add(startFix);

	                            $3Dmol.GLDraw.drawCylinder(geo, baseStartPt, baseEndPt, 0.4, $3Dmol.CC.color(baseEndPt.color), 0, 2);
	                            baseStartPt = null;
	                            baseEndPt = null;   
	                        }

	                        // determine color and thickness of the next strand segment
	                        if (gradientScheme && cartoon.color === 'spectrum')
	                            nextColor = gradientScheme.valueToHex(next.resi, gradientScheme.range());
	                        else
	                            nextColor = $3Dmol.getColorFromStyle(next, cartoon).getHex();
	                        colors.push(nextColor);
	                        if ($.isNumeric(cartoon.thickness))
	                            thickness = cartoon.thickness;
	                        else
	                            thickness = defaultThickness;

	                        
	                        curr = next; // advance backbone
	                        //nextResAtom = atomList[parseInt(i) + resSize[curr.resn]];
	                        backbonePt = new $3Dmol.Vector3(curr.x, curr.y, curr.z);
	                        backbonePt.resi = curr.resi;
	                        currColor = nextColor;
	                    }

	                    // click handling
	                    if (next.clickable === true &&
	                        (next.intersectionShape === undefined || next.intersectionShape.triangle === undefined)) 
	                        next.intersectionShape = {sphere : null, cylinder : [], line : [], triangle : []};
	                }

	                // atoms used to orient the backbone strand
	                else if (isAlphaCarbon(curr) && next.atom === "O"
	                      || inNucleicAcid && curr.atom === "P" && (next.atom === "OP2" || next.atom === "O2P")
	                      || inNucleicAcid && curr.atom.indexOf("O5") == 0 && next.atom.indexOf("C5") == 0)
	                {
	                    orientPt = new $3Dmol.Vector3(next.x, next.y, next.z);
	                    orientPt.resi = next.resi;
	                    if (next.atom === "OP2" || next.atom === "O2P") // for NA 3' terminus
	                        termOrientPt = new $3Dmol.Vector3(next.x, next.y, next.z);
	                }

	                // NA 3' terminus is an edge case, need a vector for most recent O3'
	                else if (inNucleicAcid && next.atom.indexOf("O3") == 0)
	                {
	                    terminalPt = new $3Dmol.Vector3(next.x, next.y, next.z);
	                }

	                // atoms used for drawing the NA base cylinders (diff for purines and pyramidines)
	                else if ((next.atom === "N1" && $.inArray(next.resn.trim(), purResns) != -1) ||
	                         (next.atom === "N3" && $.inArray(next.resn.trim(), pyrResns) != -1))
	                {
	                    baseEndPt = new $3Dmol.Vector3(next.x, next.y, next.z);
	                    baseEndPt.color = $3Dmol.getColorFromStyle(next, cartoon).getHex();
	                }

	                // when we have a backbone point and orientation point in the same residue, accumulate strand points
	                if (orientPt && backbonePt && orientPt.resi === backbonePt.resi)
	                {
	                    arrow = addBackbonePoints(points, num, !doNotSmoothen, backbonePt, orientPt, prevOrientPt, curr, atomList, i);
	                    prevOrientPt = orientPt;
	                    backbonePt = null;
	                    orientPt = null;
	                    colors.push(nextColor);
	                    if (arrow) colors.push(nextColor);
	                }
	            }
	        }

	        if (baseEndPt) // draw last NA base if needed
	        {
	            if (terminalPt)
	                baseStartPt = new $3Dmol.Vector3().addVectors(curr, terminalPt).multiplyScalar(0.5);
	            else
	                baseStartPt = new $3Dmol.Vector3(curr.x, curr.y, curr.z);

	            $3Dmol.GLDraw.drawCylinder(geo, baseStartPt, baseEndPt, 0.4, $3Dmol.CC.color(baseEndPt.color), 0, 2);
	            arrow = addBackbonePoints(points, num, !doNotSmoothen, terminalPt, termOrientPt, prevOrientPt, curr, atomList, i);
	            colors.push(nextColor);
	            if (arrow) colors.push(nextColor);
	        }

	        // for default style, draw the last strand
	        for (i = 0; !thickness && i < num; i++)
	            drawSmoothCurve(group, points[i], 1, colors, div, points.opacity);
	        if (fill && points[0].length > 0)
	        {
	            drawStrip(group, points, colors, div, thickness, points.opacity, points.style);
	        }
	        if (geo != null && geo.vertices > 0)
	        {
	            var cartoonMaterial = new $3Dmol.MeshDoubleLambertMaterial();
	            cartoonMaterial.vertexColors = $3Dmol.FaceColors;
	            if (typeof(points.opacity) === "number" && points.opacity >= 0 && points.opacity < 1) {
	                cartoonMaterial.transparent = true;
	                cartoonMaterial.opacity = points.opacity;
	            }
	            var cartoonMesh = new $3Dmol.Mesh(geo, cartoonMaterial);
	            group.add(cartoonMesh);
	            geo = null;
	        }

	        if (traceGeo != null && traceGeo.vertices > 0) // generate last mesh for trace geometry
	        {
	            var traceMaterial = new $3Dmol.MeshDoubleLambertMaterial();
	            traceMaterial.vertexColors = $3Dmol.FaceColors;
	            if (typeof(traceGeo.opacity) === "number" && traceGeo.opacity >= 0 && traceGeo.opacity < 1) {
	                traceMaterial.transparent = true;
	                traceMaterial.opacity = traceGeo.opacity;
	                delete traceGeo.opacity;
	            }
	            var traceMesh = new $3Dmol.Mesh(traceGeo, traceMaterial);
	            group.add(traceMesh);
	        }
	    };

	    var addBackbonePoints = function(points, num, smoothen, backbonePt, orientPt, prevOrientPt, backboneAtom, atomList, atomi)
	    {
	        var widthScalar, i, delta, v, addArrowPoints, testOpacity, testStyle;
	        
	        // dictionary of standard amino acid sizes, in number of atoms
	        var resSize = {ALA: 5, ARG: 11, ASN:8, ASP:8, CYS:6, GLN:9, GLU: 9, GLY:4, HIS:10,
	            ILE:8, LEU: 8, LYS: 9, MET:8, PHE:11, PRO:7, SER:6, THR:7, TRP:14, TYR:12, VAL:7}
	        
	        if(!backbonePt || !orientPt || !backboneAtom)
	            return;
	        
	        // the side vector points along the axis from backbone atom to orientation atom (eg. CA to O, in peptides)
	        var sideVec = orientPt.sub(backbonePt);
	        sideVec.normalize();

	        // the forward vector points along the axis from backbone atom to next backbone atom
	        var forwardVec = atomList[parseInt(atomi) + resSize[backboneAtom.resn]];
	        forwardVec = forwardVec ? new $3Dmol.Vector3(forwardVec.x, forwardVec.y, forwardVec.z) : new $3Dmol.Vector3(0, 0, 0);
	        forwardVec.sub(backbonePt);

	        // adjustments for proper beta arrow appearance
	        if (backboneAtom.ss === "arrow start")
	        {
	            var adjustment = forwardVec.clone().multiplyScalar(0.3).cross(orientPt); // adjust perpendicularly to strand face
	            backbonePt.add(adjustment);

	            var upVec = forwardVec.clone().cross(sideVec).normalize();
	            sideVec.rotateAboutVector(upVec, 0.43);
	        }

	        // determine from cartoon style or secondary structure how wide the strand should be here
	        // ribbon shape should have same width as thickness
	        if (backboneAtom.style.cartoon.ribbon)
	        {
	            widthScalar = backboneAtom.style.cartoon.thickness || defaultThickness;

	        } else // depending on secondary structure, multiply the orientation vector by some scalar
	        {
	            if (!backboneAtom.style.cartoon.width)
	            {
	                if (backboneAtom.ss === "c")
	                {
	                    if (backboneAtom.atom === "P")
	                        widthScalar = nucleicAcidWidth;
	                    else
	                        widthScalar = coilWidth;
	                } else if (backboneAtom.ss === "arrow start")
	                {
	                    widthScalar = helixSheetWidth;
	                    addArrowPoints = true;

	                } else if (backboneAtom.ss === "arrow end")
	                    widthScalar = coilWidth;
	                
	                else if (backboneAtom.ss === "h" && backboneAtom.style.cartoon.tubes || backboneAtom.ss === "tube start")
	                    widthScalar = coilWidth;

	                else
	                    widthScalar = helixSheetWidth;
	            }
	            else widthScalar = backboneAtom.style.cartoon.width;  
	        }

	        // make sure the strand orientation doesn't twist more than 90 degrees
	        if (prevOrientPt != null && sideVec.dot(prevOrientPt) < 0)
	            sideVec.negate();


	        sideVec.multiplyScalar(widthScalar);
	        for (i = 0; i < num; i++)
	        {
	            // produces NUM incremental points from backbone atom minus orientation vector
	            //  to backbone atom plus orientation vector
	            delta = -1 + i * 2/(num - 1); // -1 to 1 incrementing by num
	            v = new $3Dmol.Vector3(backbonePt.x + delta * sideVec.x,
	                                   backbonePt.y + delta * sideVec.y,
	                                   backbonePt.z + delta * sideVec.z);
	            v.atom = backboneAtom;
	            if (smoothen && backboneAtom.ss === "s") 
	                v.smoothen = true;
	            points[i].push(v); // a num-length array of arrays, where each inner array contains length-wise points
	                               // along the backbone offset by some constant pertaining to its cell in the outer array
	        }

	        if (addArrowPoints)
	        {

	            sideVec.multiplyScalar(2);
	            for (i = 0; i < num; i++)
	            {
	                delta = -1 + i * 2/(num - 1); // -1 to 1 incrementing by num
	                v = new $3Dmol.Vector3(backbonePt.x + delta * sideVec.x,
	                                       backbonePt.y + delta * sideVec.y,
	                                       backbonePt.z + delta * sideVec.z);
	                v.atom = backboneAtom;
	                v.smoothen = false;
	                v.skip = true;
	                points[i].push(v);
	            }
	        }

	        // make sure the strand is all the same opacity and style
	        testOpacity = parseFloat(backboneAtom.style.cartoon.opacity) || 1;
	        if (points.opacity)
	        {
	            if (points.opacity != testOpacity)
	            {
	                console.log("Warning: a cartoon-style chain's opacity is ambiguous");
	                points.opacity = 1;
	            }

	        } else points.opacity = testOpacity;

	        testStyle = backboneAtom.style.cartoon.style || 'default';
	        if (points.style)
	        {
	            if (points.style != testStyle)
	            {
	                console.log("Warning: a cartoon chain's strand-style is ambiguous");
	                points.style = 'default';
	            }

	        } else points.style = testStyle;

	        // revert ss keywords used for arrow rendering back to original value
	        if (backboneAtom.ss === "arrow start" || backboneAtom.ss === "arrow end")
	            backboneAtom.ss = "s";

	        return addArrowPoints;
	    };

	    var defaultDrawCartoon = function(group, atomList, gradientScheme, quality)
	    {
	        quality = parseInt(parseFloat(quality)*5) || 5;
	        drawCartoon(group, atomList, gradientScheme, fill=true, doNotSmoothen=false, num=quality, div=quality);
	    }

	    return defaultDrawCartoon;
	})();
	//

	var $3Dmol = $3Dmol || {};

	/**
	 * Lower level utilities for creating WebGL shape geometries.
	 * These are not intended for general consumption.
	 * @namespace $3Dmol.GLDraw
	  */
	$3Dmol.GLDraw = (function() {

	    var draw = {}; // object for exporting functions

	    // Rotation matrix around z and x axis -
	    // according to y basis vector
	    // TODO: Try to optimize this (square roots?)
	    var getRotationMatrix = function() {

	        var d = new $3Dmol.Vector3();
	        // var rot = new Float32Array(9);

	        return function(dir) {

	            d.set(dir[0], dir[1], dir[2]);

	            var dx = d.x, dy = d.y, dz = d.z;

	            var dxy = Math.sqrt(dx * dx + dy * dy);
	            var dxz, dyz;

	            var sinA, cosA, sinB, cosB, sinC, cosC;

	            // about z axis - Phi
	            if (dxy < 0.0001) {
	                sinA = 0;
	                cosA = 1;
	            }

	            else {
	                sinA = -dx / dxy;
	                cosA = dy / dxy;
	            }

	            // recast dy in terms of new axes - z is the same

	            dy = -sinA * dx + cosA * dy;
	            dyz = Math.sqrt(dy * dy + dz * dz);

	            // about new x axis - Theta

	            if (dyz < 0.0001) {
	                sinB = 0;
	                cosB = 1;
	            }

	            else {
	                sinB = dz / dyz;
	                cosB = dy / dyz;
	            }

	            var rot = new Float32Array(9);
	            rot[0] = cosA;
	            rot[1] = sinA;
	            rot[2] = 0;
	            rot[3] = -sinA * cosB;
	            rot[4] = cosA * cosB;
	            rot[5] = sinB;
	            rot[6] = sinA * sinB;
	            rot[7] = -cosA * sinB;
	            rot[8] = cosB;

	            return rot;

	        };

	    }();
	    
	    // Ortho normal vectors for cylinder radius/ sphere cap equator and cones
	    // Direction is j basis (0,1,0)
	    var basisVectors = function() {

	        var ret = {
	            vertices : [],
	            norms : []
	        };

	        var nvecs = [];

	        var subdivisions = 4; // including the initial 2, eg. 4 => 16 subintervals
	        var N = Math.pow(2, subdivisions);  // eg. 2**4 = 16 subintervals in total
	        var i = 2;  // start with 2 subdivisions already done
	        var M = Math.pow(2, i); // 4
	        var spacing = N/M;  // 16/4 = 4; if there were 5 subdivs, then 32/4 = 8.
	        var j;

	        nvecs[0] = new $3Dmol.Vector3(-1, 0, 0);
	        nvecs[spacing] = new $3Dmol.Vector3(0, 0, 1);
	        nvecs[spacing*2] = new $3Dmol.Vector3(1, 0, 0);
	        nvecs[spacing*3] = new $3Dmol.Vector3(0, 0, -1);

	        for ( i = 3; i <= subdivisions; i ++ ) {
	            // eg. i=3, we need to add 2**(3-1) = 4 new vecs. Call it M.
	            // their spacing is N/M, eg. N=16, M=4, N/M=4; M=8, N/M=2.
	            // they start off at half this spacing
	            // and are equal to the average of the two vectors on either side
	            M = Math.pow(2, (i-1));
	            spacing = N/M;
	            for ( j = 0; j < (M-1); j ++ ) {
	                nvecs[spacing/2 + j*spacing] = nvecs[j*spacing].clone().add(nvecs[(j+1)*spacing]).normalize();
	            }
	            // treat the last one specially so it wraps around to zero
	            j = M - 1;
	            nvecs[spacing/2 + j*spacing] = nvecs[j*spacing].clone().add(nvecs[0]).normalize();
	        }

	        /*
	         * nvecs[0] = new $3Dmol.Vector3(-1,0,0); nvecs[1] = new
	         * $3Dmol.Vector3(0,0,1); nvecs[2] = new $3Dmol.Vector3(1,0,0);
	         * nvecs[3] = new $3Dmol.Vector3(0,0,-1);
	         */
	        return nvecs;

	    }();

	    // memoize capped cylinder for given radius
	    var cylVertexCache = {

	        // memoize both rounded and flat caps (hemisphere and circle)
	        cache : {false:{}, true:{}},

	        getVerticesForRadius : function(radius, flat) {

	            if (this.cache[flat][radius] !== undefined)
	                return this.cache[flat][radius];

	            var dir = new $3Dmol.Vector3(0, 1, 0);
	            var w = basisVectors.length;
	            var nvecs = [], norms = [];
	            var n;

	            for (var i = 0; i < w; i++) {
	                // bottom
	                nvecs.push(basisVectors[i].clone().multiplyScalar(radius));
	                // top
	                nvecs.push(basisVectors[i].clone().multiplyScalar(radius));

	                // NOTE: this normal is used for constructing sphere caps -
	                // cylinder normals taken care of in drawCylinder
	                n = basisVectors[i].clone().normalize();
	                norms.push(n);
	                norms.push(n);
	            }

	            // norms[0]

	            var verticesRows = [];

	            // Require that heightSegments is even and >= 2
	            // Equator points at h/2 (theta = pi/2)
	            // (repeated) polar points at 0 and h (theta = 0 and pi)
	            var heightSegments = 10, widthSegments = w; // 16 or however many
	                                                        // basis vectors for
	                                                        // cylinder

	            if (heightSegments % 2 !== 0 || !heightSegments) {
	                console.error("heightSegments must be even");

	                return null;
	            }

	            var phiStart = 0;
	            var phiLength = Math.PI * 2;

	            var thetaStart = 0;
	            var thetaLength = Math.PI;

	            var x, y;
	            var polar = false, equator = false;

	            for (y = 0; y <= heightSegments; y++) {

	                polar = (y === 0 || y === heightSegments) ? true : false;
	                equator = (y === heightSegments / 2) ? true : false;

	                var verticesRow = [], toRow = [];

	                for (x = 0; x <= widthSegments; x++) {

	                    // Two vertices rows for equator pointing to previously
	                    // constructed cyl points
	                    if (equator) {
	                        var xi = (x < widthSegments) ? 2 * x : 0;
	                        toRow.push(xi + 1);
	                        verticesRow.push(xi);

	                        continue;
	                    }

	                    var u = x / widthSegments;
	                    var v = y / heightSegments;

	                    // Only push first polar point

	                    if (!polar || x === 0) {

	                        if (x < widthSegments) {
	                            var vertex = new $3Dmol.Vector3();
	                            vertex.x = -radius
	                                    * Math.cos(phiStart + u * phiLength)
	                                    * Math.sin(thetaStart + v * thetaLength);
	                            vertex.y = flat ? 0 : radius * Math.cos(thetaStart + v * thetaLength);
	                            vertex.z = radius
	                                    * Math.sin(phiStart + u * phiLength)
	                                    * Math.sin(thetaStart + v * thetaLength);

	                            if (Math.abs(vertex.x) < 1e-5)
	                                vertex.x = 0;
	                            if (Math.abs(vertex.y) < 1e-5)
	                                vertex.y = 0;
	                            if (Math.abs(vertex.z) < 1e-5)
	                                vertex.z = 0;

	                            if (flat) {
	                                n = new $3Dmol.Vector3(0, Math.cos(thetaStart + v * thetaLength), 0);
	                                n.normalize();
	                            }
	                            else {
	                                n = new $3Dmol.Vector3(vertex.x, vertex.y, vertex.z);
	                                n.normalize();
	                            }

	                            nvecs.push(vertex);
	                            norms.push(n);

	                            verticesRow.push(nvecs.length - 1);
	                        }

	                        // last point is just the first point for this row
	                        else {
	                            verticesRow.push(nvecs.length - widthSegments);
	                        }

	                    }

	                    // x > 0; index to already added point
	                    else if (polar)
	                        verticesRow.push(nvecs.length - 1);

	                }

	                // extra equator row
	                if (equator)
	                    verticesRows.push(toRow);

	                verticesRows.push(verticesRow);

	            }

	            var obj = {
	                vertices : nvecs,
	                normals : norms,
	                verticesRows : verticesRows,
	                w : widthSegments,
	                h : heightSegments
	            };

	            this.cache[flat][radius] = obj;

	            return obj;

	        }
	    };

	    // creates a cylinder
	    var drawnC = 0;
	    
	    /** Create a cylinder 
	     * @function $3Dmol.GLDraw.drawCylinder
	     * @param {geometry}
	     *            geo
	     * @param {Point}
	     *            from
	     * @param {Point}
	     *            to
	     * @param {float}
	     *            radius
	     * @param {$3Dmol.Color}
	     *            color
	     * @param {integer} fromCap - 0 for none, 1 for flat, 2 for round; Note: currently do not support different styles of caps on the same cylinder.
	     * @param {integer} toCap = 0 for none, 1 for flat, 2 for round
	     *            
	     * */
	    draw.drawCylinder = function(geo, from, to, radius, color, fromCap, toCap) {
	        if (!from || !to)
	            return;
	        drawnC++;
	        // vertices
	        var drawcaps = fromCap || toCap;

	        var flat = false;
	        if (fromCap == 1 && toCap == 1) // 0 is none, 1 is flat, 2 is round
	          	flat = true;

	        color = color || {r:0, g:0, b:0};

	        /** @type {Array.<number>} */
	        var dir = [ to.x, to.y, to.z ];
	        dir[0] -= from.x;
	        dir[1] -= from.y;
	        dir[2] -= from.z;

	        var e = getRotationMatrix(dir);
	        // get orthonormal vectors from cache
	        // TODO: Will have orient with model view matrix according to direction
	        var vobj = cylVertexCache.getVerticesForRadius(radius, flat);

	        // w (n) corresponds to the number of orthonormal vectors for cylinder
	        // (default 16)
	        var n = vobj.w, h = vobj.h;
	        var w = n;
	        // get orthonormal vector
	        var n_verts = (drawcaps) ? h * n + 2 : 2 * n;

	        var geoGroup = geo.updateGeoGroup(n_verts);

	        var vertices = vobj.vertices, normals = vobj.normals, verticesRows = vobj.verticesRows;
	        var toRow = verticesRows[h / 2], fromRow = verticesRows[h / 2 + 1];

	        var start = geoGroup.vertices;
	        var offset, faceoffset;
	        var i, x, y, z;

	        var vertexArray = geoGroup.vertexArray;
	        var normalArray = geoGroup.normalArray;
	        var colorArray = geoGroup.colorArray;
	        var faceArray = geoGroup.faceArray;
	        // add vertices, opposing vertices paired together
	        for (i = 0; i < n; ++i) {

	            var vi = 2 * i;

	            x = e[0] * vertices[vi].x + e[3] * vertices[vi].y + e[6]
	                    * vertices[vi].z;
	            y = e[1] * vertices[vi].x + e[4] * vertices[vi].y + e[7]
	                    * vertices[vi].z;
	            z = e[5] * vertices[vi].y + e[8] * vertices[vi].z;

	            // var xn = x/radius, yn = y/radius, zn = z/radius;

	            offset = 3 * (start + vi);
	            faceoffset = geoGroup.faceidx;

	            // from
	            vertexArray[offset] = x + from.x;
	            vertexArray[offset + 1] = y + from.y;
	            vertexArray[offset + 2] = z + from.z;
	            // to
	            vertexArray[offset + 3] = x + to.x;
	            vertexArray[offset + 4] = y + to.y;
	            vertexArray[offset + 5] = z + to.z;

	            // normals
	            normalArray[offset] = x;
	            normalArray[offset + 3] = x;
	            normalArray[offset + 1] = y;
	            normalArray[offset + 4] = y;
	            normalArray[offset + 2] = z;
	            normalArray[offset + 5] = z;

	            // colors
	            colorArray[offset] = color.r;
	            colorArray[offset + 3] = color.r;
	            colorArray[offset + 1] = color.g;
	            colorArray[offset + 4] = color.g;
	            colorArray[offset + 2] = color.b;
	            colorArray[offset + 5] = color.b;

	            // faces
	            // 0 - 2 - 1
	            faceArray[faceoffset] = fromRow[i] + start;
	            faceArray[faceoffset + 1] = fromRow[i + 1] + start;
	            faceArray[faceoffset + 2] = toRow[i] + start;
	            // 1 - 2 - 3
	            faceArray[faceoffset + 3] = toRow[i] + start;
	            faceArray[faceoffset + 4] = fromRow[i + 1] + start;
	            faceArray[faceoffset + 5] = toRow[i + 1] + start;

	            geoGroup.faceidx += 6;

	        }

	        // SPHERE CAPS

	        if (drawcaps) {

	            // h - sphere rows, verticesRows.length - 2
	            var ystart = (toCap) ? 0 : h / 2;
	            var yend = (fromCap) ? h + 1 : h / 2 + 1;

	            var v1, v2, v3, v4, x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4, nx1, nx2, nx3, nx4, ny1, ny2, ny3, ny4, nz1, nz2, nz3, nz4, v1offset, v2offset, v3offset, v4offset;

	            for (y = ystart; y < yend; y++) {
	                if (y === h / 2)
	                    continue;
	                // n number of points for each level (verticesRows[i].length -
	                // 1)
	                var cap = (y <= h / 2) ? to : from;

	                for (x = 0; x < n; x++) {

	                    faceoffset = geoGroup.faceidx;

	                    v1 = verticesRows[y][x + 1];
	                    v1offset = (v1 + start) * 3;
	                    v2 = verticesRows[y][x];
	                    v2offset = (v2 + start) * 3;
	                    v3 = verticesRows[y + 1][x];
	                    v3offset = (v3 + start) * 3;
	                    v4 = verticesRows[y + 1][x + 1];
	                    v4offset = (v4 + start) * 3;

	                    // rotate sphere vectors
	                    x1 = e[0] * vertices[v1].x + e[3] * vertices[v1].y + e[6]
	                            * vertices[v1].z;
	                    x2 = e[0] * vertices[v2].x + e[3] * vertices[v2].y + e[6]
	                            * vertices[v2].z;
	                    x3 = e[0] * vertices[v3].x + e[3] * vertices[v3].y + e[6]
	                            * vertices[v3].z;
	                    x4 = e[0] * vertices[v4].x + e[3] * vertices[v4].y + e[6]
	                            * vertices[v4].z;

	                    y1 = e[1] * vertices[v1].x + e[4] * vertices[v1].y + e[7]
	                            * vertices[v1].z;
	                    y2 = e[1] * vertices[v2].x + e[4] * vertices[v2].y + e[7]
	                            * vertices[v2].z;
	                    y3 = e[1] * vertices[v3].x + e[4] * vertices[v3].y + e[7]
	                            * vertices[v3].z;
	                    y4 = e[1] * vertices[v4].x + e[4] * vertices[v4].y + e[7]
	                            * vertices[v4].z;

	                    z1 = e[5] * vertices[v1].y + e[8] * vertices[v1].z;
	                    z2 = e[5] * vertices[v2].y + e[8] * vertices[v2].z;
	                    z3 = e[5] * vertices[v3].y + e[8] * vertices[v3].z;
	                    z4 = e[5] * vertices[v4].y + e[8] * vertices[v4].z;

	                    vertexArray[v1offset] = x1 + cap.x;
	                    vertexArray[v2offset] = x2 + cap.x;
	                    vertexArray[v3offset] = x3 + cap.x;
	                    vertexArray[v4offset] = x4 + cap.x;

	                    vertexArray[v1offset + 1] = y1 + cap.y;
	                    vertexArray[v2offset + 1] = y2 + cap.y;
	                    vertexArray[v3offset + 1] = y3 + cap.y;
	                    vertexArray[v4offset + 1] = y4 + cap.y;

	                    vertexArray[v1offset + 2] = z1 + cap.z;
	                    vertexArray[v2offset + 2] = z2 + cap.z;
	                    vertexArray[v3offset + 2] = z3 + cap.z;
	                    vertexArray[v4offset + 2] = z4 + cap.z;

	                    colorArray[v1offset] = color.r;
	                    colorArray[v2offset] = color.r;
	                    colorArray[v3offset] = color.r;
	                    colorArray[v4offset] = color.r;

	                    colorArray[v1offset + 1] = color.g;
	                    colorArray[v2offset + 1] = color.g;
	                    colorArray[v3offset + 1] = color.g;
	                    colorArray[v4offset + 1] = color.g;

	                    colorArray[v1offset + 2] = color.b;
	                    colorArray[v2offset + 2] = color.b;
	                    colorArray[v3offset + 2] = color.b;
	                    colorArray[v4offset + 2] = color.b;

	                    nx1 = e[0] * normals[v1].x + e[3] * normals[v1].y + e[6]
	                            * normals[v1].z;
	                    nx2 = e[0] * normals[v2].x + e[3] * normals[v2].y + e[6]
	                            * normals[v2].z;
	                    nx3 = e[0] * normals[v3].x + e[3] * normals[v3].y + e[6]
	                            * normals[v3].z;
	                    nx4 = e[0] * normals[v4].x + e[3] * normals[v4].y + e[6]
	                            * normals[v4].z;

	                    ny1 = e[1] * normals[v1].x + e[4] * normals[v1].y + e[7]
	                            * normals[v1].z;
	                    ny2 = e[1] * normals[v2].x + e[4] * normals[v2].y + e[7]
	                            * normals[v2].z;
	                    ny3 = e[1] * normals[v3].x + e[4] * normals[v3].y + e[7]
	                            * normals[v3].z;
	                    ny4 = e[1] * normals[v4].x + e[4] * normals[v4].y + e[7]
	                            * normals[v4].z;

	                    nz1 = e[5] * normals[v1].y + e[8] * normals[v1].z;
	                    nz2 = e[5] * normals[v2].y + e[8] * normals[v2].z;
	                    nz3 = e[5] * normals[v3].y + e[8] * normals[v3].z;
	                    nz4 = e[5] * normals[v4].y + e[8] * normals[v4].z;

	                    // if (Math.abs(vobj.sphereVertices[v1].y) === radius) {
	                    if (y === 0) {
	                        // face = [v1, v3, v4];
	                        // norm = [n1, n3, n4];

	                        normalArray[v1offset] = nx1;
	                        normalArray[v3offset] = nx3;
	                        normalArray[v4offset] = nx4;
	                        normalArray[v1offset + 1] = ny1;
	                        normalArray[v3offset + 1] = ny3;
	                        normalArray[v4offset + 1] = ny4;
	                        normalArray[v1offset + 2] = nz1;
	                        normalArray[v3offset + 2] = nz3;
	                        normalArray[v4offset + 2] = nz4;

	                        faceArray[faceoffset] = v1 + start;
	                        faceArray[faceoffset + 1] = v3 + start;
	                        faceArray[faceoffset + 2] = v4 + start;

	                        geoGroup.faceidx += 3;

	                    }

	                    // else if (Math.abs(vobj.sphereVertices[v3].y) === radius)
	                    // {
	                    else if (y === yend - 1) {
	                        // face = [v1, v2, v3];
	                        // norm = [n1, n2, n3];

	                        normalArray[v1offset] = nx1;
	                        normalArray[v2offset] = nx2;
	                        normalArray[v3offset] = nx3;
	                        normalArray[v1offset + 1] = ny1;
	                        normalArray[v2offset + 1] = ny2;
	                        normalArray[v3offset + 1] = ny3;
	                        normalArray[v1offset + 2] = nz1;
	                        normalArray[v2offset + 2] = nz2;
	                        normalArray[v3offset + 2] = nz3;

	                        faceArray[faceoffset] = v1 + start;
	                        faceArray[faceoffset + 1] = v2 + start;
	                        faceArray[faceoffset + 2] = v3 + start;

	                        geoGroup.faceidx += 3;

	                    }

	                    else {
	                        // face = [v1, v2, v3, v4];
	                        // norm = [n1, n2, n3, n4];

	                        normalArray[v1offset] = nx1;
	                        normalArray[v2offset] = nx2;
	                        normalArray[v4offset] = nx4;
	                        normalArray[v1offset + 1] = ny1;
	                        normalArray[v2offset + 1] = ny2;
	                        normalArray[v4offset + 1] = ny4;
	                        normalArray[v1offset + 2] = nz1;
	                        normalArray[v2offset + 2] = nz2;
	                        normalArray[v4offset + 2] = nz4;

	                        normalArray[v2offset] = nx2;
	                        normalArray[v3offset] = nx3;
	                        normalArray[v4offset] = nx4;
	                        normalArray[v2offset + 1] = ny2;
	                        normalArray[v3offset + 1] = ny3;
	                        normalArray[v4offset + 1] = ny4;
	                        normalArray[v2offset + 2] = nz2;
	                        normalArray[v3offset + 2] = nz3;
	                        normalArray[v4offset + 2] = nz4;

	                        faceArray[faceoffset] = v1 + start;
	                        faceArray[faceoffset + 1] = v2 + start;
	                        faceArray[faceoffset + 2] = v4 + start;

	                        faceArray[faceoffset + 3] = v2 + start;
	                        faceArray[faceoffset + 4] = v3 + start;
	                        faceArray[faceoffset + 5] = v4 + start;

	                        geoGroup.faceidx += 6;
	                    }

	                }
	            }

	        }

	        geoGroup.vertices += n_verts;
	    };

	    /** Create a cone 
	     * @function $3Dmol.GLDraw.drawCone
	     * @param {geometry}
	     *            geo
	     * @param {Point}
	     *            from
	     * @param {Point}
	     *            to
	     * @param {float}
	     *            radius
	     * @param {$3Dmol.Color}
	     *            color
	     *            */
	    draw.drawCone = function(geo, from, to, radius, color) {
	        if (!from || !to)
	            return;

	        color = color || {r:0, g:0, b:0};

	        var dir =[to.x, to.y, to.z ];        
	        dir.x -= from.x;
	        dir.y -= from.y;
	        dir.z -= from.z;

	        var e = getRotationMatrix(dir);


	        // n vertices around bottom plust the two points
	        var n = basisVectors.length;
	        var basis = basisVectors;
	        var n_verts =  n + 2;

	        
	        //setup geo structures
	        var geoGroup = geo.updateGeoGroup(n_verts);
	        var start = geoGroup.vertices;    
	        var offset, faceoffset;
	        var i, x, y, z;
	        var vertexArray = geoGroup.vertexArray;
	        var normalArray = geoGroup.normalArray;
	        var colorArray = geoGroup.colorArray;
	        var faceArray = geoGroup.faceArray;
	        
	        var offset = start*3;
	        var ndir = new $3Dmol.Vector3(dir[0],dir[1],dir[2]).normalize();
	        //base point first vertex
	        vertexArray[offset] = from.x;
	        vertexArray[offset+1] = from.y;
	        vertexArray[offset+2] = from.z;
	        normalArray[offset] = -ndir.x;
	        normalArray[offset + 1] = -ndir.y;
	        normalArray[offset + 2] = -ndir.z;
	        colorArray[offset] = color.r;
	        colorArray[offset + 1] = color.g;
	        colorArray[offset + 2] = color.b;
	        
	        //second vertex top
	        vertexArray[offset+3] = to.x;
	        vertexArray[offset+4] = to.y;
	        vertexArray[offset+5] = to.z;
	        
	        normalArray[offset+3] = ndir.x;
	        normalArray[offset+4] = ndir.y;
	        normalArray[offset+5] = ndir.z;
	        colorArray[offset+3] = color.r;
	        colorArray[offset + 4] = color.g;
	        colorArray[offset + 5] = color.b;
	        
	        offset += 6;
	        
	        // add circle vertices
	        for (i = 0; i < n; ++i) {
	            var vec = basis[i].clone();
	            vec.multiplyScalar(radius);
	            x = e[0] * vec.x + e[3] * vec.y + e[6]
	                    * vec.z;
	            y = e[1] * vec.x + e[4] * vec.y + e[7]
	                    * vec.z;
	            z = e[5] * vec.y + e[8] * vec.z;

	            // from
	            vertexArray[offset] = x + from.x;
	            vertexArray[offset + 1] = y + from.y;
	            vertexArray[offset + 2] = z + from.z;

	            // normals
	            normalArray[offset] = x;
	            normalArray[offset + 1] = y;
	            normalArray[offset + 2] = z;

	            // colors
	            colorArray[offset] = color.r;
	            colorArray[offset + 1] = color.g;
	            colorArray[offset + 2] = color.b;
	            
	            offset += 3;

	        }
	        geoGroup.vertices += (n+2);
	        //faces
	        var faceoffset = geoGroup.faceidx;
	        for( i = 0; i < n; i++) {
	            //two neighboring circle vertices
	            var v1 = start+2+i;
	            var v2 = start+2+ ((i+1)%n);
	            
	            faceArray[faceoffset] = v1;
	            faceArray[faceoffset+1] = v2;
	            faceArray[faceoffset+2] = start;
	            faceoffset += 3;
	            faceArray[faceoffset] = v1;
	            faceArray[faceoffset+1] = v2;
	            faceArray[faceoffset+2] = start+1;
	            faceoffset += 3;
	        }
	        geoGroup.faceidx += 6*n;
	    };

	    
	    // Sphere component
	    var sphereVertexCache = {
	        cache : {},
	        getVerticesForRadius : function(radius) {

	            if (typeof (this.cache[radius]) !== "undefined")
	                return this.cache[radius];

	            var obj = {
	                vertices : [],
	                verticesRows : [],
	                normals : []
	            };
	            // scale quality with radius heuristically
	            var sphereQuality = 1;
	            var widthSegments = 16 * sphereQuality;
	            var heightSegments = 10 * sphereQuality;
	            if (radius < 1) {
	                widthSegments = 10 * sphereQuality;
	                heightSegments = 8 * sphereQuality;
	            }

	            var phiStart = 0;
	            var phiLength = Math.PI * 2;

	            var thetaStart = 0;
	            var thetaLength = Math.PI;

	            var x, y, vertices = [], uvs = [];

	            for (y = 0; y <= heightSegments; y++) {

	                var verticesRow = [];
	                for (x = 0; x <= widthSegments; x++) {

	                    var u = x / widthSegments;
	                    var v = y / heightSegments;

	                    var vertex = {};
	                    vertex.x = -radius * Math.cos(phiStart + u * phiLength)
	                            * Math.sin(thetaStart + v * thetaLength);
	                    vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
	                    vertex.z = radius * Math.sin(phiStart + u * phiLength)
	                            * Math.sin(thetaStart + v * thetaLength);

	                    var n = new $3Dmol.Vector3(vertex.x, vertex.y, vertex.z);
	                    n.normalize();

	                    obj.vertices.push(vertex);
	                    obj.normals.push(n);

	                    verticesRow.push(obj.vertices.length - 1);

	                }

	                obj.verticesRows.push(verticesRow);

	            }

	            this.cache[radius] = obj;
	            return obj;
	        }

	    };

	    /** Create a sphere.
	     * @function $3Dmol.GLDraw.drawSphere
	     * @param {geometry}
	     *            geo
	     * @param {Point}
	     *            pos
	     * @param {float}
	     *            radius
	     * @param {$3Dmol.Color}
	     *            color
	     */
	    draw.drawSphere = function(geo, pos, radius, color) {

	        var center = new $3Dmol.Vector3(pos.x, pos.y, pos.z);

	        var x, y;
	        var vobj = sphereVertexCache.getVerticesForRadius(radius);

	        var vertices = vobj.vertices;
	        var normals = vobj.normals;

	        var geoGroup = geo.updateGeoGroup(vertices.length);

	        var start = geoGroup.vertices;
	        var vertexArray = geoGroup.vertexArray;
	        var colorArray = geoGroup.colorArray;
	        var faceArray = geoGroup.faceArray;
	        var lineArray = geoGroup.lineArray;
	        var normalArray = geoGroup.normalArray;

	        for (var i = 0, il = vertices.length; i < il; ++i) {
	            var offset = 3 * (start + i);
	            var v = vertices[i];

	            vertexArray[offset] = (v.x + pos.x);
	            vertexArray[offset + 1] = (v.y + pos.y);
	            vertexArray[offset + 2] = (v.z + pos.z);

	            colorArray[offset] = color.r;
	            colorArray[offset + 1] = color.g;
	            colorArray[offset + 2] = color.b;

	        }

	        geoGroup.vertices += vertices.length;

	        var verticesRows = vobj.verticesRows;
	        var h = verticesRows.length - 1;

	        for (y = 0; y < h; y++) {
	            var w = verticesRows[y].length - 1;
	            for (x = 0; x < w; x++) {

	                var faceoffset = geoGroup.faceidx, lineoffset = geoGroup.lineidx;

	                var v1 = verticesRows[y][x + 1] + start, v1offset = v1 * 3;
	                var v2 = verticesRows[y][x] + start, v2offset = v2 * 3;
	                var v3 = verticesRows[y + 1][x] + start, v3offset = v3 * 3;
	                var v4 = verticesRows[y + 1][x + 1] + start, v4offset = v4 * 3;

	                var n1 = normals[v1 - start];
	                var n2 = normals[v2 - start];
	                var n3 = normals[v3 - start];
	                var n4 = normals[v4 - start];
	                var face, norm;
	                if (Math.abs(vertices[v1 - start].y) === radius) {
	                    // face = [v1, v3, v4];
	                    // norm = [n1, n3, n4];

	                    normalArray[v1offset] = n1.x;
	                    normalArray[v3offset] = n3.x;
	                    normalArray[v4offset] = n4.x;
	                    normalArray[v1offset + 1] = n1.y;
	                    normalArray[v3offset + 1] = n3.y;
	                    normalArray[v4offset + 1] = n4.y;
	                    normalArray[v1offset + 2] = n1.z;
	                    normalArray[v3offset + 2] = n3.z;
	                    normalArray[v4offset + 2] = n4.z;

	                    faceArray[faceoffset] = v1;
	                    faceArray[faceoffset + 1] = v3;
	                    faceArray[faceoffset + 2] = v4;

	                    lineArray[lineoffset] = v1;
	                    lineArray[lineoffset + 1] = v3;
	                    lineArray[lineoffset + 2] = v1;
	                    lineArray[lineoffset + 3] = v4;
	                    lineArray[lineoffset + 4] = v3;
	                    lineArray[lineoffset + 5] = v4;

	                    geoGroup.faceidx += 3;
	                    geoGroup.lineidx += 6;

	                } else if (Math.abs(vertices[v3 - start].y) === radius) {
	                    // face = [v1, v2, v3];
	                    // norm = [n1, n2, n3];

	                    normalArray[v1offset] = n1.x;
	                    normalArray[v2offset] = n2.x;
	                    normalArray[v3offset] = n3.x;
	                    normalArray[v1offset + 1] = n1.y;
	                    normalArray[v2offset + 1] = n2.y;
	                    normalArray[v3offset + 1] = n3.y;
	                    normalArray[v1offset + 2] = n1.z;
	                    normalArray[v2offset + 2] = n2.z;
	                    normalArray[v3offset + 2] = n3.z;

	                    faceArray[faceoffset] = v1;
	                    faceArray[faceoffset + 1] = v2;
	                    faceArray[faceoffset + 2] = v3;

	                    lineArray[lineoffset] = v1;
	                    lineArray[lineoffset + 1] = v2;
	                    lineArray[lineoffset + 2] = v1;
	                    lineArray[lineoffset + 3] = v3;
	                    lineArray[lineoffset + 4] = v2;
	                    lineArray[lineoffset + 5] = v3;

	                    geoGroup.faceidx += 3;
	                    geoGroup.lineidx += 6;

	                } else {
	                    // face = [v1, v2, v3, v4];
	                    // norm = [n1, n2, n3, n4];

	                    normalArray[v1offset] = n1.x;
	                    normalArray[v2offset] = n2.x;
	                    normalArray[v4offset] = n4.x;
	                    normalArray[v1offset + 1] = n1.y;
	                    normalArray[v2offset + 1] = n2.y;
	                    normalArray[v4offset + 1] = n4.y;
	                    normalArray[v1offset + 2] = n1.z;
	                    normalArray[v2offset + 2] = n2.z;
	                    normalArray[v4offset + 2] = n4.z;

	                    normalArray[v2offset] = n2.x;
	                    normalArray[v3offset] = n3.x;
	                    normalArray[v4offset] = n4.x;
	                    normalArray[v2offset + 1] = n2.y;
	                    normalArray[v3offset + 1] = n3.y;
	                    normalArray[v4offset + 1] = n4.y;
	                    normalArray[v2offset + 2] = n2.z;
	                    normalArray[v3offset + 2] = n3.z;
	                    normalArray[v4offset + 2] = n4.z;

	                    faceArray[faceoffset] = v1;
	                    faceArray[faceoffset + 1] = v2;
	                    faceArray[faceoffset + 2] = v4;

	                    faceArray[faceoffset + 3] = v2;
	                    faceArray[faceoffset + 4] = v3;
	                    faceArray[faceoffset + 5] = v4;

	                    lineArray[lineoffset] = v1;
	                    lineArray[lineoffset + 1] = v2;
	                    lineArray[lineoffset + 2] = v1;
	                    lineArray[lineoffset + 3] = v4;

	                    lineArray[lineoffset + 4] = v2;
	                    lineArray[lineoffset + 5] = v3;
	                    lineArray[lineoffset + 6] = v3;
	                    lineArray[lineoffset + 7] = v4;

	                    geoGroup.faceidx += 6;
	                    geoGroup.lineidx += 8;

	                }

	            }
	        }

	    };

	    return draw;

	})();// A model is a collection of related atoms.  Bonds are only allowed between
	//atoms in the same model.  An atom is uniquely specified by its model id and
	//its serial number.
	//A glmodel knows how to apply the styles on each atom to create a gl object

	var $3Dmol = $3Dmol || {};

	/**
	 * GLModel represents a group of related atoms
	 * @constructor 
	 * @param {number=} mid 
	 * @param {Object=} defaultcolors Object defining default atom colors as atom => color property value pairs
	 * @see $3Dmol.download
	 */
	$3Dmol.GLModel = (function() {

	    // class variables go here
	    var defaultAtomStyle = {
	        line : {}
	    };

	    var Nucleotides = [ '  G', '  A', '  T', '  C', '  U', ' DG', ' DA', ' DT',
	            ' DC', ' DU' ];

	    var defaultlineWidth = 1.0;

	    // Reference: A. Bondi, J. Phys. Chem., 1964, 68, 441.
	    var vdwRadii = {
	        "H" : 1.2,
	        "Li" : 1.82,
	        "LI" : 1.82,
	        "Na" : 2.27,
	        "NA" : 2.27,
	        "K" : 2.75,
	        "C" : 1.7,
	        "N" : 1.55,
	        "O" : 1.52,
	        "F" : 1.47,
	        "P" : 1.80,
	        "S" : 1.80,
	        "CL" : 1.75,
	        "Cl" : 1.75,
	        "BR" : 1.85,
	        "Br" : 1.85,
	        "SE" : 1.90,
	        "Se" : 1.90,
	        "ZN" : 1.39,
	        "Zn" : 1.39,
	        "CU" : 1.4,
	        "Cu" : 1.4,
	        "NI" : 1.63,
	        "Ni" : 1.63
	    };

	    var validAtomSpecs = [
	        "resn", // Parent residue name
	        "x", // Atom's x coordinate
	        "y", // Atom's y coordinate
	        "z", // Atom's z coordinate
	        "color", // Atom's color, as hex code
	        "surfaceColor", // Hex code for color to be used for surface patch over this atom
	        "elem", // Element abbreviation (e.g. 'H', 'Ca', etc)
	        "hetflag", // Set to true if atom is a heteroatom
	        "chain", // Chain this atom belongs to, if specified in input file (e.g 'A' for chain A)
	        "resi", // Residue number 
	        "icode",
	        "rescode",
	        "serial", // Atom's serial id numbermodels
	        "atom", // Atom name; may be more specific than 'elem' (e.g 'CA' for alpha carbon)
	        "bonds", // Array of atom ids this atom is bonded to
	        "ss", // Secondary structure identifier (for cartoon render; e.g. 'h' for helix)
	        "singleBonds", // true if this atom forms only single bonds or no bonds at all
	        "bondOrder", // Array of this atom's bond orders, corresponding to bonds identfied by 'bonds'
	        "properties", // Optional mapping of additional properties
	        "b", // Atom b factor data
	        "pdbline", // If applicable, this atom's record entry from the input PDB file (used to output new PDB from models)
	        "clickable", // Set this flag to true to enable click selection handling for this atom
	        "callback", // Callback click handler function to be executed on this atom and its parent viewer
	        "invert" // for selection, inverts the meaning of the selection
	    ];

	    var validAtomSelectionSpecs = validAtomSpecs.concat([  // valid atom specs are ok too
	        "model", // a single model or list of models from which atoms should be selected
	        "bonds", // overloaded to select number of bonds, e.g. {bonds: 0} will select all nonbonded atoms
	        "predicate", // user supplied function that gets passed an {AtomSpec} and should return true if the atom should be selected
	        "invert", // if set, inverts the meaning of the selection
	        "byres", // if set, expands the selection to include all atoms of any residue that has any atom selected
	        "expand", // expands the selection to include all atoms within a given distance from the selection
	        "within" // intersects the selection with the set of atoms within a given distance from another selection
	    ]);

	    var validAtomStyleSpecs = [
	        "line", // draw bonds as lines
	        "cross", // draw atoms as crossed lines (aka stars)
	        "stick", // draw bonds as capped cylinders
	        "sphere", // draw atoms as spheres
	        "cartoon" // draw cartoon representation of secondary structure
	    ];

	    // class functions

	    // return true if a and b represent the same style
	    var sameObj = function(a,b) {
	        if(a && b)
	            return JSON.stringify(a) == JSON.stringify(b);
	        else
	            return a == b;
	    };    

	   
	    function GLModel(mid, defaultcolors) {
	        // private variables
	        var atoms = [];
	        var frames = [];
	        var id = mid;
	        var hidden = false;
	        var molObj = null;
	        var renderedMolObj = null;
	        var lastColors = null;
	        var modelData = {};
	        var idMatrix = new $3Dmol.Matrix4();
	        var dontDuplicateAtoms;
	        var defaultColor = $3Dmol.elementColors.defaultColor;
	        
	        var ElementColors = (defaultcolors) ? defaultcolors : $3Dmol.elementColors.defaultColors;


	        // drawing functions must be associated with model object since
	        // geometries can't span multiple canvases

	        // sphere drawing
	        var defaultSphereRadius = 1.5;

	        // return proper radius for atom given style
	        /** 
	         * 
	         * @param {AtomSpec} atom
	         * @param {atomstyle} style
	         * @return {number} 
	         * 
	         */
	        var getRadiusFromStyle = function(atom, style) {
	            var r = defaultSphereRadius;
	            if (typeof (style.radius) != "undefined")
	                r = style.radius;
	            else if (vdwRadii[atom.elem])
	                r = vdwRadii[atom.elem];

	            if (typeof (style.scale) != "undefined")
	                r *= style.scale;
	            return r;
	        };

	        // cross drawing
	        /** @typedef CrossStyleSpec
	         * @prop {boolean} hidden - do not show 
	         * @prop {number} linewidth 
	         * @prop {number} radius 
	         * @prop {number} scale - scale radius by specified amount
	         * @prop {ColorschemeSpec} colorscheme - element based coloring
	         * @prop {ColorSpec} color - fixed coloring, overrides colorscheme
	         */
	        
	        /**
	         * 
	         * @param {AtomSpec} atom
	         * @param {$3Dmol.Geometry[]} geos
	         */
	        var drawAtomCross = function(atom, geos) {
	            if (!atom.style.cross)
	                return;
	            var style = atom.style.cross;
	            if (style.hidden)
	                return;
	            var linewidth = (style.linewidth || defaultlineWidth);
	            if (!geos[linewidth])
	                geos[linewidth] = new $3Dmol.Geometry();
	                
	            var geoGroup = geos[linewidth].updateGeoGroup(6);
	            
	            var delta = getRadiusFromStyle(atom, style);

	            var points = [ [ delta, 0, 0 ], [ -delta, 0, 0 ], [ 0, delta, 0 ],
	                    [ 0, -delta, 0 ], [ 0, 0, delta ], [ 0, 0, -delta ] ];

	            var clickable = atom.clickable;
	            if (clickable && atom.intersectionShape === undefined)
	                atom.intersectionShape = {sphere : [], cylinder : [], line : []};
	            
	            var c = $3Dmol.getColorFromStyle(atom, style);
	            
	            var vertexArray = geoGroup.vertexArray;
	            var colorArray = geoGroup.colorArray;
	            
	            for ( var j = 0; j < 6; j++) {
	                
	                var offset = geoGroup.vertices*3;
	                
	                geoGroup.vertices++;
	                vertexArray[offset] = atom.x + points[j][0];
	                vertexArray[offset+1] = atom.y + points[j][1];
	                vertexArray[offset+2] = atom.z + points[j][2];
	                colorArray[offset] = c.r;
	                colorArray[offset+1] = c.g;
	                colorArray[offset+2] = c.b;
	                
	                if (clickable){
	                    var point = new $3Dmol.Vector3(points[j][0], points[j][1], points[j][2]);
	                    
	                    //decrease cross size for selection to prevent misselection from atom overlap
	                    point.multiplyScalar(0.1);
	                    point.set(point.x+atom.x, point.y+atom.y, point.z+atom.z);
	                    atom.intersectionShape.line.push(point);
	                }

	            }
	                        
	        };

	        //from atom, return a normalized vector v that is orthogonal and along which
	        //it is appropraite to draw multiple bonds
	        var getSideBondV = function(atom, atom2, i) {

	            var p1 = new $3Dmol.Vector3(atom.x, atom.y, atom.z);
	            var p2 = new $3Dmol.Vector3(atom2.x, atom2.y, atom2.z);

	            var dir = p2.clone();
	            var v = null;
	            dir.sub(p1);

	            var p1a, p1b, p2a, p2b;
	            var i2, j2, atom3, p3, dir2;
	            if (atom.bonds.length === 1) {
	                if (atom2.bonds.length === 1) {
	                    v = dir.clone();
	                    if (Math.abs(v.x) > 0.0001)
	                        v.y += 1;
	                    else
	                        v.x += 1;
	                } else {
	                    i2 = (i + 1) % atom2.bonds.length;
	                    j2 = atom2.bonds[i2];
	                    atom3 = atoms[j2];
	                    p3 = new $3Dmol.Vector3(atom3.x, atom3.y, atom3.z);

	                    dir2 = p3.clone();
	                    dir2.sub(p1);

	                    v = dir2.clone();
	                    v.cross(dir);
	                }
	            } else {
	                // get vector 2 different neighboring atom
	                i2 = (i + 1) % atom.bonds.length;
	                j2 = atom.bonds[i2];
	                atom3 = atoms[j2];
	                p3 = new $3Dmol.Vector3(atom3.x, atom3.y, atom3.z);

	                dir2 = p3.clone();
	                dir2.sub(p1);

	                v = dir2.clone();
	                v.cross(dir);
	            }

	            // especially for C#C (triple bond) dir and dir2
	            // may be opposites resulting in a zero v
	            if (v.lengthSq() < 0.01) {
	                v = dir.clone();
	                if (Math.abs(v.x) > 0.0001)
	                    v.y += 1;
	                else
	                    v.x += 1;
	            }

	            v.cross(dir);
	            v.normalize();
	            
	            return v;
	            
	            //v.multiplyScalar(r * 1.5);

	        }
	        
	        var getTripleBondPoints = function() {
	            
	            v.cross(dir);
	            v.normalize();
	            v.multiplyScalar(r * 3);

	            p1a = p1.clone();
	            p1a.add(v);
	            p1b = p1.clone();
	            p1b.sub(v);

	            p2a = p1a.clone();
	            p2a.add(dir);
	            p2b = p1b.clone();
	            p2b.add(dir);
	        }
	        
	        var addLine = function(vertexArray, colorArray, offset, p1, p2, c1) {
	            //make line from p1 to p2, does not incremeant counts
	            vertexArray[offset] = p1.x; vertexArray[offset+1] = p1.y; vertexArray[offset+2] = p1.z;
	            colorArray[offset] = c1.r; colorArray[offset+1] = c1.g; colorArray[offset+2] = c1.b;
	            vertexArray[offset+3] = p2.x; vertexArray[offset+4] = p2.y; vertexArray[offset+5] = p2.z;
	            colorArray[offset+3] = c1.r; colorArray[offset+4] = c1.g; colorArray[offset+5] = c1.b;            
	        }
	        
	        /**@typedef LineStyleSpec
	         * @prop {boolean} hidden - do not show line
	         * @prop {number} linewidth 
	         * @prop {ColorschemeSpec} colorscheme - element based coloring
	         * @prop {ColorSpec} color - fixed coloring, overrides colorscheme
	         */
	        
	        // bonds - both atoms must match bond style
	        // standardize on only drawing for lowest to highest
	        /**
	         * 
	         * @param {AtomSpec}
	         *            atom
	         * @param {AtomSpec[]} atoms
	         * @param {$3Dmol.Geometry[]} geos
	         */
	        var drawBondLines = function(atom, atoms, geos) {
	            if (!atom.style.line)
	                return;
	            var style = atom.style.line;
	            if (style.hidden)
	                return;

	            // have a separate geometry for each linewidth
	            var linewidth = (style.linewidth || defaultlineWidth);

	            if (!geos[linewidth])
	                geos[linewidth] = new $3Dmol.Geometry();
	            /** @type {geometryGroup} */
	            var geoGroup = geos[linewidth].updateGeoGroup(6*atom.bonds.length); //reserve enough space even for triple bonds
	            
	            var vertexArray = geoGroup.vertexArray;
	            var colorArray = geoGroup.colorArray;
	            
	            for ( var i = 0; i < atom.bonds.length; i++) {
	                var j = atom.bonds[i]; // our neighbor
	                
	                var atom2 = atoms[j];
	                if (!atom2.style.line)
	                    continue; // don't sweat the details

	                if (atom.serial >= atom2.serial) // only draw if less, this way we can do multi bonds correctly
	                    continue;
	                var p1 = new $3Dmol.Vector3(atom.x, atom.y, atom.z);
	                var p2 = new $3Dmol.Vector3(atom2.x, atom2.y, atom2.z);                
	                var mp = p1.clone().add(p2).multiplyScalar(0.5);
	                var singleBond = false;               
	                
	                if (atom.clickable){
	                    if (atom.intersectionShape === undefined)
	                        atom.intersectionShape = {sphere : [], cylinder : [], line : [], triangle : []};
	                    atom.intersectionShape.line.push(p1);
	                    atom.intersectionShape.line.push(p2);
	                }

	                var c1 = $3Dmol.getColorFromStyle(atom, atom.style.line);
	                var c2 = $3Dmol.getColorFromStyle(atom2, atom2.style.line);
	               
	                if(atom.bondStyles && atom.bondStyles[i]) {
	                    var bstyle = atom.bondStyles[i];
	                    if(!bstyle.iswire) {
	                        continue;
	                    }
	                    if(bstyle.radius) bondR = bstyle.radius;
	                    if(bstyle.singleBond) singleBond = true;
	                    if(typeof(bstyle.color1) != "undefined") {
	                        c1 = $3Dmol.CC.color(bstyle.color1);
	                    }
	                    if(typeof(bstyle.color2) != "undefined") {
	                        c2 = $3Dmol.CC.color(bstyle.color2);
	                    }
	                }

	                var offset = geoGroup.vertices*3;
	                
	                if(atom.bondOrder[i] > 1 && atom.bondOrder[i] < 4 && !singleBond) {
	                    var v = getSideBondV(atom, atom2, i);
	                    var dir = p2.clone();
	                    dir.sub(p1);
	                    
	                    if(atom.bondOrder[i] == 2) { //double
	                        
	                        v.multiplyScalar(.1);
	                           p1a = p1.clone();
	                        p1a.add(v);
	                        p1b = p1.clone();
	                        p1b.sub(v);

	                        p2a = p1a.clone();
	                        p2a.add(dir);
	                        p2b = p1b.clone();
	                        p2b.add(dir);
	                        
	                        if(c1 == c2) {
	                            geoGroup.vertices += 4;
	                            addLine(vertexArray, colorArray, offset, p1a, p2a, c1);                            
	                            addLine(vertexArray, colorArray, offset+6, p1b, p2b, c1);                            
	                        }
	                        else {
	                            geoGroup.vertices += 8;
	                            dir.multiplyScalar(0.5);
	                            var mpa = p1a.clone();
	                            mpa.add(dir);
	                            var mpb = p1b.clone();
	                            mpb.add(dir);
	                            
	                            addLine(vertexArray, colorArray, offset, p1a, mpa, c1);                            
	                            addLine(vertexArray, colorArray, offset+6, mpa, p2a, c2);                            
	                            addLine(vertexArray, colorArray, offset+12, p1b, mpb, c1); 
	                            addLine(vertexArray, colorArray, offset+18, mpb, p2b, c2); 
	                        }
	                    }
	                    else if(atom.bondOrder[i] == 3) { //triple
	                        
	                        v.multiplyScalar(.1);
	                           p1a = p1.clone();
	                        p1a.add(v);
	                        p1b = p1.clone();
	                        p1b.sub(v);

	                        p2a = p1a.clone();
	                        p2a.add(dir);
	                        p2b = p1b.clone();
	                        p2b.add(dir);
	                        
	                        if(c1 == c2) {
	                            geoGroup.vertices += 6;
	                            addLine(vertexArray, colorArray, offset, p1, p2, c1);                            
	                            addLine(vertexArray, colorArray, offset+6, p1a, p2a, c1);                            
	                            addLine(vertexArray, colorArray, offset+12, p1b, p2b, c1);                            
	                        }
	                        else {
	                            geoGroup.vertices += 12;
	                            dir.multiplyScalar(0.5);
	                            var mpa = p1a.clone();
	                            mpa.add(dir);
	                            var mpb = p1b.clone();
	                            mpb.add(dir);

	                            addLine(vertexArray, colorArray, offset, p1, mp, c1);                            
	                            addLine(vertexArray, colorArray, offset+6, mp, p2, c2);
	                            addLine(vertexArray, colorArray, offset+12, p1a, mpa, c1);                            
	                            addLine(vertexArray, colorArray, offset+18, mpa, p2a, c2);                            
	                            addLine(vertexArray, colorArray, offset+24, p1b, mpb, c1); 
	                            addLine(vertexArray, colorArray, offset+30, mpb, p2b, c2); 
	                        }
	                    }
	                }
	                else { //single bond                                    
	                    if(c1 == c2) {
	                        geoGroup.vertices += 2;
	                        addLine(vertexArray, colorArray, offset, p1, p2, c1);
	                    } else {
	                        geoGroup.vertices += 4;
	                        addLine(vertexArray, colorArray, offset, p1, mp, c1);
	                        addLine(vertexArray, colorArray, offset+6, mp, p2, c2);                        
	                    }
	                    
	                }
	            }

	        };

	        // bonds as cylinders
	        var defaultStickRadius = 0.25;

	        /**@typedef SphereStyleSpec
	         * @prop {boolean} hidden - do not show atom
	         * @prop {number} radius - override van der waals radius
	         * @prop {number} scale - scale radius by specified amount
	         * @prop {ColorschemeSpec} colorscheme - element based coloring
	         * @prop {ColorSpec} color - fixed coloring, overrides colorscheme
	         */
	        
	        //sphere drawing
	        //See also: drawCylinder
	        /** 
	         * 
	         * @param {AtomSpec} atom
	         * @param {$3Dmol.Geometry} geo
	         */
	        var drawAtomSphere = function(atom, geo) {
	            
	            if (!atom.style.sphere)
	                return;
	            var style = atom.style.sphere;
	            if (style.hidden)
	                return;
	                                                                 
	            var C = $3Dmol.getColorFromStyle(atom, style);
	            
	            var x, y;
	            var radius = getRadiusFromStyle(atom, style);
	            
	            if ((atom.clickable === true) && (atom.intersectionShape !== undefined)) {
	                var center = new $3Dmol.Vector3(atom.x, atom.y, atom.z);
	                atom.intersectionShape.sphere.push(new $3Dmol.Sphere(center, radius));
	            }
	            
	            $3Dmol.GLDraw.drawSphere(geo, atom, radius, C);    
	            
	        };

	        var drawAtomInstanced = function(atom, geo) {

	            if (!atom.style.sphere)
	                return;
	            var style = atom.style.sphere;
	            if (style.hidden)
	                return;

	            var radius = getRadiusFromStyle(atom, style);
	            var C = $3Dmol.getColorFromStyle(atom, style);

	            var geoGroup = geo.updateGeoGroup(1);
	            var startv =  geoGroup.vertices;
	            var start = startv*3;
	            var vertexArray = geoGroup.vertexArray;
	            var colorArray = geoGroup.colorArray;
	            var radiusArray = geoGroup.radiusArray;

	            vertexArray[start] = atom.x;
	            vertexArray[start+1] = atom.y ;
	            vertexArray[start+2] = atom.z;

	            var normalArray = geoGroup.normalArray;
	            var colorArray = geoGroup.colorArray;
	            colorArray[start] = C.r;
	            colorArray[start+1] = C.g;
	            colorArray[start+2] = C.b;

	            radiusArray[startv] = radius;

	            geoGroup.vertices += 1;

	        };

	        var drawSphereImposter = function(geo, center, radius, C) {
	            //create flat square                                   
	            var geoGroup = geo.updateGeoGroup(4);
	            var startv =  geoGroup.vertices;
	            var start = startv*3;
	            var vertexArray = geoGroup.vertexArray;
	            var colorArray = geoGroup.colorArray;
	            
	            //use center point for each vertex
	            for(var i = 0; i < 4; i++) {
	                vertexArray[start+3*i] = center.x;
	                vertexArray[start+3*i+1] = center.y ;
	                vertexArray[start+3*i+2] = center.z;                           
	            }
	            

	            //same colors for all 4 vertices
	            var normalArray = geoGroup.normalArray;
	            var colorArray = geoGroup.colorArray;
	            for(var i = 0; i < 4; i++) {
	                colorArray[start+3*i] = C.r;
	                colorArray[start+3*i+1] = C.g;
	                colorArray[start+3*i+2] = C.b;                
	            }
	            
	            normalArray[start+0] = -radius;
	            normalArray[start+1] = radius;
	            normalArray[start+2] = 0;
	            
	            normalArray[start+3] = -radius;
	            normalArray[start+4] = -radius;
	            normalArray[start+5] = 0;
	            
	            normalArray[start+6] = radius;
	            normalArray[start+7] = -radius;
	            normalArray[start+8] = 0;
	            
	            normalArray[start+9] = radius;
	            normalArray[start+10] = radius;
	            normalArray[start+11] = 0;
	            
	            geoGroup.vertices += 4;
	            
	            //two faces
	            var faceArray = geoGroup.faceArray;
	            var faceoffset = geoGroup.faceidx; //not number faces, but index
	            faceArray[faceoffset+0] = startv;
	            faceArray[faceoffset+1] = startv+1;
	            faceArray[faceoffset+2] = startv+2;
	            faceArray[faceoffset+3] = startv+2;
	            faceArray[faceoffset+4] = startv+3;
	            faceArray[faceoffset+5] = startv;
	            geoGroup.faceidx += 6;
	        };
	        
	        //dkoes -  code for sphere imposters
	        var drawAtomImposter = function(atom, geo) {
	            
	            if (!atom.style.sphere)
	                return;
	            var style = atom.style.sphere;
	            if (style.hidden)
	                return;
	            
	            var radius = getRadiusFromStyle(atom, style);
	            var C = $3Dmol.getColorFromStyle(atom, style);
	            
	            drawSphereImposter(geo, atom, radius, C);            
	        };
	                
	          
	        var drawStickImposter =  function(geo, from, to, radius, color, fromCap, toCap) {
	           //we need the four corners - two have from coord, two have to coord, the normal
	            //is the opposing point, from which we can get the normal and length
	            //also need the radius
	            var geoGroup = geo.updateGeoGroup(4);
	            var startv =  geoGroup.vertices;
	            var start = startv*3;
	            var vertexArray = geoGroup.vertexArray;
	            var colorArray = geoGroup.colorArray;
	            var radiusArray = geoGroup.radiusArray;
	            var normalArray = geoGroup.normalArray;
	            //encode extra bits of information in the color
	            var r = color.r;
	            var g = color.g;
	            var b = color.b;
	            
	            var negateColor = function(c) {
	                //set sign bit
	                var n = -c;
	                if(n == 0) n = -0.0001;
	                return n;
	            };
	            
	            /* for sticks, always draw caps, but we could in theory set caps in color */
	            
	            //4 vertices, distinguish between p1 and p2 with neg blue
	            var pos = start;
	            for(var i = 0; i < 4; i++) {
	                vertexArray[pos] = from.x;
	                normalArray[pos] = to.x;
	                colorArray[pos] = r;
	                pos++;
	                vertexArray[pos] = from.y;
	                normalArray[pos] = to.y;
	                colorArray[pos] = g;
	                pos++;
	                vertexArray[pos] = from.z;
	                normalArray[pos] = to.z;
	                if(i < 2)
	                    colorArray[pos] = b;
	                else
	                    colorArray[pos] = negateColor(b);
	                pos++;
	            }

	            geoGroup.vertices += 4;

	            radiusArray[startv] = -radius;
	            radiusArray[startv+1] = radius;
	            radiusArray[startv+2] = -radius;
	            radiusArray[startv+3] = radius;      
	                        
	            //two faces
	            var faceArray = geoGroup.faceArray;
	            var faceoffset = geoGroup.faceidx; //not number faces, but index
	            faceArray[faceoffset+0] = startv;
	            faceArray[faceoffset+1] = startv+1;
	            faceArray[faceoffset+2] = startv+2;
	            faceArray[faceoffset+3] = startv+2;
	            faceArray[faceoffset+4] = startv+3;
	            faceArray[faceoffset+5] = startv;
	            geoGroup.faceidx += 6;          
	        };
	        
	        /**@typedef StickStyleSpec
	         * @prop {boolean} hidden - do not show 
	         * @prop {number} radius 
	         * @prop {boolean} singleBonds - draw all bonds as single bonds if set
	         * @prop {ColorschemeSpec} colorscheme - element based coloring
	         * @prop {ColorSpec} color - fixed coloring, overrides colorscheme
	         */
	        
	        // draws cylinders and small spheres (at bond radius)
	        var drawBondSticks = function(atom, atoms, geo) {
	            if (!atom.style.stick)
	                return;
	            var style = atom.style.stick;
	            if (style.hidden)
	                return;

	            var atomBondR = style.radius || defaultStickRadius;
	            var bondR = atomBondR;
	            var atomSingleBond = style.singleBonds || false;
	            var fromCap = 0, toCap = 0;

	            var C1 = $3Dmol.getColorFromStyle(atom, style);

	            var mp, mp1, mp2;
	            
	            if (!atom.capDrawn && atom.bonds.length < 4)
	                fromCap = 2;
	            
	            var drawCyl = $3Dmol.GLDraw.drawCylinder; //mesh cylinder
	            if(geo.imposter) 
	                drawCyl = drawStickImposter;

	                
	            for (var i = 0; i < atom.bonds.length; i++) {
	                var j = atom.bonds[i]; // our neighbor
	                var atom2 = atoms[j]; //parsePDB, etc should only add defined bonds
	                
	                if (atom.serial < atom2.serial) {// only draw if less, this
	                    // lets us combine
	                    // cylinders of the same
	                    // color
	                    var style2 = atom2.style;
	                    if (!style2.stick)
	                        continue; // don't sweat the details                     
	                   
	                    var C2 = $3Dmol.getColorFromStyle(atom2, style2.stick);
	                    
	                    //support bond specific styles
	                    bondR = atomBondR;                    
	                    var singleBond = atomSingleBond;
	                    if(atom.bondStyles && atom.bondStyles[i]) {
	                        var bstyle = atom.bondStyles[i];
	                        if(bstyle.iswire) {
	                            continue;
	                        }
	                        if(bstyle.radius) bondR = bstyle.radius;
	                        if(bstyle.singleBond) singleBond = true;
	                        if(typeof(bstyle.color1) != "undefined") {
	                            C1 = $3Dmol.CC.color(bstyle.color1);
	                        }
	                        if(typeof(bstyle.color2) != "undefined") {
	                            C2 = $3Dmol.CC.color(bstyle.color2);
	                        }
	                    }
	                    var p1 = new $3Dmol.Vector3(atom.x, atom.y, atom.z);
	                    var p2 = new $3Dmol.Vector3(atom2.x, atom2.y, atom2.z);

	                    // draw cylinders
	                    if (atom.bondOrder[i] === 1 || singleBond) {

	                        if (!atom2.capDrawn && atom2.bonds.length < 4)
	                            toCap = 2;       
	                                                
	                        if (C1 != C2) {
	                            mp = new $3Dmol.Vector3().addVectors(p1, p2)
	                                    .multiplyScalar(0.5);
	                            drawCyl(geo, p1, mp, bondR, C1, fromCap, 0);
	                            drawCyl(geo, mp, p2, bondR, C2, 0, toCap);
	                        } else {
	                            drawCyl(geo, p1, p2, bondR, C1, fromCap, toCap);
	                        }
	                        
	                        if (atom.clickable || atom2.clickable) {
	                            mp = new $3Dmol.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
	                            if (atom.clickable){
	                                var cylinder1 = new $3Dmol.Cylinder(p1 , mp , bondR);
	                                var sphere1 = new $3Dmol.Sphere(p1 , bondR);
	                                atom.intersectionShape.cylinder.push(cylinder1);   
	                                atom.intersectionShape.sphere.push(sphere1);                             
	                            }
	                            if (atom2.clickable){
	                                var cylinder2 = new $3Dmol.Cylinder(p2 , mp , bondR);
	                                var sphere2 = new $3Dmol.Sphere(p2 , bondR);
	                                atom2.intersectionShape.cylinder.push(cylinder2);
	                                atom2.intersectionShape.sphere.push(sphere2);
	                            }

	                        }
	                        
	                    } 
	                    
	                    else if (atom.bondOrder[i] > 1) {
	                        var mfromCap = 0; mtoCap = 0; //multi bond caps
	                        
	                        if(bondR != atomBondR) {
	                            //assume jmol style multiple bonds - the radius doesn't fit within atom sphere
	                            mfromCap = 2;
	                            mtoCap = 2;
	                        }
	                        
	                        var dir = p2.clone();
	                        var v = null;
	                        dir.sub(p1);
	                        
	                        var r, p1a, p1b, p2a, p2b;
	                        var v = getSideBondV(atom, atom2, i);
	                        
	                        if (atom.bondOrder[i] == 2) {
	                            var r = bondR/2.5;
	                            var v = getSideBondV(atom, atom2, i);
	                            
	                            v.multiplyScalar(r*1.5);
	                            p1a = p1.clone();
	                            p1a.add(v);
	                            p1b = p1.clone();
	                            p1b.sub(v);

	                            p2a = p1a.clone();
	                            p2a.add(dir);
	                            p2b = p1b.clone();
	                            p2b.add(dir);

	                                                                 
	                            if (C1 != C2) {
	                                mp = new $3Dmol.Vector3().addVectors(p1a, p2a)
	                                        .multiplyScalar(0.5);
	                                mp2 = new $3Dmol.Vector3().addVectors(p1b, p2b)
	                                        .multiplyScalar(0.5);
	                                drawCyl(geo, p1a, mp, r, C1, mfromCap, 0);
	                                drawCyl(geo, mp, p2a, r, C2, 0, mtoCap);
	                                drawCyl(geo, p1b, mp2, r, C1, mfromCap, 0);
	                                drawCyl(geo, mp2, p2b, r, C2, 0, mtoCap);
	                            } else {
	                                drawCyl(geo, p1a, p2a, r, C1, mfromCap, mtoCap);
	                                drawCyl(geo, p1b, p2b, r, C1, mfromCap, mtoCap);
	                            }
	                            if (atom.clickable || atom2.clickable){
	                                mp = new $3Dmol.Vector3().addVectors(p1a, p2a)
	                                               .multiplyScalar(0.5);
	                                mp2 = new $3Dmol.Vector3().addVectors(p1b, p2b)
	                                                .multiplyScalar(0.5);
	                                if (atom.clickable) {
	                                    cylinder1a = new $3Dmol.Cylinder(p1a , mp , r);
	                                    cylinder1b = new $3Dmol.Cylinder(p1b , mp2 , r);
	                                    atom.intersectionShape.cylinder.push(cylinder1a);
	                                    atom.intersectionShape.cylinder.push(cylinder1b);
	                                }
	                                if (atom2.clickable) {
	                                    cylinder2a = new $3Dmol.Cylinder(p2a , mp , r);
	                                    cylinder2b = new $3Dmol.Cylinder(p2b , mp2 , r);
	                                    atom2.intersectionShape.cylinder.push(cylinder2a);
	                                    atom2.intersectionShape.cylinder.push(cylinder2b);                               
	                                }
	                            }
	                        } 
	                        else if (atom.bondOrder[i] == 3) {
	                            r = bondR / 4;
	                            v.cross(dir);
	                            v.normalize();
	                            v.multiplyScalar(r * 3);

	                            p1a = p1.clone();
	                            p1a.add(v);
	                            p1b = p1.clone();
	                            p1b.sub(v);

	                            p2a = p1a.clone();
	                            p2a.add(dir);
	                            p2b = p1b.clone();
	                            p2b.add(dir);

	                            if (C1 != C2) {
	                                mp = new $3Dmol.Vector3().addVectors(p1a, p2a)
	                                        .multiplyScalar(0.5);
	                                mp2 = new $3Dmol.Vector3().addVectors(p1b, p2b)
	                                        .multiplyScalar(0.5);
	                                mp3 = new $3Dmol.Vector3().addVectors(p1, p2)
	                                        .multiplyScalar(0.5);
	                                drawCyl(geo, p1a, mp, r, C1, mfromCap, 0);
	                                drawCyl(geo, mp, p2a, r, C2, 0, mtoCap);
	                                drawCyl(geo, p1, mp3, r, C1, fromCap, 0);
	                                drawCyl(geo, mp3, p2, r, C2, 0, toCap);
	                                drawCyl(geo, p1b, mp2, r, C1, mfromCap, 0);
	                                drawCyl(geo, mp2, p2b, r, C2, 0, mtoCap);
	                            } else {
	                                drawCyl(geo, p1a, p2a, r, C1, mfromCap, mtoCap);
	                                drawCyl(geo, p1, p2, r, C1, fromCap, toCap);
	                                drawCyl(geo, p1b, p2b, r, C1, mfromCap, mtoCap);

	                            }
	                            if (atom.clickable || atom2.clickable) {
	                                mp = new $3Dmol.Vector3().addVectors(p1a, p2a)
	                                        .multiplyScalar(0.5);
	                                mp2 = new $3Dmol.Vector3().addVectors(p1b, p2b)
	                                        .multiplyScalar(0.5);
	                                mp3 = new $3Dmol.Vector3().addVectors(p1, p2)
	                                        .multiplyScalar(0.5);
	                                                                
	                                if (atom.clickable) {
	                                    cylinder1a = new $3Dmol.Cylinder(p1a.clone(), mp.clone(), r);
	                                    cylinder1b = new $3Dmol.Cylinder(p1b.clone(), mp2.clone(), r);
	                                    cylinder1c = new $3Dmol.Cylinder(p1.clone(), mp3.clone(), r);
	                                    atom.intersectionShape.cylinder.push(cylinder1a);
	                                    atom.intersectionShape.cylinder.push(cylinder1b);
	                                    atom.intersectionShape.cylinder.push(cylinder1c);
	                                } 
	                                if (atom2.clickable) {                               
	                                    cylinder2a = new $3Dmol.Cylinder(p2a.clone(), mp.clone(), r);
	                                    cylinder2b = new $3Dmol.Cylinder(p2b.clone(), mp2.clone(), r);
	                                    cylinder2c = new $3Dmol.Cylinder(p2.clone(), mp3.clone(), r);
	                                    atom2.intersectionShape.cylinder.push(cylinder2a);
	                                    atom2.intersectionShape.cylinder.push(cylinder2b);
	                                    atom2.intersectionShape.cylinder.push(cylinder2c);                                
	                                }
	                            }
	                        }
	                    }
	                     
	                }                   
	                                 
	            }            

	            // draw non bonded heteroatoms as spheres
	            var drawSphere = false;
	            var numsinglebonds = 0;
	            var differentradii = false;
	            //also, if any bonds were drawn as multiples, need sphere
	            for(var i = 0; i < atom.bonds.length; i++) {
	                var singleBond = atomSingleBond;
	                if(atom.bondStyles && atom.bondStyles[i]) {
	                    var bstyle = atom.bondStyles[i];
	                    if(bstyle.singleBond) singleBond = true;
	                    if(bstyle.radius && bstyle.radius != atomBondR) {
	                        differentradii = true;
	                    }
	                }
	                if(singleBond || atom.bondOrder[i] == 1) {
	                    numsinglebonds++;
	                }
	            }
	            
	            if(differentradii) { //jmol style double/triple bonds - no sphere
	                if(numsinglebonds > 0) drawSphere = true; //unless needed as a cap
	            }
	            else if(numsinglebonds == 0 && atom.bonds.length > 0) {
	                drawSphere = true;
	            }
	           
	            if (drawSphere) {
	                var savedstyle = atom.style;
	                bondR = atomBondR;
	                //do not use bond style as this can be variable, particularly
	                //with jmol export of double/triple bonds
	                if(geo.imposter) {
	                    drawSphereImposter(geo.sphereGeometry, atom, bondR, C1);
	                }
	                else {
	                    $3Dmol.GLDraw.drawSphere(geo, atom, bondR, C1);
	                }
	            }
	            
	        };
	        
	        

	        // go through all the atoms and regenerate their geometries
	        // we try to have one geometry for each style since this is much much
	        // faster
	        // at some point we should optimize this to avoid unnecessary
	        // recalculation
	        /** param {AtomSpec[]} atoms */
	        var createMolObj = function(atoms, options) {

	            options = options || {};

	            var ret = new $3Dmol.Object3D();
	            var cartoonAtoms = [];
	            var lineGeometries = {};
	            var crossGeometries = {};
	            
	            var drawSphereFunc = drawAtomSphere;
	            var sphereGeometry = null;
	            var stickGeometry = null;
	            if (options.supportsImposters) {
	                drawSphereFunc = drawAtomImposter;
	                sphereGeometry = new $3Dmol.Geometry(true);
	                sphereGeometry.imposter = true;
	                stickGeometry = new $3Dmol.Geometry(true, true);
	                stickGeometry.imposter = true;
	                stickGeometry.sphereGeometry = sphereGeometry; //for caps
	                stickGeometry.drawnCaps = {};
	            }
	            else if (options.supportsAIA) {
	                drawSphereFunc = drawAtomInstanced;
	                sphereGeometry = new $3Dmol.Geometry(false, true,true);
	                sphereGeometry.instanced = true;
	                stickGeometry = new $3Dmol.Geometry(true); //don't actually have instanced sticks
	            }  else {
	                sphereGeometry = new $3Dmol.Geometry(true);
	                stickGeometry = new $3Dmol.Geometry(true);
	            }
	            
	            var i, j, n, testOpacities;
	            var opacities = {};
	            var range = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
	            for (i = 0, n = atoms.length; i < n; i++) {
	                var atom = atoms[i];
	                // recreate gl info for each atom as necessary
	                // set up appropriate intersection spheres for clickable atoms

	                if (atom && atom.style) {

	                    if (atom.clickable && atom.intersectionShape === undefined)
	                        atom.intersectionShape = {sphere: [], cylinder: [], line: [], triangle : []};

	                    testOpacities = {line:undefined, cross:undefined, stick:undefined, sphere:undefined};
	                    for (j in testOpacities)
	                    {
	                        if (atom.style[j])
	                        {
	                            if (atom.style[j].opacity)
	                                testOpacities[j] = parseFloat(atom.style[j].opacity);
	                            else
	                                testOpacities[j] = 1;

	                        } else testOpacities[j] = undefined;

	                        if (opacities[j])
	                        {
	                            if (testOpacities[j] != undefined && opacities[j] != testOpacities[j])
	                            {
	                                console.log("Warning: " + j + " opacity is ambiguous");
	                                opacities[j] = 1;
	                            }

	                        } else opacities[j] = testOpacities[j];
	                    }

	                    drawSphereFunc(atom, sphereGeometry);
	                   
	                    drawAtomCross(atom, crossGeometries);
	                    drawBondLines(atom, atoms, lineGeometries);
	                    drawBondSticks(atom, atoms, stickGeometry);

	                    if (typeof (atom.style.cartoon) !== "undefined" && !atom.style.cartoon.hidden) {
	                        //gradient color scheme range
	                        if (atom.style.cartoon.color === "spectrum" && typeof(atom.resi) === "number" && !atom.hetflag) {                            
	                            if (atom.resi < range[0])
	                                range[0] = atom.resi;
	                            if (atom.resi > range[1])
	                                range[1] = atom.resi;
	                        }

	                        cartoonAtoms.push(atom);
	                    }                   
	                }
	            }
	            // create cartoon if needed - this is a whole model analysis
	            if (cartoonAtoms.length > 0) {
	                var gradientscheme = null;
	                //TODO: Should have an option to choose gradient type
	                if (range[0] < range[1])
	                    gradientscheme = new $3Dmol.Gradient.Sinebow(range[0], range[1]);

	                $3Dmol.drawCartoon(ret, cartoonAtoms, gradientscheme);

	            }

	            // add sphere geometry
	            if (sphereGeometry && sphereGeometry.vertices > 0) {
	                //Initialize buffers in geometry                
	                sphereGeometry.initTypedArrays();                
	                var sphereMaterial = null;
	                
	                //create appropriate material
	                if(sphereGeometry.imposter) {
	                    sphereMaterial = new $3Dmol.SphereImposterMaterial({
	                        ambient : 0x000000,
	                        vertexColors : true,
	                        reflectivity : 0
	                    });            
	                }
	                else if(sphereGeometry.instanced) {
	                    var sphere = new $3Dmol.Geometry(true);
	                    $3Dmol.GLDraw.drawSphere(sphere, {x:0, y:0, z:0}, 1, new $3Dmol.Color(0.5, 0.5, 0.5));
	                    sphere.initTypedArrays();
	                    sphereMaterial = new $3Dmol.InstancedMaterial({
	                        sphereMaterial : new $3Dmol.MeshLambertMaterial({
	                            ambient : 0x000000,
	                            vertexColors : true,
	                            reflectivity : 0,
	                        }),
	                        sphere : sphere
	                    });                
	                }
	                else { //regular mesh
	                    var sphereMaterial = new $3Dmol.MeshLambertMaterial({
	                        ambient : 0x000000,
	                        vertexColors : true,
	                        reflectivity : 0,
	                    });
	                }
	                if (opacities.sphere < 1 && opacities.sphere >= 0)
	                {
	                    sphereMaterial.transparent = true;
	                    sphereMaterial.opacity = opacities.sphere;
	                }
	                
	                var sphere = new $3Dmol.Mesh(sphereGeometry, sphereMaterial);
	                ret.add(sphere);
	            }
	            
	            // add stick geometry
	            if (stickGeometry.vertices > 0) {
	                
	                if(stickGeometry.imposter) {
	                    var imposterMaterial = new $3Dmol.StickImposterMaterial({
	                        ambient : 0x000000,
	                        vertexColors : true,
	                        reflectivity : 0
	                    });
	                    
	                    //Initialize buffers in geometry                
	                    stickGeometry.initTypedArrays();
	                    
	                    var sticks = new $3Dmol.Mesh(stickGeometry, imposterMaterial);
	                    ret.add(sticks);                    
	                } else {                
	                    var cylinderMaterial = new $3Dmol.MeshLambertMaterial({
	                        vertexColors : true,
	                        ambient : 0x000000,
	                        reflectivity : 0
	                    });
	                    if (opacities.stick < 1 && opacities.stick >= 0)
	                    {
	                        cylinderMaterial.transparent = true;
	                        cylinderMaterial.opacity = opacities.stick;
	                    }
	    
	                    //Initialize buffers in geometry                
	                    stickGeometry.initTypedArrays();
	                    
	                    if (cylinderMaterial.wireframe)
	                        stickGeometry.setUpWireframe();
	                
	                    var sticks = new $3Dmol.Mesh(stickGeometry, cylinderMaterial);
	                    ret.add(sticks);
	                }
	            }
	            
	            //var linewidth;
	            // add any line geometries, distinguished by line width
	            for (i in lineGeometries) {
	                if (lineGeometries.hasOwnProperty(i)) {
	                    var linewidth = i;
	                    var lineMaterial = new $3Dmol.LineBasicMaterial({
	                        linewidth : linewidth,
	                        vertexColors : true
	                    });
	                    if (opacities.line < 1 && opacities.line >= 0)
	                    {
	                        lineMaterial.transparent = true;
	                        lineMaterial.opacity = opacities.line;
	                    }
	                    
	                    lineGeometries[i].initTypedArrays();
	                    
	                    var line = new $3Dmol.Line(lineGeometries[i], lineMaterial,
	                            $3Dmol.LinePieces);

	                    ret.add(line);
	                }
	            }

	            // add any cross geometries
	            for (i in crossGeometries) {
	                if (crossGeometries.hasOwnProperty(i)) {
	                    var linewidth = i;
	                    var crossMaterial = new $3Dmol.LineBasicMaterial({
	                        linewidth : linewidth,
	                        vertexColors : true
	                    });
	                    if (opacities.cross < 1 && opacities.cross >= 0)
	                    {
	                        crossMaterial.transparent = true;
	                        crossMaterial.opacity = opacities.cross;
	                    }

	                    crossGeometries[i].initTypedArrays();
	                    
	                    var cross = new $3Dmol.Line(crossGeometries[i], crossMaterial,
	                            $3Dmol.LinePieces);

	                    ret.add(cross);
	                }
	            }
	            
	            //for BIOMT assembly
	            if (dontDuplicateAtoms && modelData.symmetries && modelData.symmetries.length > 0) {
	                var finalRet = new $3Dmol.Object3D();
	                var t;
	                for (t = 0; t < modelData.symmetries.length; t++) {
	                    var transformedRet = new $3Dmol.Object3D();
	                    transformedRet = ret.clone();
	                    transformedRet.matrix.copy(modelData.symmetries[t]);
	                    transformedRet.matrixAutoUpdate = false;
	                    finalRet.add(transformedRet);
	                }
	                return finalRet;
	            }

	            return ret;
	        };
	        
	        
	        this.getCrystData = function() {
	            if (modelData.cryst) {
	                return modelData.cryst;
	            }
	            else {
	                return null;
	            }
	        }
	        
	        /**
	         * Returns list of rotational/translational matrices if there is BIOMT data
	         * Otherwise returns a list of just the ID matrix
	         *
	         * @function $3Dmol.GlModel#getSymmetries
	         * @return {Array<$3Dmol.Matrix4>}
	         *
	         */
	        this.getSymmetries = function() {
	            
	            if (typeof(modelData.symmetries) == 'undefined') {
	                modelData.symmetries = [idMatrix];
	            }
	            return modelData.symmetries; 
	        };
	        
	        /**
	         * Sets symmetries based on specified matrices in list
	         *
	         * @function $3Dmol.GlModel#setSymmetries
	         * @param {Array<$3Dmol.Matrix4>} list
	         *
	         */
	        this.setSymmetries = function(list) {
	            if (typeof(list) == "undefined") { //delete sym data
	                modelData.symmetries = [idMatrix];
	            }
	            else {
	                modelData.symmetries = list;
	            }
	        };

	        /**
	         * Returns model id number
	         * 
	         * @function $3Dmol.GLModel#getID
	         * @return {number} Model ID
	         */
	        this.getID = function() {
	            return id;
	        };
	        
	        /**
	         * Returns model's frames property, a list of atom lists
	         * 
	         * @function $3Dmol.GLModel#getFrames
	         * @return {Array.<Object>}
	         */
	        this.getFrames = function() {
	            return frames;
	        };
	        
	        /**
	         * Sets model's atomlist to specified frame
	         * Sets to last frame if framenum out of range
	         * 
	         * @function $3Dmol.GLModel#setFrame
	         * @param {number} framenum - model's atoms are set to this index in frames list
	         */
	        this.setFrame = function(framenum) {
	            if (frames.length == 0) {
	                return;
	            }
	            if (framenum >= 0 && framenum < frames.length) {
	                atoms = frames[framenum];
	            }
	            else {
	                atoms = frames[frames.length-1];
	            }
	            molObj = null;
	        };
	        
	        /**
	         * Add atoms as frames of model
	         * 
	         * @function $3Dmol.GLModel#addFrame
	         * @param {AtomSpec} atom - atoms to be added
	         */
	        this.addFrame = function(atoms) {
	            frames.push(atoms);
	        };

	        
	        /**
	         * If model atoms have dx, dy, dz properties (in some xyz files), vibrate populates the model's frame property based on parameters.
	         * Model can then be animated
	         * 
	         * @function $3Dmol.GLModel#vibrate
	         * @param {number} numFrames - number of frames to be created, default to 10
	         * @param {number} amplitude - amplitude of distortion, default to 1 (full)
	         */
	        this.vibrate = function(numFrames, amplitude) {
	            var vectors = [];
	            var amplitude = amplitude || 1;
	            var numFrames = numFrames || 10; 
	            for (var i = 0; i < atoms.length; i++) {
	                var vector = new $3Dmol.Vector3(atoms[i].dx, atoms[i].dy, atoms[i].dz);
	                vectors.push(vector);
	            }
	            numFrames--;
	            for (var i = 1; i <= numFrames; i++) {
	                var newAtoms = [];
	                for (var j = 0; j < atoms.length; j++) {
	                    var newVector = new $3Dmol.Vector3(atoms[j].dx, atoms[j].dy, atoms[j].dz);
	                    var starting = new $3Dmol.Vector3(atoms[j].x, atoms[j].y, atoms[j].z);
	                    newVector.sub(starting);
	                    newVector.multiplyScalar((i*amplitude)/numFrames);
	                    starting.add(newVector);
	                    var newAtom = {};
	                    for (var k in atoms[j]) {
	                        newAtom[k] = atoms[j][k];
	                    }
	                    newAtom.x = starting.x;
	                    newAtom.y = starting.y;
	                    newAtom.z = starting.z;
	                    newAtoms.push(newAtom);
	                }
	                frames.push(newAtoms);
	            }
	            frames.unshift(atoms); //add 1st frame
	        };
	        
	        // set default style and colors for atoms
	        this.setAtomDefaults = function(atoms) {
	            for ( var i = 0; i < atoms.length; i++) {
	                var atom = atoms[i];
	                if (atom) {
	                    atom.style = atom.style || defaultAtomStyle;
	                    atom.color = atom.color || ElementColors[atom.elem] || defaultColor;
	                    atom.model = id;
	                    if (atom.clickable)
	                        atom.intersectionShape = {sphere : [], cylinder : [], line : [], triangle : []};
	                }
	            }
	        };

	        /** add atoms to this model from molecular data string
	         * 
	         * @function $3Dmol.GLModel#addMolData
	         * @param {string|ArrayBuffer} data - atom structure file input data string, for gzipped input use ArrayBuffer
	         * @param {string} format - input file string format (e.g 'pdb', 'sdf', 'sdf.gz', etc.)
	         * @param {Object} options - format dependent options (e.g. 'options.keepH' to keep hydrogens)
	         */
	        this.addMolData = function(data, format, options) {
	            options = options || {};
	            var parsedAtoms = $3Dmol.GLModel.parseMolData(data, format, options);
	            dontDuplicateAtoms = !options.duplicateAssemblyAtoms;
	            var mData = parsedAtoms.modelData;
	            if (mData) {
	                if (Array.isArray(mData)) {
	                    modelData = mData[0];
	                } else {
	                    modelData = mData;
	                }
	            }

	            if (frames.length == 0) { //first call
	                for (var i = 0; i < parsedAtoms.length; i++) {
	                    if (parsedAtoms[i].length != 0)
	                        frames.push(parsedAtoms[i]);
	                }
	                if(frames[0])
	                    atoms = frames[0];
	            }
	            
	            else { //subsequent calls
	                if (options.frames) { //add to new frame
	                    for (var i = 0; i < parsedAtoms.length; i++) {
	                        frames.push(parsedAtoms[i]);
	                    }
	                }
	                else { //add atoms to current frame
	                    for (var i = 0; i < parsedAtoms.length; i++) {
	                        this.addAtoms(parsedAtoms[i]); 
	                    }
	                }
	            }
	            
	            for (var i = 0; i < frames.length; i++) {
	                this.setAtomDefaults(frames[i], id);
	            }
	            
	            if(options.vibrate && options.vibrate.frames && options.vibrate.amplitude) {
	                //fill in vibrational modes
	                this.vibrate(options.vibrate.frames, options.vibrate.amplitude);
	            }

	        };

	        this.setDontDuplicateAtoms = function(dup) {
	            dontDuplicateAtoms = dup;
	        }

	        this.setModelData = function(mData) {
	            modelData = mData;
	        }
	        
	        /** given a selection specification, return true if atom is selected
	         * 
	         * @function $3Dmol.GLModel#atomIsSelected
	         * @param {AtomSpec} atom
	         * @param {AtomSelectionSpec} sel
	         * @return {boolean}
	         */
	        this.atomIsSelected = function(atom, sel) {
	            if (typeof (sel) === "undefined")
	                return true; // undef gets all
	            var invert = !!sel.invert;
	            var ret = true;
	            for ( var key in sel) {
	                if(key === 'predicate') { //a user supplied function for evaluating atoms
	                    if(!sel['predicate'](atom) ) {
	                        ret = false;
	                        break;
	                    }
	                }
	                else if(key == "properties" && atom[key]) {
	                    for (var propkey in sel.properties) {
	                        if(typeof(atom.properties[propkey]) === 'undefined') {
	                            ret = false;
	                            break
	                        }
	                        if(atom.properties[propkey] != sel.properties[propkey]) {
	                            ret = false;
	                            break;
	                        }
	                    }
	                }
	                else if (sel.hasOwnProperty(key) && key != "props" && key != "invert" && key != "model" && key != "byres" && key != "expand" && key != "within") {

	                    // if something is in sel, atom must have it                    
	                    if (typeof (atom[key]) === "undefined") {
	                        ret = false;
	                        break;
	                    }
	                    var isokay = false;
	                    if(key === "bonds") {
	                        //special case counting number of bonds, for selecting nonbonded mostly
	                        var val = sel[key];
	                        if(val != atom.bonds.length) {
	                            ret = false;
	                            break;
	                        }
	                    }
	                    else if ($.isArray(sel[key])) {
	                        // can be any of the listed values
	                        var valarr = sel[key];
	                        for ( var i = 0; i < valarr.length; i++) {
	                            if (atom[key] == valarr[i]) {
	                                isokay = true;
	                                break;
	                            }
	                        }
	                        if (!isokay) {
	                            ret = false;
	                            break;
	                        }
	                    } else { // single match
	                        var val = sel[key];
	                        if (atom[key] != val) {
	                            ret = false;
	                            break;
	                        }
	                    }
	                }
	            }
	            
	            return invert ? !ret : ret;
	        };


	        /** return list of atoms selected by sel, this is specific to glmodel
	         * 
	         * @function $3Dmol.GLModel#selectedAtoms
	         * @param {AtomSelectionSpec} sel
	         * @return {Array.<Object>}
	         */
	        this.selectedAtoms = function(sel, from) {
	            var ret = [];
	            sel = sel || {};
	            if (!from) from = atoms;
	            var aLength = from.length;
	            for ( var i = 0; i < aLength; i++) {
	                var atom = from[i];
	                if (atom) {
	                    if (this.atomIsSelected(atom, sel))
	                        ret.push(atom);
	                }
	            }

	            // expand selection by some distance
	            if (sel.hasOwnProperty("expand")) {

	                // get atoms in expanded bounding box

	                var expand = expandAtomList(ret, parseFloat(sel.expand));
	                var retlen = ret.length;
	                for (var i = 0; i < expand.length; i++) {
	                    for (var j = 0; j < retlen; j++) {

	                        var dist = squaredDistance(expand[i], ret[j]);
	                        var thresh = Math.pow(sel.expand, 2);
	                        if (dist < thresh && dist > 0) {
	                            ret.push(expand[i]);
	                        }
	                    }
	                }
	            }

	            // selection within distance of sub-selection
	            if (sel.hasOwnProperty("within") && sel.within.hasOwnProperty("sel") && sel.within.hasOwnProperty("distance")) {

	                // get atoms in second selection
	                var sel2 = this.selectedAtoms(sel.within.sel, atoms);
	                var within = [];
	                for (var i = 0; i < sel2.length; i++) {
	                    for (var j = 0; j < ret.length; j++) {

	                        var dist = squaredDistance(sel2[i], ret[j]);
	                        var thresh = Math.pow(parseFloat(sel.within.distance), 2);
	                        if (dist < thresh && dist > 0) {
	                            within.push(ret[j]);
	                        }
	                    }
	                }
	                ret = within;
	            }

	            // byres selection flag
	            if (sel.hasOwnProperty("byres")) {

	                // Keep track of visited residues, visited atoms, and atom stack
	                var vResis = {};
	                var vAtoms = [];
	                var stack = [];

	                for (var i = 0; i < ret.length; i++) {
	                    
	                    // Check if atom is part of a residue, and that the residue hasn't been traversed yet
	                    var atom = ret[i];
	                    var c = atom.chain;
	                    var r = atom.resi;
	                    if (vResis[c] === undefined) vResis[c] = {};
	                    if (atom.hasOwnProperty("resi") && vResis[c][r] === undefined) {

	                        // Perform a depth-first search of atoms with the same resi
	                        vResis[c][r] = true;
	                        stack.push(atom);
	                        while(stack.length > 0) {
	                            atom = stack.pop();
	                            c = atom.chain;
	                            r = atom.resi;
	                            if (vAtoms[atom.index] === undefined) {
	                                vAtoms[atom.index] = true;
	                                for (var j = 0; j < atom.bonds.length; j++) {
	                                    var atom2 = atoms[atom.bonds[j]];
	                                    if (vAtoms[atom2.index] === undefined && atom2.hasOwnProperty("resi") && atom2.chain == c && atom2.resi == r) {
	                                        stack.push(atom2);
	                                        ret.push(atom2);
	                                    }
	                                }
	                            }
	                        }
	                    }   
	                }
	            }

	            return ret;
	        };

	        var squaredDistance = function(atom1, atom2) {
	            var xd = atom2.x - atom1.x;
	            var yd = atom2.y - atom1.y;
	            var zd = atom2.z - atom1.z;
	            return (Math.pow(xd, 2) + Math.pow(yd, 2) + Math.pow(zd, 2));
	        };

	        /** returns a list of atoms in the expanded bounding box, but not in the current one
	         *
	         *  Bounding box:
	         *
	         *    [ [ xmin, ymin, zmin ],
	         *      [ xmax, ymax, zmax ],
	         *      [ xctr, yctr, zctr ] ]
	         *
	         **/
	        var expandAtomList = function(atomList, amt) {

	            if (amt <= 0) return atomList;

	            var pb = $3Dmol.getExtent(atomList); // previous bounding box
	            var nb = [[], [], []]; // expanded bounding box

	            for (var i = 0; i < 3; i++)
	            {
	                nb[0][i] = pb[0][i]-amt;
	                nb[1][i] = pb[1][i]+amt;
	                nb[2][i] = pb[2][i];
	            }

	            // look in added box "shell" for new atoms
	            var expand = [];
	            for (var i = 0; i < atoms.length; i++) {

	                var x = atoms[i].x;
	                var y = atoms[i].y;
	                var z = atoms[i].z;

	                if (x >= nb[0][0] && x <= nb[1][0] && y >= nb[0][1] && y <= nb[1][1] && z >= nb[0][2] && z <= nb[1][2]) {
	                    if (!(x >= pb[0][0] && x <= pb[1][0] && y >= pb[0][1] && y <= pb[1][1] && z >= pb[0][2] && z <= pb[1][2])) {
	                        expand.push(atoms[i]);
	                    }
	                }
	            }
	            return expand;
	        };
	        
	        /** Add list of new atoms to model.  Adjusts bonds appropriately.
	         * 
	         * @function $3Dmol.GLModel#addAtoms
	         * @param {type} newatoms
	         */        
	        this.addAtoms = function(newatoms) {
	            molObj = null;
	            var start = atoms.length;
	            var indexmap = [];
	            // mapping from old index to new index
	            var i;
	            for(i = 0; i < newatoms.length; i++) {
	                if(typeof(newatoms[i].index) == "undefined")
	                    newatoms[i].index = i;
	                if(typeof(newatoms[i].serial) == "undefined")
	                    newatoms[i].serial = i;
	                indexmap[newatoms[i].index] = start+i;
	            }
	            
	            // copy and push newatoms onto atoms
	            for(i = 0; i < newatoms.length; i++) {
	                var olda = newatoms[i];
	                var nindex = indexmap[olda.index];
	                var a = $.extend(false, {}, olda);
	                a.index = nindex;
	                a.bonds = [];
	                a.bondOrder = [];
	                a.model = id;
	                a.style = a.style || defaultAtomStyle;
	                if(typeof(a.color) == "undefined")
	                    a.color = ElementColors[a.elem] || defaultColor;                
	                // copy over all bonds contained in selection,
	                // updating indices appropriately
	                var nbonds = olda.bonds ? olda.bonds.length : 0;
	                for(var j = 0; j < nbonds; j++) {
	                    var neigh = indexmap[olda.bonds[j]];
	                    if(typeof(neigh) != "undefined") {
	                        a.bonds.push(neigh);
	                        a.bondOrder.push(olda.bondOrder ? olda.bondOrder[j] : 1);
	                    }                
	                }
	                atoms.push(a);
	            }
	        };

	        /** Remove specified atoms from model
	         * 
	         * @function $3Dmol.GLModel#removeAtoms
	         * @param {type} badatoms
	         * @return {removeAtoms}
	         */
	        this.removeAtoms = function(badatoms) {
	            molObj = null;
	            // make map of all baddies
	            var baddies = [];
	            var i;
	            for(i = 0; i < badatoms.length; i++) {
	                baddies[badatoms[i].index] = true;
	            }
	            
	            // create list of good atoms
	            var newatoms = [];
	            for(i = 0; i < atoms.length; i++) {
	                var a = atoms[i];
	                if(!baddies[a.index])
	                    newatoms.push(a);
	            }
	            
	            // clear it all out
	            atoms = [];
	            // and add back in to get updated bonds
	            this.addAtoms(newatoms);
	        };
	        
	        
	        /** Set atom style of selected atoms
	         * 
	         * @function $3Dmol.GLModel#setStyle
	         * @param {AtomSelectionSpec} sel
	         * @param {AtomStyleSpec} style
	         * @param {boolean} add - if true, add to current style, don't replace
	         */
	        this.setStyle = function(sel, style, add) {
	            
	            if(typeof(style) === 'undefined' && typeof(add) == 'undefined') {
	                //if a single argument is provided, assume it is a style and select all
	                style = sel;
	                sel = {};
	            }
	            
	            // report to console if this is not a valid selector
	            var s;
	            for (s in sel) {
	                if(validAtomSelectionSpecs.indexOf(s) === -1) {
	                    console.log('Unknown selector ' + s);
	                }
	            }
	            // report to console if this is not a valid style
	            for (s in style) {
	                if(validAtomStyleSpecs.indexOf(s) === -1) {
	                    console.log('Unknown style ' + s);
	                }
	            }

	            var changedAtoms = false;
	            // somethings we only calculate if there is a change in a certain
	            // style, although these checks will only catch cases where both
	            // are either null or undefined
	            
	            var setStyleHelper = function(atomArr) {
	                var selected = that.selectedAtoms(sel, atomArr);
	                for (var i = 0; i < atomArr.length; i++) {
	                    if (atomArr[i]) atomArr[i].capDrawn = false; //reset for proper stick render
	                }
	            
	                for ( var i = 0; i < selected.length; i++) {                
	                    changedAtoms = true;
	                    if (selected[i].clickable) 
	                        selected[i].intersectionShape = {sphere : [], cylinder : [], line : [], triangle : []};                    
	                   

	                    if(!add) selected[i].style = {};
	                    for(s in style) {
	                        if(style.hasOwnProperty(s)) {
	                            selected[i].style[s]=selected[i].style[s]||{}; //create distinct object for each atom
	                            for(var prop in style[s]){
	                                selected[i].style[s][prop]=style[s][prop];
	                            }
	                        }
	                    }
	                }
	            }
	            
	            var that = this;
	            setStyleHelper(atoms);
	            for (var i = 0; i < frames.length; i++) {
	                setStyleHelper(frames[i]);
	            }
	            
	            if (changedAtoms)
	                molObj = null; //force rebuild
	            
	        };

	        /** Set clickable and callback of selected atoms
	         * 
	         * @function $3Dmol.GLModel#setClickable
	         * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to
	         * @param {boolean} clickable - whether click-handling is enabled for the selection
	         * @param {function} callback - function called when an atom in the selection is clicked
	         */
	        this.setClickable = function(sel, clickable, callback) {           

	            // report to console if this is not a valid selector
	            var s;
	            for (s in sel) {
	                if (validAtomSelectionSpecs.indexOf(s) === -1) {
	                    console.log('Unknown selector ' + s);
	                }
	            }

	            // make sure clickable is a boolean
	            clickable = !!clickable;

	            // report to console if callback is not a valid function
	            if (callback && typeof callback != "function") {
	                console.log("Callback is not a function");
	                return;
	            }

	            var i;
	            var selected = this.selectedAtoms(sel, atoms);
	            var len = selected.length;
	            for (i = 0; i < len; i++) {                

	                selected[i].intersectionShape = {sphere : [], cylinder : [], line : [], triangle : []};
	                selected[i].clickable = clickable;
	                if (callback) selected[i].callback = callback;

	            }

	            if (len > 0) molObj = null; // force rebuild to get correct intersection shapes         
	        };
	        
	        /** given a mapping from element to color, set atom colors
	         * 
	         * @function $3Dmol.GLModel#setColorByElement
	         * @param {type} sel
	         * @param {type} colors
	         */
	        this.setColorByElement = function(sel, colors) {
	            
	            if(molObj !== null && sameObj(colors,lastColors))
	                return; // don't recompute
	            lastColors = colors;
	            var atoms = this.selectedAtoms(sel, atoms);
	            if(atoms.length > 0)
	                molObj = null; // force rebuild
	            for ( var i = 0; i < atoms.length; i++) {
	                var a = atoms[i];
	                if(typeof(colors[a.elem]) !== "undefined") {
	                    a.color = colors[a.elem];
	                }
	            }
	        };
	        
	        /**
	         * @function $3Dmol.GLModel.setColorByProperty
	         * @param {type} sel
	         * @param {type} prop
	         * @param {type} scheme
	         */
	        this.setColorByProperty = function(sel, prop, scheme, range) {
	            var atoms = this.selectedAtoms(sel, atoms);
	            lastColors = null; // don't bother memoizing
	            if(atoms.length > 0)
	                molObj = null; // force rebuild
	            var min =  Number.POSITIVE_INFINITY;
	            var max =  Number.NEGATIVE_INFINITY;
	            var i, a;
	            
	            if(!range) { //no explicit range, get from scheme
	                range = scheme.range();
	            }
	            
	            if(!range) { //no range in scheme, compute the range for this model
	                range = $3Dmol.getPropertyRange(atoms, prop);
	            }
	            // now apply colors using scheme
	            for (i = 0; i < atoms.length; i++) {
	                a = atoms[i];
	                var val = $3Dmol.getAtomProperty(a, prop);
	                if(val != null) {
	                    a.color = scheme.valueToHex(parseFloat(a.properties[prop]), [range[0],range[1]]);
	                }                    
	            }
	        };
	        
	        /**
	         * @function $3Dmol.GLModel.setColorByFunction
	         * @param {type} sel
	         * @param {type} func
	         */
	        this.setColorByFunction = function(sel, colorfun) {
	            var atoms = this.selectedAtoms(sel, atoms);
	            lastColors = null; // don't bother memoizing
	            if(atoms.length > 0)
	                molObj = null; // force rebuild
	            
	            // now apply colorfun
	            for (i = 0; i < atoms.length; i++) {
	                a = atoms[i];
	                a.color = colorfun(a);
	            }
	        };

	        /** Convert the model into an object in the format of a ChemDoodle JSON model.
	         *
	         * @function $3Dmol.GLModel#toCDObject
	         * @param {boolean} whether or not to include style information. Defaults to false.
	         * @return {Object}
	         */
	        this.toCDObject = function(includeStyles) {
	            var out = { a:[], b:[] };
	            if (includeStyles) {
	                out.s = [];
	            }
	            for (var i = 0; i < atoms.length; i++) {
	                var atomJSON = {};
	                var atom = atoms[i];
	                atomJSON.x = atom.x;
	                atomJSON.y = atom.y;
	                atomJSON.z = atom.z;
	                if (atom.elem != "C") {
	                    atomJSON.l = atom.elem;
	                }
	                if (includeStyles) {
	                    var s = 0;
	                    while (s < out.s.length &&
	                          (JSON.stringify(atom.style) !== JSON.stringify(out.s[s]))) {
	                        s++;
	                    }
	                    if (s === out.s.length) {
	                        out.s.push(atom.style);
	                    }
	                    if (s !== 0) {
	                        atomJSON.s = s;
	                    }
	                }
	                
	                out.a.push(atomJSON);

	                for (var b = 0; b < atom.bonds.length; b++) {
	                    var firstAtom = i;
	                    var secondAtom = atom.bonds[b];
	                    if (firstAtom >= secondAtom)
	                        continue;
	                    var bond = {
	                        b: firstAtom,
	                        e: secondAtom
	                    };
	                    var bondOrder =  atom.bondOrder[b];
	                    if (bondOrder != 1) {
	                        bond.o = bondOrder;
	                    }
	                    out.b.push(bond);
	                }
	            }
	            return out;
	        }


	        /** manage the globj for this model in the possed modelGroup - if it has to be regenerated, remove and add
	         * 
	         * @function $3Dmol.GLModel#globj
	         * @param {$3Dmol.Object3D} group
	         * @param Object options
	         */
	        this.globj = function(group, options) {
	            var time = new Date();
	            if(molObj === null) { // have to regenerate
	                molObj = createMolObj(atoms, options);
	                var time2 = new Date();
	                //console.log("object creation time: " + (time2 - time));
	                if(renderedMolObj) { // previously rendered, remove
	                    group.remove(renderedMolObj);
	                    renderedMolObj = null;
	                }
	                renderedMolObj = molObj.clone();
	                if(hidden) {
	                    renderedMolObj.setVisible(false);
	                    molObj.setVisible(false);
	                }
	                group.add(renderedMolObj);              
	            }
	        };
	        
	        /** Remove any renderable mol object from scene
	         * 
	         * @function $3Dmol.GLModel#removegl
	         * @param {$3Dmol.Object3D} group
	         */
	        this.removegl = function(group) {
	            if(renderedMolObj) {
	                //dispose of geos and materials
	                if (renderedMolObj.geometry !== undefined) renderedMolObj.geometry.dispose();             
	                if (renderedMolObj.material !== undefined) renderedMolObj.material.dispose();
	                group.remove(renderedMolObj);
	                renderedMolObj = null;
	            }
	            molObj = null;
	        };
	        
	        /** Don't show this model is future renderings.  Keep all styles and state
	         * so it can be efficiencly shown again.
	         * 
	         * @function $3Dmol.GLModel#hide
	         */
	        this.hide = function() {
	            hidden = true;
	            if(renderedMolObj) renderedMolObj.setVisible(false);
	            if(molObj) molObj.setVisible(false);
	        }
	        
	        this.show = function() {
	            hidden = false;
	            if(renderedMolObj) renderedMolObj.setVisible(true);
	            if(molObj) molObj.setVisible(true);
	        }
	        
	        /** Create labels for residues of selected atoms.
	         * Will create a single label at the center of mass of all atoms
	         * with the same chain,resn, and resi.
	         * @function $3Dmol.GLModel#addResLabels
	         * 
	         * @param {AtomSelectionSpec} sel
	         * @param {$3Dmol.GLViewer} viewer
	         */
	        this.addResLabels = function(sel, viewer, style) {
	            var atoms = this.selectedAtoms(sel, atoms);
	            var bylabel = {}
	            //collect by chain:resn:resi
	            for(var i = 0; i < atoms.length; i++) {
	                var a = atoms[i];
	                var c = a.chain;
	                var resn = a.resn;
	                var resi = a.resi;
	                var label =  resn + '' + resi;
	                if(!bylabel[c]) bylabel[c] = {};
	                if(!bylabel[c][label]) bylabel[c][label] = []
	                bylabel[c][label].push(a);
	            }
	            
	            var mystyle = $.extend(true, {}, style);
	            //now compute centers of mass
	            for(var c in bylabel) {
	                if(bylabel.hasOwnProperty(c)) {
	                    var labels = bylabel[c];
	                    for(var label in labels) {
	                        if(labels.hasOwnProperty(label)) {
	                            var atoms = labels[label];
	                            var sum = new $3Dmol.Vector3(0,0,0);
	                            for(var i = 0; i < atoms.length; i++) {
	                                var a = atoms[i];
	                                sum.x += a.x;
	                                sum.y += a.y;
	                                sum.z += a.z;
	                            }
	                            sum.divideScalar(atoms.length);
	                            mystyle.position = sum;
	                            viewer.addLabel(label, mystyle);
	                        }                        
	                    }
	                }
	            }
	        }

	    }

	    GLModel.parseMolData = function(data, format, options) {
	        format = format || "";

	        if (!data)
	            return []; //leave an empty model

	        if(/\.gz$/.test(format)) {
	            //unzip gzipped files
	            format = format.replace(/\.gz$/,'');
	            try {
	                data = pako.inflate(data, {to: 'string'});
	            } catch(err) {
	                console.log(err);
	            }
	        }

	        if(typeof($3Dmol.Parsers[format]) == "undefined") {
	            //let someone provide a file name and get format from extension
	            format = format.split('.').pop();
	            if(typeof($3Dmol.Parsers[format]) == "undefined") {
	                console.log("Unknown format: "+format);
	                //try to guess correct format from data contents
	                if(data.match(/^@<TRIPOS>MOLECULE/gm)) {
	                    format = "mol2";
	                } else if(data.match(/^HETATM/gm) || data.match(/^ATOM/gm)) {
	                    format = "pdb";
	                } else if(data.match(/^.*\n.*\n.\s*(\d+)\s+(\d+)/gm)){
	                    format = "sdf"; //could look at line 3
	                } else {
	                    format = "xyz";
	                }
	                console.log("Best guess: "+format);
	            }
	        }
	        var parse = $3Dmol.Parsers[format];
	        var parsedAtoms = parse(data, options);

	        return parsedAtoms;
	    };


	    // set default style and colors for atoms
	    GLModel.setAtomDefaults = function(atoms, id) {
	        for ( var i = 0; i < atoms.length; i++) {
	            var atom = atoms[i];
	            if (atom) {
	                atom.style = atom.style || defaultAtomStyle;
	                atom.color = atom.color || ElementColors[atom.elem] || defaultColor;
	                atom.model = id;
	                if (atom.clickable)
	                    atom.intersectionShape = {sphere : [], cylinder : [], line : [], triangle : []};
	            }
	        }
	    };

	    return GLModel;
	    
	})();
	/**
	 * A GLShape is a collection of user specified shapes.
	 * 
	 * @constructor $3Dmol.GLShape
	 * @extends {ShapeSpec}
	 * @param {number} sid - Unique identifier
	 * @param {ShapeSpec} stylespec - shape style specification
	 */
	$3Dmol.GLShape = (function() {

	    // Marching cube, to match with protein surface generation
	    var ISDONE = 2;

	    
	    var finalizeGeo = function(geo) {
	        //to avoid creating a bunch of geometries, we leave geoGroup untruncated
	        //until render is called, at which point we truncate; 
	        //successive called up updateGeo will return a new geometry
	        var geoGroup = geo.updateGeoGroup(0);
	        if(geoGroup.vertices > 0) {
	            geoGroup.truncateArrayBuffers(true, true);
	        }
	    };
	    
	    /**
	     * 
	     * @param {$3Dmol.Geometry}
	     *            geo
	     * @param {$3Dmol.Color |
	     *            colorlike} color
	     */
	    var updateColor = function(geo, color) {

	        var C = color || $3Dmol.CC.color(color);
	        geo.colorsNeedUpdate = true;
	        
	        var r,g,b;
	        if(! (color.constructor === Array)) {
	            r = color.r;
	            g = color.g;
	            b = color.b;
	        }


	        for ( var gg in geo.geometryGroups) {

	            var geoGroup = geo.geometryGroups[gg];
	            var colorArr = geoGroup.colorArray;

	            for (var i = 0, il = geoGroup.vertices; i < il; ++i) {
	            
	                if( color.constructor === Array) {
	                    var c = color[i];
	                    r = c.r;
	                    g = c.g;
	                    b = c.b;
	                }

	                colorArr[i * 3] = r;
	                colorArr[i * 3 + 1] = g;
	                colorArr[i * 3 + 2] = b;
	            }
	        }

	    };


	    /**
	     * @param {$3Dmol.GLShape}
	     *            shape
	     * @param {geometryGroup}
	     *            geoGroup
	     * @param {ArrowSpec}
	     *            spec
	     */
	    var drawArrow = function(shape, geo, spec) {

	        var from = spec.start, end = spec.end, radius = spec.radius, radiusRatio = spec.radiusRatio, mid = spec.mid;

	        if (!(from && end))
	            return;

	        var geoGroup = geo.updateGeoGroup(51);

	        // vertices

	        var dir = end.clone();
	        dir.sub(from).multiplyScalar(mid);
	        var to = from.clone().add(dir);
	        var negDir = dir.clone().negate();

	        shape.intersectionShape.cylinder.push(new $3Dmol.Cylinder(from.clone(),
	                to.clone(), radius));
	        shape.intersectionShape.sphere.push(new $3Dmol.Sphere(from.clone(),
	                radius));

	        // get orthonormal vector
	        var nvecs = [];
	        nvecs[0] = dir.clone();
	        if (Math.abs(nvecs[0].x) > 0.0001)
	            nvecs[0].y += 1;
	        else
	            nvecs[0].x += 1;
	        nvecs[0].cross(dir);
	        nvecs[0].normalize();

	        nvecs[0] = nvecs[0];
	        // another orth vector
	        nvecs[4] = nvecs[0].clone();
	        nvecs[4].crossVectors(nvecs[0], dir);
	        nvecs[4].normalize();
	        nvecs[8] = nvecs[0].clone().negate();
	        nvecs[12] = nvecs[4].clone().negate();

	        // now quarter positions
	        nvecs[2] = nvecs[0].clone().add(nvecs[4]).normalize();
	        nvecs[6] = nvecs[4].clone().add(nvecs[8]).normalize();
	        nvecs[10] = nvecs[8].clone().add(nvecs[12]).normalize();
	        nvecs[14] = nvecs[12].clone().add(nvecs[0]).normalize();

	        // eights
	        nvecs[1] = nvecs[0].clone().add(nvecs[2]).normalize();
	        nvecs[3] = nvecs[2].clone().add(nvecs[4]).normalize();
	        nvecs[5] = nvecs[4].clone().add(nvecs[6]).normalize();
	        nvecs[7] = nvecs[6].clone().add(nvecs[8]).normalize();
	        nvecs[9] = nvecs[8].clone().add(nvecs[10]).normalize();
	        nvecs[11] = nvecs[10].clone().add(nvecs[12]).normalize();
	        nvecs[13] = nvecs[12].clone().add(nvecs[14]).normalize();
	        nvecs[15] = nvecs[14].clone().add(nvecs[0]).normalize();

	        var start = geoGroup.vertices;
	        var vertexArray = geoGroup.vertexArray;
	        var colorArray = geoGroup.colorArray;
	        var faceArray = geoGroup.faceArray;
	        var normalArray = geoGroup.normalArray;
	        var lineArray = geoGroup.lineArray;

	        var offset, i, n;
	        // add vertices, opposing vertices paired together
	        for (i = 0, n = nvecs.length; i < n; ++i) {
	            offset = 3 * (start + 3 * i);
	            var bottom = nvecs[i].clone().multiplyScalar(radius).add(from);
	            var top = nvecs[i].clone().multiplyScalar(radius).add(to);
	            var conebase = nvecs[i].clone()
	                    .multiplyScalar(radius * radiusRatio).add(to);

	            vertexArray[offset] = bottom.x;
	            vertexArray[offset + 1] = bottom.y;
	            vertexArray[offset + 2] = bottom.z;

	            vertexArray[offset + 3] = top.x;
	            vertexArray[offset + 4] = top.y;
	            vertexArray[offset + 5] = top.z;

	            vertexArray[offset + 6] = conebase.x;
	            vertexArray[offset + 7] = conebase.y;
	            vertexArray[offset + 8] = conebase.z;

	            if (i > 0) {
	                var prev_x = vertexArray[offset - 3];
	                var prev_y = vertexArray[offset - 2];
	                var prev_z = vertexArray[offset - 1];

	                var c = new $3Dmol.Vector3(prev_x, prev_y, prev_z);
	                var b = end.clone(), b2 = to.clone();
	                var a = new $3Dmol.Vector3(conebase.x, conebase.y, conebase.z);

	                shape.intersectionShape.triangle.push(new $3Dmol.Triangle(a, b,
	                        c));
	                shape.intersectionShape.triangle.push(new $3Dmol.Triangle(c
	                        .clone(), b2, a.clone()));
	            }
	        }

	        geoGroup.vertices += 48;
	        offset = geoGroup.vertices * 3;

	        // caps
	        vertexArray[offset] = from.x;
	        vertexArray[offset + 1] = from.y;
	        vertexArray[offset + 2] = from.z;

	        vertexArray[offset + 3] = to.x;
	        vertexArray[offset + 4] = to.y;
	        vertexArray[offset + 5] = to.z;

	        vertexArray[offset + 6] = end.x;
	        vertexArray[offset + 7] = end.y;
	        vertexArray[offset + 8] = end.z;

	        geoGroup.vertices += 3;

	        // now faces
	        var face, norm, faceoffset, lineoffset;
	        var t1, t2, t2b, t3, t3b, t4, t1offset, t2offset, t2boffset, t3offset, t3boffset, t4offset;
	        var n1, n2, n3, n4;
	        var n_vertices = 0;
	        var fromi = geoGroup.vertices - 3, toi = geoGroup.vertices - 2, endi = geoGroup.vertices - 1;
	        var fromoffset = fromi * 3, tooffset = toi * 3, endoffset = endi * 3;
	        for (i = 0, n = nvecs.length - 1; i < n; ++i) {

	            var ti = start + 3 * i;
	            offset = ti * 3;
	            faceoffset = geoGroup.faceidx;
	            lineoffset = geoGroup.lineidx;

	            t1 = ti;
	            t1offset = t1 * 3;
	            t2 = ti + 1;
	            t2offset = t2 * 3;
	            t2b = ti + 2;
	            t2boffset = t2b * 3;
	            t3 = ti + 4;
	            t3offset = t3 * 3;
	            t3b = ti + 5;
	            t3boffset = t3b * 3;
	            t4 = ti + 3;
	            t4offset = t4 * 3;

	            // face = [t1, t2, t4], [t2, t3, t4];
	            // face = [t1, t2, t3, t4];

	            norm = [ nvecs[i], nvecs[i], nvecs[i + 1], nvecs[i + 1] ];

	            n1 = n2 = nvecs[i];
	            n3 = n4 = nvecs[i + 1];

	            normalArray[t1offset] = n1.x;
	            normalArray[t2offset] = n2.x;
	            normalArray[t4offset] = n4.x;
	            normalArray[t1offset + 1] = n1.y;
	            normalArray[t2offset + 1] = n2.y;
	            normalArray[t4offset + 1] = n4.y;
	            normalArray[t1offset + 2] = n1.z;
	            normalArray[t2offset + 2] = n2.z;
	            normalArray[t4offset + 2] = n4.z;

	            normalArray[t2offset] = n2.x;
	            normalArray[t3offset] = n3.x;
	            normalArray[t4offset] = n4.x;
	            normalArray[t2offset + 1] = n2.y;
	            normalArray[t3offset + 1] = n3.y;
	            normalArray[t4offset + 1] = n4.y;
	            normalArray[t2offset + 2] = n2.z;
	            normalArray[t3offset + 2] = n3.z;
	            normalArray[t4offset + 2] = n4.z;

	            normalArray[t2boffset] = n2.x;
	            normalArray[t3boffset] = n3.x;
	            normalArray[t2boffset + 1] = n2.y;
	            normalArray[t3boffset + 1] = n3.y;
	            normalArray[t2boffset + 2] = n2.z;
	            normalArray[t3boffset + 2] = n3.z;

	            // sides
	            faceArray[faceoffset] = t1;
	            faceArray[faceoffset + 1] = t2;
	            faceArray[faceoffset + 2] = t4;
	            faceArray[faceoffset + 3] = t2;
	            faceArray[faceoffset + 4] = t3;
	            faceArray[faceoffset + 5] = t4;
	            // caps
	            faceArray[faceoffset + 6] = t1;
	            faceArray[faceoffset + 7] = t4;
	            faceArray[faceoffset + 8] = fromi;
	            faceArray[faceoffset + 9] = t2b;
	            faceArray[faceoffset + 10] = toi;
	            faceArray[faceoffset + 11] = t3b;
	            // arrowhead
	            faceArray[faceoffset + 12] = t2b;
	            faceArray[faceoffset + 13] = endi;
	            faceArray[faceoffset + 14] = t3b;

	            // sides
	            lineArray[lineoffset] = t1;
	            lineArray[lineoffset + 1] = t2;
	            lineArray[lineoffset + 2] = t1;
	            lineArray[lineoffset + 3] = t4;
	            // lineArray[lineoffset+4] = t2, lineArray[lineoffset+5] = t3;
	            lineArray[lineoffset + 4] = t3;
	            lineArray[lineoffset + 5] = t4;
	            // caps
	            lineArray[lineoffset + 6] = t1;
	            lineArray[lineoffset + 7] = t4;
	            // lineArray[lineoffset+10] = t1, lineArray[lineoffset+11] = fromi;
	            // lineArray[lineoffset+12] = t4, lineArray[lineoffset+13] = fromi;

	            lineArray[lineoffset + 8] = t2b;
	            lineArray[lineoffset + 9] = t2; // toi
	            lineArray[lineoffset + 10] = t2b;
	            lineArray[lineoffset + 11] = t3b;
	            lineArray[lineoffset + 12] = t3;
	            lineArray[lineoffset + 13] = t3b; // toi
	            // arrowhead
	            lineArray[lineoffset + 14] = t2b;
	            lineArray[lineoffset + 15] = endi;
	            lineArray[lineoffset + 16] = t2b;
	            lineArray[lineoffset + 17] = t3b;
	            lineArray[lineoffset + 18] = endi;
	            lineArray[lineoffset + 19] = t3b;

	            geoGroup.faceidx += 15;
	            geoGroup.lineidx += 20;

	        }
	        // final face

	        face = [ start + 45, start + 46, start + 1, start, start + 47,
	                start + 2 ];
	        norm = [ nvecs[15], nvecs[15], nvecs[0], nvecs[0] ];

	        faceoffset = geoGroup.faceidx;
	        lineoffset = geoGroup.lineidx;

	        t1 = face[0];
	        t1offset = t1 * 3;
	        t2 = face[1];
	        t2offset = t2 * 3;
	        t2b = face[4];
	        t2boffset = t2b * 3;
	        t3 = face[2];
	        t3offset = t3 * 3;
	        t3b = face[5];
	        t3boffset = t3b * 3;
	        t4 = face[3];
	        t4offset = t4 * 3;

	        n1 = n2 = nvecs[15];
	        n3 = n4 = nvecs[0];

	        normalArray[t1offset] = n1.x;
	        normalArray[t2offset] = n2.x;
	        normalArray[t4offset] = n4.x;
	        normalArray[t1offset + 1] = n1.y;
	        normalArray[t2offset + 1] = n2.y;
	        normalArray[t4offset + 1] = n4.y;
	        normalArray[t1offset + 2] = n1.z;
	        normalArray[t2offset + 2] = n2.z;
	        normalArray[t4offset + 2] = n4.z;

	        normalArray[t2offset] = n2.x;
	        normalArray[t3offset] = n3.x;
	        normalArray[t4offset] = n4.x;
	        normalArray[t2offset + 1] = n2.y;
	        normalArray[t3offset + 1] = n3.y;
	        normalArray[t4offset + 1] = n4.y;
	        normalArray[t2offset + 2] = n2.z;
	        normalArray[t3offset + 2] = n3.z;
	        normalArray[t4offset + 2] = n4.z;

	        normalArray[t2boffset] = n2.x;
	        normalArray[t3boffset] = n3.x;
	        normalArray[t2boffset + 1] = n2.y;
	        normalArray[t3boffset + 1] = n3.y;
	        normalArray[t2boffset + 2] = n2.z;
	        normalArray[t3boffset + 2] = n3.z;

	        // Cap normals
	        dir.normalize();
	        negDir.normalize();
	        normalArray[fromoffset] = negDir.x;
	        normalArray[tooffset] = normalArray[endoffset] = dir.x;
	        normalArray[fromoffset + 1] = negDir.y;
	        normalArray[tooffset + 1] = normalArray[endoffset + 1] = dir.y;
	        normalArray[fromoffset + 2] = negDir.z;
	        normalArray[tooffset + 2] = normalArray[endoffset + 2] = dir.z;

	        // Final side
	        faceArray[faceoffset] = t1;
	        faceArray[faceoffset + 1] = t2;
	        faceArray[faceoffset + 2] = t4;
	        faceArray[faceoffset + 3] = t2;
	        faceArray[faceoffset + 4] = t3;
	        faceArray[faceoffset + 5] = t4;
	        // final caps
	        faceArray[faceoffset + 6] = t1;
	        faceArray[faceoffset + 7] = t4;
	        faceArray[faceoffset + 8] = fromi;
	        faceArray[faceoffset + 9] = t2b;
	        faceArray[faceoffset + 10] = toi;
	        faceArray[faceoffset + 11] = t3b;
	        // final arrowhead
	        faceArray[faceoffset + 12] = t2b;
	        faceArray[faceoffset + 13] = endi;
	        faceArray[faceoffset + 14] = t3b;

	        // sides
	        lineArray[lineoffset] = t1;
	        lineArray[lineoffset + 1] = t2;
	        lineArray[lineoffset + 2] = t1;
	        lineArray[lineoffset + 3] = t4;
	        // lineArray[lineoffset+4] = t2, lineArray[lineoffset+5] = t3;
	        lineArray[lineoffset + 4] = t3;
	        lineArray[lineoffset + 5] = t4;
	        // caps
	        lineArray[lineoffset + 6] = t1;
	        lineArray[lineoffset + 7] = t4;
	        // lineArray[lineoffset+10] = t1, lineArray[lineoffset+11] = fromi;
	        // lineArray[lineoffset+12] = t4, lineArray[lineoffset+13] = fromi;

	        lineArray[lineoffset + 8] = t2b;
	        lineArray[lineoffset + 9] = t2; // toi
	        lineArray[lineoffset + 10] = t2b;
	        lineArray[lineoffset + 11] = t3b;
	        lineArray[lineoffset + 12] = t3;
	        lineArray[lineoffset + 13] = t3b; // toi
	        // arrowhead
	        lineArray[lineoffset + 14] = t2b;
	        lineArray[lineoffset + 15] = endi;
	        lineArray[lineoffset + 16] = t2b;
	        lineArray[lineoffset + 17] = t3b;
	        lineArray[lineoffset + 18] = endi;
	        lineArray[lineoffset + 19] = t3b;

	        geoGroup.faceidx += 15;
	        geoGroup.lineidx += 20;

	    };

	    //helper function for adding an appropriately sized mesh
	    var addCustomGeo = function(shape, geo, mesh, color, clickable) {
	        var geoGroup = geo.addGeoGroup();
	        var vertexArr = mesh.vertexArr, normalArr = mesh.normalArr, 
	            faceArr = mesh.faceArr;

	        geoGroup.vertices = vertexArr.length;
	        geoGroup.faceidx = faceArr.length;

	        var offset, v, a, b, c, i, il;
	        var vertexArray = geoGroup.vertexArray;
	        var colorArray = geoGroup.colorArray;
	        
	        if(! (color.constructor === Array)) {
	            var r = color.r;
	            var g = color.g;
	            var b = color.b;
	        }
	        for (i = 0, il = geoGroup.vertices; i < il; ++i) {
	            offset = i * 3;
	            v = vertexArr[i];
	            vertexArray[offset] = v.x;
	            vertexArray[offset + 1] = v.y;
	            vertexArray[offset + 2] = v.z;
	            
	            if( color.constructor === Array) {
	                var c = color[i];
	                var r = c.r;
	                var g = c.g;
	                var b = c.b;
	            }
	            
	            colorArray[offset] = r;
	            colorArray[offset + 1] = g;
	            colorArray[offset + 2] = b;
	        }
	        
	        if(clickable) {
	            for (i = 0, il = geoGroup.faceidx / 3; i < il; ++i) {
	                offset = i * 3;
	                a = faceArr[offset];
	                b = faceArr[offset + 1];
	                c = faceArr[offset + 2];
	                var vA = new $3Dmol.Vector3(), vB = new $3Dmol.Vector3(), vC = new $3Dmol.Vector3();
	                shape.intersectionShape.triangle.push(new $3Dmol.Triangle(vA
	                        .copy(vertexArr[a]), vB.copy(vertexArr[b]), vC
	                        .copy(vertexArr[c])));
	            }
	        }
	        
	        if(clickable) {
	            
	            var center = new $3Dmol.Vector3(0,0,0);
	            var cnt = 0;
	            for(var g = 0; g < geo.geometryGroups.length; g++) {
	                center.add(geo.geometryGroups[g].getCentroid());
	                cnt++;
	            }
	            center.divideScalar(cnt);
	            
	            
	            updateBoundingFromPoints(shape.boundingSphere, {centroid: center}, vertexArray);
	        }

	        geoGroup.faceArray = new Uint16Array(faceArr);

	        geoGroup.truncateArrayBuffers(true, true);

	        if (normalArr.length < geoGroup.vertices)
	            geoGroup.setNormals();
	        else {

	            var normalArray = geoGroup.normalArray = new Float32Array(geoGroup.vertices * 3);
	            var n;
	            for (i = 0, il = geoGroup.vertices; i < il; ++i) {
	                offset = i * 3;
	                n = normalArr[i];
	                normalArray[offset] = n.x;
	                normalArray[offset + 1] = n.y;
	                normalArray[offset + 2] = n.z;
	            }
	        }
	        
	        geoGroup.setLineIndices();
	        geoGroup.lineidx = geoGroup.lineArray.length;
	    };
	    

	    
	    // handles custom shape generation from user supplied arrays
	    // May need to generate normal and/or line indices
	    /**
	     * @param {$3Dmol.GLShape}
	     *            shape
	     * @param {geometry}
	     *            geo
	     * @param {CustomSpec}
	     *            customSpec
	     */
	    var drawCustom = function(shape, geo, customSpec) {
	        var mesh = customSpec;
	        var vertexArr = mesh.vertexArr, normalArr = mesh.normalArr, 
	        faceArr = mesh.faceArr;
	        if (vertexArr.length === 0 || faceArr.length === 0) {
	            console
	                    .warn("Error adding custom shape component: No vertices and/or face indices supplied!");
	        }

	        var color = customSpec.color;
	        if(typeof(color) == 'undefined') {
	            color = shape.color;
	        }
	        color =  $3Dmol.CC.color(color);

	        //var firstgeo = geo.geometryGroups.length;
	        var splits = $3Dmol.splitMesh(mesh);
	        for(var i = 0, n = splits.length; i < n; i++) {
	            addCustomGeo(shape, geo, splits[i], splits[i].colorArr ? splits[i].colorArr : color, customSpec.clickable);
	        } 
	    }; 

	    // Update a bounding sphere's position and radius
	    // from list of centroids and new points
	    /**
	     * @param {$3Dmol.Sphere}
	     *            sphere
	     * @param {Object}
	     *            components
	     * @param {Array}
	     *            points
	     */
	    var updateBoundingFromPoints = function(sphere, components, points) {

	        sphere.center.set(0, 0, 0);

	        var i, il;

	        if (components.length > 0) {

	            for (i = 0, il = components.length; i < il; ++i) {
	                var centroid = components[i].centroid;
	                sphere.center.add(centroid);
	            }

	            sphere.center.divideScalar(components.length);
	        }

	        var maxRadiusSq = sphere.radius * sphere.radius;

	        for (i = 0, il = points.length / 3; i < il; i++) {
	            var x = points[i * 3], y = points[i * 3 + 1], z = points[i * 3 + 2];
	            var radiusSq = sphere.center.distanceToSquared({
	                x : x,
	                y : y,
	                z : z
	            });
	            maxRadiusSq = Math.max(maxRadiusSq, radiusSq);
	        }

	        sphere.radius = Math.sqrt(maxRadiusSq);

	    };

	    /**
	     * 
	     * @param {$3Dmol.GLShape}
	     *            shape
	     * @param {ShapeSpec}
	     *            stylespec
	     * @returns {undefined}
	     */
	    var updateFromStyle = function(shape, stylespec) {
	        if(typeof(stylespec.color) != 'undefined') {
	            shape.color = stylespec.color || new $3Dmol.Color();
	            if(! (stylespec.color instanceof $3Dmol.Color))
	                shape.color = $3Dmol.CC.color(stylespec.color);
	        }
	        shape.wireframe = stylespec.wireframe ? true : false;
	        //opacity is the preferred nomenclature, support alpha for backwards compat
	        shape.opacity = stylespec.alpha ? $3Dmol.Math.clamp(stylespec.alpha, 0.0,
	                1.0) : 1.0;
	        if(typeof(stylespec.opacity) != 'undefined') {
	            shape.opacity = $3Dmol.Math.clamp(stylespec.opacity, 0.0, 1.0);
	        }
	        shape.side = (stylespec.side !== undefined) ? stylespec.side
	                : $3Dmol.DoubleSide;

	        shape.linewidth = typeof(stylespec.linewidth) == 'undefined' ? 1 : stylespec.linewidth;
	        // Click handling
	        shape.clickable = stylespec.clickable ? true : false;
	        shape.callback = typeof (stylespec.callback) === "function" ? stylespec.callback
	                : null;
	        shape.hidden = stylespec.hidden;
	    };

	    /**
	     * Custom renderable shape
	     * 
	     * @constructor $3Dmol.GLShape
	     * 
	     * @param {Object}
	     *            stylespec
	     * @returns {$3Dmol.GLShape}
	     */
	    function GLShape(stylespec) {

	        stylespec = stylespec || {};
	        $3Dmol.ShapeIDCount++;

	        this.boundingSphere = new $3Dmol.Sphere();
	        /** @type {IntersectionShapes} */
	        this.intersectionShape = {
	            sphere : [],
	            cylinder : [],
	            line : [],
	            triangle : []
	        };

	        updateFromStyle(this, stylespec);

	        // Keep track of shape components and their centroids
	        var components = [];
	        var shapeObj = null;
	        var renderedShapeObj = null;

	        var geo = new $3Dmol.Geometry(true);
	        var linegeo = new $3Dmol.Geometry(true);

	        /** Update shape with new style specification
	         * @param {ShapeSpec} newspec
	         * @return {$3Dmol.GLShape}
	         */
	        this.updateStyle = function(newspec) {

	            for ( var prop in newspec) {
	                stylespec[prop] = newspec[prop];
	            }

	            updateFromStyle(this, stylespec);
	        };

	        /**
	         * Creates a custom shape from supplied vertex and face arrays
	         * @function $3Dmol.GLShape#addCustom
	         * @param {CustomSpec} customSpec
	         * @return {$3Dmol.GLShape}
	         */
	        this.addCustom = function(customSpec) {

	            customSpec.vertexArr = customSpec.vertexArr || [];
	            customSpec.faceArr = customSpec.faceArr || [];
	            customSpec.normalArr = customSpec.normalArr || [];

	            var firstgeo = geo.geometryGroups.length;
	            // will split mesh as needed
	            drawCustom(this, geo, customSpec);
	        };

	        /**
	         * Creates a sphere shape
	         * @function $3Dmol.GLShape#addSphere
	         * @param {SphereSpec} sphereSpec
	         * @return {$3Dmol.GLShape}
	         */
	        this.addSphere = function(sphereSpec) {

	            sphereSpec.center = sphereSpec.center || {
	                x : 0,
	                y : 0,
	                z : 0
	            };
	            sphereSpec.radius = sphereSpec.radius ? $3Dmol.Math.clamp(
	                    sphereSpec.radius, 0, Infinity) : 1.5;
	            sphereSpec.color = $3Dmol.CC.color(sphereSpec.color);
	            
	            this.intersectionShape.sphere.push(new $3Dmol.Sphere(
	                    sphereSpec.center, sphereSpec.radius));

	            $3Dmol.GLDraw.drawSphere(geo, sphereSpec.center,
	                    sphereSpec.radius, sphereSpec.color);

	            components.push({
	                centroid : new $3Dmol.Vector3(sphereSpec.center.x,
	                        sphereSpec.center.y, sphereSpec.center.z)
	            });
	            var geoGroup = geo.updateGeoGroup(0);
	            
	            updateBoundingFromPoints(this.boundingSphere, components,
	                    geoGroup.vertexArray);
	        };

	        /**
	         * Creates a cylinder shape
	         * @function $3Dmol.GLShape#addCylinder
	         * @param {CylinderSpec} cylinderSpec
	         * @return {$3Dmol.GLShape}
	         */
	        this.addCylinder = function(cylinderSpec) {

	            cylinderSpec.start = cylinderSpec.start || {};
	            cylinderSpec.end = cylinderSpec.end || {};

	            var start = new $3Dmol.Vector3(cylinderSpec.start.x || 0,
	                    cylinderSpec.start.y || 0, cylinderSpec.start.z || 0);
	            var end = new $3Dmol.Vector3(cylinderSpec.end.x,
	                    cylinderSpec.end.y || 0, cylinderSpec.end.z || 0);
	        	if(typeof(end.x) == 'undefined') end.x = 3; //show something even if undefined

	            var radius = cylinderSpec.radius || 0.1;
	            var color = $3Dmol.CC.color(cylinderSpec.color);
	            
	            this.intersectionShape.cylinder.push(new $3Dmol.Cylinder(start, end, radius));

	            $3Dmol.GLDraw.drawCylinder(geo, start, end, radius, color, cylinderSpec.fromCap, cylinderSpec.toCap);            
	            
	            var centroid = new $3Dmol.Vector3();
	            components.push({
	                centroid : centroid.addVectors(start,end).multiplyScalar(0.5)
	            });
	            var geoGroup = geo.updateGeoGroup(0);
	            updateBoundingFromPoints(this.boundingSphere, components,
	                    geoGroup.vertexArray);

	        };

	        /**
	         * Creates a line shape
	         * @function $3Dmol.GLShape#addLine         
	         * @param {LineSpec} lineSpec
	         * @return {$3Dmol.GLShape}
	         */
	        this.addLine = function(lineSpec) {
	            lineSpec.start = lineSpec.start || {};
	            lineSpec.end = lineSpec.end || {};

	            var start = new $3Dmol.Vector3(lineSpec.start.x || 0,
	                    lineSpec.start.y || 0, lineSpec.start.z || 0);
	            var end = new $3Dmol.Vector3(lineSpec.end.x,
	                    lineSpec.end.y || 0, lineSpec.end.z || 0);            
	            if(typeof(end.x) == 'undefined') end.x = 3; //show something even if undefined

	            var geoGroup = geo.updateGeoGroup(2);

	            //make line from start to end
	            //for consistency with rest of shapes, uses vertices and lines rather
	            //than a separate line geometry
	            var vstart = geoGroup.vertices;
	            var i = vstart*3;
	            var vertexArray = geoGroup.vertexArray;
	            vertexArray[i] = start.x;
	            vertexArray[i+1] = start.y;
	            vertexArray[i+2] = start.z;
	            vertexArray[i+3] = end.x;
	            vertexArray[i+4] = end.y;
	            vertexArray[i+5] = end.z;
	            geoGroup.vertices += 2;
	            
	            var lineArray = geoGroup.lineArray;
	            var li =  geoGroup.lineidx;
	            lineArray[li] = vstart;
	            lineArray[li+1] = vstart+1;
	            geoGroup.lineidx += 2;
	            
	        }
	        /**
	         * Creates an arrow shape
	         * @function $3Dmol.GLShape#addArrow        
	         * @param {ArrowSpec} arrowSpec
	         * @return {$3Dmol.GLShape}
	         */
	        this.addArrow = function(arrowSpec) {

	            arrowSpec.start = arrowSpec.start || {};
	            arrowSpec.end = arrowSpec.end || {};

	            arrowSpec.start = new $3Dmol.Vector3(arrowSpec.start.x || 0,
	                    arrowSpec.start.y || 0, arrowSpec.start.z || 0);

	            if (arrowSpec.dir instanceof $3Dmol.Vector3
	                    && arrowSpec.length instanceof number) {
	                var end = arrowSpec.dir.clone().multiplyScalar(arrowSpec.length).add(
	                        start);
	                arrowSpec.end = end;
	            }

	            else {
	                arrowSpec.end = new $3Dmol.Vector3(arrowSpec.end.x,
	                        arrowSpec.end.y || 0, arrowSpec.end.z || 0);
	            	if(typeof(arrowSpec.end.x) == 'undefined') arrowSpec.end.x = 3; //show something even if undefined
	            }

	            arrowSpec.radius = arrowSpec.radius || 0.1;

	            arrowSpec.radiusRatio = arrowSpec.radiusRatio || 1.618034;
	            arrowSpec.mid = (0 < arrowSpec.mid && arrowSpec.mid < 1) ? arrowSpec.mid
	                    : 0.618034;


	            drawArrow(this, geo, arrowSpec);

	            var centroid = new $3Dmol.Vector3();
	            components.push({
	                centroid : centroid.addVectors(arrowSpec.start, arrowSpec.end)
	                        .multiplyScalar(0.5)
	            });
	            var geoGroup = geo.updateGeoGroup(0);
	            updateBoundingFromPoints(this.boundingSphere, components,
	                    geoGroup.vertexArray);

	        };
	        
	        /**
	         * Create isosurface from voluemetric data.
	         * @function $3Dmol.GLShape#addIsosurface         
	         * @param {$3Dmol.VolumeData} data - volumetric input data
	         * @param {IsoSurfaceSpec} isoSpec - volumetric data shape specification
	         */
	        this.addIsosurface = function(data, volSpec) {
	            var isoval = (volSpec.isoval !== undefined && typeof (volSpec.isoval) === "number") ? volSpec.isoval
	                    : 0.0;
	            var voxel = (volSpec.voxel) ? true : false;
	            var smoothness = (volSpec.smoothness === undefined) ? 1 : volSpec.smoothness;

	            var nX = data.size.x;
	            var nY = data.size.y;
	            var nZ = data.size.z;
	            var vertnums = new Int16Array(nX * nY * nZ);
	            var vals = data.data;
	            var i, il;

	            for (i = 0, il = vertnums.length; i < il; ++i)
	                vertnums[i] = -1;

	            //mark locations partitioned by isoval
	            var bitdata = new Uint8Array(nX * nY * nZ);

	            for (i = 0, il = vals.length; i < il; ++i) {
	                var val = (isoval >= 0) ? vals[i] - isoval : isoval - vals[i];

	                if (val > 0)
	                    bitdata[i] |= ISDONE;

	            }

	            var verts = [], faces = [];

	            $3Dmol.MarchingCube.march(bitdata, verts, faces, {
	                fulltable : true,
	                voxel : voxel,
	                unitCube : data.unit,
	                origin : data.origin,
	                matrix: data.matrix,
	                nX : nX,
	                nY : nY,
	                nZ : nZ
	            });

	            if (!voxel && smoothness > 0)
	                $3Dmol.MarchingCube.laplacianSmooth(smoothness, verts, faces);

	            drawCustom(this, geo, {
	                vertexArr : verts,
	                faceArr : faces,
	                normalArr : [],
	                clickable : volSpec.clickable
	            });
	           
	            this.updateStyle(volSpec);
	            
	            //computing bounding sphere from vertices
	            var origin = new $3Dmol.Vector3(data.origin.x, data.origin.y, data.origin.z);
	            var size = new $3Dmol.Vector3(data.size.x*data.unit.x, data.size.y*data.unit.y, data.size.z*data.unit.z);            

	            var total = new $3Dmol.Vector3(0,0,0);
	            var maxv = origin.clone();
	            var minv = origin.clone().add(size);
	            for(var i = 0; i < verts.length; i++) {
	                total.add(verts[i]);
	                maxv.max(verts[i]);
	                minv.min(verts[i]);
	            }
	            total.divideScalar(verts.length);
	            var len1 = total.distanceTo(minv);
	            var len2 = total.distanceTo(maxv);
	            this.boundingSphere.center = total;
	            this.boundingSphere.radius = Math.max(len1,len2);
	           
	        };
	        
	        /** 
	         * @deprecated Use addIsosurface instead
	         * Creates custom shape from volumetric data 
	         * @param {string} data - Volumetric input data 
	         * @param {string} fmt - Input data format (e.g. 'cube' for cube file format)
	         * @param {IsoSurfaceSpec} isoSpec - Volumetric data shape specification
	         * @return {$3Dmol.GLShape}
	         */
	        this.addVolumetricData = function(data, fmt, volSpec) {
	            var data = new $3Dmol.VolumeData(data, fmt);
	            this.addIsosurface(data, volSpec);
	        };

	        /**
	         * Initialize webgl objects for rendering
	         * @param {$3Dmol.Object3D} group
	         * 
	         */  
	        this.globj = function(group) {

	            if (renderedShapeObj) {
	                group.remove(renderedShapeObj);
	                renderedShapeObj = null;
	            }
	            
	            if(this.hidden)
	                return;
	            finalizeGeo(geo);
	            geo.initTypedArrays();

	            if(typeof(this.color) != 'undefined')
	                updateColor(geo, this.color);

	            shapeObj = new $3Dmol.Object3D();
	            var material = null;
	            if(this.side == $3Dmol.DoubleSide) {
	                var material = new $3Dmol.MeshDoubleLambertMaterial({
	                    wireframe : this.wireframe,
	                    side : this.side,
	                    transparent : (this.opacity < 1) ? true : false,
	                    opacity : this.opacity,
	                    wireframeLinewidth: this.linewidth
	                });
	            } else {
	                var material = new $3Dmol.MeshLambertMaterial({
	                    wireframe : this.wireframe,
	                    side : this.side,
	                    transparent : (this.opacity < 1) ? true : false,
	                    opacity : this.opacity,
	                    wireframeLinewidth: this.linewidth
	                });
	            }
	            
	            var mesh = new $3Dmol.Mesh(geo, material);

	            shapeObj.add(mesh);
	            
	            var lineMaterial = new $3Dmol.LineBasicMaterial({
	                linewidth : this.linewidth,
	                color: this.color
	            });
	            var line = new $3Dmol.Line(linegeo, lineMaterial,
	                    $3Dmol.LinePieces);
	            shapeObj.add(line);

	            renderedShapeObj = shapeObj.clone();
	            group.add(renderedShapeObj);

	        };

	        this.removegl = function(group) {
	            if (renderedShapeObj) {
	                // dispose of geos and materials
	                if (renderedShapeObj.geometry !== undefined)
	                    renderedShapeObj.geometry.dispose();
	                if (renderedShapeObj.material !== undefined)
	                    renderedShapeObj.material.dispose();
	                group.remove(renderedShapeObj);
	                renderedShapeObj = null;
	            }
	            shapeObj = null;
	        };

	    };

	    Object.defineProperty(GLShape.prototype, "position", {

	        get : function() {
	            return this.boundingSphere.center;
	        }

	    });

	    Object.defineProperty(GLShape.prototype, "x", {

	        get : function() {
	            return this.boundingSphere.center.x;
	        }

	    });

	    Object.defineProperty(GLShape.prototype, "y", {

	        get : function() {
	            return this.boundingSphere.center.y;
	        }

	    });

	    Object.defineProperty(GLShape.prototype, "z", {

	        get : function() {
	            return this.boundingSphere.center.z;
	        }

	    });

	    return GLShape;

	}());

	$3Dmol.ShapeIDCount = 0;


	$3Dmol.splitMesh = function(mesh) {
		    var MAXVERT = 64000; //webgl only supports 2^16 elements, leave a little breathing room (require at least 2)
	    //peel off 64k vertices rsvh into their own mesh
	    //duplicating vertices and normals as necessary to preserve faces and lines
		
	        if(mesh.vertexArr.length < MAXVERT) return [mesh]; //typical case
	        
	        var nverts = mesh.vertexArr.length;
	        var slices = [{vertexArr: [], normalArr: [], faceArr: []}];
	        if(mesh.colorArr) slices.colorArr = [];
	        var vertSlice = []; //indexed by original vertex to get current slice
	        var vertIndex =[]; //indexed by original vertex to get index within slice
	        var currentSlice = 0;
	        
	        //for each face, make sure all three vertices (or copies) are in the same slice
	        var faces = mesh.faceArr;
	        var vs = [0,0,0];
	        for(var i = 0, nf = faces.length; i < nf; i += 3) {
	            var slice = slices[currentSlice];
	            for(var j = 0; j < 3; j++) {
	                //process each vertex to make sure it is assigned a slice
	                //all vertices of a face must belong to the same slice
	                var v = faces[i+j];
	                if(vertSlice[v] !== currentSlice) { //true if undefined
	                    vertSlice[v] = currentSlice;
	                    vertIndex[v] = slice.vertexArr.length;
	                    slice.vertexArr.push(mesh.vertexArr[v]);
	                    if(mesh.normalArr && mesh.normalArr[v]) slice.normalArr.push(mesh.normalArr[v]);
	                    if(mesh.colorArr && mesh.colorArr[v]) slice.colorArr.push(mesh.colorArr[v]);
	                }
	                slice.faceArr.push(vertIndex[v]);
	            }
	            
	            if(slice.vertexArr.length >= MAXVERT) {
	                //new slice
	                slices.push({vertexArr: [], normalArr: [], faceArr: []});
	                if(mesh.colorArr) slices.colorArr = [];
	                currentSlice++;
	            }
	        }
	        return slices;
	    }
	//a molecular viewer based on GLMol



	/**
	 * WebGL-based 3Dmol.js viewer
	 * Note: The preferred method of instantiating a GLViewer is through {@link $3Dmol.createViewer} 
	 * 
	 * @constructor 
	 * @param {Object} element HTML element within which to create viewer
	 * @param {function} callback - Callback function to be immediately executed on this viewer
	 * @param {Object} defaultcolors - Object defining default atom colors as atom => color property value pairs for all models within this viewer
	 */
	$3Dmol.GLViewer = (function() {
	    // private class variables
	    var numWorkers = 4; // number of threads for surface generation
	    var maxVolume = 64000; // how much to break up surface calculations

	    // private class helper functions

	    function GLViewer(element, config) { 
	        // set variables
	        config = config || {};
	        var callback = config.callback;
	        var defaultcolors = config.defaultcolors;    	
	        if(!defaultcolors)
	            defaultcolors = $3Dmol.elementColors.defaultColors;
	        var nomouse = config.nomouse;
	        var bgColor = 0;

	        if(typeof(config.backgroundColor) != undefined) {
	            bgColor = $3Dmol.CC.color(config.backgroundColor).getHex();
	        }

	        var camerax = 0;
	        if(typeof(config.camerax) != undefined) {
	            camerax = parseFloat(config.camerax);
	        }
	        var _viewer = this;
	        var container = element;
	        var id = container.id;
	        var glDOM = null;

	        var models = []; // atomistic molecular models
	        var surfaces = {};
	        var shapes = []; // Generic shapes
	        var labels = [];
	        var clickables = []; //things you can click on
	        
	        var WIDTH = container.width();
	        var HEIGHT = container.height();

	        // set dimensions
	        // $(container).width(WIDTH);
	        // $(container).height(HEIGHT);

	        var ASPECT = WIDTH / HEIGHT;
	        var NEAR = 1, FAR = 800;
	        var CAMERA_Z = 150;
	        var fov = 20;

	        var linkedViewers = [];

	        var renderer = new $3Dmol.Renderer({
	            antialias : true,
	            preserveDrawingBuffer: true, //so we can export images
	            premultipliedAlpha : false/* more traditional compositing with background */
	        });

	        renderer.domElement.style.width = "100%";
	        renderer.domElement.style.height = "100%";
	        renderer.domElement.style.padding = "0";
	        renderer.domElement.style.position = "absolute"; //TODO: get rid of this
	        renderer.domElement.style.top = "0px";
	        renderer.domElement.style.left = "0px";
	        renderer.domElement.style.zIndex = "0";

	        var camera = new $3Dmol.Camera(fov, ASPECT, NEAR, FAR, config.orthographic);
	        camera.position = new $3Dmol.Vector3(camerax, 0, CAMERA_Z);
	        var lookingAt = new $3Dmol.Vector3();
	        camera.lookAt(lookingAt);

	        var raycaster = new $3Dmol.Raycaster(new $3Dmol.Vector3(0, 0, 0),
	                new $3Dmol.Vector3(0, 0, 0));
	        var projector = new $3Dmol.Projector();
	        var mouseVector = new $3Dmol.Vector3(0, 0, 0);

	        var scene = null;
	        var rotationGroup = null; // which contains modelGroup
	        var modelGroup = null;

	        var fogStart = 0.4;
	        var slabNear = -50; // relative to the center of rotationGroup
	        var slabFar = 50;

	        // UI variables
	        var cq = new $3Dmol.Quaternion(0, 0, 0, 1);
	        var dq = new $3Dmol.Quaternion(0, 0, 0, 1);
	        var animated = false;
	        var isDragging = false;
	        var mouseStartX = 0;
	        var mouseStartY = 0;
	        var touchDistanceStart = 0;
	        var currentModelPos = 0;
	        var cz = 0;
	        var cslabNear = 0;
	        var cslabFar = 0;      
	        
	        var nextSurfID = function() {
	            //compute the next highest surface id directly from surfaces
	            //this is necessary to support linking of model data
	            var max = 0;
	            for (i in surfaces) { // this is an object with possible holes
	                if(!surfaces.hasOwnProperty(i)) continue;
	                if(i > max) max = i;
	            }
	            return max+1;
	        };

	        var setSlabAndFog = function() {
	            var center = camera.position.z - rotationGroup.position.z;
	            if (center < 1)
	                center = 1;
	            camera.near = center + slabNear;
	            if (camera.near < 1)
	                camera.near = 1;
	            camera.far = center + slabFar;
	            if (camera.near + 1 > camera.far)
	                camera.far = camera.near + 1;

	            camera.fov = fov;
	            camera.right = center * Math.tan(Math.PI / 180 * fov);
	            camera.left = -camera.right;
	            camera.top = camera.right / ASPECT;
	            camera.bottom = -camera.top;
	            
	            camera.updateProjectionMatrix();
	            scene.fog.near = camera.near + fogStart
	                    * (camera.far - camera.near);
	            // if (scene.fog.near > center) scene.fog.near = center;
	            scene.fog.far = camera.far;
	        };

	        // display scene
	        //if nolink is set/true, don't propagate changes to linked viewers
	        var show = function(nolink) {
	            if (!scene)
	                return;

	            // var time = new Date();
	            setSlabAndFog();
	            renderer.render(scene, camera);
	            // console.log("rendered in " + (+new Date() - time) + "ms");
	            
	            if(!nolink && linkedViewers.length > 0) {
	                var view = _viewer.getView();
	                for(var i = 0; i < linkedViewers.length; i++) {
	                    var other = linkedViewers[i];
	                    other.setView(view, true);
	                }
	            }
	        };

	        var initializeScene = function() {

	            scene = new $3Dmol.Scene();
	            scene.fog = new $3Dmol.Fog(bgColor, 100, 200);

	            modelGroup = new $3Dmol.Object3D();
	            rotationGroup = new $3Dmol.Object3D();
	            rotationGroup.useQuaternion = true;
	            rotationGroup.quaternion = new $3Dmol.Quaternion(0, 0, 0, 1);
	            rotationGroup.add(modelGroup);

	            scene.add(rotationGroup);

	            // setup lights
	            var directionalLight = new $3Dmol.Light(0xFFFFFF);
	            directionalLight.position = new $3Dmol.Vector3(0.2, 0.2, 1)
	                    .normalize();
	            directionalLight.intensity = 1.0;
	            scene.add(directionalLight);
	        };

	        initializeScene();

	        renderer.setClearColorHex(bgColor, 1.0);
	        scene.fog.color = $3Dmol.CC.color(bgColor);

	        var clickedAtom = null;

	        // enable mouse support

	        //regenerate the list of clickables
	        var updateClickables = function() {
	            clickables.splice(0,clickables.length);
	            var i, il;

	            for (i = 0, il = models.length; i < il; i++) {
	                var model = models[i];
	                if(model) {
	                    var atoms = model.selectedAtoms({
	                        clickable : true
	                    });
	                    Array.prototype.push.apply(clickables, atoms); //add atoms into clickables
	                }
	            }

	            for (i = 0, il = shapes.length; i < il; i++) {

	                var shape = shapes[i];
	                if (shape && shape.clickable) {
	                    clickables.push(shape);
	                }
	            }
	        };
	        
	        // Checks for selection intersects on mousedown
	        var handleClickSelection = function(mouseX, mouseY, event) {
	            if(clickables.length == 0) return;
	            var mouse = {
	                x : mouseX,
	                y : mouseY,
	                z : -1.0
	            };
	            mouseVector.set(mouse.x, mouse.y, mouse.z);
	            projector.unprojectVector(mouseVector, camera);
	            mouseVector.sub(camera.position).normalize();

	            raycaster.set(camera.position, mouseVector);

	            var intersects = [];

	            intersects = raycaster.intersectObjects(modelGroup, clickables);
	            if (intersects.length) {
	                var selected = intersects[0].clickable;
	                if (selected.callback !== undefined
	                        && typeof (selected.callback) === "function") {
	                    selected.callback(selected, _viewer, event, container);
	                }
	            }
	        };

	        var calcTouchDistance = function(ev) { // distance between first two
	                                                // fingers
	            var xdiff = ev.originalEvent.targetTouches[0].pageX
	                    - ev.originalEvent.targetTouches[1].pageX;
	            var ydiff = ev.originalEvent.targetTouches[0].pageY
	                    - ev.originalEvent.targetTouches[1].pageY;
	            return Math.sqrt(xdiff * xdiff + ydiff * ydiff);
	        }
	        
	        //check targetTouches as well
	        var getXY = function(ev) {
	            var x = ev.pageX, y = ev.pageY;
	            if (ev.originalEvent.targetTouches
	                    && ev.originalEvent.targetTouches[0]) {
	                x = ev.originalEvent.targetTouches[0].pageX;
	                y = ev.originalEvent.targetTouches[0].pageY;
	            }
	            else if (ev.originalEvent.changedTouches
	                    && ev.originalEvent.changedTouches[0]) {
	                x = ev.originalEvent.changedTouches[0].pageX;
	                y = ev.originalEvent.changedTouches[0].pageY;
	            }            
	            return [x,y];
	        };

	        //for a given screen (x,y) displacement return model displacement 
	        var screenXY2model = function(x,y) {
	            var dx = x/WIDTH;
	            var dy = y/HEIGHT;
	            var zpos = rotationGroup.position.z; 
	            var q = rotationGroup.quaternion;                        
	            var t = new $3Dmol.Vector3(0,0,zpos);
	            projector.projectVector(t, camera);
	            t.x += dx*2;
	            t.y -= dy*2;
	            projector.unprojectVector(t, camera);
	            t.z = 0;                            
	            t.applyQuaternion(q);
	            return t;
	        }

	        // this event is bound to the body element, not the container,
	        // so no need to put it inside initContainer()
	        $('body').bind('mouseup touchend', function(ev) {
	            // handle selection
	            if(isDragging && scene) { //saw mousedown, haven't moved
	                var xy = getXY(ev);
	                var x = xy[0];
	                var y = xy[1];
	                if(x == mouseStartX && y == mouseStartY) {
	                    var offset = $('canvas',container).offset();
	                    var mouseX = ((x - offset.left) / WIDTH) * 2 - 1;
	                    var mouseY = -((y - offset.top) / HEIGHT) * 2 + 1;

	                    handleClickSelection(mouseX, mouseY, ev, container);
	                }
	            }
	            
	            isDragging = false;

	        });
	        
	        var _handleMouseDown = this._handleMouseDown = function(ev) {
	            ev.preventDefault();
	            if (!scene)
	                return;
	            var xy = getXY(ev);
	            var x = xy[0];
	            var y = xy[1];
	            
	            if (x === undefined)
	                return;
	            isDragging = true;
	            clickedAtom = null;
	            mouseButton = ev.which;
	            mouseStartX = x;
	            mouseStartY = y;
	            touchDistanceStart = 0;
	            if (ev.originalEvent.targetTouches
	                    && ev.originalEvent.targetTouches.length == 2) {
	                touchDistanceStart = calcTouchDistance(ev);
	            }
	            cq = rotationGroup.quaternion;
	            cz = rotationGroup.position.z;
	            currentModelPos = modelGroup.position.clone();
	            cslabNear = slabNear;
	            cslabFar = slabFar;
	        };
	        
	        var _handleMouseScroll  = this._handleMouseScroll = function(ev) { // Zoom
	            ev.preventDefault();
	            if (!scene)
	                return;
	            var scaleFactor = (CAMERA_Z - rotationGroup.position.z) * 0.85;
	            var mult = 1.0;
	            if(ev.originalEvent.ctrlKey) {
	                mult = -1.0; //this is a pinch event turned into a wheel event (or they're just holding down the ctrl)
	            }
	            if (ev.originalEvent.detail) { // Webkit
	                rotationGroup.position.z += mult * scaleFactor
	                        * ev.originalEvent.detail / 10;
	            } else if (ev.originalEvent.wheelDelta) { // Firefox
	                rotationGroup.position.z -= mult * scaleFactor
	                        * ev.originalEvent.wheelDelta / 400;
	            }
	            if(rotationGroup.position.z > CAMERA_Z) rotationGroup.position.z = CAMERA_Z*0.999; //avoid getting stuck

	            show();
	        };
	        
	        var _handleMouseMove = this._handleMouseMove = function(ev) { // touchmove
	            WIDTH = container.width();
	            HEIGHT = container.height();
	            ev.preventDefault();
	            if (!scene)
	                return;
	            if (!isDragging)
	                return;
	            var mode = 0;

	            var xy = getXY(ev);
	            var x = xy[0];
	            var y = xy[1];
	            if (x === undefined)
	                return;
	            var dx = (x - mouseStartX) / WIDTH;
	            var dy = (y - mouseStartY) / HEIGHT;
	            // check for pinch
	            if (touchDistanceStart != 0
	                    && ev.originalEvent.targetTouches
	                    && ev.originalEvent.targetTouches.length == 2) {
	                var newdist = calcTouchDistance(ev);
	                // change to zoom
	                mode = 2;
	                dy = (newdist - touchDistanceStart) * 2
	                        / (WIDTH + HEIGHT);
	                console.log("pinch "+touchDistanceStart+" dy "+dy);
	            } else if (ev.originalEvent.targetTouches
	                    && ev.originalEvent.targetTouches.length == 3) {
	                // translate
	                mode = 1;
	            }

	            var r = Math.sqrt(dx * dx + dy * dy);
	            var scaleFactor;
	            if (mode == 3
	                    || (mouseButton == 3 && ev.ctrlKey)) { // Slab
	                slabNear = cslabNear + dx * 100;
	                slabFar = cslabFar + dy * 100;
	            } else if (mode == 2 || mouseButton == 3
	                    || ev.shiftKey) { // Zoom
	                scaleFactor = (CAMERA_Z - rotationGroup.position.z) * 0.85;
	                if (scaleFactor < 80)
	                    scaleFactor = 80;
	                rotationGroup.position.z = cz + dy * scaleFactor;
	                if(rotationGroup.position.z > CAMERA_Z) rotationGroup.position.z = CAMERA_Z*0.999; //avoid getting stuck
	            } else if (mode == 1 || mouseButton == 2
	                    || ev.ctrlKey) { // Translate
	                var t = screenXY2model(x-mouseStartX, y-mouseStartY);
	                modelGroup.position.addVectors(currentModelPos,t);
	                
	            } else if ((mode === 0 || mouseButton == 1)
	                    && r !== 0) { // Rotate
	                var rs = Math.sin(r * Math.PI) / r;
	                dq.x = Math.cos(r * Math.PI);
	                dq.y = 0;
	                dq.z = rs * dx;
	                dq.w = -rs * dy;
	                rotationGroup.quaternion = new $3Dmol.Quaternion(
	                        1, 0, 0, 0);
	                rotationGroup.quaternion.multiply(dq);
	                rotationGroup.quaternion.multiply(cq);
	            }
	            show();
	        };
	        
	        var initContainer = function(element) {
	            container = element;
	            WIDTH = container.width();
	            HEIGHT = container.height();
	            ASPECT = WIDTH / HEIGHT;
	            renderer.setSize(WIDTH, HEIGHT);
	            container.append(renderer.domElement);
	            glDOM = $(renderer.domElement);

	            if (!nomouse) {
	                // user can request that the mouse handlers not be installed
	                glDOM.bind('mousedown touchstart', _handleMouseDown);
	                glDOM.bind('DOMMouseScroll mousewheel', _handleMouseScroll);
	                glDOM.bind('mousemove touchmove', _handleMouseMove);
	                
	                glDOM.bind("contextmenu", function(ev) {
	                    ev.preventDefault();
	                });
	            }
	        };
	        initContainer(container);

	        // public methods
	        /**
	         * Change the viewer's container element 
	         * Also useful if the original container element was removed from the DOM.
	         * 
	         * @function $3Dmol.GLViewer#resetContainer
	         *
	         * @param {Object | string} element
	         *            Either HTML element or string identifier. Defaults to the element used to initialize the viewer.

	         * @example
	         * // Assume there exist HTML divs with ids "gldiv", "gldiv2"
	         * var element = $("#gldiv"), element2 = $("#gldiv2");
	         * // Create GLViewer within 'gldiv'
	         * var myviewer = $3Dmol.createViewer(element);
	         * // Move the canvas to the other div
	         * myviewer.setContainer(element2)
	         *
	         * @example
	         * // Assume there exists an HTML div with id "gldiv"
	         * var element = $("#gldiv");
	         * // Create GLViewer within 'gldiv'
	         * var myviewer = $3Dmol.createViewer(element);
	         * // Remove the element from the DOM, and add a new element
	         * element.remove()
	         * $('body').prepend("<div id='newdiv'></div>")
	         * // Show the canvas in the new element
	         * myviewer.setContainer('newdiv')
	         */
	        this.setContainer = function(element) {
	            if($.type(element) === "string")
	                element = $("#"+element);
	            if(!element) {
	                element = container
	            };
	            initContainer(element);
	            return this;
	        };
	        
	        /**
	         * Set the background color (default white)
	         * 
	         * @function $3Dmol.GLViewer#setBackgroundColor
	         * @param {number}
	         *            hex Hexcode specified background color, or standard color spec
	         * @param {number}
	         *            a Alpha level (default 1.0)
	         * 
	         * @example
	         * 
	         * //Set 'myviewer' background color to white
	         * myviewer.setBackgroundColor(0xffffff)
	         * 
	         */
	        this.setBackgroundColor = function(hex, a) {
	            if(typeof(a) == "undefined") {
	                a = 1.0;
	            }
	            else if(a < 0 || a > 1.0) {
	                a = 1.0;
	            }
	            var c = $3Dmol.CC.color(hex);
	            scene.fog.color = c;
	            bgColor = c.getHex();
	            renderer.setClearColorHex(c.getHex(), a);
	            show();
	            return this;
	        };
	        
	        /**
	         * Set view projection scheme.  Either orthographic or perspective.  
	         * Default is perspective.  Orthographic can also be enabled on viewer creation
	         * by setting orthographic to true in the config object.
	         * 
	         * @function $3Dmol.GLViewer#setProjection
	         * 
	         * @example
	         * myviewer.setProjection("orthographic");
	         * 
	         */
	        this.setProjection = function(proj) {
	            camera.ortho = (proj === "orthographic");
	            setSlabAndFog();            
	        };
	        
	        /**
	         * Set global view styles.  
	         * @function $3Dmol.GLViewer#setViewStyle
	         * 
	         * @example
	         * myviewer.setViewStyle({style:"outline", color:"black", width:0.1})
	         * 
	         */
	         this.setViewStyle = function(parameters) {
	            if (parameters["style"] === "outline") {
	                var params = {};
	                if(parameters.color) params.color =  $3Dmol.CC.color(parameters.color);
	                if(parameters.width) params.width = parameters.width;
	                renderer.enableOutline(params);
	            } else {
	                renderer.disableOutline();
	            }           
	            return this;
	        }
	         
	        if(config.style) { //enable setting style in constructor
	             this.setViewStyle(config);
	        }

	        /**
	         * Set viewer width
	         * 
	         * @function $3Dmol.GLViewer#setWidth
	         * @param {number}
	         *            w Width in pixels
	         */
	        this.setWidth = function(w) {
	            WIDTH = w || WIDTH;
	            renderer.setSize(WIDTH, HEIGHT);
	            return this;
	        };

	        /**
	         * Set viewer height
	         * 
	         * @function $3Dmol.GLViewer#setHeight
	         * @param {number}
	         *            h Height in pixels
	         */
	        this.setHeight = function(h) {
	            HEIGHT = h || HEIGHT;
	            renderer.setSize(WIDTH, HEIGHT);
	            return this;
	        };

	        /**
	         * Resize viewer according to containing HTML element's dimensions
	         * 
	         * @function $3Dmol.GLViewer#resize
	         */
	        this.resize = function() {
	            WIDTH = container.width();
	            HEIGHT = container.height();
	            ASPECT = WIDTH / HEIGHT;
	            renderer.setSize(WIDTH, HEIGHT);
	            camera.aspect = ASPECT;
	            camera.updateProjectionMatrix();
	            show();
	            return this;
	        };

	        $(window).resize(this.resize);

	        /**
	         * Return specified model
	         * 
	         * @function $3Dmol.GLViewer#getModel
	         * @param {number}
	         *            [id=last model id] - Retrieve model with specified id
	         * @default Returns last model added to viewer
	         * @return {GLModel}
	         * 
	         * @example // Retrieve reference to first GLModel added var m =
	         *          glviewer.getModel(0);
	         */
	        this.getModel = function(id) {
	            id = id || models.length - 1;
	            return models[id];
	        };

	        /**
	         * Rotate scene by angle degrees around axis
	         * 
	         * @function $3Dmol.GLViewer#rotate
	         * @param {number}
	         *            [angle] - Angle, in degrees, to rotate by.
	         * @param {string}
	         *            [angle] - Axis ("x", "y", or "z") to rotate around.
	         *            Default "y"
	         * 
	         */
	        this.rotate = function(angle, axis) {
	            if (typeof (axis) === "undefined") {
	                axis = "y";
	            }
	            var i = 0, j = 0, k = 0;
	            var rangle = Math.PI * angle / 180.0;
	            var s = Math.sin(rangle / 2.0);
	            var c = Math.cos(rangle / 2.0);
	            if (axis == "x")
	                i = s;
	            if (axis == "y")
	                j = s;
	            if (axis == "z")
	                k = s;

	            var q = new $3Dmol.Quaternion(i, j, k, c).normalize();
	            rotationGroup.quaternion.multiply(q);
	            show();
	            return this;
	        };

	        /** Returns an array representing the current viewpoint.
	         * Translation, zoom, and rotation quaternion. 
	         * @function $3Dmol.GLViewer#getView
	         * @returns {Array.<number>} arg
	         *  */
	        this.getView = function() {
	            if (!modelGroup)
	                return [ 0, 0, 0, 0, 0, 0, 0, 1 ];
	            var pos = modelGroup.position;
	            var q = rotationGroup.quaternion;
	            return [ pos.x, pos.y, pos.z, rotationGroup.position.z, q.x, q.y,
	                    q.z, q.w ];
	        };

	        /** Sets the view to the specified translation, zoom, and rotation.
	         * 
	         * @function $3Dmol.GLViewer#setView
	         * @param {Array.<number>} arg Array formatted identically to the return value of getView */
	        this.setView = function(arg, nolink) {

	            if (arg === undefined
	                    || !(arg instanceof Array || arg.length !== 8))
	                return this;

	            if (!modelGroup || !rotationGroup)
	                return this;
	            modelGroup.position.x = arg[0];
	            modelGroup.position.y = arg[1];
	            modelGroup.position.z = arg[2];
	            rotationGroup.position.z = arg[3];
	            rotationGroup.quaternion.x = arg[4];
	            rotationGroup.quaternion.y = arg[5];
	            rotationGroup.quaternion.z = arg[6];
	            rotationGroup.quaternion.w = arg[7];
	            if(typeof(arg[8]) != "undefined") {
	                rotationGroup.position.x = arg[8];
	                rotationGroup.position.y = arg[9];
	            }
	            show(nolink);
	            return this;
	        };

	        // apply styles, models, etc in viewer
	        /**
	         * Render current state of viewer, after 
	         * adding/removing models, applying styles, etc.
	         * 
	         * @function $3Dmol.GLViewer#render
	         */
	        this.render = function() {

	            updateClickables(); //must render for clickable styles to take effect
	            var time1 = new Date();
	            var view = this.getView();
	            
	            var i, n;
	            var exts = renderer.supportedExtensions();
	            for (i = 0; i < models.length; i++) {
	                if (models[i]) {
	                    models[i].globj(modelGroup, exts);
	                }
	            }

	            for (i = 0; i < shapes.length; i++) {
	                if (shapes[i]) {
	                    shapes[i].globj(modelGroup, exts);
	                }
	            }
	            
	            for (i in surfaces) { // this is an object with possible holes
	                if(!surfaces.hasOwnProperty(i)) continue;
	                var surfArr = surfaces[i];
	                for (n = 0; n < surfArr.length; n++) {
	                    if (surfArr.hasOwnProperty(n)) {
	                        var geo = surfArr[n].geo;
	                        // async surface generation can cause
	                        // the geometry to be webgl initialized before it is fully
	                        // formed; force various recalculations until full surface
	                        // is
	                        // available
	                        if (!surfArr[n].finished) {
	                            geo.verticesNeedUpdate = true;
	                            geo.elementsNeedUpdate = true;
	                            geo.normalsNeedUpdate = true;
	                            geo.colorsNeedUpdate = true;
	                            geo.buffersNeedUpdate = true;
	                            geo.boundingSphere = null;

	                            if (surfArr[n].done)
	                                surfArr[n].finished = true;

	                            // remove partially rendered surface
	                            if (surfArr[n].lastGL)
	                                modelGroup.remove(surfArr[n].lastGL);

	                            // create new surface
	                            var smesh = null;

	                            if(surfArr[n].mat instanceof $3Dmol.LineBasicMaterial) {
	                                //special case line meshes
	                                smesh = new $3Dmol.Line(geo, surfArr[n].mat);
	                            }
	                            else {
	                                smesh = new $3Dmol.Mesh(geo, surfArr[n].mat);
	                            }
	                            if(surfArr[n].mat.transparent && surfArr[n].mat.opacity == 0) {
	                                //don't bother with hidden surfaces
	                                smesh.visible = false;
	                            } else {
	                                smesh.visible = true;
	                            }
	                            if (surfArr[n].symmetries.length > 1 || 
	                            (surfArr[n].symmetries.length == 1 && 
	                            !(surfArr[n].symmetries[n].isIdentity()))) {
	                                var j;
	                                var tmeshes = new $3Dmol.Object3D(); //transformed meshes
	                                for (j = 0; j < surfArr[n].symmetries.length; j++) {
	                                    var tmesh = smesh.clone();
	                                    tmesh.matrix = surfArr[n].symmetries[j];
	                                    tmesh.matrixAutoUpdate = false;
	                                    tmeshes.add(tmesh);
	                                }
	                                surfArr[n].lastGL = tmeshes;
	                                modelGroup.add(tmeshes);
	                            }
	                            else {
	                                surfArr[n].lastGL = smesh;
	                                modelGroup.add(smesh);
	                            }
	                        } // else final surface already there
	                    }
	                }
	            }
	            
	            this.setView(view); // Calls show() => renderer render
	            var time2 = new Date();
	            //console.log("render time: " + (time2 - time1));
	            return this;
	        };

	        /**
	         * 
	         * @param {AtomSelectionSpec}
	         *            sel
	         * @return {AtomSpec[]}
	         */
	        function getAtomsFromSel(sel) {
	            var atoms = [];
	            if (typeof (sel) === "undefined")
	                sel = {};

	            var ms = [];
	            var i;

	            if (typeof sel.model === "undefined") {
	                for (i = 0; i < models.length; i++) {
	                    if (models[i])
	                        ms.push(models[i]);
	                }
	            } else { // specific to some models
	                ms = sel.model;
	                if (!$.isArray(ms))
	                    ms = [ ms ];
	            }

	            for (i = 0; i < ms.length; i++) {
	                atoms = atoms.concat(ms[i].selectedAtoms(sel));
	            }

	            return atoms;
	        }

	        /**
	         * 
	         * @param {AtomSpec}
	         *            atom
	         * @param {AtomSpec}
	         *            sel
	         * @return {boolean}
	         */
	        function atomIsSelected(atom, sel) {
	            if (typeof (sel) === "undefined")
	                sel = {};

	            var ms = [];
	            var i;

	            if (typeof sel.model === "undefined") {
	                for (i = 0; i < models.length; i++) {
	                    if (models[i])
	                        ms.push(models[i]);
	                }
	            } else { // specific to some models
	                ms = sel.model;
	                if (!$.isArray(ms))
	                    ms = [ ms ];
	            }

	            for (i = 0; i < ms.length; i++) {
	                if (ms[i].atomIsSelected(atom, sel))
	                    return true;
	            }

	            return false;
	        }

	        
	        /** return list of atoms selected by sel
	         * 
	         * @function $3Dmol.GLViewer#selectedAtoms
	         * @param {AtomSelectionSpec} sel
	         * @return {Array.<Object>}
	         */
	        this.selectedAtoms = function(sel) {
	            return getAtomsFromSel(sel);
	        };
	        
	        /**
	         * Return pdb output of selected atoms (if atoms from pdb input)
	         * 
	         * @function $3Dmol.GLViewer#pdbData  
	         * @param {Object=} [sel] - Selection specification specifying model and atom properties to select.  Default: all atoms in viewer
	         * @return {string} PDB string of selected atoms
	         */
	        this.pdbData = function(sel) {
	            var atoms = getAtomsFromSel(sel);
	            var ret = "";
	            for (var i = 0, n = atoms.length; i < n; ++i) {
	                ret += atoms[i].pdbline + "\n";
	            }
	            return ret;
	        };

	        /**
	         * Zoom current view by a constant factor
	         * 
	         * @function $3Dmol.GLViewer#zoom
	         * @param {number}
	         *            [factor] - Magnification factor. Values greater than 1
	         *            will zoom in, less than one will zoom out. Default 2.
	         * 
	         */
	        this.zoom = function(factor) {
	            var factor = factor || 2;
	            var scale = (CAMERA_Z - rotationGroup.position.z) / factor;
	            rotationGroup.position.z = CAMERA_Z - scale;
	            show();
	            return this;
	        };
	        
	        /**
	         * Translate current view by x,y screen coordinates
	         * This pans the camera rather than translating the model.
	         * 
	         * @function $3Dmol.GLViewer#translate
	         * @param {number} x
	         * @param {number} y
	         * 
	         */
	        this.translate = function(x, y) {
	            
	            var dx = x/WIDTH;
	            var dy = y/HEIGHT;
	            var v = new $3Dmol.Vector3(0,0,-CAMERA_Z);

	            projector.projectVector(v, camera);
	            v.x -= dx;
	            v.y -= dy;
	            projector.unprojectVector(v, camera);
	            v.z = 0;            
	            lookingAt.add(v);
	            camera.lookAt(lookingAt);
	            show();
	            return this;
	        };
	        

	        /**
	         * Zoom to center of atom selection
	         * 
	         * @function $3Dmol.GLViewer#zoomTo
	         * @param {Object}
	         *            [sel] - Selection specification specifying model and atom
	         *            properties to select. Default: all atoms in viewer
	         * @example // Assuming we have created a model of a protein with
	         *          multiple chains (e.g. from a PDB file), focus on atoms in
	         *          chain B glviewer.zoomTo({chain: 'B'});
	         *  // Focus on centroid of all atoms of all models in this
	         * viewer glviewer.zoomTo(); // (equivalent to glviewer.zoomTo({}) )
	         */
	        this.zoomTo = function(sel) {
	            var allatoms, alltmp;
	            sel = sel || {};
	            var atoms = getAtomsFromSel(sel);
	            var tmp = $3Dmol.getExtent(atoms);

	            if($.isEmptyObject(sel)) {
	                //include shapes when zooming to full scene
	                //TODO: figure out a good way to specify shapes as part of a selection
	                $.each(shapes, function(i, shape) {
	                	if(shape && shape.boundingSphere && shape.boundingSphere.center)
	                	    var c = shape.boundingSphere.center;
	                	    var r = shape.boundingSphere.radius;
	                	    if(r > 0) {
	                	        //make sure full shape is visible
	                            atoms.push(new $3Dmol.Vector3(c.x+r,c.y,c.z));
	                            atoms.push(new $3Dmol.Vector3(c.x-r,c.y,c.z));
	                            atoms.push(new $3Dmol.Vector3(c.x,c.y+r,c.z));
	                            atoms.push(new $3Dmol.Vector3(c.x,c.y-r,c.z));
	                            atoms.push(new $3Dmol.Vector3(c.x,c.y,c.z+r));
	                            atoms.push(new $3Dmol.Vector3(c.x,c.y,c.z-r));
	                	    } else {
	                            atoms.push(c);
	                	    }
	                });
	                tmp = $3Dmol.getExtent(atoms);
	                allatoms = atoms;
	                alltmp = tmp;

	            }
	            else {
	                allatoms = getAtomsFromSel({});
	                alltmp = $3Dmol.getExtent(allatoms);
	            }

	            // use selection for center
	            var center = new $3Dmol.Vector3(tmp[2][0], tmp[2][1], tmp[2][2]);
	            modelGroup.position = center.clone().multiplyScalar(-1);
	            // but all for bounding box
	            var x = alltmp[1][0] - alltmp[0][0], y = alltmp[1][1]
	                    - alltmp[0][1], z = alltmp[1][2] - alltmp[0][2];

	            var maxD = Math.sqrt(x * x + y * y + z * z);
	            if (maxD < 5)
	                maxD = 5;

	            // use full bounding box for slab/fog
	            slabNear = -maxD / 1.9;
	            slabFar = maxD / 2;

	            // for zoom, use selection box
	            x = tmp[1][0] - tmp[0][0];
	            y = tmp[1][1] - tmp[0][1];
	            z = tmp[1][2] - tmp[0][2];
	            maxD = Math.sqrt(x * x + y * y + z * z);
	            if (maxD < 5)
	                maxD = 5;
	            
	            //find the farthest atom from center to get max distance needed for view
	            var maxDsq = 25;
	            for (var i = 0; i < atoms.length; i++) {
	                if(atoms[i]) {
	                    var dsq = center.distanceToSquared(atoms[i]);
	                    if(dsq > maxDsq)
	                        maxDsq = dsq;
	                }
	            }
	            
	            var maxD = Math.sqrt(maxDsq)*2;

	            rotationGroup.position.z = -(maxD * 0.5
	                    / Math.tan(Math.PI / 180.0 * camera.fov / 2) - CAMERA_Z);
	            show();
	            
	            return this;
	        };
	        
	        /**
	         * Set slab of view (contents outside of slab are clipped). M
	         * Must call render to update.
	         * 
	         * @function $3Dmol.GLViewer#setSlab
	         * @param {near}
	         * @param {far}
	         */
	        this.setSlab = function(near, far) {
	            slabNear = near;
	            slabFar = far;
	        };
	        
	        /**
	         * Get slab of view (contents outside of slab are clipped).
	         * 
	         * @function $3Dmol.GLViewer#setSlab
	         * @return {Object} near/far
	         */
	        this.getSlab = function(sel) {
	            return {near: slabNear, far: slabFar};
	        };
	                
	        /**
	         * Add label to viewer
	         * 
	         * @function $3Dmol.GLViewer#addLabel
	         * @param {string}
	         *            text - Label text
	         * @param {Object}
	         *            data - Label style specification
	         * @return {$3Dmol.Label}
	         * 
	         * @example
	         *  // Assuming glviewer contains a model representing a protein, label
	         * all alpha carbons with their residue name
	         *  // Select all alpha carbons (have property atom : "CA") from last
	         * model added var atoms =
	         * glviewer.getModel().selectedAtoms({atom:"CA"}); var labels = [];
	         * 
	         * for (var a in atoms) { var atom = atoms[a];
	         *  // Create label at alpha carbon's position displaying atom's residue
	         * and residue number var labelText = atom.resname + " " + atom.resi;
	         * 
	         * var l = glviewer.createLabel(labelText, {fontSize: 12, position: {x:
	         * atom.x, y: atom.y, z: atom.z});
	         * 
	         * labels.push(l); }

	         *  // Render labels glviewer.render();
	         */
	        this.addLabel = function(text, data) {
	            var label = new $3Dmol.Label(text, data);
	            label.setContext();
	            modelGroup.add(label.sprite);
	            labels.push(label);
	            show();
	            return label;
	        };
	        
	        /** Add residue labels.  This will generate one label per a
	         * residue within the selected atoms.  The label will be at the
	         * centroid of the atoms and styled according to the passed style.
	         * The label text will be [resn][resi]
	         * 
	         * @param {Object} sel
	         * @param {Object} style
	         */
	        this.addResLabels = function(sel, style) {
	            applyToModels("addResLabels", sel, this, style);
	            return this;
	        }

	        /**
	         * Remove label from viewer
	         * 
	         * @function $3Dmol.GLViewer#removeLabel
	         * @param {$3Dmol.Label}
	         *            label - $3Dmol label
	         * 
	         * @example // Remove labels created in [addLabel example]{@link $3Dmol.GLViewer#addLabel}
	         * 
	         * for (var i = 0; i < labels.length; i++) {
	         * glviewer.removeLabel(label); }
	         * 
	         * glviewer.render();
	         */
	        this.removeLabel = function(label) {
	            //todo: don't do the linear search
	            for(var i = 0; i < labels.length; i++) {
	                if(labels[i] == label) {
	                    labels.splice(i,1);
	                    label.dispose();
	                    modelGroup.remove(label.sprite);
	                    break;
	                }
	            }
	            return this;
	        };

	        /**
	         * Remove all labels from viewer
	         * 
	         * @function $3Dmol.GLViewer#removeAllLabels
	         */
	        this.removeAllLabels = function() {
	            for (var i = 0; i < labels.length; i++) {
	                modelGroup.remove(labels[i].sprite);
	            }
	            labels.splice(0,labels.length); //don't overwrite in case linked
	            return this;
	        };
	        
	        // Modify label style
	        /**
	         * Modify existing label's style
	         * 
	         * @function $3Dmol.GLViewer#setLabelStyle
	         * @param {$3Dmol.Label}
	         *            label - $3Dmol label
	         * @param {Object}
	         *            stylespec - Label style specification
	         * @return {$3Dmol.Label}
	         */
	        this.setLabelStyle = function(label, stylespec) {
	            modelGroup.remove(label.sprite);
	            label.dispose();
	            label.stylespec = stylespec;
	            label.setContext();
	            modelGroup.add(label.sprite);
	            show();
	            return label;

	        };

	        // Change label text
	        /**
	         * Modify existing label's text
	         * 
	         * @function $3Dmol.GLViewer#setLabelText
	         * @param {$3Dmol.Label}
	         *            label - $3Dmol label
	         * @param {String}
	         *            text - Label text
	         * @return {$3Dmol.Label}
	         */
	        this.setLabelText = function(label, text) {
	            modelGroup.remove(label.sprite);
	            label.dispose();
	            label.text = text;
	            label.setContext();
	            modelGroup.add(label.sprite);
	            show();
	            return label;

	        };

	        /**
	         * Add shape object to viewer 
	         * @see {@link $3Dmol.GLShape}
	         * 
	         * @function $3Dmol.GLViewer#addShape
	         * @param {ShapeSpec} shapeSpec - style specification for label
	         * @return {$3Dmol.GLShape}
	         */
	        this.addShape = function(shapeSpec) {
	            shapeSpec = shapeSpec || {};
	            var shape = new $3Dmol.GLShape(shapeSpec);
	            shape.shapePosition = shapes.length;
	            shapes.push(shape);

	            return shape;

	        };

	        /**
	         * Remove shape object from viewer
	         *
	         * @function $3Dmol.GLViewer#removeShape
	         * @param {$3Dmol.GLShape} shape - Reference to shape object to remove
	         */
	        this.removeShape = function(shape) {
	            if (!shape)
	                return this;
	            shape.removegl(modelGroup);
	            delete shapes[shape.shapePosition];
	            // clear off back of model array
	            while (shapes.length > 0
	                    && typeof (shapes[shapes.length - 1]) === "undefined")
	                shapes.pop();
	            return this;
	        };
	        
	        /**
	         * Remove all shape objects from viewer
	         * @function $3Dmol.GLViewer#removeAllShapes
	         */
	        this.removeAllShapes = function() {
	            for (var i = 0; i < shapes.length; i++) {
	                var shape = shapes[i];
	                shape.removegl(modelGroup);
	            }
	            shapes.splice(0,shapes.length);
	            return this;
	        }

	        /**
	         * Create and add sphere shape. This method provides a shorthand 
	         * way to create a spherical shape object
	         * 
	         * @function $3Dmol.GLViewer#addSphere
	         * @param {SphereSpec} spec - Sphere shape style specification
	         * @return {$3Dmol.GLShape}
	         */
	        this.addSphere = function(spec) {
	            spec = spec || {};
	            var s = new $3Dmol.GLShape(spec);
	            s.shapePosition = shapes.length;
	            s.addSphere(spec);
	            shapes.push(s);

	            return s;
	        };

	        /**
	         * Create and add arrow shape
	         * 
	         * @function $3Dmol.GLViewer#addArrow
	         * @param {ArrowSpec} spec - Style specification
	         * @return {$3Dmol.GLShape}
	         */
	        this.addArrow = function(spec) {
	            spec = spec || {};
	            var s = new $3Dmol.GLShape(spec);
	            s.shapePosition = shapes.length;
	            s.addArrow(spec);
	            shapes.push(s);

	            return s;
	        };
	        
	        /**
	         * Create and add cylinder shape
	         * 
	         * @function $3Dmol.GLViewer#addCylinder
	         * @param {CylinderSpec} spec - Style specification
	         * @return {$3Dmol.GLShape}
	         */
	        this.addCylinder = function(spec) {
	            spec = spec || {};
	            var s = new $3Dmol.GLShape(spec);
	            s.shapePosition = shapes.length;
	            s.addCylinder(spec);
	            shapes.push(s);

	            return s;
	        };

	        /**
	         * Create and add line shape
	         * 
	         * @function $3Dmol.GLViewer#addLine
	         * @param {LineSpec} spec - Style specification, can specify dashed, dashLength, and gapLength
	         * @return {$3Dmol.GLShape}
	         */
	        this.addLine = function(spec) {
	            spec = spec || {};
	            spec.wireframe = true;
	            var s = new $3Dmol.GLShape(spec);
	            s.shapePosition = shapes.length;
	            if (spec.dashed)
	                s = addLineDashed(spec, s);
	            else
	                s.addLine(spec);
	            shapes.push(s);

	            return s;
	        };
	        
	        
	        /**
	         * Create and add unit cell
	         *
	         * @function $3Dmol.GLViewer#addUnitCell
	         * @param {GLModel} Model with unit cell information (e.g., pdb derived).
	         * @return {$3Dmol.GLShape}  Line shape delineating unit cell.
	         */
	        this.addUnitCell = function(model) {

	            var s = new $3Dmol.GLShape({'wireframe' : true});
	            s.shapePosition = shapes.length;
	            var data = model.getCrystData();
	            if (data) {
	                var a = data.a, b = data.b, c = data.c, alpha = data.alpha, beta = data.beta, gamma = data.gamma;
	                alpha = alpha * Math.PI/180.0;
	                beta = beta * Math.PI/180.0;
	                gamma = gamma * Math.PI/180.0;
	            
	                var u, v, w;
	            
	                u = Math.cos(beta);
	                v = (Math.cos(alpha) - Math.cos(beta)*Math.cos(gamma))/Math.sin(gamma);
	                w = Math.sqrt(Math.max(0, 1-u*u-v*v));
	            
	                var matrix = new $3Dmol.Matrix4(a, b*Math.cos(gamma), c*u, 0, 
	                                                0, b*Math.sin(gamma), c*v, 0,
	                                                0, 0,                 c*w, 0,
	                                                0, 0,                 0,   1); 
	         
	                var points = [  new $3Dmol.Vector3(0, 0, 0),
	                                new $3Dmol.Vector3(1, 0, 0),
	                                new $3Dmol.Vector3(0, 1, 0),
	                                new $3Dmol.Vector3(0, 0, 1),
	                                new $3Dmol.Vector3(1, 1, 0),
	                                new $3Dmol.Vector3(0, 1, 1),
	                                new $3Dmol.Vector3(1, 0, 1),
	                                new $3Dmol.Vector3(1, 1, 1)  ];
	                            
	                for (var i = 0; i < points.length; i++) {
	                    points[i] = points[i].applyMatrix4(matrix);
	                }
	            
	                s.addLine({start: points[0], end: points[1]});
	                s.addLine({start: points[0], end: points[2]});
	                s.addLine({start: points[1], end: points[4]});
	                s.addLine({start: points[2], end: points[4]});
	            
	                s.addLine({start: points[0], end: points[3]});
	                s.addLine({start: points[3], end: points[5]});
	                s.addLine({start: points[2], end: points[5]});
	            
	                s.addLine({start: points[1], end: points[6]});
	                s.addLine({start: points[4], end: points[7]});
	                s.addLine({start: points[6], end: points[7]});
	            
	                s.addLine({start: points[3], end: points[6]});
	                s.addLine({start: points[5], end: points[7]});
	            }
	            
	            shapes.push(s);
	            return s;
	        };

	        function addLineDashed(spec, s) {
	            spec.dashLength = spec.dashLength || 0.5;
	            spec.gapLength = spec.gapLength || 0.5;
	            spec.start = spec.start || {};
	            spec.end = spec.end || {};
	            
	            var p1 = new $3Dmol.Vector3(spec.start.x || 0,
	        			spec.start.y || 0, spec.start.z || 0)
	        	var p2 = new $3Dmol.Vector3(spec.end.x,
	        			spec.end.y || 0, spec.end.z || 0);
	        			
	            var dir = new $3Dmol.Vector3();
	            var dash = new $3Dmol.Vector3();
	            var gap = new $3Dmol.Vector3();
	            var length, dashAmt, gapAmt;
	            var temp = p1.clone();
	            var drawn = 0;

	            dir.subVectors(p2, p1);
	            length = dir.length();
	            dir.normalize();
	            dash = dir.clone();
	            gap = dir.clone();
	            dash.multiplyScalar(spec.dashLength);
	            gap.multiplyScalar(spec.gapLength);
	            dashAmt = dash.length();
	            gapAmt = gap.length();

	            while (drawn < length) {
	                if ((drawn + dashAmt) > length) { 
	                    spec.start = p1;
	                    spec.end = p2;
	                    s.addLine(spec);
	                    break;
	                }
	                temp.addVectors(p1, dash); 
	                spec.start = p1;
	                spec.end = temp;
	                s.addLine(spec);
	                p1 = temp.clone();
	                drawn += dashAmt;

	                temp.addVectors(p1, gap);
	                p1 = temp.clone();   
	                drawn += gapAmt;
	            }
	        			
	        	return s;
	        }

	        /**
	         * Add custom shape component from user supplied function
	         * 
	         * @function $3Dmol.GLViewer#addCustom
	         * @param {CustomSpec} spec - Style specification
	         * @return {$3Dmol.GLShape}
	         */
	        this.addCustom = function(spec) {
	            spec = spec || {};
	            var s = new $3Dmol.GLShape(spec);
	            s.shapePosition = shapes.length;
	            s.addCustom(spec);
	            shapes.push(s);

	            return s;
	        };

	        /**
	         * Construct isosurface from volumetric data in gaussian cube format
	         * @deprecated
	         * @function $3Dmol.GLViewer#addVolumetricData
	         * @param {String} data - Input file contents 
	         * @param {String} format - Input file format (currently only supports "cube")
	         * @param {IsoSurfaceSpec} spec - Shape style specification
	         * @return {$3Dmol.GLShape}
	         * 
	         * @example
	         * viewer.addVolumetricData(data, "cube", {isoval: 0.01, color: "blue", opacity: 0.95});              
	         * viewer.addVolumetricData(data, "cube", {isoval: -0.01, color: "red", opacity: 0.95}); 
	         */
	        this.addVolumetricData = function(data, format, spec) {
	            spec = spec || {};
	            var s = new $3Dmol.GLShape(spec);
	            s.shapePosition = shapes.length;
	            s.addVolumetricData(data, format, spec);
	            shapes.push(s);

	            return s;
	        };
	        
	        /**
	         * Construct isosurface from volumetric data
	         * @function $3Dmol.GLViewer#addIsosurface
	         * @param {$3Dmol.VolumeData} data - volumetric data
	         * @param {IsoSurfaceSpec} spec - Shape style specification
	         * @return {$3Dmol.GLShape}
	         * 
	         * @example
	         * var data = new $3Dmol.VolumeData(str,"cube");
	         * viewer.addIsosurface(data, {isoval: 0.01, color: "blue", opacity: 0.95});              
	         * viewer.addIsosurface(data, {isoval: -0.01, color: "red", opacity: 0.95}); 
	         */
	        this.addIsosurface = function(data,  spec) {
	            spec = spec || {};
	            var s = new $3Dmol.GLShape(spec);
	            s.shapePosition = shapes.length;
	            s.addIsosurface(data, spec);
	            shapes.push(s);

	            return s;
	        };
	        
	        /**
	         * Sets the atomlists of all models in the viewer to specified frame
	         * Sets to last frame if framenum out of range
	         * 
	         * @function $3Dmol.GLViewer#setFrame
	         * @param {number} framenum - each model in viewer has their atoms set to this index in frames list
	         */
	        this.setFrame = function(framenum) {
	            for (var i = 0; i < models.length; i++) {
	                models[i].setFrame(framenum);
	            }
	            return this;
	        };
	        
	        /**
	         * Returns the number of frames that the model with the most frames in the viewer has
	         * 
	         * @function $3Dmol.GLViewer#getFrames
	         * @return {number}
	         */
	        this.getFrames = function() {
	            var mostFrames = 0;
	            var modelNum = 0;
	            for (var i = 0; i < models.length; i++) {
	                if (models[i].getFrames().length > mostFrames) {
	                    modelNum = i;
	                    mostFrames = models[i].getFrames().length;
	                }
	            }
	            return mostFrames;
	        };
	        

	        /**
	         * Animate all models in viewer from their respective frames
	         * @function $3Dmol.GLViewer#animate
	         * @param {Object} options - can specify interval (speed of animation), loop (direction
	         * of looping, 'backward', 'forward' or 'backAndForth') and reps (numer of repetitions, 0 indicates infinite loop)
	         *      
	         * @example
	         * viewer.addModelAsFrames(data, "pdb");
	         * viewer.animate({interval: 75, loop: "backward", reps: 30});
	         */
	        this.animate = function(options) {
	            animated = true;
	            var interval = 100;
	            var loop = "forward";
	            var reps = 0;
	            options = options || {};
	            if (options.interval) {
	                interval = options.interval;
	            }
	            if (options.loop) {
	                loop = options.loop;
	            }
	            if (options.reps) {
	                reps = options.reps;
	            }
	            var mostFrames = this.getFrames();
	            var that = this;
	            var currFrame = 0;
	            var inc = 1;
	            var displayCount = 0;
	            var displayMax = mostFrames * reps;
	            var display = function(direction) {
	                if (direction == "forward") {
	                    that.setFrame(currFrame);
	                    currFrame = (currFrame + inc) % mostFrames;
	                }
	                else if (direction == "backward") {
	                    that.setFrame((mostFrames-1) - currFrame);
	                    currFrame = (currFrame + inc) % mostFrames;
	                }
	                else { //back and forth
	                    that.setFrame(currFrame);
	                    currFrame += inc;
	                    inc *= (((currFrame % (mostFrames-1)) == 0) ? -1 : 1);
	                }
	                that.render();
	                if (++displayCount == displayMax || !that.isAnimated()) {
	                    clearInterval(intervalID);
	                }
	            };
	            var intervalID = setInterval( function() { display(loop); }, interval);
	            return this;
	        };
	        
	        /**
	         * Stop animation of all models in viewer
	         * @function $3Dmol.GLViewer#stopAnimate
	         */
	        this.stopAnimate = function() {
	            animated = false;
	            return this;
	        };
	        
	        /**
	         * Return true if viewer is currently being animated, false otherwise
	         * @function $3Dmol.GLViewer#isAnimated
	         * @return {boolean}
	         */
	        this.isAnimated = function() {
	            return animated;
	        };
	        

	        /**
	         * Create and add model to viewer, given molecular data and its format 
	         * (pdb, sdf, xyz, or mol2)
	         * 
	         * @function $3Dmol.GLViewer#addModel
	         * @param {string} data - Input data
	         * @param {string} format - Input format ('pdb', 'sdf', 'xyz', or 'mol2')
	         * @return {$3Dmol.GLModel}
	         */
	        this.addModel = function(data, format, options) {
	            var m = new $3Dmol.GLModel(models.length, defaultcolors);
	            m.addMolData(data, format, options);
	            models.push(m);

	            return m;
	        };
	        
	        /**
	         * Given multimodel file and its format, add atom data to the viewer as separate models
	         * and return list of these models
	         * 
	         * @function $3Dmol.GLViewer#addModels
	         * @param {string} data - Input data
	         * @param {string} format - Input format ('pdb', 'sdf', 'xyz', or 'mol2')
	         * @return {Array<$3Dmol.GLModel>}
	         */
	        this.addModels = function(data, format, options) {
	            options = options || {};
	            options.multimodel = true;
	            options.frames = true;

	            var modelatoms = $3Dmol.GLModel.parseMolData(data, format, options);

	            for (var i = 0; i < modelatoms.length; i++) {
	                var newModel = new $3Dmol.GLModel(models.length, defaultcolors);
	                newModel.setAtomDefaults(modelatoms[i]);
	                newModel.addFrame(modelatoms[i]);
	                newModel.setFrame(0);
	                newModel.setModelData(modelatoms.modelData[i]);
	                newModel.setDontDuplicateAtoms(!options.duplicateAssemblyAtoms);
	                models.push(newModel);
	            }
	            
	            return models;
	        };
	        
	        /**
	         * Create and add model to viewer. Given multimodel file and its format, 
	         * different atomlists are stored in model's frame
	         * property and model's atoms are set to the 0th frame
	         * 
	         * @function $3Dmol.GLViewer#addModelsAsFrames
	         * @param {string} data - Input data
	         * @param {string} format - Input format ('pdb', 'sdf', 'xyz', or 'mol2')
	         * @return {$3Dmol.GLModel}
	         */
	        this.addModelsAsFrames = function(data, format, options) {
	            options = options || {};
	            options.multimodel = true;
	            options.frames = true;
	            var m = new $3Dmol.GLModel(models.length, defaultcolors);
	            m.addMolData(data, format, options);
	            models.push(m);

	            return m;
	        };
	        
	        /**
	         * Create and add model to viewer. Given multimodel file and its format,
	         * all atoms are added to one model
	         * 
	         * @function $3Dmol.GLViewer#addAsOneMolecule
	         * @param {string} data - Input data
	         * @param {string} format - Input format ('pdb', 'sdf', 'xyz', or 'mol2')
	         * @return {$3Dmol.GLModel}
	         */
	        this.addAsOneMolecule = function(data, format, options) {
	            options = options || {};
	            options.multimodel = true;
	            options.onemol = true;
	            var m = new $3Dmol.GLModel(models.length, defaultcolors);
	            m.addMolData(data, format, options);
	            models.push(m);
	            
	            return m;
	        };
	        

	        /**
	         * Delete specified model from viewer
	         * 
	         * @function $3Dmol.GLViewer#removeModel
	         * @param {$3Dmol.GLModel} model
	         */
	        this.removeModel = function(model) {
	            if (!model)
	                return;
	            model.removegl(modelGroup);
	            delete models[model.getID()];
	            // clear off back of model array
	            while (models.length > 0
	                    && typeof (models[models.length - 1]) === "undefined")
	                models.pop();
	            return this;
	        };

	        /** 
	         * Delete all existing models
	         * @function $3Dmol.GLViewer#removeAllModels
	         */
	        this.removeAllModels = function() {
	            for (var i = 0; i < models.length; i++) {
	                var model = models[i];
	                model.removegl(modelGroup);

	            }
	            models.splice(0,models.length); //don't simply overwrite array in case linked
	            return this;
	        };

	        /**
	         * Export one or all of the loaded models into ChemDoodle compatible JSON.
	         * @function $3Dmol.GLViewer#exportJSON
	         * @param {boolean} includeStyles - Whether or not to include style information.
	         * @param {number} modelID - Optional parameter for which model to export. If left out, export all of them.
	         * @return {string}
	         */
	        this.exportJSON = function(includeStyles, modelID) {
	            var object = {};
	            if (modelID === undefined) {
	                object.m = models.map(function(model) {
	                    return model.toCDObject(includeStyles);
	                });
	            } else {
	                object.m = [ model[modelID].toCDObject() ];
	            }
	            return JSON.stringify(object);
	        }

	        /**
	         * Create a new model from atoms specified by sel.
	         * If extract, removes selected atoms from existing models 
	         * 
	         * @function $3Dmol.GLViewer#createModelFrom
	         * @param {Object} sel - Atom selection specification
	         * @param {boolean=} extract - If true, remove selected atoms from existing models
	         * @return {$3Dmol.GLModel}
	         */
	        this.createModelFrom = function(sel, extract) {
	            var m = new $3Dmol.GLModel(models.length, defaultcolors);
	            for (var i = 0; i < models.length; i++) {
	                if (models[i]) {
	                    var atoms = models[i].selectedAtoms(sel);
	                    m.addAtoms(atoms);
	                    if (extract)
	                        models[i].removeAtoms(atoms);
	                }
	            }
	            models.push(m);
	            return m;
	        };

	        function applyToModels(func, sel, value1, value2) {
	            
	            //apply func to all models that are selected by sel with value1 and 2
	            var ms = []
	            if (typeof sel.model === "undefined") {
	                for (i = 0; i < models.length; i++) {
	                    if (models[i])
	                        ms.push(models[i]);
	                }
	            } else { // specific to some models
	                ms = sel.model;
	                if (!$.isArray(ms))
	                    ms = [ ms ];
	            }
	            
	            
	            for (var i = 0; i < ms.length; i++) {
	                if (ms[i]) {
	                    ms[i][func](sel, value1, value2);
	                }
	            }
	        }

	        /**
	         * Set style properties to all selected atoms
	         * 
	         * @function $3Dmol.GLViewer#setStyle
	         * @param {AtomSelectionSpec} sel - Atom selection specification
	         * @param {AtomStyleSpec} style - Style spec to apply to specified atoms
	         * 
	         * @example
	         * viewer.setStyle({}, {stick:{}}); //set all atoms to stick
	         * viewer.setStyle({chain: 'B'}, {cartoon: {color: 'spectrum'}}); //set chain B to rainbow cartoon
	         */
	        this.setStyle = function(sel, style) {
	            if(typeof(style) === 'undefined') {
	                //if a single argument is provided, assume it is a style and select all
	                style = sel;
	                sel = {};
	            }
	            
	            applyToModels("setStyle", sel, style, false);
	            return this;
	        };

	        /**
	         * Add style properties to all selected atoms
	         * 
	         * @function $3Dmol.GLViewer#addStyle
	         * @param {AtomSelectionSpec} sel - Atom selection specification
	         * @param {AtomStyleSpec} style - style spec to add to specified atoms
	         */
	        this.addStyle = function(sel, style) {
	            if(typeof(style) === 'undefined') {
	                //if a single argument is provided, assume it is a style and select all
	                style = sel;
	                sel = {};
	            }
	            applyToModels("setStyle", sel, style, true);
	            return this;
	        };

	        /**
	         * Set click-handling properties to all selected atoms
	         * 
	         * @function $3Dmol.GLViewer#setClickable
	         * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to
	         * @param {boolean} clickable - whether click-handling is enabled for the selection
	         * @param {function} callback - function called when an atom in the selection is clicked
	         * 
	         * @example
	         * viewer.setClickable({}, false); // disable click-handling for entire viewer
	         * viewer.setClickable({chain: 'B'}, true, function(){ console.log(this.elem); }); // chain B prints the clicked element to console
	         */
	        this.setClickable = function(sel, clickable, callback) {
	            applyToModels("setClickable", sel, clickable, callback);
	            return this;
	        };

	        /**
	         * @function $3Dmol.GLViewer#setColorByProperty
	         * @param {AtomSelectionSpec} sel
	         * @param {type} prop
	         * @param {type} scheme
	         */
	        this.setColorByProperty = function(sel, prop, scheme) {
	            applyToModels("setColorByProperty", sel, prop, scheme);
	            return this;
	        };

	        /**
	         * @function $3Dmol.GLViewer#setColorByElement
	         * @param {AtomSelectionSpec} sel
	         * @param {type} colors
	         */
	        this.setColorByElement = function(sel, colors) {
	            applyToModels("setColorByElement", sel, colors);
	            return this;
	        };

	        /**
	         * 
	         * @param {AtomSpec[]} atomlist
	         * @param {Array}
	         *            extent
	         * @return {Array}
	         */
	        var getAtomsWithin = function(atomlist, extent) {
	            var ret = [];

	            for (var i = 0; i < atomlist.length; i++) {
	                var atom = atomlist[i];
	                if (typeof (atom) == "undefined")
	                    continue;

	                if (atom.x < extent[0][0] || atom.x > extent[1][0])
	                    continue;
	                if (atom.y < extent[0][1] || atom.y > extent[1][1])
	                    continue;
	                if (atom.z < extent[0][2] || atom.z > extent[1][2])
	                    continue;
	                ret.push(i);
	            }
	            return ret;
	        };

	        // return volume of extent
	        var volume = function(extent) {
	            var w = extent[1][0] - extent[0][0];
	            var h = extent[1][1] - extent[0][1];
	            var d = extent[1][2] - extent[0][2];
	            return w * h * d;
	        }; // volume
	        /*
	         * Break up bounding box/atoms into smaller pieces so we can parallelize
	         * with webworkers and also limit the size of the working memory Returns
	         * a list of bounding boxes with the corresponding atoms. These extents
	         * are expanded by 4 angstroms on each side.
	         */
	        /**
	         * 
	         * @param {Array}
	         *            extent
	         * @param {AtomSpec[]} atomlist
	         * @param {AtomSpec[]} atomstoshow
	         * @return {Array}
	         */
	        var carveUpExtent = function(extent, atomlist, atomstoshow) {
	            var ret = [];

	            var copyExtent = function(extent) {
	                // copy just the dimensions
	                var ret = [];
	                ret[0] = [ extent[0][0], extent[0][1], extent[0][2] ];
	                ret[1] = [ extent[1][0], extent[1][1], extent[1][2] ];
	                return ret;
	            }; // copyExtent
	            var splitExtentR = function(extent) {
	                // recursively split until volume is below maxVol
	                if (volume(extent) < maxVolume) {
	                    return [ extent ];
	                } else {
	                    // find longest edge
	                    var w = extent[1][0] - extent[0][0];
	                    var h = extent[1][1] - extent[0][1];
	                    var d = extent[1][2] - extent[0][2];

	                    var index;

	                    if (w > h && w > d) {
	                        index = 0;
	                    } else if (h > w && h > d) {
	                        index = 1;
	                    } else {
	                        index = 2;
	                    }

	                    // create two halves, splitting at index
	                    var a = copyExtent(extent);
	                    var b = copyExtent(extent);
	                    var mid = (extent[1][index] - extent[0][index]) / 2
	                            + extent[0][index];
	                    a[1][index] = mid;
	                    b[0][index] = mid;

	                    var alist = splitExtentR(a);
	                    var blist = splitExtentR(b);
	                    return alist.concat(blist);
	                }
	            }; // splitExtentR

	            // divide up extent
	            var splits = splitExtentR(extent);
	            // now compute atoms within expanded (this could be more efficient)
	            var off = 6; // enough for water and 2*r, also depends on scale
	            // factor
	            for (var i = 0, n = splits.length; i < n; i++) {
	                var e = copyExtent(splits[i]);
	                e[0][0] -= off;
	                e[0][1] -= off;
	                e[0][2] -= off;
	                e[1][0] += off;
	                e[1][1] += off;
	                e[1][2] += off;

	                var atoms = getAtomsWithin(atomlist, e);
	                var toshow = getAtomsWithin(atomstoshow, splits[i]);

	                // ultimately, divide up by atom for best meshing
	                ret.push({
	                    extent : splits[i],
	                    atoms : atoms,
	                    toshow : toshow
	                });
	            }

	            return ret;
	        };

	        // create a mesh defined from the passed vertices and faces and material
	        // Just create a single geometry chunk - broken up whether sync or not
	        /**
	         * 
	         * @param {AtomSpec[]} atoms
	         * @param {{vertices:number,faces:number}}
	         *            VandF
	         * @param {$3Dmol.MeshLambertMaterial}
	         *            mat
	         * @return {$3Dmol.Mesh}
	         */
	        var generateSurfaceMesh = function(atoms, VandF, mat) {
	            var geo = new $3Dmol.Geometry(true);
	            // Only one group per call to generate surface mesh (addSurface
	            // should split up mesh render)
	            var geoGroup = geo.updateGeoGroup(0);

	            // set colors for vertices
	            var colors = [];
	            for (i = 0, il = atoms.length; i < il; i++) {
	                var atom = atoms[i];
	                if (atom) {
	                    if (typeof (atom.surfaceColor) != "undefined") {
	                        colors[i] = atom.surfaceColor;
	                    } else if (atom.color) // map from atom
	                        colors[i] = $3Dmol.CC.color(atom.color);
	                }
	            }
	            
	            var vertexArray = geoGroup.vertexArray;

	            // reconstruct vertices and faces
	            var v = VandF['vertices'];
	            var offset;
	            var i, il;
	            for (i = 0, il = v.length; i < il; i++) {
	                offset = geoGroup.vertices * 3;
	                vertexArray[offset] = v[i].x;
	                vertexArray[offset + 1] = v[i].y;
	                vertexArray[offset + 2] = v[i].z;
	                geoGroup.vertices++;                
	            }

	            //set colorArray of there are per-atom colors
	            var colorArray = geoGroup.colorArray;
	            
	            if(mat.voldata && mat.volscheme) {
	                //convert volumetric data into colors
	                var scheme = mat.volscheme;
	                var voldata = mat.voldata;
	                var range = scheme.range() || [-1,1];
	                for (i = 0, il = v.length; i < il; i++) {
	                    var val = voldata.getVal(v[i].x,v[i].y,v[i].z);
	                    var col =  $3Dmol.CC.color(scheme.valueToHex(val, range));
	                    var offset = i * 3;
	                    colorArray[offset] = col.r;
	                    colorArray[offset + 1] = col.g;
	                    colorArray[offset + 2] = col.b;
	                }
	            }
	            else if(colors.length > 0) { //have atom colors
	                for (i = 0, il = v.length; i < il; i++) {
	                    var A = v[i].atomid;
	                    var offsetA = i * 3;

	                    colorArray[offsetA] = colors[A].r;
	                    colorArray[offsetA + 1] = colors[A].g;
	                    colorArray[offsetA + 2] = colors[A].b;
	                }
	            }
	            
	            var faces = VandF['faces'];
	            geoGroup.faceidx = faces.length;// *3;
	            geo.initTypedArrays();

	            var verts = geoGroup.vertexArray;
	            var normalArray = geoGroup.normalArray;
	            var vA, vB, vC, norm;

	            // Setup colors, faces, and normals
	            for (i = 0, il = faces.length; i < il; i += 3) {

	                // var a = faces[i].a, b = faces[i].b, c = faces[i].c;
	                var a = faces[i], b = faces[i + 1], c = faces[i + 2];
	                var A = v[a]['atomid'];
	                var B = v[b]['atomid'];
	                var C = v[c]['atomid'];

	                var offsetA = a * 3, offsetB = b * 3, offsetC = c * 3;

	                // setup Normals
	                // todo - calculate normals in parallel code
	                vA = new $3Dmol.Vector3(verts[offsetA], verts[offsetA + 1],
	                        verts[offsetA + 2]);
	                vB = new $3Dmol.Vector3(verts[offsetB], verts[offsetB + 1],
	                        verts[offsetB + 2]);
	                vC = new $3Dmol.Vector3(verts[offsetC], verts[offsetC + 1],
	                        verts[offsetC + 2]);

	                vC.subVectors(vC, vB);
	                vA.subVectors(vA, vB);
	                vC.cross(vA);

	                // face normal
	                norm = vC;
	                norm.normalize();

	                normalArray[offsetA] += norm.x;
	                normalArray[offsetB] += norm.x;
	                normalArray[offsetC] += norm.x;
	                normalArray[offsetA + 1] += norm.y;
	                normalArray[offsetB + 1] += norm.y;
	                normalArray[offsetC + 1] += norm.y;
	                normalArray[offsetA + 2] += norm.z;
	                normalArray[offsetB + 2] += norm.z;
	                normalArray[offsetC + 2] += norm.z;

	            }
	            geoGroup.faceArray = new Uint16Array(faces);
	            var mesh = new $3Dmol.Mesh(geo, mat);
	            mesh.doubleSided = true;        
	            return mesh;
	        };

	        // do same thing as worker in main thread
	        /**
	         * 
	         * @param {$3Dmol.SurfaceType}
	         *            type
	         * @param {Array}
	         *            expandedExtent
	         * @param {Array}
	         *            extendedAtoms
	         * @param {Array}
	         *            atomsToShow
	         * @param {AtomSpec[]} atoms
	         * @param {number}
	         *            vol
	         * @return {Object}
	         */
	        var generateMeshSyncHelper = function(type, expandedExtent,
	                extendedAtoms, atomsToShow, atoms, vol) {
	            var time = new Date();
	            var ps = new $3Dmol.ProteinSurface();
	            ps.initparm(expandedExtent, (type === 1) ? false : true, vol);

	            var time2 = new Date();
	            //console.log("initialize " + (time2 - time) + "ms");

	            ps.fillvoxels(atoms, extendedAtoms);

	            var time3 = new Date();
	            //console.log("fillvoxels " + (time3 - time2) + "  " + (time3 - time) + "ms");

	            ps.buildboundary();

	            if (type == $3Dmol.SurfaceType.SES) {
	                ps.fastdistancemap();
	                ps.boundingatom(false);
	                ps.fillvoxelswaals(atoms, extendedAtoms);
	            }

	            var time4 = new Date();
	            //console.log("buildboundaryetc " + (time4 - time3) + "  " + (time4 - time) + "ms");

	            ps.marchingcube(type);

	            var time5 = new Date();
	            //console.log("marching cube " + (time5 - time4) + "  "+ (time5 - time) + "ms");

	            return ps.getFacesAndVertices(atomsToShow);
	        };

	        /**
	         * 
	         * @param {matSpec}
	         *            style
	         * @return {$3Dmol.MeshLambertMaterial}
	         */
	        function getMatWithStyle(style) {
	            var mat = new $3Dmol.MeshLambertMaterial();
	            mat.vertexColors = $3Dmol.VertexColors;

	            for ( var prop in style) {
	                if (prop === "color" || prop === "map") {
	                    // ignore
	                } else if (style.hasOwnProperty(prop))
	                    mat[prop] = style[prop];
	            }
	            if (style.opacity !== undefined) {
	                if (style.opacity === 1)
	                    mat.transparent = false;
	                else
	                    mat.transparent = true;
	            }

	            return mat;
	        }

	        
	        /**
	         * Adds an explicit mesh as a surface object.
	         * @function $3Dmol.GLViewer#addMesh
	         * @param {$3Dmol.Mesh}
	         *            mesh
	         * @param {Object}
	         *            style
	         * @returns {Number} surfid
	         */
	        this.addMesh = function(mesh) {
	            var surfobj = {
	                geo : mesh.geometry,
	                mat : mesh.material,
	                done : true,
	                finished : false //the rendered finishes surfaces when they are done
	            };
	            var surfid = nextSurfID();
	            surfaces[surfid] = surfobj;
	            return surfid;
	        }

	        //return a shallow copy of list l, e.g., for atoms so we can
	        //ignore superficial changes (ie surfacecolor, position) that happen
	        //while we're surface building
	        var shallowCopy = function(l) {
	            var ret = [];
	            $.each(l, function(k,v) {
	                ret[k] = $.extend({},v);
	            });
	            return ret;
	        }
	        /**
	         * Add surface representation to atoms
	         *  @function $3Dmol.GLViewer#addSurface
	         * @param {$3Dmol.SurfaceType} type - Surface type
	         * @param {SurfaceStyleSpec} style - optional style specification for surface material (e.g. for different coloring scheme, etc)
	         * @param {AtomSelectionSpec} atomsel - Show surface for atoms in this selection
	         * @param {AtomSelectionSpec} allsel - Use atoms in this selection to calculate surface; may be larger group than 'atomsel' 
	         * @param {AtomSelectionSpec} focus - Optionally begin rendering surface specified atoms
	         * 
	         * @return {number} surfid - Identifying number for this surface
	         */
	        this.addSurface = function(type, style, atomsel, allsel, focus) {
	            // type 1: VDW 3: SAS 4: MS 2: SES
	            // if sync is true, does all work in main thread, otherwise uses
	            // workers
	            // with workers, must ensure group is the actual modelgroup since
	            // surface
	            // will get added asynchronously
	            // all atoms in atomlist are used to compute surfaces, but only the
	            // surfaces
	            // of atomsToShow are displayed (e.g., for showing cavities)
	            // if focusSele is specified, will start rending surface around the
	            // atoms specified by this selection
	            var atomlist = null, focusSele = null;
	            //TODO: currently generating a shallow copy to avoid problems when atoms are chagned
	            //during surface generation - come up with a better solution
	            var atomsToShow = shallowCopy(getAtomsFromSel(atomsel));
	            if(!allsel) {
	                atomlist = atomsToShow;
	            }
	            else {
	                atomlist = shallowCopy(getAtomsFromSel(allsel));
	            }
	            
	            var symmetries = false;
	            var n;
	            for (n = 0; n < models.length; n++) { 
	                if(models[n]) {
	                    var symMatrices = models[n].getSymmetries();
	                    if (symMatrices.length > 1 || (symMatrices.length == 1 && !(symMatrices[0].isIdentity()))) {
	                        symmetries = true;
	                        break;
	                    }
	                }
	            }

	            var addSurfaceHelper = function addSurfaceHelper(surfobj, atomlist, atomsToShow) {
	            
	                if(!focus) {
	                    focusSele = atomsToShow;
	                } else {
	                    focusSele = shallowCopy(getAtomsFromSel(focus));
	                }

	                var atom;
	                var time = new Date();
	                var extent = $3Dmol.getExtent(atomsToShow, true);

	                var i, il;
	                if (style['map'] && style['map']['prop']) {
	                    // map color space using already set atom properties
	                    /** @type {AtomSpec} */
	                    var prop = style['map']['prop'];
	                    /** @type {Gradient} */
	                    var scheme = style['map']['scheme'] || style['map']['gradient'] || new $3Dmol.Gradient.RWB();
	                    var range = scheme.range();
	                    if (!range) {
	                        range = $3Dmol.getPropertyRange(atomsToShow, prop);
	                    }
	                    style.colorscheme = {prop: prop, gradient: scheme};

	                }
	                
	                //cache surface color on each atom
	                for (i = 0, il = atomlist.length; i < il; i++) {
	                    atom = atomlist[i];
	                    atom.surfaceColor = $3Dmol.getColorFromStyle(atom, style);
	                }                

	                var totalVol = volume(extent); // used to scale resolution
	                var extents = carveUpExtent(extent, atomlist, atomsToShow);

	                if (focusSele && focusSele.length && focusSele.length > 0) {
	                    var seleExtent = $3Dmol.getExtent(focusSele, true);
	                    // sort by how close to center of seleExtent
	                    var sortFunc = function(a, b) {
	                        var distSq = function(ex, sele) {
	                            // distance from e (which has no center of mass) and
	                            // sele which does
	                            var e = ex.extent;
	                            var x = e[1][0] - e[0][0];
	                            var y = e[1][1] - e[0][1];
	                            var z = e[1][2] - e[0][2];
	                            var dx = (x - sele[2][0]);
	                            dx *= dx;
	                            var dy = (y - sele[2][1]);
	                            dy *= dy;
	                            var dz = (z - sele[2][2]);
	                            dz *= dz;

	                            return dx + dy + dz;
	                        };
	                        var d1 = distSq(a, seleExtent);
	                        var d2 = distSq(b, seleExtent);
	                        return d1 - d2;
	                    };
	                    extents.sort(sortFunc);
	                }

	                //console.log("Extents " + extents.length + "  "+ (+new Date() - time) + "ms");


	                var reducedAtoms = [];
	                // to reduce amount data transfered, just pass x,y,z,serial and elem
	                for (i = 0, il = atomlist.length; i < il; i++) {
	                    atom = atomlist[i];
	                    reducedAtoms[i] = {
	                        x : atom.x,
	                        y : atom.y,
	                        z : atom.z,
	                        serial : i,
	                        elem : atom.elem
	                    };
	                }

	                var sync = !!($3Dmol.syncSurface);
	                if (sync) { // don't use worker, still break up for memory purposes

	                    // to keep the browser from locking up, call through setTimeout
	                    var callSyncHelper = function callSyncHelper(i) {
	                        if (i >= extents.length)
	                            return;

	                        var VandF = generateMeshSyncHelper(type, extents[i].extent,
	                                extents[i].atoms, extents[i].toshow, reducedAtoms,
	                                totalVol);
	                        var mesh = generateSurfaceMesh(atomlist, VandF, mat);
	                        $3Dmol.mergeGeos(surfobj.geo, mesh);
	                        _viewer.render();

	                        setTimeout(callSyncHelper, 1, i + 1);
	                    }

	                    setTimeout(callSyncHelper, 1, 0);

	                    // TODO: Asynchronously generate geometryGroups (not separate
	                    // meshes) and merge them into a single geometry
	                } else { // use worker

	                    var workers = [];
	                    if (type < 0)
	                        type = 0; // negative reserved for atom data
	                    for (i = 0, il = numWorkers; i < il; i++) {
	                        // var w = new Worker('3Dmol/SurfaceWorker.js');
	                        var w = new Worker($3Dmol.SurfaceWorker);
	                        workers.push(w);
	                        w.postMessage({
	                            'type' : -1,
	                            'atoms' : reducedAtoms,
	                            'volume' : totalVol
	                        });
	                    }
	                    var cnt = 0;

	                    var rfunction = function(event) {
	                        var VandFs = $3Dmol.splitMesh({vertexArr:event.data.vertices,
								                           faceArr:event.data.faces});
						    for(var i=0,vl=VandFs.length;i<vl;i++){
	                            var VandF={vertices:VandFs[i].vertexArr,
									       faces:VandFs[i].faceArr};
	                            var mesh = generateSurfaceMesh(atomlist, VandF, mat);
	                            $3Dmol.mergeGeos(surfobj.geo, mesh);
	                            _viewer.render();
							}

	                    //    console.log("async mesh generation " + (+new Date() - time) + "ms");
	                        cnt++;
	                        if (cnt == extents.length)
	                            surfobj.done = true;
	                    };

	                    var efunction = function(event) {
	                        console.log(event.message + " (" + event.filename + ":" + event.lineno + ")");
	                    };

	                    for (i = 0; i < extents.length; i++) {
	                        var worker = workers[i % workers.length];
	                        worker.onmessage = rfunction;

	                        worker.onerror = efunction;

	                        worker.postMessage({
	                            'type' : type,
	                            'expandedExtent' : extents[i].extent,
	                            'extendedAtoms' : extents[i].atoms,
	                            'atomsToShow' : extents[i].toshow
	                        });
	                    }
	                }

	                // NOTE: This is misleading if 'async' mesh generation - returns
	                // immediately
	                //console.log("full mesh generation " + (+new Date() - time) + "ms");
	            }
	            
	            style = style || {};
	            var mat = getMatWithStyle(style);
	            var surfobj = [];
	            
	            if (symmetries) { //do preprocessing
	                var modelsAtomList = {};
	                var modelsAtomsToShow = {};
	                for (n = 0; n < models.length; n++) {
	                    modelsAtomList[n] = [];
	                    modelsAtomsToShow[n] = [];
	                }
	                for (n = 0; n < atomlist.length; n++) {
	                    modelsAtomList[atomlist[n].model].push(atomlist[n]);
	                }
	                for (n = 0; n < atomsToShow.length; n++) {
	                    modelsAtomsToShow[atomsToShow[n].model].push(atomsToShow[n]);
	                }
	                for (n = 0; n < models.length; n++) {
	                    surfobj.push({
	                        geo : new $3Dmol.Geometry(true),
	                        mat : mat,
	                        done : false,
	                        finished : false,
	                        symmetries : models[n].getSymmetries()
	                    // also webgl initialized
	                    });
	                    addSurfaceHelper(surfobj[n], modelsAtomList[n], modelsAtomsToShow[n]);
	                }
	            }
	            else {
	                surfobj.push({
	                    geo : new $3Dmol.Geometry(true),
	                    mat : mat,
	                    done : false,
	                    finished : false,
	                    symmetries : [new $3Dmol.Matrix4()]
	                });
	                addSurfaceHelper(surfobj[surfobj.length-1], atomlist, atomsToShow);
	            } 
	            var surfid = nextSurfID();
	            surfaces[surfid] = surfobj;
	            
	            return surfid;

	        };

	        /**
	         * Set the surface material to something else, must render change
	        *  @function $3Dmol.GLViewer#setSurfaceMaterialStyle
	         * @param {number} surf - Surface ID to apply changes to
	         * @param {matSpec} style - new material style specification
	         */ 
	        this.setSurfaceMaterialStyle = function(surf, style) {
	            if (surfaces[surf]) {
	                surfArr = surfaces[surf];
	                for (var i = 0; i < surfArr.length; i++) {
	                    surfArr[i].mat = getMatWithStyle(style);
	                    surfArr[i].mat.side = $3Dmol.FrontSide;
	                    surfArr[i].finished = false; // trigger redraw
	                }
	            }
	            return this;
	        };

	        /**
	         * Remove surface with given ID
	         * @function $3Dmol.GLViewer#removeSurface
	         * @param {number} surf - surface id
	         */
	        this.removeSurface = function(surf) {
	            var surfArr = surfaces[surf];
	            for (var i = 0; i < surfArr.length; i++) {
	                if (surfArr[i] && surfArr[i].lastGL) {
	                    if (surfArr[i].geo !== undefined)
	                        surfArr[i].geo.dispose();
	                    if (surfArr[i].mat !== undefined)
	                        surfArr[i].mat.dispose();
	                    modelGroup.remove(surfArr[i].lastGL); // remove from scene
	                }
	            }
	            delete surfaces[surf];
	            show();
	            return this;
	        };
	        
	        /** Remove all surfaces.
	         * @function $3Dmol.GLViewer#removeAllSurfaces */
	        this.removeAllSurfaces = function() {
	            for (n in  surfaces) {
	                if(!surfaces.hasOwnProperty(n)) continue;
	                var surfArr = surfaces[n];
	                for(var i = 0; i < surfArr.length; i++) {
	                    if (surfArr[i] && surfArr[i].lastGL) {
	                        if (surfArr[i].geo !== undefined)
	                            surfArr[i].geo.dispose();
	                        if (surfArr[i].mat !== undefined)
	                            surfArr[i].mat.dispose();
	                        modelGroup.remove(surfArr[i].lastGL); // remove from scene
	                    }
	                }
	                delete surfaces[n];
	            }
	            show();
	            return this;
	        };

	        /** return Jmol moveto command to position this scene */
	        this.jmolMoveTo = function() {
	            var pos = modelGroup.position;
	            // center on same position
	            var ret = "center { " + (-pos.x) + " " + (-pos.y) + " " + (-pos.z)
	                    + " }; ";
	            // apply rotation
	            var q = rotationGroup.quaternion;
	            ret += "moveto .5 quaternion { " + q.x + " " + q.y + " " + q.z
	                    + " " + q.w + " };";
	            // zoom is tricky.. maybe i would be best to let callee zoom on
	            // selection?
	            // can either do a bunch of math, or maybe zoom to the center with a
	            // fixed
	            // but reasonable percentage

	            return ret;
	        };

	        /** Clear scene of all objects 
	         * @function $3Dmol.GLViewer#clear
	         * */
	        this.clear = function() {
	            this.removeAllSurfaces();
	            this.removeAllModels();
	            this.removeAllLabels();
	            this.removeAllShapes();
	            show();
	            return this;
	        };

	        // props is a list of objects that select certain atoms and enumerate
	        // properties for those atoms
	        /**
	         * @function $3Dmol.GLViewer#mapAtomProperties
	         * Add specified properties to all atoms matching input argument
	         * @function $3Dmol.GLViewer#mapAtomProperties
	         * @param {Object} props, either array of atom selectors with associated props, or function that takes atom and sets its properties
	         * @param {AtomSelectionSpec} sel
	         */
	        this.mapAtomProperties = function(props, sel) {
	            sel = sel || {};
	            var atoms = getAtomsFromSel(sel);
	            
	            if(typeof(props) == "function") {
	                for (var a = 0, numa = atoms.length; a < numa; a++) {
	                    var atom = atoms[a];
	                    props(atom);
	                }
	            }
	            else {
	                for (var a = 0, numa = atoms.length; a < numa; a++) {
	                    var atom = atoms[a];
	                    for (var i = 0, n = props.length; i < n; i++) {
	                        var prop = props[i];
	                        if (prop.props) {
	                            for ( var p in prop.props) {
	                                if (prop.props.hasOwnProperty(p)) {
	                                    // check the atom
	                                    if (atomIsSelected(atom, prop)) {
	                                        if (!atom.properties)
	                                            atom.properties = {};
	                                        atom.properties[p] = prop.props[p];
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return this;
	        };

	        /**
	         * @function $3Dmol.GLViewer#linkViewer
	         * Synchronize this view matrix of this viewer to the passed viewer.
	         * When the viewpoint of this viewer changes, the other viewer will
	         * be set to this viewer's view.
	         * @function $3Dmol.GLViewer#linkViewer
	         */
	        this.linkViewer = function(otherviewer) {
	           linkedViewers.push(otherviewer);
	           return this;
	        };
	        

	        try {
	            if (typeof (callback) === "function")
	                callback(this);
	        } catch (e) {
	            // errors in callback shouldn't invalidate the viewer
	            console.log("error with glviewer callback: " + e);
	        }
	    }

	    return GLViewer;

	})();

	$3Dmol['glmolViewer'] = $3Dmol.GLViewer;
	//color scheme mappings
	var $3Dmol = $3Dmol || {};

	/** Color mapping gradiens
	 * @interface
	 * @param {number} min
	 * @param {number} max
	 */
	$3Dmol.Gradient = function(min, max) {};

	/**
	 * Map value to hex color
	 * @param {number} val
	 * @param {number} range
	 * @returns {number}
	 */
	$3Dmol.Gradient.valueToHex = function(val, range) {};
	//return range used for color mapping, null if none set
	$3Dmol.Gradient.range = function() {};



	/**
	 * Color scheme red to white to blue, for charges
	 * @constructor
	 * @implements {$3Dmol.Gradient}
	 */
	$3Dmol.Gradient.RWB = function(min, max,mid) {
	    var mult = 1.0;
	    if(typeof(max) == 'undefined' && $.isArray(min) && min.length >= 2) {
	        //we were passed a single range
	        max = min[1];
	        min = min[0];
	    }
	    if(max < min) { //reverse the order
	        mult = -1.0;
	        min *= -1.0;
	        max *= -1.0;
	    }
	        
	    //map value to hex color, range is provided
	    this.valueToHex = function(val, range) {
	        var lo, hi;
	        val = mult*val; //reverse if necessary
	        if(range) {
	            lo = range[0];
	            hi = range[1];
	        }
	        else {
	            lo = min;
	            hi = max;
	        }
	    
	        if(val === undefined)
	            return 0xffffff;
	        
	        if(val < lo) val = lo;
	        if(val > hi) val = hi;
	        
	        var middle = (hi+lo)/2;
	        if(typeof(mid) != 'undefined')
	            middle = mid; //allow user to specify midpoint
	        var scale, color;
	        
	        //scale bottom from red to white
	        if(val <= middle) {
	            scale = Math.floor(255*Math.sqrt((val-lo)/(middle-lo)));
	            color = 0xff0000 + 0x100*scale + scale;
	            return color;
	        }
	        else { //form white to blue
	            scale = Math.floor(255*Math.sqrt((1-(val-middle)/(hi-middle))));
	            color =  0x10000*scale+0x100*scale+0xff;
	            return color;
	        }
	    };
	    

	    //return range used for color mapping, null if none set
	    this.range = function() {
	        if(typeof(min) != "undefined" && typeof(max) != "undefined") {
	            return [min,max];
	        }
	        return null;
	    };

	};

	/**
	 * rainbow gradient, but without purple to match jmol
	 * @constructor
	 * @implements {$3Dmol.Gradient}
	 */
	$3Dmol.Gradient.ROYGB = function(min, max) {
	    var mult = 1.0;
	    if(typeof(max) == 'undefined' && $.isArray(min) && min.length >= 2) {
	        //we were passed a single range
	        max = min[1];
	        min = min[0];
	    }
	    if(max < min) { //reverse the order
	        mult = -1.0;
	        min *= -1.0;
	        max *= -1.0;
	    }
	    
	    //map value to hex color, range is provided
	    this.valueToHex = function(val, range) {
	        var lo, hi;
	        val = mult*val;
	        if(range) {
	            lo = range[0];
	            hi = range[1];
	        }
	        else {
	            lo = min;
	            hi = max;
	        }
	    
	        if(typeof(val) == "undefined")
	            return 0xffffff;
	        
	        if(val < lo) val = lo;
	        if(val > hi) val = hi;
	        
	        var mid = (lo+hi)/2;
	        var q1 = (lo+mid)/2;
	        var q3 = (mid+hi)/2;
	        
	        var scale, color;
	        
	        if(val < q1) { //scale green up, red up, blue down
	            scale = Math.floor(255*Math.sqrt((val-lo)/(q1-lo)));
	            color = 0xff0000 + 0x100*scale + 0;
	            return color;
	        }
	        else if(val < mid) { //scale red down, green up, blue down
	            scale = Math.floor(255*Math.sqrt((1-(val-q1)/(mid-q1))));
	            color =  0x010000*scale+0xff00+0x0;
	            return color;
	        }
	        else if(val < q3) { //scale blue up, red down, green up
	            scale = Math.floor(255*Math.sqrt((val-mid)/(q3-mid)));
	            color = 0x000000 + 0xff00 + 0x1*scale;
	            return color;
	        }
	        else { //scale green down, blue up, red down
	            scale = Math.floor(255*Math.sqrt((1-(val-q3)/(hi-q3))));
	            color =  0x000000+0x0100*scale+0xff;
	            return color;
	        }        
	    };
	   

	    //return range used for color mapping, null if none set
	    this.range = function() {
	        if(typeof(min) != "undefined" && typeof(max) != "undefined") {
	            return [min,max];
	        }
	        return null;
	    };

	};

	/**
	 * rainbow gradient with constant saturation, all the way to purple!
	 * @constructor
	 * @implements {$3Dmol.Gradient}
	 */
	$3Dmol.Gradient.Sinebow = function(min, max) {
	    var mult = 1.0;
	    if(typeof(max) == 'undefined' && $.isArray(min) && min.length >= 2) {
	        //we were passed a single range
	        max = min[1];
	        min = min[0];
	    }
	    if(max < min) { //reverse the order
	        mult = -1.0;
	        min *= -1.0;
	        max *= -1.0;
	    }
	    //map value to hex color, range is provided
	    this.valueToHex = function(val, range) {
	        var lo, hi;
	        val = mult*val;
	        if(range) {
	            lo = range[0];
	            hi = range[1];
	        }
	        else {
	            lo = min;
	            hi = max;
	        }
	    
	        if(typeof(val) == "undefined")
	            return 0xffffff;
	        
	        if(val < lo) val = lo;
	        if(val > hi) val = hi;
	        
	        var scale = (val-lo)/(hi-lo);
	        var h = (5*scale/6.0+0.5);
	        var r = Math.sin(Math.PI*h);
	        r *= r*255;
	        var g = Math.sin(Math.PI*(h+1/3.0));
	        g *= g*255;
	        var b = Math.sin(Math.PI*(h+2/3.0));
	        b *= b*255;
	        
	        return 0x10000*Math.floor(r)+0x100*Math.floor(b)+0x1*Math.floor(g);
	    };
	    

	    //return range used for color mapping, null if none set
	    this.range = function() {
	        if(typeof(min) != "undefined" && typeof(max) != "undefined") {
	            return [min,max];
	        }
	        return null;
	    };

	};
	//Adapted from the text sprite example from http://stemkoski.github.io/Three.js/index.html

	$3Dmol.LabelCount = 0;

	/**
	 * Renderable labels
	 * @constructor $3Dmol.Label
	 * @param {string} tag - Label text
	 * @param {LabelSpec} parameters Label style and font specifications
	 */
	$3Dmol.Label = function(text, parameters) {

	    this.id = $3Dmol.LabelCount++;
	    this.stylespec = parameters || {};

	    this.canvas = document.createElement('canvas');
	    //todo: implement resizing canvas..
	    this.canvas.width = 134;
	    this.canvas.height = 35;
	    this.context = this.canvas.getContext('2d');
	    this.sprite = new $3Dmol.Sprite();
	    this.text = text;

	};

	$3Dmol.Label.prototype = {

	    constructor : $3Dmol.Label,

	    getStyle : function () { return this.stylespec; }, 
	    
	    setContext : function() {
	        // function for drawing rounded rectangles - for Label drawing
	        var roundRect = function(ctx, x, y, w, h, r, drawBorder) {

	            ctx.beginPath();
	            ctx.moveTo(x + r, y);
	            ctx.lineTo(x + w - r, y);
	            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
	            ctx.lineTo(x + w, y + h - r);
	            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
	            ctx.lineTo(x + r, y + h);
	            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
	            ctx.lineTo(x, y + r);
	            ctx.quadraticCurveTo(x, y, x + r, y);
	            ctx.closePath();
	            ctx.fill();
	            if(drawBorder)
	                ctx.stroke();

	        };
	        
	        //do all the checks to figure out what color is desired
	        var getColor = function(style, stylealpha, init) {
	            var ret = init;
	            if(typeof(style) != 'undefined') {
	                //convet regular colors
	                 if(style instanceof $3Dmol.Color) 
	                     ret = style.scaled();
	                 else //hex or name
	                    ret = $3Dmol.CC.color(style).scaled();                    
	            }
	            if(typeof(stylealpha) != 'undefined') {
	                ret.a = parseFloat(stylealpha);
	            }
	            return ret;
	        }

	        /**
	         * Label type specification
	         * @typedef LabelSpec
	         * @struct
	         * @prop {string} font - font name, default sans-serif
	         * @prop {number} fontSize - height of text, default 18
	         * @prop {ColorSpec} fontColor - font color, default white
	         * @prop {number} fontOpacity - font opacity, default 1
	         * @prop {number} borderThickness - line width of border around label, default 0
	         * @prop {ColorSpec} borderColor - color of border, default backgroundColor
	         * @prop {string} borderOpacity - color of border
	         * @prop {ColorSpec} backgroundColor - color of background, default black
	         * @prop {string} backgroundOpacity - opacity of background, default 1
	         * @prop {Object} position - x,y,z coordinates for label
	         * @prop {boolean} inFront - always put labels in from of model
	         * @prop {boolean} showBackground - show background rounded rectangle, default true
	         */
	        return function() {
	            
	            var style = this.stylespec;
	            var useScreen =  typeof(style.useScreen) == "undefined" ? false : style.useScreen;
	            
	            var showBackground = style.showBackground;
	            if(showBackground === '0' || showBackground === 'false') showBackground = false;
	            if(typeof(showBackground) == "undefined") showBackground = true; //default
	            var font = style.font ? style.font : "sans-serif";

	            var fontSize = parseInt(style.fontSize) ? parseInt(style.fontSize) : 18;

	            var fontColor = getColor(style.fontColor, style.fontOpacity,
	                     {
	                        r : 255,
	                        g : 255,
	                        b : 255,
	                        a : 1.0
	                    });

	            var padding = style.padding ? style.padding : 4;
	            var borderThickness = style.borderThickness ? style.borderThickness
	                    : 0;
	    
	            var backgroundColor = getColor(style.backgroundColor, style.backgroundOpacity, 
	                     {
	                        r : 0,
	                        g : 0,
	                        b : 0,
	                        a : 1.0
	                    });
	                    
	            var borderColor = getColor(style.borderColor, style.borderOpacity, backgroundColor);

	                    
	            var position = style.position ? style.position
	                    : {
	                        x : -10,
	                        y : 1,
	                        z : 1
	                    };
	                    
	            // Should labels always be in front of model?
	            var inFront = (style.inFront !== undefined) ? style.inFront    : true;
	            if(inFront === 'false' || inFront === '0') inFront = false;

	            // clear canvas

	            var spriteAlignment = style.alignment || $3Dmol.SpriteAlignment.topLeft;

	            var bold = "";
	            if(style.bold)
	                bold = "bold ";
	            this.context.font = bold+fontSize + "px  " + font;

	            var metrics = this.context.measureText(this.text);
	            var textWidth = metrics.width;
	            
	            if(!showBackground) borderThickness = 0;
	        
	            var width = textWidth+2.5*borderThickness +2*padding;
	            var height = fontSize*1.25+2*borderThickness+2*padding;            // 1.25 is extra height factor for text below baseline: g,j,p,q.

	            
	            if(style.backgroundImage) {
	                var img = style.backgroundImage;
	                var w = style.backgroundWidth ? style.backgroundWidth : img.width;
	                var h = style.backgroundHeight ? style.backgroundHeight : img.height;
	                if(w > width) width = w;
	                if(h > height) height = h;
	            }

	            this.canvas.width = width;
	            this.canvas.height = height;
	            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

	            var bold = "";
	            if(style.bold)
	                bold = "bold ";
	            this.context.font = bold+fontSize + "px  " + font;

	            // background color
	            this.context.fillStyle = "rgba(" + backgroundColor.r + ","
	                    + backgroundColor.g + "," + backgroundColor.b
	                    + "," + backgroundColor.a + ")";
	            // border color
	            this.context.strokeStyle = "rgba(" + borderColor.r + ","
	                    + borderColor.g + "," + borderColor.b + ","
	                    + borderColor.a + ")";

	            this.context.lineWidth = borderThickness;
	            if(showBackground) {
	                roundRect(this.context, borderThickness,borderThickness , width-2*borderThickness,height-2*borderThickness, 6, borderThickness > 0);
	            }
	            
	            if(style.backgroundImage) {
	                var img = style.backgroundImage;
	                var w = style.backgroundWidth ? style.backgroundWidth : img.width;
	                var h = style.backgroundHeight ? style.backgroundHeight : img.height;
	                this.context.drawImage(img,0,0, w, h);
	            }
	            

	            // text color
	            this.context.fillStyle = "rgba(" + fontColor.r + ","
	                    + fontColor.g + "," + fontColor.b + ","
	                    + fontColor.a + ")";
	            
	            this.context.fillText(this.text, borderThickness+padding,
	                    fontSize + borderThickness+padding, textWidth);

	            // canvas contents will be used for a texture
	            var texture = new $3Dmol.Texture(this.canvas);
	            texture.needsUpdate = true;
	            this.sprite.material = new $3Dmol.SpriteMaterial({
	                map : texture,
	                useScreenCoordinates : useScreen,
	                alignment : spriteAlignment,
	                depthTest : !inFront
	            });

	            this.sprite.scale.set(1,1,1);

	            this.sprite.position.set(position.x, position.y, position.z);
	        };

	    }(),

	    // clean up material and texture
	    dispose : function() {

	        if (this.sprite.material.map !== undefined)
	            this.sprite.material.map.dispose();
	        if (this.sprite.material !== undefined)
	            this.sprite.material.dispose();
	    }

	};

	$3Dmol = $3Dmol || {};
	//Encapsulate marching cube algorithm for isosurface generation
	// (currently used by protein surface rendering and generic volumetric data reading)
	$3Dmol.MarchingCubeInitializer = function() {
	    
	    //Marching cube algorithm - assume data has been pre-treated so isovalue is 0 
	    // (i.e. select points greater than 0)
	    //origin -  vector of origin of volumetric data (default is (0,0,0))
	    // nX, nY, nZ - specifies number of voxels in each dimension
	    // scale - cube diagonal unit vector scale (3Dmol vector) (specifying distance between data points); diagonal of cube
	    // - default is 1 - assumes unit cube (1,1,1) diag)
	    // fulltable - if true, use full marching cubes and tritables - else use trimmed table (e.g. surf render)
	    // voxel - if true, draws with a blocky voxel style (default false)
	    // verts, faces - vertex and face arrays to fill up
	    
	    //to match with protein surface...
	    var ISDONE = 2;
	    var my = {};
	    
	    my.march = function(data, verts, faces, spec) {

	        var fulltable = !!(spec.fulltable);
	        var origin = (spec.hasOwnProperty('origin') && spec.origin.hasOwnProperty('x')) ? spec.origin : {x:0, y:0, z:0};
	        var voxel = !!(spec.voxel);
	        var transform = spec.matrix; //if this is set, it overrides origin and unitCube
	        
	        var nX = spec.nX || 0;
	        var nY = spec.nY || 0;
	        var nZ = spec.nZ || 0;
	        
	        var scale = spec.scale || 1.0;
	        var unitCube = null;
	        if(spec.unitCube) {
	            unitCube = spec.unitCube;
	        } else {
	            unitCube = {x:scale,y:scale,z:scale};
	        }
	        
	        //keep track of calculated vertices to avoid repeats
	        var vertnums = new Int32Array(nX*nY*nZ);
	        
	        var i, il;
	        
	        for (i = 0, il = vertnums.length; i < il; ++i)
	            vertnums[i] = -1;

	        // create (or retrieve) a vertex at the appropriate point for
	        // the edge (p1,p2)
	        
	        var getVertex = function(i, j, k, code, p1, p2) {
	            var pt = {x:0,y:0,z:0};
	            var val1 = !!(code & (1 << p1));
	            var val2 = !!(code & (1 << p2));
	             
	            // p1 if they are the same or if !val1
	            var p = p1;
	            if (!val1 && val2)
	                p = p2;
	            
	            // adjust i,j,k by p
	            if (p & 1)
	                k++;
	            if (p & 2)
	                j++;
	            if (p & 4)
	                i++;

	            if(transform) {
	                pt = new $3Dmol.Vector3(i,j,k);
	                pt = pt.applyMatrix4(transform);
	                pt = {x: pt.x, y: pt.y, z: pt.z}; //remove vector gunk
	            } else {
	                pt.x = origin.x+unitCube.x*i;
	                pt.y = origin.y+unitCube.y*j;
	                pt.z = origin.z+unitCube.z*k;
	            }
	            
	            var index = ((nY * i) + j) * nZ + k;
	            
	            //Have to add option to do voxels
	            if (!voxel) {
	            
	                if (vertnums[index] < 0) // not created yet
	                {
	                    vertnums[index] = verts.length;
	                    verts.push( pt );
	                }
	                return vertnums[index];
	            
	            }
	            
	            else {
	                verts.push(pt);
	                return verts.length - 1;
	            }
	            
	        };
	            
	        var intersects = new Int32Array(12);
	        
	        var etable = (fulltable) ? edgeTable2 : edgeTable;
	        var tritable = (fulltable) ? triTable2 : triTable;
	                
	        //Run marching cubes algorithm
	        for (i = 0; i < nX-1; ++i) {
	            
	            for (var j = 0; j < nY-1; ++j){
	                
	                for (var k = 0; k < nZ-1; ++k){
	                    
	                    var code = 0;
	                    
	                    for (var p = 0; p < 8; ++p) {
	                        var index = ((nY * (i + ((p & 4) >> 2))) + j + ((p & 2) >> 1)) *
	                                        nZ + k + (p & 1);

	                        //TODO: Need to fix vpBits in protein surface for this to work
	                        var val = !!(data[index] & ISDONE);
	                        //var val = !!(data[index] > 0);   
	                        
	                        code |= val << p;                        
	                    }
	                    
	                    if (code === 0 || code === 255)
	                        continue;
	                    
	                    var ecode = etable[code];
	                    
	                    if (ecode === 0)
	                        continue;
	                        
	                    var ttable = tritable[code];                        
	                    
	                    if (ecode & 1)
	                        intersects[0] = getVertex(i, j, k, code, 0, 1);
	                    if (ecode & 2)
	                        intersects[1] = getVertex(i, j, k, code, 1, 3);
	                    if (ecode & 4)
	                        intersects[2] = getVertex(i, j, k, code, 3, 2);
	                    if (ecode & 8)
	                        intersects[3] = getVertex(i, j, k, code, 2, 0);
	                    if (ecode & 16)
	                        intersects[4] = getVertex(i, j, k, code, 4, 5);
	                    if (ecode & 32)
	                        intersects[5] = getVertex(i, j, k, code, 5, 7);
	                    if (ecode & 64)
	                        intersects[6] = getVertex(i, j, k, code, 7, 6);
	                    if (ecode & 128)
	                        intersects[7] = getVertex(i, j, k, code, 6, 4);
	                    if (ecode & 256)
	                        intersects[8] = getVertex(i, j, k, code, 0, 4);
	                    if (ecode & 512)
	                        intersects[9] = getVertex(i, j, k, code, 1, 5);
	                    if (ecode & 1024)
	                        intersects[10] = getVertex(i, j, k, code, 3, 7);
	                    if (ecode & 2048)
	                        intersects[11] = getVertex(i, j, k, code, 2, 6);       

	                    for (var t = 0; t < ttable.length; t += 3) {
	                        
	                        var a = intersects[ttable[t]],
	                            b = intersects[ttable[t+1]],
	                            c = intersects[ttable[t+2]];         
	                                           
	                        if (voxel && t >= 3) {
	                            verts.push(verts[a]); a = verts.length - 1;
	                            verts.push(verts[b]); b = verts.length - 1;
	                            verts.push(verts[c]); c = verts.length - 1;
	                        }

	                        
	                        faces.push(a); faces.push(b); faces.push(c);                               
	                    }              
	                    
	                }
	                
	            }
	            
	        }
	             
	        
	    };

	    my.laplacianSmooth = function(numiter, verts, faces) {
	            var tps = new Array(verts.length);
	            var i, il, j, jl, k, kl;
	            for (i = 0, il = verts.length; i < il; i++)
	                    tps[i] = {
	                        x : 0,
	                        y : 0,
	                        z : 0
	                    };
	            var vertdeg = new Array(20);
	            var flagvert;
	            for (i = 0; i < 20; i++)
	                    vertdeg[i] = new Array(verts.length);
	            for (i = 0, il = verts.length; i < il; i++)
	                    vertdeg[0][i] = 0;
	            for (i = 0, il = faces.length / 3; i < il; i++) {
	                var aoffset = i*3, boffset = i*3 + 1, coffset = i*3 + 2;
	                flagvert = true;
	                for (j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {
	                    if (faces[boffset] == vertdeg[j + 1][faces[aoffset]]) {
	                        flagvert = false;
	                        break;
	                    }
	                }
	                if (flagvert) {
	                    vertdeg[0][faces[aoffset]]++;
	                    vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[boffset];
	                }
	                flagvert = true;
	                for (j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {
	                    if (faces[coffset] == vertdeg[j + 1][faces[aoffset]]) {
	                        flagvert = false;
	                        break;
	                    }
	                }
	                if (flagvert) {
	                    vertdeg[0][faces[aoffset]]++;
	                    vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[coffset];
	                }
	                // b
	                flagvert = true;
	                for (j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {
	                    if (faces[aoffset] == vertdeg[j + 1][faces[boffset]]) {
	                        flagvert = false;
	                        break;
	                    }
	                }
	                if (flagvert) {
	                    vertdeg[0][faces[boffset]]++;
	                    vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[aoffset];
	                }
	                flagvert = true;
	                for (j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {
	                    if (faces[coffset] == vertdeg[j + 1][faces[boffset]]) {
	                        flagvert = false;
	                        break;
	                    }
	                }
	                if (flagvert) {
	                    vertdeg[0][faces[boffset]]++;
	                    vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[coffset];
	                }
	                // c
	                flagvert = true;
	                for (j = 0; j < vertdeg[0][faces[coffset]]; j++) {
	                    if (faces[aoffset] == vertdeg[j + 1][faces[coffset]]) {
	                        flagvert = false;
	                        break;
	                    }
	                }
	                if (flagvert) {
	                    vertdeg[0][faces[coffset]]++;
	                    vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[aoffset];
	                }
	                flagvert = true;
	                for (j = 0, jl = vertdeg[0][faces[coffset]]; j < jl; j++) {
	                    if (faces[boffset] == vertdeg[j + 1][faces[coffset]]) {
	                        flagvert = false;
	                        break;
	                    }
	                }
	                if (flagvert) {
	                    vertdeg[0][faces[coffset]]++;
	                    vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[boffset];
	                }
	            }

	            var wt = 1.00;
	            var wt2 = 0.50;
	            var ssign;
	            var scaleFactor = 1;
	            var outwt = 0.75 / (scaleFactor + 3.5); // area-preserving
	            for (k = 0; k < numiter; k++) {
	                    for (i = 0, il = verts.length; i < il; i++) {
	                            if (vertdeg[0][i] < 3) {
	                                    tps[i].x = verts[i].x;
	                                    tps[i].y = verts[i].y;
	                                    tps[i].z = verts[i].z;
	                            } else if (vertdeg[0][i] == 3 || vertdeg[0][i] == 4) {
	                                    tps[i].x = 0;
	                                    tps[i].y = 0;
	                                    tps[i].z = 0;
	                                    for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {
	                                            tps[i].x += verts[vertdeg[j + 1][i]].x;
	                                            tps[i].y += verts[vertdeg[j + 1][i]].y;
	                                            tps[i].z += verts[vertdeg[j + 1][i]].z;
	                                    }
	                                    tps[i].x += wt2 * verts[i].x;
	                                    tps[i].y += wt2 * verts[i].y;
	                                    tps[i].z += wt2 * verts[i].z;
	                                    tps[i].x /= wt2 + vertdeg[0][i];
	                                    tps[i].y /= wt2 + vertdeg[0][i];
	                                    tps[i].z /= wt2 + vertdeg[0][i];
	                            } else {
	                                    tps[i].x = 0;
	                                    tps[i].y = 0;
	                                    tps[i].z = 0;
	                                    for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {
	                                            tps[i].x += verts[vertdeg[j + 1][i]].x;
	                                            tps[i].y += verts[vertdeg[j + 1][i]].y;
	                                            tps[i].z += verts[vertdeg[j + 1][i]].z;
	                                    }
	                                    tps[i].x += wt * verts[i].x;
	                                    tps[i].y += wt * verts[i].y;
	                                    tps[i].z += wt * verts[i].z;
	                                    tps[i].x /= wt + vertdeg[0][i];
	                                    tps[i].y /= wt + vertdeg[0][i];
	                                    tps[i].z /= wt + vertdeg[0][i];
	                            }
	                    }
	                    for (i = 0, il = verts.length; i < il; i++) {
	                            verts[i].x = tps[i].x;
	                            verts[i].y = tps[i].y;
	                            verts[i].z = tps[i].z;
	                    }
	                    /*
	                     * computenorm(); for (var i = 0; i < vertnumber; i++) { if
	                     * (verts[i].inout) ssign = 1; else ssign = -1; verts[i].x += ssign *
	                     * outwt * verts[i].pn.x; verts[i].y += ssign * outwt *
	                     * verts[i].pn.y; verts[i].z += ssign * outwt * verts[i].pn.z; }
	                     */
	            }
	    };


	    /*
	     * These tables are based off those by Paul Bourke and Geoffrey Heller:
	     * http://paulbourke.net/geometry/polygonise/
	     * http://paulbourke.net/geometry/polygonise/table2.txt
	     * 
	     * However, they have been substantially modified to reflect a more 
	     * sensible corner numbering scheme and the discrete nature of our voxel data
	     * (resulting in fewer faces).
	     */
	    my.edgeTable = [ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	            0xb00, 0x0, 0x0, 0x0, 0x700, 0x0, 0xd00, 0xe00, 0xf00, 0x0, 0x0, 0x0,
	            0x8a, 0x0, 0x15, 0x0, 0x86, 0x0, 0x0, 0x0, 0x28c, 0x0, 0x813, 0xf19,
	            0xe10, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0x126, 0x0, 0x0, 0x15, 0x1c,
	            0x0, 0xf23, 0x419, 0xd20, 0x0, 0xa8, 0xa2, 0xaa, 0x0, 0x285, 0x9ab,
	            0x8a2, 0x0, 0x2af, 0x125, 0xac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x0, 0x0,
	            0x0, 0x0, 0x0, 0x45, 0x0, 0x384, 0x0, 0x0, 0x0, 0x700, 0x8a, 0x83,
	            0x648, 0x780, 0x0, 0x51, 0x0, 0x81a, 0x54, 0x55, 0x54, 0x56, 0x0, 0x51,
	            0x0, 0xe5c, 0x14a, 0x451, 0x759, 0x650, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x45,
	            0x0, 0x1f6, 0x0, 0x0, 0x15, 0xdfc, 0x8a, 0x7f3, 0x4f9, 0x5f0, 0xb00,
	            0x68, 0x921, 0x6a, 0x348, 0x245, 0x16f, 0x66, 0xb00, 0xe6f, 0xd65,
	            0xc6c, 0x76a, 0x663, 0x569, 0x460, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	            0xf46, 0x0, 0x0, 0x45, 0x24c, 0x2a, 0x823, 0x29, 0xb40, 0x0, 0x0, 0x0,
	            0x6ba, 0x0, 0x8f5, 0xfff, 0xef6, 0x0, 0xff, 0x2f5, 0x2fc, 0x9ea, 0x8f3,
	            0xbf9, 0xaf0, 0x0, 0x0, 0x51, 0x152, 0x0, 0xf55, 0x45f, 0xd56, 0x54,
	            0x357, 0x55, 0x154, 0x852, 0xb53, 0x59, 0x950, 0x700, 0x2c8, 0xc2,
	            0x48a, 0xfc4, 0xec5, 0xdcf, 0xcc6, 0x2c4, 0x2cf, 0xc5, 0xcc, 0xbca,
	            0xac3, 0x9c9, 0x8c0, 0x0, 0x0, 0x0, 0x0, 0xa8, 0x1a4, 0xa8, 0x7a6,
	            0xa2, 0xa2, 0x2a4, 0xbac, 0xaa, 0xa3, 0x2a8, 0x3a0, 0xd00, 0xc18,
	            0xd00, 0xe3a, 0x34, 0x35, 0x73f, 0x636, 0x924, 0x83f, 0xb35, 0xa3c,
	            0x12a, 0x33, 0x339, 0x230, 0xe00, 0xe00, 0xc12, 0xd9a, 0x684, 0x795,
	            0x49f, 0x596, 0x92, 0xb9f, 0x815, 0x99c, 0x9a, 0x393, 0x99, 0x190,
	            0xf00, 0xe08, 0xd01, 0xc0a, 0x704, 0x605, 0x50f, 0x406, 0xb02, 0xa0f,
	            0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0 ];
	    
	    var edgeTable = new Uint32Array(my.edgeTable);
	    
	    var triTable = my.triTable = [ [], [], [], [], [], [], [], [ 11, 9, 8 ], [], [], [],
	            [ 8, 10, 9 ], [], [ 10, 8, 11 ], [ 9, 11, 10 ],
	            [ 8, 10, 9, 8, 11, 10 ], [], [], [], [ 1, 7, 3 ], [], [ 4, 2, 0 ], [],
	            [ 2, 1, 7 ], [], [], [], [ 2, 7, 3, 2, 9, 7 ], [],
	            [ 1, 4, 11, 1, 0, 4 ], [ 3, 8, 0, 11, 9, 4, 11, 10, 9 ],
	            [ 4, 11, 9, 11, 10, 9 ], [], [], [], [ 5, 3, 1 ], [], [], [],
	            [ 2, 5, 8, 2, 1, 5 ], [], [], [ 2, 4, 0 ], [ 3, 2, 4 ], [],
	            [ 0, 9, 1, 8, 10, 5, 8, 11, 10 ], [ 3, 4, 0, 3, 10, 4 ],
	            [ 5, 8, 10, 8, 11, 10 ], [], [ 3, 5, 7 ], [ 7, 1, 5 ],
	            [ 1, 7, 3, 1, 5, 7 ], [], [ 9, 2, 0, 9, 7, 2 ],
	            [ 0, 3, 8, 1, 7, 11, 1, 5, 7 ], [ 11, 1, 7, 1, 5, 7 ], [],
	            [ 9, 1, 0, 5, 3, 2, 5, 7, 3 ], [ 8, 2, 5, 8, 0, 2 ],
	            [ 2, 5, 3, 5, 7, 3 ], [ 3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5 ],
	            [ 9, 1, 0, 10, 7, 11, 10, 5, 7 ], [ 3, 8, 0, 7, 10, 5, 7, 11, 10 ],
	            [ 11, 5, 7, 11, 10, 5 ], [], [], [], [], [], [ 0, 6, 2 ], [],
	            [ 7, 2, 9, 7, 9, 8 ], [], [], [], [ 8, 10, 9 ], [ 7, 1, 3 ],
	            [ 7, 1, 0 ], [ 6, 9, 3, 6, 10, 9 ], [ 7, 10, 8, 10, 9, 8 ], [],
	            [ 6, 0, 4 ], [], [ 11, 1, 4, 11, 3, 1 ], [ 2, 4, 6 ],
	            [ 2, 0, 4, 2, 4, 6 ], [ 2, 4, 6 ], [ 1, 4, 2, 4, 6, 2 ], [],
	            [ 6, 0, 4 ], [], [ 2, 11, 3, 6, 9, 4, 6, 10, 9 ], [ 8, 6, 1, 8, 1, 3 ],
	            [ 10, 0, 6, 0, 4, 6 ], [ 8, 0, 3, 9, 6, 10, 9, 4, 6 ],
	            [ 10, 4, 6, 10, 9, 4 ], [], [], [], [ 5, 3, 1 ], [], [ 0, 6, 2 ], [],
	            [ 7, 4, 8, 5, 2, 1, 5, 6, 2 ], [], [], [ 2, 4, 0 ],
	            [ 7, 4, 8, 2, 11, 3, 10, 5, 6 ], [ 7, 1, 3 ],
	            [ 5, 6, 10, 0, 9, 1, 8, 7, 4 ], [ 5, 6, 10, 7, 0, 3, 7, 4, 0 ],
	            [ 10, 5, 6, 4, 8, 7 ], [ 9, 11, 8 ], [ 3, 5, 6 ],
	            [ 0, 5, 11, 0, 11, 8 ], [ 6, 3, 5, 3, 1, 5 ], [ 3, 9, 6, 3, 8, 9 ],
	            [ 9, 6, 0, 6, 2, 0 ], [ 0, 3, 8, 2, 5, 6, 2, 1, 5 ],
	            [ 1, 6, 2, 1, 5, 6 ], [ 9, 11, 8 ], [ 1, 0, 9, 6, 10, 5, 11, 3, 2 ],
	            [ 6, 10, 5, 2, 8, 0, 2, 11, 8 ], [ 3, 2, 11, 10, 5, 6 ],
	            [ 10, 5, 6, 9, 3, 8, 9, 1, 3 ], [ 0, 9, 1, 5, 6, 10 ],
	            [ 8, 0, 3, 10, 5, 6 ], [ 10, 5, 6 ], [], [], [], [], [], [], [],
	            [ 1, 10, 2, 9, 11, 6, 9, 8, 11 ], [], [], [ 6, 0, 2 ],
	            [ 3, 6, 9, 3, 2, 6 ], [ 3, 5, 1 ], [ 0, 5, 1, 0, 11, 5 ], [ 0, 3, 5 ],
	            [ 6, 9, 11, 9, 8, 11 ], [], [], [], [ 4, 5, 9, 7, 1, 10, 7, 3, 1 ], [],
	            [ 11, 6, 7, 2, 4, 5, 2, 0, 4 ],
	            [ 11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5 ],
	            [ 6, 7, 11, 1, 10, 2, 9, 4, 5 ], [],
	            [ 4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2 ], [ 9, 4, 5, 0, 6, 7, 0, 2, 6 ],
	            [ 4, 5, 9, 6, 3, 2, 6, 7, 3 ], [ 6, 7, 11, 5, 3, 8, 5, 1, 3 ],
	            [ 6, 7, 11, 4, 1, 0, 4, 5, 1 ], [ 4, 5, 9, 3, 8, 0, 11, 6, 7 ],
	            [ 9, 4, 5, 7, 11, 6 ], [], [], [ 0, 6, 4 ], [ 8, 6, 4, 8, 1, 6 ], [],
	            [ 0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6 ],
	            [ 10, 2, 1, 6, 0, 3, 6, 4, 0 ], [ 10, 2, 1, 11, 4, 8, 11, 6, 4 ],
	            [ 4, 2, 6 ], [ 1, 0, 9, 2, 4, 8, 2, 6, 4 ], [ 2, 4, 0, 2, 6, 4 ],
	            [ 8, 2, 4, 2, 6, 4 ], [ 11, 4, 1, 11, 6, 4 ],
	            [ 0, 9, 1, 4, 11, 6, 4, 8, 11 ], [ 3, 6, 0, 6, 4, 0 ],
	            [ 8, 6, 4, 8, 11, 6 ], [ 10, 8, 9 ], [ 6, 3, 9, 6, 7, 3 ], [ 6, 7, 1 ],
	            [ 10, 7, 1, 7, 3, 1 ], [ 7, 11, 6, 8, 10, 2, 8, 9, 10 ],
	            [ 11, 6, 7, 10, 0, 9, 10, 2, 0 ], [ 2, 1, 10, 7, 11, 6, 8, 0, 3 ],
	            [ 1, 10, 2, 6, 7, 11 ], [ 7, 2, 6, 7, 9, 2 ],
	            [ 1, 0, 9, 3, 6, 7, 3, 2, 6 ], [ 7, 0, 6, 0, 2, 6 ],
	            [ 2, 7, 3, 2, 6, 7 ], [ 7, 11, 6, 3, 9, 1, 3, 8, 9 ],
	            [ 9, 1, 0, 11, 6, 7 ], [ 0, 3, 8, 11, 6, 7 ], [ 11, 6, 7 ], [], [], [],
	            [], [ 5, 3, 7 ], [ 8, 5, 2, 8, 7, 5 ], [ 5, 3, 7 ],
	            [ 1, 10, 2, 5, 8, 7, 5, 9, 8 ], [ 1, 7, 5 ], [ 1, 7, 5 ],
	            [ 9, 2, 7, 9, 7, 5 ], [ 11, 3, 2, 8, 5, 9, 8, 7, 5 ],
	            [ 1, 3, 7, 1, 7, 5 ], [ 0, 7, 1, 7, 5, 1 ], [ 9, 3, 5, 3, 7, 5 ],
	            [ 9, 7, 5, 9, 8, 7 ], [ 8, 10, 11 ], [ 3, 4, 10, 3, 10, 11 ],
	            [ 8, 10, 11 ], [ 5, 9, 4, 1, 11, 3, 1, 10, 11 ], [ 2, 4, 5 ],
	            [ 5, 2, 4, 2, 0, 4 ], [ 0, 3, 8, 5, 9, 4, 10, 2, 1 ],
	            [ 2, 1, 10, 9, 4, 5 ], [ 2, 8, 5, 2, 11, 8 ],
	            [ 3, 2, 11, 1, 4, 5, 1, 0, 4 ], [ 9, 4, 5, 8, 2, 11, 8, 0, 2 ],
	            [ 11, 3, 2, 9, 4, 5 ], [ 8, 5, 3, 5, 1, 3 ], [ 5, 0, 4, 5, 1, 0 ],
	            [ 3, 8, 0, 4, 5, 9 ], [ 9, 4, 5 ], [ 11, 9, 10 ], [ 11, 9, 10 ],
	            [ 1, 11, 4, 1, 10, 11 ], [ 8, 7, 4, 11, 1, 10, 11, 3, 1 ],
	            [ 2, 7, 9, 2, 9, 10 ], [ 4, 8, 7, 0, 10, 2, 0, 9, 10 ],
	            [ 2, 1, 10, 0, 7, 4, 0, 3, 7 ], [ 10, 2, 1, 8, 7, 4 ], [ 1, 7, 4 ],
	            [ 3, 2, 11, 4, 8, 7, 9, 1, 0 ], [ 11, 4, 2, 4, 0, 2 ],
	            [ 2, 11, 3, 7, 4, 8 ], [ 4, 1, 7, 1, 3, 7 ], [ 1, 0, 9, 8, 7, 4 ],
	            [ 3, 4, 0, 3, 7, 4 ], [ 8, 7, 4 ], [ 8, 9, 10, 8, 10, 11 ],
	            [ 3, 9, 11, 9, 10, 11 ], [ 0, 10, 8, 10, 11, 8 ],
	            [ 10, 3, 1, 10, 11, 3 ], [ 2, 8, 10, 8, 9, 10 ], [ 9, 2, 0, 9, 10, 2 ],
	            [ 8, 0, 3, 1, 10, 2 ], [ 10, 2, 1 ], [ 1, 11, 9, 11, 8, 9 ],
	            [ 11, 3, 2, 0, 9, 1 ], [ 11, 0, 2, 11, 8, 0 ], [ 11, 3, 2 ],
	            [ 8, 1, 3, 8, 9, 1 ], [ 9, 1, 0 ], [ 8, 0, 3 ], [] ];
	     
	    var edgeTable2 = [ 0x0, 0x109, 0x203, 0x30a, 0x80c, 0x905, 0xa0f,
	            0xb06, 0x406, 0x50f, 0x605, 0x70c, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190,
	            0x99, 0x393, 0x29a, 0x99c, 0x895, 0xb9f, 0xa96, 0x596, 0x49f, 0x795,
	            0x69c, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0xa3c,
	            0xb35, 0x83f, 0x936, 0x636, 0x73f, 0x435, 0x53c, 0xe3a, 0xf33, 0xc39,
	            0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0xbac, 0xaa5, 0x9af, 0x8a6, 0x7a6,
	            0x6af, 0x5a5, 0x4ac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x8c0, 0x9c9, 0xac3,
	            0xbca, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x4ca,
	            0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0x15c, 0x55, 0x35f,
	            0x256, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x55a, 0x453, 0x759, 0x650, 0xaf0,
	            0xbf9, 0x8f3, 0x9fa, 0x2fc, 0x3f5, 0xff, 0x1f6, 0xef6, 0xfff, 0xcf5,
	            0xdfc, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0x36c,
	            0x265, 0x16f, 0x66, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x76a, 0x663, 0x569,
	            0x460, 0x460, 0x569, 0x663, 0x76a, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x66,
	            0x16f, 0x265, 0x36c, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3,
	            0x6fa, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x1f6, 0xff, 0x3f5, 0x2fc, 0x9fa,
	            0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0xe5c, 0xf55, 0xc5f,
	            0xd56, 0x256, 0x35f, 0x55, 0x15c, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0,
	            0x6c9, 0x5c3, 0x4ca, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0x3c6, 0x2cf, 0x1c5,
	            0xcc, 0xbca, 0xac3, 0x9c9, 0x8c0, 0xca0, 0xda9, 0xea3, 0xfaa, 0x4ac,
	            0x5a5, 0x6af, 0x7a6, 0x8a6, 0x9af, 0xaa5, 0xbac, 0xaa, 0x1a3, 0x2a9,
	            0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x53c, 0x435, 0x73f, 0x636, 0x936,
	            0x83f, 0xb35, 0xa3c, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93,
	            0xd9a, 0x69c, 0x795, 0x49f, 0x596, 0xa96, 0xb9f, 0x895, 0x99c, 0x29a,
	            0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0x70c, 0x605, 0x50f,
	            0x406, 0xb06, 0xa0f, 0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0 ];
	     
	    var triTable2 = [ [], [ 8, 3, 0 ], [ 9, 0, 1 ], [ 8, 3, 1, 8, 1, 9 ],
	            [ 11, 2, 3 ], [ 11, 2, 0, 11, 0, 8 ], [ 11, 2, 3, 0, 1, 9 ],
	            [ 2, 1, 11, 1, 9, 11, 11, 9, 8 ], [ 10, 1, 2 ], [ 8, 3, 0, 1, 2, 10 ],
	            [ 9, 0, 2, 9, 2, 10 ], [ 3, 2, 8, 2, 10, 8, 8, 10, 9 ],
	            [ 10, 1, 3, 10, 3, 11 ], [ 1, 0, 10, 0, 8, 10, 10, 8, 11 ],
	            [ 0, 3, 9, 3, 11, 9, 9, 11, 10 ], [ 8, 10, 9, 8, 11, 10 ], [ 8, 4, 7 ],
	            [ 3, 0, 4, 3, 4, 7 ], [ 1, 9, 0, 8, 4, 7 ],
	            [ 9, 4, 1, 4, 7, 1, 1, 7, 3 ], [ 2, 3, 11, 7, 8, 4 ],
	            [ 7, 11, 4, 11, 2, 4, 4, 2, 0 ], [ 3, 11, 2, 4, 7, 8, 9, 0, 1 ],
	            [ 2, 7, 11, 2, 1, 7, 1, 4, 7, 1, 9, 4 ], [ 10, 1, 2, 8, 4, 7 ],
	            [ 2, 10, 1, 0, 4, 7, 0, 7, 3 ], [ 4, 7, 8, 0, 2, 10, 0, 10, 9 ],
	            [ 2, 7, 3, 2, 9, 7, 7, 9, 4, 2, 10, 9 ],
	            [ 8, 4, 7, 11, 10, 1, 11, 1, 3 ],
	            [ 11, 4, 7, 1, 4, 11, 1, 11, 10, 1, 0, 4 ],
	            [ 3, 8, 0, 7, 11, 4, 11, 9, 4, 11, 10, 9 ],
	            [ 7, 11, 4, 4, 11, 9, 11, 10, 9 ], [ 9, 5, 4 ], [ 3, 0, 8, 4, 9, 5 ],
	            [ 5, 4, 0, 5, 0, 1 ], [ 4, 8, 5, 8, 3, 5, 5, 3, 1 ],
	            [ 11, 2, 3, 9, 5, 4 ], [ 9, 5, 4, 8, 11, 2, 8, 2, 0 ],
	            [ 3, 11, 2, 1, 5, 4, 1, 4, 0 ],
	            [ 8, 5, 4, 2, 5, 8, 2, 8, 11, 2, 1, 5 ], [ 2, 10, 1, 9, 5, 4 ],
	            [ 0, 8, 3, 5, 4, 9, 10, 1, 2 ], [ 10, 5, 2, 5, 4, 2, 2, 4, 0 ],
	            [ 3, 4, 8, 3, 2, 4, 2, 5, 4, 2, 10, 5 ],
	            [ 5, 4, 9, 1, 3, 11, 1, 11, 10 ],
	            [ 0, 9, 1, 4, 8, 5, 8, 10, 5, 8, 11, 10 ],
	            [ 3, 4, 0, 3, 10, 4, 4, 10, 5, 3, 11, 10 ],
	            [ 4, 8, 5, 5, 8, 10, 8, 11, 10 ], [ 9, 5, 7, 9, 7, 8 ],
	            [ 0, 9, 3, 9, 5, 3, 3, 5, 7 ], [ 8, 0, 7, 0, 1, 7, 7, 1, 5 ],
	            [ 1, 7, 3, 1, 5, 7 ], [ 11, 2, 3, 8, 9, 5, 8, 5, 7 ],
	            [ 9, 2, 0, 9, 7, 2, 2, 7, 11, 9, 5, 7 ],
	            [ 0, 3, 8, 2, 1, 11, 1, 7, 11, 1, 5, 7 ],
	            [ 2, 1, 11, 11, 1, 7, 1, 5, 7 ], [ 1, 2, 10, 5, 7, 8, 5, 8, 9 ],
	            [ 9, 1, 0, 10, 5, 2, 5, 3, 2, 5, 7, 3 ],
	            [ 5, 2, 10, 8, 2, 5, 8, 5, 7, 8, 0, 2 ],
	            [ 10, 5, 2, 2, 5, 3, 5, 7, 3 ],
	            [ 3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5 ],
	            [ 9, 1, 0, 10, 7, 11, 10, 5, 7 ], [ 3, 8, 0, 7, 10, 5, 7, 11, 10 ],
	            [ 11, 5, 7, 11, 10, 5 ], [ 11, 7, 6 ], [ 0, 8, 3, 11, 7, 6 ],
	            [ 9, 0, 1, 11, 7, 6 ], [ 7, 6, 11, 3, 1, 9, 3, 9, 8 ],
	            [ 2, 3, 7, 2, 7, 6 ], [ 8, 7, 0, 7, 6, 0, 0, 6, 2 ],
	            [ 1, 9, 0, 3, 7, 6, 3, 6, 2 ], [ 7, 6, 2, 7, 2, 9, 2, 1, 9, 7, 9, 8 ],
	            [ 1, 2, 10, 6, 11, 7 ], [ 2, 10, 1, 7, 6, 11, 8, 3, 0 ],
	            [ 11, 7, 6, 10, 9, 0, 10, 0, 2 ],
	            [ 7, 6, 11, 3, 2, 8, 8, 2, 10, 8, 10, 9 ],
	            [ 6, 10, 7, 10, 1, 7, 7, 1, 3 ],
	            [ 6, 10, 1, 6, 1, 7, 7, 1, 0, 7, 0, 8 ],
	            [ 9, 0, 3, 6, 9, 3, 6, 10, 9, 6, 3, 7 ],
	            [ 6, 10, 7, 7, 10, 8, 10, 9, 8 ], [ 8, 4, 6, 8, 6, 11 ],
	            [ 11, 3, 6, 3, 0, 6, 6, 0, 4 ], [ 0, 1, 9, 4, 6, 11, 4, 11, 8 ],
	            [ 1, 9, 4, 11, 1, 4, 11, 3, 1, 11, 4, 6 ],
	            [ 3, 8, 2, 8, 4, 2, 2, 4, 6 ], [ 2, 0, 4, 2, 4, 6 ],
	            [ 1, 9, 0, 3, 8, 2, 2, 8, 4, 2, 4, 6 ], [ 9, 4, 1, 1, 4, 2, 4, 6, 2 ],
	            [ 10, 1, 2, 11, 8, 4, 11, 4, 6 ],
	            [ 10, 1, 2, 11, 3, 6, 6, 3, 0, 6, 0, 4 ],
	            [ 0, 2, 10, 0, 10, 9, 4, 11, 8, 4, 6, 11 ],
	            [ 2, 11, 3, 6, 9, 4, 6, 10, 9 ],
	            [ 8, 4, 6, 8, 6, 1, 6, 10, 1, 8, 1, 3 ],
	            [ 1, 0, 10, 10, 0, 6, 0, 4, 6 ], [ 8, 0, 3, 9, 6, 10, 9, 4, 6 ],
	            [ 10, 4, 6, 10, 9, 4 ], [ 9, 5, 4, 7, 6, 11 ],
	            [ 4, 9, 5, 3, 0, 8, 11, 7, 6 ], [ 6, 11, 7, 4, 0, 1, 4, 1, 5 ],
	            [ 6, 11, 7, 4, 8, 5, 5, 8, 3, 5, 3, 1 ], [ 4, 9, 5, 6, 2, 3, 6, 3, 7 ],
	            [ 9, 5, 4, 8, 7, 0, 0, 7, 6, 0, 6, 2 ],
	            [ 4, 0, 1, 4, 1, 5, 6, 3, 7, 6, 2, 3 ], [ 7, 4, 8, 5, 2, 1, 5, 6, 2 ],
	            [ 6, 11, 7, 1, 2, 10, 9, 5, 4 ],
	            [ 11, 7, 6, 8, 3, 0, 1, 2, 10, 9, 5, 4 ],
	            [ 11, 7, 6, 10, 5, 2, 2, 5, 4, 2, 4, 0 ],
	            [ 7, 4, 8, 2, 11, 3, 10, 5, 6 ],
	            [ 4, 9, 5, 6, 10, 7, 7, 10, 1, 7, 1, 3 ],
	            [ 5, 6, 10, 0, 9, 1, 8, 7, 4 ], [ 5, 6, 10, 7, 0, 3, 7, 4, 0 ],
	            [ 10, 5, 6, 4, 8, 7 ], [ 5, 6, 9, 6, 11, 9, 9, 11, 8 ],
	            [ 0, 9, 5, 0, 5, 3, 3, 5, 6, 3, 6, 11 ],
	            [ 0, 1, 5, 0, 5, 11, 5, 6, 11, 0, 11, 8 ],
	            [ 11, 3, 6, 6, 3, 5, 3, 1, 5 ], [ 9, 5, 6, 3, 9, 6, 3, 8, 9, 3, 6, 2 ],
	            [ 5, 6, 9, 9, 6, 0, 6, 2, 0 ], [ 0, 3, 8, 2, 5, 6, 2, 1, 5 ],
	            [ 1, 6, 2, 1, 5, 6 ], [ 1, 2, 10, 5, 6, 9, 9, 6, 11, 9, 11, 8 ],
	            [ 1, 0, 9, 6, 10, 5, 11, 3, 2 ], [ 6, 10, 5, 2, 8, 0, 2, 11, 8 ],
	            [ 3, 2, 11, 10, 5, 6 ], [ 10, 5, 6, 9, 3, 8, 9, 1, 3 ],
	            [ 0, 9, 1, 5, 6, 10 ], [ 8, 0, 3, 10, 5, 6 ], [ 10, 5, 6 ],
	            [ 10, 6, 5 ], [ 8, 3, 0, 10, 6, 5 ], [ 0, 1, 9, 5, 10, 6 ],
	            [ 10, 6, 5, 9, 8, 3, 9, 3, 1 ], [ 3, 11, 2, 10, 6, 5 ],
	            [ 6, 5, 10, 2, 0, 8, 2, 8, 11 ], [ 1, 9, 0, 6, 5, 10, 11, 2, 3 ],
	            [ 1, 10, 2, 5, 9, 6, 9, 11, 6, 9, 8, 11 ], [ 1, 2, 6, 1, 6, 5 ],
	            [ 0, 8, 3, 2, 6, 5, 2, 5, 1 ], [ 5, 9, 6, 9, 0, 6, 6, 0, 2 ],
	            [ 9, 6, 5, 3, 6, 9, 3, 9, 8, 3, 2, 6 ], [ 11, 6, 3, 6, 5, 3, 3, 5, 1 ],
	            [ 0, 5, 1, 0, 11, 5, 5, 11, 6, 0, 8, 11 ],
	            [ 0, 5, 9, 0, 3, 5, 3, 6, 5, 3, 11, 6 ],
	            [ 5, 9, 6, 6, 9, 11, 9, 8, 11 ], [ 10, 6, 5, 4, 7, 8 ],
	            [ 5, 10, 6, 7, 3, 0, 7, 0, 4 ], [ 5, 10, 6, 0, 1, 9, 8, 4, 7 ],
	            [ 4, 5, 9, 6, 7, 10, 7, 1, 10, 7, 3, 1 ],
	            [ 7, 8, 4, 2, 3, 11, 10, 6, 5 ],
	            [ 11, 6, 7, 10, 2, 5, 2, 4, 5, 2, 0, 4 ],
	            [ 11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5 ],
	            [ 6, 7, 11, 1, 10, 2, 9, 4, 5 ], [ 7, 8, 4, 5, 1, 2, 5, 2, 6 ],
	            [ 4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2 ],
	            [ 9, 4, 5, 8, 0, 7, 0, 6, 7, 0, 2, 6 ], [ 4, 5, 9, 6, 3, 2, 6, 7, 3 ],
	            [ 6, 7, 11, 4, 5, 8, 5, 3, 8, 5, 1, 3 ],
	            [ 6, 7, 11, 4, 1, 0, 4, 5, 1 ], [ 4, 5, 9, 3, 8, 0, 11, 6, 7 ],
	            [ 9, 4, 5, 7, 11, 6 ], [ 10, 6, 4, 10, 4, 9 ],
	            [ 8, 3, 0, 9, 10, 6, 9, 6, 4 ], [ 1, 10, 0, 10, 6, 0, 0, 6, 4 ],
	            [ 8, 6, 4, 8, 1, 6, 6, 1, 10, 8, 3, 1 ],
	            [ 2, 3, 11, 6, 4, 9, 6, 9, 10 ],
	            [ 0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6 ],
	            [ 10, 2, 1, 11, 6, 3, 6, 0, 3, 6, 4, 0 ],
	            [ 10, 2, 1, 11, 4, 8, 11, 6, 4 ], [ 9, 1, 4, 1, 2, 4, 4, 2, 6 ],
	            [ 1, 0, 9, 3, 2, 8, 2, 4, 8, 2, 6, 4 ], [ 2, 4, 0, 2, 6, 4 ],
	            [ 3, 2, 8, 8, 2, 4, 2, 6, 4 ],
	            [ 1, 4, 9, 11, 4, 1, 11, 1, 3, 11, 6, 4 ],
	            [ 0, 9, 1, 4, 11, 6, 4, 8, 11 ], [ 11, 6, 3, 3, 6, 0, 6, 4, 0 ],
	            [ 8, 6, 4, 8, 11, 6 ], [ 6, 7, 10, 7, 8, 10, 10, 8, 9 ],
	            [ 9, 3, 0, 6, 3, 9, 6, 9, 10, 6, 7, 3 ],
	            [ 6, 1, 10, 6, 7, 1, 7, 0, 1, 7, 8, 0 ],
	            [ 6, 7, 10, 10, 7, 1, 7, 3, 1 ],
	            [ 7, 11, 6, 3, 8, 2, 8, 10, 2, 8, 9, 10 ],
	            [ 11, 6, 7, 10, 0, 9, 10, 2, 0 ], [ 2, 1, 10, 7, 11, 6, 8, 0, 3 ],
	            [ 1, 10, 2, 6, 7, 11 ], [ 7, 2, 6, 7, 9, 2, 2, 9, 1, 7, 8, 9 ],
	            [ 1, 0, 9, 3, 6, 7, 3, 2, 6 ], [ 8, 0, 7, 7, 0, 6, 0, 2, 6 ],
	            [ 2, 7, 3, 2, 6, 7 ], [ 7, 11, 6, 3, 9, 1, 3, 8, 9 ],
	            [ 9, 1, 0, 11, 6, 7 ], [ 0, 3, 8, 11, 6, 7 ], [ 11, 6, 7 ],
	            [ 11, 7, 5, 11, 5, 10 ], [ 3, 0, 8, 7, 5, 10, 7, 10, 11 ],
	            [ 9, 0, 1, 10, 11, 7, 10, 7, 5 ],
	            [ 3, 1, 9, 3, 9, 8, 7, 10, 11, 7, 5, 10 ],
	            [ 10, 2, 5, 2, 3, 5, 5, 3, 7 ],
	            [ 5, 10, 2, 8, 5, 2, 8, 7, 5, 8, 2, 0 ],
	            [ 9, 0, 1, 10, 2, 5, 5, 2, 3, 5, 3, 7 ],
	            [ 1, 10, 2, 5, 8, 7, 5, 9, 8 ], [ 2, 11, 1, 11, 7, 1, 1, 7, 5 ],
	            [ 0, 8, 3, 2, 11, 1, 1, 11, 7, 1, 7, 5 ],
	            [ 9, 0, 2, 9, 2, 7, 2, 11, 7, 9, 7, 5 ],
	            [ 11, 3, 2, 8, 5, 9, 8, 7, 5 ], [ 1, 3, 7, 1, 7, 5 ],
	            [ 8, 7, 0, 0, 7, 1, 7, 5, 1 ], [ 0, 3, 9, 9, 3, 5, 3, 7, 5 ],
	            [ 9, 7, 5, 9, 8, 7 ], [ 4, 5, 8, 5, 10, 8, 8, 10, 11 ],
	            [ 3, 0, 4, 3, 4, 10, 4, 5, 10, 3, 10, 11 ],
	            [ 0, 1, 9, 4, 5, 8, 8, 5, 10, 8, 10, 11 ],
	            [ 5, 9, 4, 1, 11, 3, 1, 10, 11 ],
	            [ 3, 8, 4, 3, 4, 2, 2, 4, 5, 2, 5, 10 ],
	            [ 10, 2, 5, 5, 2, 4, 2, 0, 4 ], [ 0, 3, 8, 5, 9, 4, 10, 2, 1 ],
	            [ 2, 1, 10, 9, 4, 5 ], [ 8, 4, 5, 2, 8, 5, 2, 11, 8, 2, 5, 1 ],
	            [ 3, 2, 11, 1, 4, 5, 1, 0, 4 ], [ 9, 4, 5, 8, 2, 11, 8, 0, 2 ],
	            [ 11, 3, 2, 9, 4, 5 ], [ 4, 5, 8, 8, 5, 3, 5, 1, 3 ],
	            [ 5, 0, 4, 5, 1, 0 ], [ 3, 8, 0, 4, 5, 9 ], [ 9, 4, 5 ],
	            [ 7, 4, 11, 4, 9, 11, 11, 9, 10 ],
	            [ 3, 0, 8, 7, 4, 11, 11, 4, 9, 11, 9, 10 ],
	            [ 11, 7, 4, 1, 11, 4, 1, 10, 11, 1, 4, 0 ],
	            [ 8, 7, 4, 11, 1, 10, 11, 3, 1 ],
	            [ 2, 3, 7, 2, 7, 9, 7, 4, 9, 2, 9, 10 ],
	            [ 4, 8, 7, 0, 10, 2, 0, 9, 10 ], [ 2, 1, 10, 0, 7, 4, 0, 3, 7 ],
	            [ 10, 2, 1, 8, 7, 4 ], [ 2, 11, 7, 2, 7, 1, 1, 7, 4, 1, 4, 9 ],
	            [ 3, 2, 11, 4, 8, 7, 9, 1, 0 ], [ 7, 4, 11, 11, 4, 2, 4, 0, 2 ],
	            [ 2, 11, 3, 7, 4, 8 ], [ 9, 1, 4, 4, 1, 7, 1, 3, 7 ],
	            [ 1, 0, 9, 8, 7, 4 ], [ 3, 4, 0, 3, 7, 4 ], [ 8, 7, 4 ],
	            [ 8, 9, 10, 8, 10, 11 ], [ 0, 9, 3, 3, 9, 11, 9, 10, 11 ],
	            [ 1, 10, 0, 0, 10, 8, 10, 11, 8 ], [ 10, 3, 1, 10, 11, 3 ],
	            [ 3, 8, 2, 2, 8, 10, 8, 9, 10 ], [ 9, 2, 0, 9, 10, 2 ],
	            [ 8, 0, 3, 1, 10, 2 ], [ 10, 2, 1 ], [ 2, 11, 1, 1, 11, 9, 11, 8, 9 ],
	            [ 11, 3, 2, 0, 9, 1 ], [ 11, 0, 2, 11, 8, 0 ], [ 11, 3, 2 ],
	            [ 8, 1, 3, 8, 9, 1 ], [ 9, 1, 0 ], [ 8, 0, 3 ], [] ];
	            
	            return my;
	};

	//each webworker needs its own marching cube object
	$3Dmol.MarchingCube  = $3Dmol.MarchingCubeInitializer();    



	/**
	 * $3Dmol.Parsers stores functions for parsing molecular data. They all take a string of molecular data
	 * and options. The default behavior is to only read the first model in the case of multimodel files, and
	 * all parsers return a list of atom list(s)
	 * 
	 * $3Dmol.Parsers.<ext> corresponds to the parsers for files with extension ext
	 */
	$3Dmol.Parsers = (function() {
	    var parsers = {};

	    /**
	     * @param {AtomSpec[]}
	     *            atomsarray
	     */
	    var assignBonds = function(atoms) {
	        // assign bonds - yuck, can't count on connect records

	        for (var i = 0, n = atoms.length; i < n; i++) {
	            // Don't reindex if atoms are already indexed
	            if (!atoms[i].index)
	                atoms[i].index = i;
	        }

	        var grid = {};
	        var MAX_BOND_LENGTH = 4.95; // (largest bond length, Cs) 2.25 * 2 * 1.1 (fudge factor)

	        for (var index = 0; index < atoms.length; index++) {
	            var atom = atoms[index];
	            var x = Math.floor(atom.x / MAX_BOND_LENGTH);
	            var y = Math.floor(atom.y / MAX_BOND_LENGTH);
	            var z = Math.floor(atom.z / MAX_BOND_LENGTH);
	            if (!grid[x]) {
	                grid[x] = {};
	            }
	            if (!grid[x][y]) {
	                grid[x][y] = {};
	            }
	            if (!grid[x][y][z]) {
	                grid[x][y][z] = [];
	            }

	            grid[x][y][z].push(atom);
	        }

	        var findConnections = function(points, otherPoints) {
	            for (var i = 0; i < points.length; i++) {
	                var atom1 = points[i];
	                for (var j = 0; j < otherPoints.length; j++) {
	                    var atom2 = otherPoints[j];

	                    if (areConnected(atom1, atom2)) {
	                        if (atom1.bonds.indexOf(atom2.index) == -1) {
	                            atom1.bonds.push(atom2.index);
	                            atom1.bondOrder.push(1);
	                            atom2.bonds.push(atom1.index);
	                            atom2.bondOrder.push(1);
	                        }
	                    }
	                }
	            }
	        }


	        /*const*/ var OFFSETS = [
	            {x: 0, y: 0, z: 1},
	            {x: 0, y: 1, z:-1},
	            {x: 0, y: 1, z: 0},
	            {x: 0, y: 1, z: 1},
	            {x: 1, y:-1, z:-1},
	            {x: 1, y:-1, z: 0},
	            {x: 1, y:-1, z: 1},
	            {x: 1, y: 0, z:-1},
	            {x: 1, y: 0, z: 0},
	            {x: 1, y: 0, z: 1},
	            {x: 1, y: 1, z:-1},
	            {x: 1, y: 1, z: 0},
	            {x: 1, y: 1, z: 1}
	        ];
	        for (var x in grid) {
	            x = parseInt(x);
	            for (var y in grid[x]) {
	                y = parseInt(y);
	                for (var z in grid[x][y]) {
	                    z = parseInt(z);
	                    var points = grid[x][y][z];

	                    for (var i = 0; i < points.length; i++) {
	                        var atom1 = points[i];
	                        for (var j = i + 1; j < points.length; j++) {
	                            var atom2 = points[j];
	                            if (areConnected(atom1, atom2)) {
	                                if (atom1.bonds.indexOf(atom2.index) == -1) {
	                                    atom1.bonds.push(atom2.index);
	                                    atom1.bondOrder.push(1);
	                                    atom2.bonds.push(atom1.index);
	                                    atom2.bondOrder.push(1);
	                                }
	                            }
	                        }
	                    }

	                    for (var o = 0; o < OFFSETS.length; o++) {
	                        var offset = OFFSETS[o];
	                        if (!grid[x+offset.x]
	                            || !grid[x+offset.x][y+offset.y]
	                            || !grid[x+offset.x][y+offset.y][z+offset.z]) continue;

	                        var otherPoints = grid[x + offset.x][y + offset.y][z + offset.z];
	                        findConnections(points, otherPoints);
	                    }
	                }
	            }
	        }
	    };

	    // this is optimized for proteins where it is assumed connected
	    // atoms are on the same or next residue
	    /**
	     * @param {AtomSpec[]}
	     *            atomsarray
	     */
	    var assignPDBBonds = function(atomsarray) {
	        // assign bonds - yuck, can't count on connect records
	        var protatoms = [];
	        var hetatoms = [];
	        var i, n;
	        for (i = 0, n = atomsarray.length; i < n; i++) {
	            var atom = atomsarray[i];
	            atom.index = i;
	            if (atom.hetflag)
	                hetatoms.push(atom);
	            else
	                protatoms.push(atom);
	        }

	        assignBonds(hetatoms);

	        // sort by resid
	        protatoms.sort(function(a, b) {
	            if (a.chain != b.chain)
	                return a.chain < b.chain ? -1 : 1;
	            return a.resi - b.resi;
	        });

	        // for identifying connected residues
	        var currentResi = -1;
	        var reschain = -1;
	        var lastResConnected;

	        for (i = 0, n = protatoms.length; i < n; i++) {
	            var ai = protatoms[i];

	            if (ai.resi !== currentResi) {
	                currentResi = ai.resi;
	                if (!lastResConnected)
	                    reschain++;

	                lastResConnected = false;
	            }

	            ai.reschain = reschain;

	            for (var j = i + 1; j < protatoms.length; j++) {
	                var aj = protatoms[j];
	                if (aj.chain != ai.chain)
	                    break;
	                if (aj.resi - ai.resi > 1) // can't be connected
	                    break;
	                if (areConnected(ai, aj)) {
	                    if (ai.bonds.indexOf(aj.index) === -1) {
	                        // only add if not already there
	                        ai.bonds.push(aj.index);
	                        ai.bondOrder.push(1);
	                        aj.bonds.push(ai.index);
	                        aj.bondOrder.push(1);
	                    }

	                    if (ai.resi !== aj.resi)
	                        lastResConnected = true;

	                }
	            }
	        }

	    };

	    // this will identify all hydrogen bonds between backbone
	    // atoms; assume atom names are correct, only identifies
	    // single closest hbond
	    var assignBackboneHBonds = function(atomsarray) {
	        var maxlength = 3.2;
	        var maxlengthSq = 10.24;
	        var atoms = [];
	        var i, j, n;
	        for (i = 0, n = atomsarray.length; i < n; i++) {
	            atomsarray[i].index = i;
	            // only consider 'N' and 'O'
	            var atom = atomsarray[i];
	            if (!atom.hetflag && (atom.atom === "N" || atom.atom === "O")) {
	                atoms.push(atom);
	                atom.hbondOther = null;
	                atom.hbondDistanceSq = Number.POSITIVE_INFINITY;
	            }
	        }

	        atoms.sort(function(a, b) {
	            return a.z - b.z;
	        });
	        for (i = 0, n = atoms.length; i < n; i++) {
	            var ai = atoms[i];

	            for (j = i + 1; j < n; j++) {
	                var aj = atoms[j];
	                var zdiff = aj.z - ai.z;
	                if (zdiff > maxlength) // can't be connected
	                    break;
	                if (aj.atom == ai.atom)
	                    continue; // can't be connected, but later might be
	                var ydiff = Math.abs(aj.y - ai.y);
	                if (ydiff > maxlength)
	                    continue;
	                var xdiff = Math.abs(aj.x - ai.x);
	                if (xdiff > maxlength)
	                    continue;
	                var dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;
	                if (dist > maxlengthSq)
	                    continue;

	                if (aj.chain == ai.chain && Math.abs(aj.resi - ai.resi) < 4)
	                    continue; // ignore bonds between too close residues
	                // select closest hbond
	                if (dist < ai.hbondDistanceSq) {
	                    ai.hbondOther = aj;
	                    ai.hbondDistanceSq = dist;
	                }
	                if (dist < aj.hbondDistanceSq) {
	                    aj.hbondOther = ai;
	                    aj.hbondDistanceSq = dist;
	                }
	            }
	        }
	    };

	    var computeSecondaryStructure = function(atomsarray) {
	        assignBackboneHBonds(atomsarray);

	        // compute, per residue, what the secondary structure is
	        var chres = {}; // lookup by chain and resid
	        var i, il, c, r;
	        var atom, val;

	        //identify helices first
	        for (i = 0, il = atomsarray.length; i < il; i++) {
	            atom = atomsarray[i];

	            if (typeof (chres[atom.chain]) === "undefined")
	                chres[atom.chain] = [];
	            
	            if (isFinite(atom.hbondDistanceSq)) {
	                var other = atom.hbondOther;
	                if (typeof (chres[other.chain]) === "undefined")
	                    chres[other.chain] = [];
	                
	                if (Math.abs(other.resi - atom.resi) === 4) {
	                    // helix
	                    chres[atom.chain][atom.resi] = 'h';
	                } 
	            }
	        }
	        
	        // plug gaps in helices
	        for (c in chres) {
	            for (r = 1; r < chres[c].length - 1; r++) {
	                var valbefore = chres[c][r - 1];
	                var valafter = chres[c][r + 1];
	                val = chres[c][r];
	                if (valbefore == 'h' && valbefore == valafter && val != valbefore) {
	                    chres[c][r] = valbefore;
	                }
	            }
	        }
	        
	        //now potential sheets - but only if mate not part of helix
	        for (i = 0, il = atomsarray.length; i < il; i++) {
	            atom = atomsarray[i];

	            if (isFinite(atom.hbondDistanceSq) && chres[atom.chain][atom.resi] != 'h' && atom.ss != 'h') {
	                chres[atom.chain][atom.resi] = 'maybesheet';
	            }
	        }
	        
	        
	        //sheets must bond to other sheets
	        for (i = 0, il = atomsarray.length; i < il; i++) {
	            atom = atomsarray[i];

	            if (isFinite(atom.hbondDistanceSq) && chres[atom.chain][atom.resi] == 'maybesheet') {
	                var other = atom.hbondOther;
	                var otherval = chres[other.chain][other.resi];
	                if (otherval == 'maybesheet' || otherval == 's') {
	                    // true sheet
	                    chres[atom.chain][atom.resi] = 's';
	                    chres[other.chain][other.resi] = 's';
	                }
	            }
	        }
	        
	        // plug gaps in sheets and remove singletons
	        for (c in chres) {
	            for (r = 1; r < chres[c].length - 1; r++) {
	                var valbefore = chres[c][r - 1];
	                var valafter = chres[c][r + 1];
	                val = chres[c][r];
	                if (valbefore == 's' && valbefore == valafter && val != valbefore) {
	                    chres[c][r] = valbefore;
	                }
	            }
	            for (r = 0; r < chres[c].length; r++) {
	                val = chres[c][r];
	                if (val == 'h' || val == 's') {
	                    if (chres[c][r - 1] != val && chres[c][r + 1] != val)
	                        delete chres[c][r];
	                }
	            }
	        }

	        
	        // assign to all atoms in residue, keep track of start
	        var curres = null;
	        for (i = 0, il = atomsarray.length; i < il; i++) {
	            atom = atomsarray[i];
	            val = chres[atom.chain][atom.resi];
	            if (typeof (val) == "undefined" || val == 'maybesheet')
	                continue;
	            atom.ss = val;
	            if (chres[atom.chain][atom.resi - 1] != val)
	                atom.ssbegin = true;
	            if (chres[atom.chain][atom.resi + 1] != val)
	                atom.ssend = true;
	        }
	    };

	    /**
	     * @param {string}
	     *            str
	     * @param {Object}
	     *            options
	     */
	    parsers.vasp = parsers.VASP = function (str, options) {
	      var atoms = [[]];
	      var lattice = {};

	      var lines = str.replace(/^\s+/, "").split(/[\n\r]/);

	      if (lines.length < 3){
	        return atoms;
	      }

	      if (lines[1].match(/\d+/)) {
	        lattice.length = parseFloat(lines[1]);
	      } else {
	        console.log("Warning: second line of the vasp structure file must be a number");
	        return atoms;
	      }

	      if (lattice.length<0) {
	        console.log("Warning: Vasp implementation for negative lattice lengths is not yet available");
	        return atoms;
	      }

	      lattice.xVec = new Float32Array(lines[2].replace(/^\s+/, "").split(/\s+/));
	      lattice.yVec = new Float32Array(lines[3].replace(/^\s+/, "").split(/\s+/));
	      lattice.zVec = new Float32Array(lines[4].replace(/^\s+/, "").split(/\s+/));


	      var atomSymbols=lines[5].replace(/\s+/, "").replace(/\s+$/,"").split(/\s+/);
	      var atomSpeciesNumber=new Int16Array(lines[6].replace(/^\s+/, "").split(/\s+/));
	      var vaspMode=lines[7].replace(/\s+/, "");


	      if (vaspMode.match(/C/)) {
	        vaspMode = "cartesian";
	      }else if (vaspMode.match(/D/)){
	        vaspMode="direct";
	      } else {
	        console.log("Warning: Unknown vasp mode in POSCAR file: mode must be either C(artesian) or D(irect)");
	        return atoms;
	      }

	      if (atomSymbols.length != atomSpeciesNumber.length) {
	        console.log("Warning: declaration of atomary species wrong:");
	        console.log(atomSymbols);
	        console.log(atomSpeciesNumber);
	        return atoms;
	      }

	      lines.splice(0,8);

	      var atomCounter = 0;

	      for (var i = 0, len = atomSymbols.length; i < len; i++) {
	        var atomSymbol = atomSymbols[i];
	       for (var j = 0, atomLen = atomSpeciesNumber[i]; j < atomLen; j++) {

	        var coords = new Float32Array(lines[atomCounter + j].replace(/^\s+/, "").split(/\s+/));

	        atom={};
	        atom.elem = atomSymbol;
	        if (vaspMode == "cartesian") {
	          atom.x = lattice.length*coords[0];
	          atom.y = lattice.length*coords[1];
	          atom.z = lattice.length*coords[2];
	        } else {
	          atom.x = lattice.length*(coords[0]*lattice.xVec[0] + coords[1]*lattice.yVec[0] + coords[2]*lattice.zVec[0]);
	          atom.y = lattice.length*(coords[0]*lattice.xVec[1] + coords[1]*lattice.yVec[1] + coords[2]*lattice.zVec[1]);
	          atom.z = lattice.length*(coords[0]*lattice.xVec[2] + coords[1]*lattice.yVec[2] + coords[2]*lattice.zVec[2]);
	        }

	        atom.bonds=[];

	        atoms[0].push(atom);
	       }
	        atomCounter += atomSpeciesNumber[i];
	      }

	      return atoms;


	    }

	    /**
	     * @param {string}
	     *            str
	     * @param {Object}
	     *            options
	     */
	    parsers.cube = parsers.CUBE = function(str, options) {
	        var atoms = [[]];
	        var lines = str.replace(/^\s+/, "").split(/\n\r|\r+/);

	        if (lines.length < 6)
	            return atoms;

	        var lineArr = lines[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(
	                " ");

	        var natoms = Math.abs(parseFloat(lineArr[0]));

	        lineArr = lines[3].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");

	        // might have to convert from bohr units to angstroms
	        var convFactor = (parseFloat(lineArr[0]) > 0) ? 0.529177 : 1;

	        // Extract atom portion; send to new GLModel...
	        lines = lines.splice(6, natoms);

	        var start = atoms[atoms.length-1].length;
	        var end = start + lines.length;

	        for (var i = start; i < end; ++i) {
	            var atom = {};
	            atom.serial = i;
	            var line = lines[i - start];
	            var tokens = line.replace(/^\s+/, "").replace(/\s+/g, " ").split(
	                    " ");

	            if (tokens[0] == 6)
	                atom.elem = "C";

	            else if (tokens[0] == 1)
	                atom.elem = "H";

	            else if (tokens[0] == 8)
	                atom.elem = "O";

	            else if (tokens[0] == 17)
	                atom.elem = "Cl";

	            atom.x = parseFloat(tokens[2]) * convFactor;
	            atom.y = parseFloat(tokens[3]) * convFactor;
	            atom.z = parseFloat(tokens[4]) * convFactor;

	            atom.hetflag = true;
	            atom.bonds = [];
	            atom.bondOrder = [];
	            atom.properties = {};
	            atoms[atoms.length-1].push(atom);

	        }
	        for (var i = 0; i < atoms.length; i++)
	            assignBonds(atoms[i]);

	        return atoms;
	    };

	    // read an XYZ file from str and return result
	    /**
	     * @param {string}
	     *            str
	     * @param {Object}
	     *            options
	     */
	    parsers.xyz = parsers.XYZ = function(str, options) {
	        
	        var atoms = [[]];
	        var lines = str.split(/\r?\n|\r/);
	        while (lines.length > 0) {
	            if (lines.length < 3)
	                break;
	            var atomCount = parseInt(lines[0]);
	            if (isNaN(atomCount) || atomCount <= 0)
	                break;
	            if (lines.length < atomCount + 2)
	                break;
	            var offset = 2;
	            var start = atoms[atoms.length-1].length;
	            var end = start + atomCount;
	            for (var i = start; i < end; i++) {
	                var line = lines[offset++];
	                var tokens = line.replace(/^\s+/, "").replace(/\s+/g, " ").split(
	                        " ");
	                var atom = {};
	                atom.serial = i;
	                var elem = tokens[0];
	                atom.atom = atom.elem = elem[0].toUpperCase() + elem.substr(1).toLowerCase();
	                atom.x = parseFloat(tokens[1]);
	                atom.y = parseFloat(tokens[2]);
	                atom.z = parseFloat(tokens[3]);
	                atom.hetflag = true;
	                atom.bonds = [];
	                atom.bondOrder = [];
	                atom.properties = {};
	                atoms[atoms.length-1][i] = atom;
	                if (tokens.length >= 7) {
	                    atom.dx = parseFloat(tokens[4]);
	                    atom.dy = parseFloat(tokens[5]);
	                    atom.dz = parseFloat(tokens[6]);
	                }
	            }

	            if (options.multimodel) {
	                atoms.push([]);
	                lines.splice(0, offset);
	            }
	            else {
	                break;
	            }
	        }
	        
	        for (var i = 0; i < atoms.length; i++) {
	            assignBonds(atoms[i]);
	        }
	        
	        if (options.onemol) {
	            var temp = atoms;
	            atoms = [];
	            atoms.push(temp[0]);
	            for (var i = 1; i < temp.length; i++) {
	                var offset = atoms[0].length;
	                for (var j = 0; j < temp[i].length; j++) {
	                    var a = temp[i][j];
	                    for (var k = 0; k < a.bonds.length; k++) {
	                        a.bonds[k] = a.bonds[k] + offset;
	                    }
	                    a.index = atoms[0].length;
	                    a.serial = atoms[0].length;
	                    atoms[0].push(a);
	                }
	            }
	        }

	         return atoms;
	    };

	    // put atoms specified in sdf fromat in str into atoms
	    // adds to atoms, does not replace
	    /**
	     * @param {string}
	     *            str
	     * @param {Object}
	     *            options
	     */
	    parsers.sdf = parsers.SDF = function(str, options) {

	        var atoms = [[]];
	        var noH = false;
	        if (typeof options.keepH !== "undefined")
	            noH = !options.keepH;
	        var lines = str.split(/\r?\n|\r/);
	        
	        while(lines.length > 0) { 
	            if (lines.length < 4)
	                break;
	            var atomCount = parseInt(lines[3].substr(0, 3));
	            if (isNaN(atomCount) || atomCount <= 0)
	                break;
	            var bondCount = parseInt(lines[3].substr(3, 3));
	            var offset = 4;
	            if (lines.length < 4 + atomCount + bondCount)
	                break;

	            // serial is atom's index in file; index is atoms index in 'atoms'
	            var serialToIndex = [];
	            var start = atoms[atoms.length-1].length;
	            var end = start + atomCount;
	            var i, line;
	            for (i = start; i < end; i++,offset++) {
	                line = lines[offset];
	                var atom = {};
	                var elem = line.substr(31, 3).replace(/ /g, "");
	                atom.atom = atom.elem = elem[0].toUpperCase() + elem.substr(1).toLowerCase();

	                if (atom.elem != 'H' || !noH) {
	                    atom.serial = i;
	                    serialToIndex[i] = atoms[atoms.length-1].length;
	                    atom.x = parseFloat(line.substr(0, 10));
	                    atom.y = parseFloat(line.substr(10, 10));
	                    atom.z = parseFloat(line.substr(20, 10));
	                    atom.hetflag = true;
	                    atom.bonds = [];
	                    atom.bondOrder = [];
	                    atom.properties = {};
	                    atom.index = atoms[atoms.length-1].length;
	                    atoms[atoms.length-1].push(atom);
	                }
	            }

	            for (i = 0; i < bondCount; i++,offset++) {
	                line = lines[offset];
	                var from = serialToIndex[parseInt(line.substr(0, 3)) - 1 + start];
	                var to = serialToIndex[parseInt(line.substr(3, 3)) - 1 + start];
	                var order = parseInt(line.substr(6, 3));
	                if (typeof (from) != 'undefined' && typeof (to) != 'undefined') {
	                    atoms[atoms.length-1][from].bonds.push(to);
	                    atoms[atoms.length-1][from].bondOrder.push(order);
	                    atoms[atoms.length-1][to].bonds.push(from);
	                    atoms[atoms.length-1][to].bondOrder.push(order);
	                }
	            }
	            if (options.multimodel) {
	                if (!options.onemol)
	                    atoms.push([]);
	                while (lines[offset] != "$$$$")
	                    offset++
	                lines.splice(0, ++offset);
	            }
	            else {
	                break;
	            }
	        }

	        return atoms;
	    };

	    // This parses the ChemDoodle json file format. Although this is registered
	    // for the json file extension, other chemical json file formats exist that
	    // this can not parse. Check which one you have and do not assume that
	    // .json can be parsed
	    parsers.cdjson = parsers.json = function(str, options) {
	        var atoms = [[]];
	        if (typeof str === "string") { // Str is usually automatically parsed by JQuery
	            str = JSON.parse(str);
	        }
	        var molecules = str.m;
	        var atomsInFile = molecules[0].a; // Assumes there is at least one
	        var bondsInFile = molecules[0].b; // molecule and ignores any more
	                                          // Ignores any shapes
	        var styles = molecules[0].s;
	        var parseStyle = options !== undefined && options.parseStyle !== undefined ? options.parseStyle : styles !== undefined;
	        
	        var offset = atoms[atoms.length-1].length; // When adding atoms their index will be
	                                   // Offset by the number of existing atoms
	        
	        for (var i = 0; i < atomsInFile.length; i++) {
	            var currentAtom = atomsInFile[i];
	            var atom = {};
	            atom.id = currentAtom.i; // Probably won't exist. Doesn't seem to
	                                     // break anything.
	            atom.x = currentAtom.x;
	            atom.y = currentAtom.y;
	            atom.z = currentAtom.z || 0; // Default value if file is 2D

	            atom.bonds = [];
	            atom.bondOrder = [];
	            
	            var elem = currentAtom.l || 'C';
	            atom.elem = elem[0].toUpperCase() + elem.substr(1).toLowerCase();

	            atom.serial = atoms[atoms.length-1].length;
	            if (parseStyle) {
	                atom.style = styles[currentAtom.s || 0];
	            }
	            atoms[atoms.length-1].push(atom);
	        }
	        for (var i = 0; i < bondsInFile.length; i++) {
	            var currentBond = bondsInFile[i];
	            var beginIndex = currentBond.b + offset;
	            var endIndex = currentBond.e + offset;
	            var bondOrder = currentBond.o || 1;
	            
	            var firstAtom = atoms[atoms.length-1][beginIndex];
	            var secondAtom = atoms[atoms.length-1][endIndex];

	            firstAtom.bonds.push(endIndex);
	            firstAtom.bondOrder.push(bondOrder);
	            secondAtom.bonds.push(beginIndex);
	            secondAtom.bondOrder.push(bondOrder);
	        }
	        return atoms;
	    }

	    // puts atoms specified in mmCIF fromat in str into atoms
	    /**
	     * @param {string}
	     *            str
	     * @param {Object}
	     *            options
	     */
	    parsers.mcif = parsers.cif = function(str, options) {
	        var atoms = [];
	        var noAssembly = !options.doAssembly; // don't assemble by default
	        var copyMatrix = !options.duplicateAssemblyAtoms;
	        var modelData = atoms.modelData = [];

	        // Used to handle quotes correctly
	        function splitRespectingQuotes(string, separator) {
	            var sections = [];
	            var sectionStart = 0;
	            var sectionEnd = 0;
	            while (sectionEnd < string.length) {
	                while (string.substr(sectionEnd, separator.length) !== separator
	                        && sectionEnd < string.length) {
	                    // currently does not support escaping quotes
	                    if (string[sectionEnd] === "'") {
	                        sectionEnd++;
	                        while (sectionEnd < string.length
	                                && string[sectionEnd] !== "'") {
	                            sectionEnd++;
	                        }
	                    } else if (string[sectionEnd] === '"') {
	                        sectionEnd++;
	                        while (sectionEnd < string.length
	                                && string[sectionEnd] !== '"') {
	                            sectionEnd++;
	                        }
	                    }
	                    sectionEnd++;

	                }
	                sections.push(string.substr(sectionStart, sectionEnd
	                        - sectionStart));
	                sectionStart = sectionEnd = sectionEnd + separator.length;
	            }
	            return sections;
	        }


	        var lines = str.split(/\r?\n|\r/);
	        // Filter text to remove comments, trailing spaces, and empty lines
	        var linesFiltered = [];
	        var trimDisabled = false;
	        for (var lineNum = 0; lineNum < lines.length; lineNum++) {
	            // first remove comments
	            // incorrect if #'s are allowed in strings
	            // comments might only be allowed at beginning of line, not sure
	            var line = lines[lineNum].split('#')[0];

	            // inside data blocks, the string must be left verbatim
	            // datablocks are started with a ';' at the beginning of a line
	            // and ended with a ';' on its own line.
	            if (trimDisabled) {
	                if (line[0] === ';') {
	                    trimDisabled = false;
	                }
	            } else {
	                if (line[0] === ';') {
	                    trimDisabled = true;
	                }
	            }

	            if (trimDisabled || line !== "") {
	                if (!trimDisabled) {
	                    line = line.trim();
	                    if (line[0] === '_') {
	                        // Replace dot separating category from data item with underscore. Dots aren't guarenteed, to makes
	                        // files consistent.
	                        var dot = line.split(/\s/)[0].indexOf('.');
	                        if (dot > -1) {
	                            line[dot] = '_';
	                            line = line.substr(0,dot) + '_' + line.substr(dot + 1)
	                        }
	                    }
	                }
	                linesFiltered.push(line);
	            }
	        }

	        var lineNum = 0;
	        while (lineNum < linesFiltered.length) {
	            while (! linesFiltered[lineNum].startsWith("data_") ||
	                   linesFiltered[lineNum] === "data_global") {
	                lineNum++;
	            }
	            lineNum++;

	            // Process the lines and puts all of the data into an object.
	            var mmCIF = {};
	            while (lineNum < linesFiltered.length &&
	                   ! linesFiltered[lineNum].startsWith("data_")) {
	                if (linesFiltered[lineNum][0] === undefined) {
	                    lineNum++;
	                } else if (linesFiltered[lineNum][0] === '_') {
	                    var dataItemName = (linesFiltered[lineNum].split(/\s/)[0]).toLowerCase();
	                    var dataItem = (mmCIF[dataItemName] = mmCIF[dataItemName] || []);

	                    // if nothing left on the line go to the next one
	                    var restOfLine = linesFiltered[lineNum]
	                        .substr(linesFiltered[lineNum].indexOf(dataItemName)
	                                + dataItemName.length);
	                    if (restOfLine === "") {
	                        lineNum++;
	                        if (linesFiltered[lineNum][0] === ';') {
	                            var dataBlock = linesFiltered[lineNum].substr(1);
	                            lineNum++;
	                            while (linesFiltered[lineNum] !== ';') {
	                                dataBlock = dataBlock + '\n'
	                                            + linesFiltered[lineNum];
	                                lineNum++;
	                            }
	                            dataItem.push(dataBlock);
	                        } else {
	                            dataItem.push(linesFiltered[lineNum]);
	                        }
	                    } else {
	                        dataItem.push(restOfLine.trim());
	                    }
	                    lineNum++;
	                } else if (linesFiltered[lineNum].substr(0, 5) === "loop_") {
	                    lineNum++;
	                    var dataItems = [];
	                    while (linesFiltered[lineNum] === ""
	                           || linesFiltered[lineNum][0] === '_') {
	                        if (linesFiltered[lineNum] !== "") {
	                            var dataItemName = (linesFiltered[lineNum].split(/\s/)[0]).toLowerCase();
	                            var dataItem = (mmCIF[dataItemName] = mmCIF[dataItemName] || []);
	                            dataItems.push(dataItem);
	                        }
	                        lineNum++;
	                    }

	                    var currentDataItem = 0;
	                    while (lineNum < linesFiltered.length
	                           && linesFiltered[lineNum][0] !== '_'
	                           && !linesFiltered[lineNum].startsWith("loop_")
	                           && !linesFiltered[lineNum].startsWith("data_")) {
	                        var line = splitRespectingQuotes(linesFiltered[lineNum], " ");
	                        for (var field = 0; field < line.length; field++) {
	                            if (line[field] !== "") {
	                                dataItems[currentDataItem].push(line[field]);
	                                currentDataItem = (currentDataItem + 1) % dataItems.length;
	                            }
	                        }
	                        lineNum++;
	                    }
	                } else {
	                    lineNum++;
	                }
	            }

	            modelData.push({symmetries:[]});

	            // Pulls atom information out of the data
	            atoms.push([]);
	            var currentIndex = 0;
	            var atomCount = mmCIF._atom_site_id !== undefined ? mmCIF._atom_site_id.length
	                : mmCIF._atom_site_label.length;
	            function sqr(n) {
	                return n*n;
	            }
	            var conversionMatrix;
	            if (mmCIF._cell_length_a !== undefined) {
	                var a = parseFloat(mmCIF._cell_length_a);
	                var b = parseFloat(mmCIF._cell_length_b);
	                var c = parseFloat(mmCIF._cell_length_c);
	                var alpha_deg = parseFloat(mmCIF._cell_angle_alpha) || 90;
	                var beta_deg = parseFloat(mmCIF._cell_angle_beta) || 90;
	                var gamma_deg = parseFloat(mmCIF._cell_angle_gamma) || 90;
	                var alpha = alpha_deg * Math.PI / 180;
	                var beta = beta_deg * Math.PI / 180;
	                var gamma = gamma_deg * Math.PI / 180;
	                var cos_alpha = Math.cos(alpha);
	                var cos_beta = Math.cos(beta);
	                var cos_gamma = Math.cos(gamma);
	                var sin_gamma = Math.sin(gamma);
	                conversionMatrix = [
	                    [a, b*cos_gamma, c*cos_beta],
	                    [0, b*sin_gamma, c*(cos_alpha-cos_beta*cos_gamma)/sin_gamma],
	                    [0, 0, c*Math.sqrt(1-sqr(cos_alpha)-sqr(cos_beta)-sqr(cos_gamma)+2*cos_alpha*cos_beta*cos_gamma)/sin_gamma]
	                ];
	                modelData[modelData.length-1].cryst = {'a' : a, 'b' : b, 'c' : c, 'alpha' : alpha_deg, 'beta' : beta_deg, 'gamma' : gamma_deg};
	            }
	            function fractionalToCartesian(a, b, c) {
	                var x = conversionMatrix[0][0]*a + conversionMatrix[0][1]*b + conversionMatrix[0][2]*c;
	                var y = conversionMatrix[1][0]*a + conversionMatrix[1][1]*b + conversionMatrix[1][2]*c;
	                var z = conversionMatrix[2][0]*a + conversionMatrix[2][1]*b + conversionMatrix[2][2]*c;
	                return {x:x, y:y, z:z};
	            }
	            for (var i = 0; i < atomCount; i++) {
	                if (mmCIF._atom_site_group_pdb !== undefined && mmCIF._atom_site_group_pdb[i] === "TER")
	                    continue;
	                var atom = {};
	                if (mmCIF._atom_site_cartn_x !== undefined) {
	                    atom.x = parseFloat(mmCIF._atom_site_cartn_x[i]);
	                    atom.y = parseFloat(mmCIF._atom_site_cartn_y[i]);
	                    atom.z = parseFloat(mmCIF._atom_site_cartn_z[i]);
	                }
	                else {
	                    var coords = fractionalToCartesian(
	                        parseFloat(mmCIF._atom_site_fract_x[i]),
	                        parseFloat(mmCIF._atom_site_fract_y[i]),
	                        parseFloat(mmCIF._atom_site_fract_z[i]));
	                    atom.x = coords.x;
	                    atom.y = coords.y;
	                    atom.z = coords.z;
	                }
	                atom.chain = mmCIF._atom_site_auth_asym_id ? mmCIF._atom_site_auth_asym_id[i] : undefined;
	                atom.resi = mmCIF._atom_site_auth_seq_id ? parseInt(mmCIF._atom_site_auth_seq_id[i]) : undefined;
	                atom.resn = mmCIF._atom_site_auth_comp_id ? mmCIF._atom_site_auth_comp_id[i].trim() : undefined;
	                atom.atom = mmCIF._atom_site_auth_atom_id ? mmCIF._atom_site_auth_atom_id[i].replace(/"/gm,'')  : undefined; //"primed" names are in quotes
	                atom.hetflag = !mmCIF._atom_site_group_pdb || mmCIF._atom_site_group_pdb[i] === "HETA" || mmCIF._atom_site_group_pdb[i] === "HETATM";
	                var elem = mmCIF._atom_site_type_symbol[i];
	                atom.elem = elem[0].toUpperCase() + elem.substr(1).toLowerCase();
	                atom.bonds = [];
	                atom.ss = 'c';
	                atom.serial = i;
	                atom.bondOrder = [];
	                atom.properties = {};
	                atoms[atoms.length-1].push(atom);
	            }

	            if (mmCIF._pdbx_struct_oper_list_id !== undefined && !noAssembly) {
	                for (var i = 0; i < mmCIF._pdbx_struct_oper_list_id.length; i++) {
	                    var matrix11 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[1][1]'][i]);
	                    var matrix12 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[1][2]'][i]);
	                    var matrix13 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[1][3]'][i]);
	                    var vector1 = parseFloat(mmCIF['_pdbx_struct_oper_list_vector[1]'][i]);
	                    var matrix21 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[2][1]'][i]);
	                    var matrix22 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[2][2]'][i]);
	                    var matrix23 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[2][3]'][i]);
	                    var vector2 = parseFloat(mmCIF['_pdbx_struct_oper_list_vector[2]'][i]);
	                    var matrix31 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[3][1]'][i]);
	                    var matrix32 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[3][2]'][i]);
	                    var matrix33 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[3][3]'][i]);
	                    var vector3 = parseFloat(mmCIF['_pdbx_struct_oper_list_vector[3]'][i]);

	                    var matrix = new $3Dmol.Matrix4(matrix11, matrix12, matrix13, vector1,
	                                                    matrix21, matrix22, matrix23, vector2,
	                                                    matrix31, matrix32, matrix33, vector3);
	                    modelData[modelData.length-1].symmetries.push(matrix);
	                }
	                for (var i = 0; i < atoms.length; i++) {
	                    processSymmetries(modelData[modelData.length-1].symmetries, copyMatrix, atoms[i]);
	                }
	            }
	            function parseTerm(term){
	                var negative = term.match('-');
	                term = term.replace(/[-xyz]/g, "");
	                var fractionParts = term.split('/');

	                var numerator, denominator;
	                if (fractionParts[1] === undefined) {
	                    denominator = 1;
	                }
	                else {
	                    denominator = parseInt(fractionParts[1]);
	                }
	                if (fractionParts[0] === "") {
	                    numerator = 1;
	                }
	                else {
	                    numerator = parseInt(fractionParts[0]);
	                }
	                return numerator / denominator * (negative ? -1 : 1);
	            }
	            if (mmCIF._symmetry_equiv_pos_as_xyz !== undefined) {
	                for (var sym = 0; sym < mmCIF._symmetry_equiv_pos_as_xyz.length; sym++) {
	                    var transform = mmCIF._symmetry_equiv_pos_as_xyz[sym].replace(/["' ]/g,"");
	                    var componentStrings = transform.split(',').map(
	                        function(val){
	                            return val.replace(/-/g,"+-");
	                        });
	                    var matrix = new $3Dmol.Matrix4(0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,1);
	                    for (var coord = 0; coord < 3; coord++) {
	                        var terms = componentStrings[coord].split('+');
	                        var constant = 0, xTerm = 0, yTerm = 0, zTerm = 0;
	                        for (var t = 0; t < terms.length; t++) {
	                            var term = terms[t];
	                            if (term === "")
	                                continue;
	                            var coefficient = parseTerm(term);
	                            if (term.match('x')) {
	                                matrix.elements[coord + 0] = coefficient;
	                            }
	                            else if (term.match('y')) {
	                                matrix.elements[coord + 4] = coefficient;
	                            }
	                            else if (term.match('z')) {
	                                matrix.elements[coord + 8] = coefficient;
	                            }
	                            else {
	                                matrix.elements[coord + 12] = coefficient;
	                            }
	                        }
	                    }
	                    var conversionMatrix4 = new $3Dmol.Matrix4(
	                        conversionMatrix[0][0], conversionMatrix[0][1], conversionMatrix[0][2], 0,
	                        conversionMatrix[1][0], conversionMatrix[1][1], conversionMatrix[1][2], 0,
	                        conversionMatrix[2][0], conversionMatrix[2][1], conversionMatrix[2][2], 0);
	                    var conversionInverse = (new $3Dmol.Matrix4()).getInverse(conversionMatrix4, true);
	                    matrix = (new $3Dmol.Matrix4()).multiplyMatrices(matrix, conversionInverse);
	                    matrix = (new $3Dmol.Matrix4()).multiplyMatrices(conversionMatrix4, matrix);
	                    modelData[modelData.length-1].symmetries.push(matrix);
	                }
	            }
	        }
	        for (var i = 0; i < atoms.length; i++) {
	            assignBonds(atoms[i]);
	            computeSecondaryStructure(atoms[i]);
	            processSymmetries(modelData[i].symmetries, copyMatrix, atoms[i]);
	        }

	        return atoms;
	    }

	    // parse SYBYL mol2 file from string - assumed to only contain one molecule
	    // tag
	    /**
	     * @param {string}
	     *            str
	     * @param {Object}
	     *            options
	     */
	    parsers.mol2 = parsers.MOL2 = function(str, options) {

	        var atoms = [[]];
	        var noH = false;
	        if (typeof options.keepH !== "undefined")
	            noH = !options.keepH;

	        // assert (mol_pos < atom_pos), "Unexpected formatting of mol2 file
	        // (expected 'molecule' section before 'atom' section)";

	        var lines = str.substr(mol_pos, str.length).split(/\r?\n|\r/);
	        
	        while(lines.length > 0) { 
	        
	            // Note: these regex's work, though they don't match '<TRIPOS>'
	            // correctly - something to do with angle brackets
	            var mol_pos = str.search(/@<TRIPOS>MOLECULE/);
	            var atom_pos = str.search(/@<TRIPOS>ATOM/);

	            // Assuming both Molecule and Atom sections exist
	            if (mol_pos == -1 || atom_pos == -1)
	                break;
	        
	            // serial is atom's index in file; index is atoms index in 'atoms'
	            var serialToIndex = []; 
	            var tokens = lines[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(
	                    " ");
	            var natoms = parseInt(tokens[0]);
	            var nbonds = 0;

	            if (tokens.length > 1)
	                nbonds = parseInt(tokens[1]);

	            var offset = 4;
	            var i;
	            // Continue until 'Atom' section
	            for (i = 3; i < lines.length; i++) {
	                if (lines[i] == "@<TRIPOS>ATOM") {
	                    offset = i + 1;
	                    break;
	                }
	            }
	        
	            var start = atoms[atoms.length-1].length;
	            var end = start + natoms;
	            var line;
	            // Process ATOMS
	            for (i = start; i < end; i++) {
	                line = lines[offset++];
	                tokens = line.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
	                var atom = {};
	                // get element
	                var elem = tokens[5].split('.')[0];
	                atom.atom = atom.elem = elem[0].toUpperCase() + elem.substr(1).toLowerCase();
	                if (atom.elem == 'H' && noH) {
	                    // ignore
	                } else {
	                    // 'index' is this atom's index in 'atoms'; 'serial' is this
	                    // atom's
	                    // serial id in mol2 file
	                    var index = atoms[atoms.length-1].length;
	                    var serial = parseInt(tokens[0]);
	                    atom.serial = serial;
	                    // atom.serial = i;

	                    atom.x = parseFloat(tokens[2]);
	                    atom.y = parseFloat(tokens[3]);
	                    atom.z = parseFloat(tokens[4]);
	                    atom.atom = tokens[5];
	                    var charge = parseFloat(tokens[8]);
	                    
	                    atom.index = index;
	                    atom.bonds = [];
	                    atom.bondOrder = [];
	                    atom.properties = {
	                        'charge' : charge,
	                        'partialCharge' : charge
	                    };
	                    serialToIndex[serial] = index;

	                    atoms[atoms.length-1].push(atom);
	                }
	            }

	            // Process BONDS
	            var bonds_found = false;
	            while (offset < lines.length) {
	                if (lines[offset++] == "@<TRIPOS>BOND") {
	                    bonds_found = true;
	                    break;
	                }
	            }

	            if (bonds_found && nbonds) {
	                for (i = 0; i < nbonds; i++) {
	                    line = lines[offset++];

	                    tokens = line.replace(/^\s+/, "").replace(/\s+/g, " ").split(
	                            " ");
	                    var from = parseInt(tokens[1]);
	                    fromAtom = atoms[atoms.length-1][serialToIndex[from]];
	                    var to = parseInt(tokens[2]);
	                    toAtom = atoms[atoms.length-1][serialToIndex[to]];

	                    // Won't be able to read aromatic bonds correctly...
	                    var order = parseInt(tokens[3]);
	                    if (isNaN(order))
	                        order = 1;

	                    if (fromAtom !== undefined && toAtom !== undefined) {
	                        fromAtom.bonds.push(serialToIndex[to]);
	                        fromAtom.bondOrder.push(order);
	                        toAtom.bonds.push(serialToIndex[from]);
	                        toAtom.bondOrder.push(order);
	                    }

	                }
	            }
	            if (options.multimodel) {
	                if (!options.onemol)
	                    atoms.push([])
	                lines.splice(0, offset);
	                str = lines.join("\n"); //update for str.search
	                continue;
	            }
	            else {
	                break;
	            }
	        }
	        return atoms;

	    };

	    var bondTable = {
	            H :0.37,                                                                                                                                He:0.32,
	            Li:1.34,Be:0.90,                                                                                B :0.82,C :0.77,N :0.75,O :0.73,F :0.71,Ne:0.69,
	            Na:1.54,Mg:1.30,                                                                                Al:1.18,Si:1.11,P :1.06,S :1.02,Cl:0.99,Ar:0.97,
	            K :1.96,Ca:1.74,Sc:1.44,Ti:1.56,V :1.25,/* Cr */Mn:1.39,Fe:1.25,Co:1.26,Ni:1.21,Cu:1.38,Zn:1.31,Ga:1.26,Ge:1.22,/* As */Se:1.16,Br:1.14,Kr:1.10,
	            Rb:2.11,Sr:1.92,Y :1.62,Zr:1.48,Nb:1.37,Mo:1.45,Tc:1.56,Ru:1.26,Rh:1.35,Pd:1.31,Ag:1.53,Cd:1.48,In:1.44,Sn:1.41,Sb:1.38,Te:1.35,I :1.33,Xe:1.30,
	            Cs:2.25,Ba:1.98,Lu:1.60,Hf:1.50,Ta:1.38,W :1.46,Re:1.59,Os:1.44,Ir:1.37,Pt:1.28,Au:1.44,Hg:1.49,Tl:1.48,Pb:1.47,Bi:1.46,/* Po *//* At */Rn:1.45,

	            // None of the boottom row or any of the Lanthanides have bond lengths
	    }
	    var bondLength = function(elem) {
	        return bondTable[elem] || 1.6;
	    }
	    // return true if atom1 and atom2 are probably bonded to each other
	    // based on distance alone
	    var areConnected = function(atom1, atom2) {
	        var maxsq = bondLength(atom1.elem) + bondLength(atom2.elem);
	        maxsq += 0.25;// fudge factor, especially important for md frames, also see 1i3d
	        maxsq *= maxsq;

	        var xdiff = atom1.x - atom2.x;
	        xdiff *= xdiff;
	        if (xdiff > maxsq)
	            return false;
	        var ydiff = atom1.y - atom2.y;
	        ydiff *= ydiff;
	        if (ydiff > maxsq)
	            return false;
	        var zdiff = atom1.z - atom2.z;
	        zdiff *= zdiff;
	        if (zdiff > maxsq)
	            return false;

	        var distSquared = xdiff + ydiff + zdiff;

	        if (isNaN(distSquared))
	            return false;
	        else if (distSquared < 0.5)
	            return false; // maybe duplicate position.
	        else if (distSquared > maxsq)
	            return false;
	        else
	            return true;
	    };

	    //adds symmetry info to either duplicate and rotate/translate biological unit later or add extra atoms now
	    var processSymmetries = function(copyMatrices, copyMatrix, atoms) {
	        var end = atoms.length;
	        var offset = end;
	        var t, l, n;
	        if (!copyMatrix) { // do full assembly
	            for (t = 0; t < copyMatrices.length; t++) {
	                if (!copyMatrices[t].isIdentity()) {
	                    var xyz = new $3Dmol.Vector3();
	                    for (n = 0; n < end; n++) {
	                        var bondsArr = [];
	                        for (l = 0; l < atoms[n].bonds.length; l++) {
	                            bondsArr.push(atoms[n].bonds[l] + offset);
	                        }
	                        xyz.set(atoms[n].x, atoms[n].y, atoms[n].z);
	                        xyz.applyMatrix4(copyMatrices[t]);
	                        var newAtom = {};
	                        for (var i in atoms[n]) {
	                            newAtom[i] = atoms[n][i];
	                        }
	                        newAtom.x = xyz.x;
	                        newAtom.y = xyz.y;
	                        newAtom.z = xyz.z;
	                        newAtom.bonds = bondsArr;
	                        atoms.push(newAtom);
	                    }
	                    offset = atoms.length;
	                }
	            }
	        }
	        else if(copyMatrices.length > 1) {
	            for (t = 0; t < atoms.length; t++) {
	                var symmetries = [];
	                for (l = 0; l < copyMatrices.length; l++) {
	                    if (!copyMatrices[l].isIdentity()) {
	                        var newXYZ = new $3Dmol.Vector3();
	                        newXYZ.set(atoms[t].x, atoms[t].y, atoms[t].z);
	                        newXYZ.applyMatrix4(copyMatrices[l]);
	                        symmetries.push(newXYZ);
	                    }
	                }
	                atoms[t].symmetries = symmetries;
	            }
	        }
	    }


	    // parse pdb file from str and create atoms
	    // if computeStruct is true will always perform secondary structure
	    // analysis,
	    // otherwise only do analysis of SHEET/HELIX comments are missing
	    /**
	     * @param {string}
	     *            str
	     * @param {Object}
	     *            options - keepH (do not strip hydrogens), noSecondaryStructure
	     *            (do not compute ss)
	     */
	    parsers.pdb = parsers.PDB = parsers.pdbqt = parsers.PDBQT = function(str, options) {

	        var atoms = [[]];
	        var atoms_cnt = 0;
	        var noH = !options.keepH; // suppress hydrogens by default
	        var computeStruct = !options.noSecondaryStructure;
	        var noAssembly = !options.doAssembly; // don't assemble by default
	        var copyMatrix = !options.duplicateAssemblyAtoms; //default true
	        var modelData = atoms.modelData = [{symmetries:[]}];

	        var start = atoms[atoms.length-1].length;
	        var atom;
	        var protein = {
	            sheet : [],
	            helix : []
	        }; // get secondary structure straight from pdb

	        var hasStruct = false;
	        var serialToIndex = []; // map from pdb serial to index in atoms
	        var lines = str.split(/\r?\n|\r/);
	        var i, j, k, line;
	        var seenbonds = {}; //sometimes connect records are duplicated as an unofficial means of relaying bond orders
	        for (i = 0; i < lines.length; i++) {
	            line = lines[i].replace(/^\s*/, ''); // remove indent
	            var recordName = line.substr(0, 6);
	            var startChain, startResi, endChain, endResi;
	            
	            if(recordName.indexOf("END") == 0) {
	                if (options.multimodel) {
	                    if (!options.onemol) {
	                        atoms.push([]);
	                        modelData.push({symmetries:[]});
	                    }
	                    continue;
	                }
	                else {
	                    break;
	                }
	            }

	            else if (recordName == 'ATOM  ' || recordName == 'HETATM') {
	                var resn, chain, resi, icode, x, y, z, hetflag, elem, serial, altLoc, b;
	                altLoc = line.substr(16, 1);
	                if (altLoc != ' ' && altLoc != 'A')
	                    continue; // FIXME: ad hoc
	                serial = parseInt(line.substr(6, 5));
	                atom = line.substr(12, 4).replace(/ /g, "");
	                resn = line.substr(17, 3).replace(/ /g, "");
	                chain = line.substr(21, 1);
	                resi = parseInt(line.substr(22, 4));
	                icode = line.substr(26, 1);
	                x = parseFloat(line.substr(30, 8));
	                y = parseFloat(line.substr(38, 8));
	                z = parseFloat(line.substr(46, 8));
	                b = parseFloat(line.substr(60, 8));
	                elem = line.substr(76, 2).replace(/ /g, "");
	                if (elem === '' || typeof(bondTable[elem]) === 'undefined') { // for some incorrect PDB files
	                    elem = line.substr(12, 2).replace(/ /g, "");
	                    if(elem.length > 0 && elem[0] == 'H' && elem != 'Hg') {
	                        elem = 'H'; //workaround weird hydrogen names from MD, note mercury must use lowercase
	                    }
	                    if(elem.length > 1) {
	                        elem = elem[0].toUpperCase() + elem.substr(1).toLowerCase();   
	                        if(typeof(bondTable[elem]) === 'undefined') {
	                            //not a known element, probably should just use first letter
	                            elem = elem[0];
	                        } else if(line[0] == 'A' && elem == 'Ca') { //alpha carbon, not calcium
	                            elem = "C";
	                        }
	                    }
	                } else {
	                    elem = elem[0].toUpperCase() + elem.substr(1).toLowerCase();                    
	                }

	                if(elem == 'H' && noH)
	                    continue;
	                if (line[0] == 'H')
	                    hetflag = true;
	                else
	                    hetflag = false;
	                serialToIndex[serial] = atoms[atoms.length-1].length;
	                atoms[atoms.length-1].push({
	                    'resn' : resn,
	                    'x' : x,
	                    'y' : y,
	                    'z' : z,
	                    'elem' : elem,
	                    'hetflag' : hetflag,
	                    'chain' : chain,
	                    'resi' : resi,
	                    'icode' : icode,
	                    'rescode' : resi + (icode != ' ' ? "^" + icode : ""), // combo
	                    // resi
	                    // and
	                    // icode
	                    'serial' : serial,
	                    'atom' : atom,
	                    'bonds' : [],
	                    'ss' : 'c',
	                    'bondOrder' : [],
	                    'properties' : {},
	                    'b' : b,
	                    'pdbline' : line
	                });
	            } else if (recordName == 'SHEET ') {
	                hasStruct = true;
	                startChain = line.substr(21, 1);
	                startResi = parseInt(line.substr(22, 4));
	                endChain = line.substr(32, 1);
	                endResi = parseInt(line.substr(33, 4));
	                protein.sheet
	                        .push([ startChain, startResi, endChain, endResi ]);
	            } else if (recordName == 'CONECT') {
	                // MEMO: We don't have to parse SSBOND, LINK because both are
	                // also
	                // described in CONECT. But what about 2JYT???
	                var from = parseInt(line.substr(6, 5));
	                var fromindex = serialToIndex[from];
	                var fromAtom = atoms[atoms.length-1][fromindex];
	                for (j = 0; j < 4; j++) {
	                    var to = parseInt(line.substr([ 11, 16, 21, 26 ][j], 5));
	                    var toindex = serialToIndex[to];
	                    var toAtom = atoms[atoms.length-1][toindex];
	                    if (fromAtom !== undefined && toAtom !== undefined) {
	                        // duplicated conect records indicate bond order
	                        if(!seenbonds[ [fromindex,toindex] ]) {
	                            seenbonds[ [fromindex,toindex] ] = 1;
	                            if (fromAtom.bonds.length == 0 || fromAtom.bonds[fromAtom.bonds.length - 1] != toindex) {
	                                fromAtom.bonds.push(toindex);
	                                fromAtom.bondOrder.push(1);
	                            }
	                        } else { //update bond order
	                            seenbonds[ [fromindex,toindex] ] += 1;
	                            
	                            for(var bi = 0; bi < fromAtom.bonds.length; bi++) {
	                                if(fromAtom.bonds[bi] == toindex) {
	                                    var newbo = seenbonds[ [fromindex,toindex] ];
	                                    if(newbo >= 4) { //aromatic
	                                        fromAtom.bondOrder[bi] = 1;
	                                    } else {
	                                        fromAtom.bondOrder[bi] = newbo;
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            } else if (recordName == 'HELIX ') {
	                hasStruct = true;
	                startChain = line.substr(19, 1);
	                startResi = parseInt(line.substr(21, 4));
	                endChain = line.substr(31, 1);
	                endResi = parseInt(line.substr(33, 4));
	                protein.helix
	                        .push([ startChain, startResi, endChain, endResi ]);
	            } else if ((!noAssembly) && (recordName == 'REMARK')
	                    && (line.substr(13, 5) == 'BIOMT')) {
	                var n;
	                var matrix = new $3Dmol.Matrix4(); 
	                for (n = 1; n <= 3; n++) {
	                    line = lines[i].replace(/^\s*/, '');
	                    if (parseInt(line.substr(18, 1)) == n) { // check for all
	                                                                // three lines
	                                                                // by matching #
	                                                                // @ end of
	                                                                // "BIOMT" to n
	                        matrix.elements[(n - 1)] = parseFloat(line.substr(23,
	                                10));
	                        matrix.elements[(n - 1) + 4] = parseFloat(line.substr(
	                                33, 10));
	                        matrix.elements[(n - 1) + 8] = parseFloat(line.substr(
	                                43, 10));
	                        matrix.elements[(n - 1) + 12] = parseFloat(line
	                                .substr(53));
	                        i++;
	                    } else {
	                        while (line.substr(13, 5) == 'BIOMT') {
	                            i++;
	                            line = lines[i].replace(/^\s*/, '');
	                        }
	                    }
	                }
	                matrix.elements[3] = 0;
	                matrix.elements[7] = 0;
	                matrix.elements[11] = 0;
	                matrix.elements[15] = 1;
	                modelData[modelData.length-1].symmetries.push(matrix);
	                i--; // set i back
	            } else if (recordName == 'CRYST1') {
	                var a, b, c, alpha, beta, gamma;
	                a = parseFloat(line.substr(7, 8));
	                b = parseFloat(line.substr(16, 8));
	                c = parseFloat(line.substr(25, 8));
	                alpha = parseFloat(line.substr(34, 6));
	                beta = parseFloat(line.substr(41, 6));
	                gamma = parseFloat(line.substr(48, 6));
	                modelData[modelData.length-1].cryst = {'a' : a, 'b' : b, 'c' : c, 'alpha' : alpha, 'beta' : beta, 'gamma' : gamma};
	            }
	        }

	        var starttime = (new Date()).getTime();
	        
	        for (var n = 0; n < atoms.length; n++) {
	            // assign bonds - yuck, can't count on connect records
	            assignPDBBonds(atoms[n]);
	            // console.log("bond connecting " + ((new Date()).getTime() -
	            // starttime));
	        
	            if (!noAssembly)
	                processSymmetries(modelData[n].symmetries, copyMatrix, atoms[n]);

	            if (computeStruct || !hasStruct) {
	                starttime = (new Date()).getTime();
	                computeSecondaryStructure(atoms[n]);
	                // console.log("secondary structure " + ((new Date()).getTime() -
	                // starttime));
	            }

	            // Assign secondary structures from pdb file
	            for (i = start; i < atoms[n].length; i++) {
	                atom = atoms[n][i];
	                if (atom === undefined)
	                    continue;

	                var found = false;
	                // MEMO: Can start chain and end chain differ?
	                for (j = 0; j < protein.sheet.length; j++) {
	                    if (atom.chain != protein.sheet[j][0])
	                        continue;
	                    if (atom.resi < protein.sheet[j][1])
	                        continue;
	                    if (atom.resi > protein.sheet[j][3])
	                        continue;
	                    atom.ss = 's';
	                    if (atom.resi == protein.sheet[j][1])
	                        atom.ssbegin = true;
	                    if (atom.resi == protein.sheet[j][3])
	                        atom.ssend = true;
	                }
	                for (j = 0; j < protein.helix.length; j++) {
	                    if (atom.chain != protein.helix[j][0])
	                        continue;
	                    if (atom.resi < protein.helix[j][1])
	                        continue;
	                    if (atom.resi > protein.helix[j][3])
	                        continue;
	                    atom.ss = 'h';
	                    if (atom.resi == protein.helix[j][1])
	                        atom.ssbegin = true;
	                    else if (atom.resi == protein.helix[j][3])
	                        atom.ssend = true;
	                }
	            }
	        }
	        
	        return atoms;
	    };

	    /**
	     * Parse a pqr file from str and create atoms. A pqr file is assumed to be a
	     * whitespace delimited PDB with charge and radius fields.
	     *
	     * @param {string}
	     *            str
	     * @param {Object}
	     *            options - noSecondaryStructure (do not compute ss)
	     */
	    parsers.pqr = parsers.PQR = function(str, options) {

	        var atoms = [[]];
	        var atoms_cnt = 0;
	        var start = atoms[atoms.length-1].length;
	        var atom;
	        var computeStruct = !options.noSecondaryStructure;
	        var noAssembly = !options.doAssembly; // don't assemble by default
	        var copyMatrix = !options.duplicateAssemblyAtoms; //default true
	        var modelData = atoms.modelData = [{symmetries:[]}];
	        
	        var serialToIndex = []; // map from pdb serial to index in atoms
	        var lines = str.split(/\r?\n|\r/);
	        var i, j, k, line;
	        for (i = 0; i < lines.length; i++) {
	            line = lines[i].replace(/^\s*/, ''); // remove indent
	            var recordName = line.substr(0, 6);
	            var startChain, startResi, endChain, endResi;
	            
	            if (recordName.indexOf("END") == 0) {
	                if (options.multimodel) {
	                    if (!options.onemol)
	                        atoms.push([]);
	                    continue;
	                }
	                else {
	                    break;
	                }
	            }
	            else if (recordName == 'ATOM  ' || recordName == 'HETATM') {
	                // I would have liked to split based solely on whitespace, but
	                // it seems that there is no guarantee that all the fields will
	                // be filled out (e.g. the chain) so this doesn't work
	                var serial = parseInt(line.substr(6, 5));
	                var atom = line.substr(12, 4).replace(/ /g, "");
	                var resn = line.substr(17, 3);
	                var chain = line.substr(21, 1);
	                var resi = parseInt(line.substr(22, 4));
	                // however let's split the coordinates, charge and radius by
	                // whitespace
	                // to support extra precision
	                var vals = line.substr(30).trim().split(/\s+/);
	                var x = parseFloat(vals[0]);
	                var y = parseFloat(vals[1]);
	                var z = parseFloat(vals[2]);
	                var charge = parseFloat(vals[3]);
	                var radius = parseFloat(vals[4]);

	                var elem = atom[0];
	                if (atom.length > 1 && atom[1].toUpperCase() != atom[1]) {
	                    // slight hack - identify two character elements by the
	                    // second character in the atom name being lowercase
	                    elem = atom.substr(0, 2);
	                }

	                if (line[0] == 'H')
	                    hetflag = true;
	                else
	                    hetflag = false;
	                serialToIndex[serial] = atoms[atoms.length-1].length;
	                atoms[atoms.length-1].push({
	                    'resn' : resn,
	                    'x' : x,
	                    'y' : y,
	                    'z' : z,
	                    'elem' : elem,
	                    'hetflag' : hetflag,
	                    'chain' : chain,
	                    'resi' : resi,
	                    'serial' : serial,
	                    'atom' : atom,
	                    'bonds' : [],
	                    'ss' : 'c',
	                    'bondOrder' : [],
	                    'properties' : {
	                        'charge' : charge,
	                        'partialCharge' : charge,
	                        'radius' : radius
	                    },
	                    'pdbline' : line
	                });
	            } else if (recordName == 'CONECT') {
	                // MEMO: We don't have to parse SSBOND, LINK because both are
	                // also
	                // described in CONECT. But what about 2JYT???
	                var from = parseInt(line.substr(6, 5));
	                var fromAtom = atoms[atoms.length-1][serialToIndex[from]];
	                for (j = 0; j < 4; j++) {
	                    var to = parseInt(line.substr([ 11, 16, 21, 26 ][j], 5));
	                    var toAtom = atoms[atoms.length-1][serialToIndex[to]];
	                    if (fromAtom !== undefined && toAtom !== undefined) {
	                        fromAtom.bonds.push(serialToIndex[to]);
	                        fromAtom.bondOrder.push(1);
	                    }
	                }
	            }
	        }

	        // assign bonds - yuck, can't count on connect records
	        for (var i = 0; i < atoms.length; i++) {
	            assignPDBBonds(atoms[i]);
	            if (computeStruct)
	                computeSecondaryStructure(atoms[i]);
	        }
	        
	        return atoms;
	    };
	    
	    var fromCharCode = function( charCodeArray ){
	        return String.fromCharCode.apply( null, charCodeArray ).replace(/\0/g, '');
	    };
	    
	    var convertSS = function(val) {
	      //convert mmtf code to 3dmol code
	        if(val == 2) return 'h';
	        if(val == 3) return 's';
	        return 'c';
	    };

	    
	    //mmtf shoul be passed as a binary UInt8Array buffer
	    parsers.mmtf = parsers.MMTF = function(bindata, options) {
	        
	        var noH = !options.keepH; // suppress hydrogens by default

	        var mmtfData = MMTF.decode( bindata );
	        var atoms = [[]];
	        var modelData = atoms.modelData = [];
	        
	        // setup index counters
	        var modelIndex = 0;
	        var chainIndex = 0;
	        var groupIndex = 0;
	        var atomIndex = 0;

	        // setup optional fields
	        var chainNameList = mmtfData.chainNameList;
	        var secStructList = mmtfData.secStructList;
	        var insCodeList = mmtfData.insCodeList;
	        var sequenceIndexList = mmtfData.sequenceIndexList;
	        var bFactorList = mmtfData.bFactorList;
	        var altLocList = mmtfData.altLocList;
	        var occupancyList = mmtfData.occupancyList;
	        var bondAtomList = mmtfData.bondAtomList;
	        var bondOrderList = mmtfData.bondOrderList;
	        
	        var numModels = mmtfData.numModels;
	        if (numModels == 0) return atoms;
	        if (!options.multimodel) numModels = 1; //first only
	        // hoisted loop variables
	        var i, j, k, kl, m, n;
	        
	        //extract symmetries - only take first assembly, apply to all models (ignoring changes for now)
	        var noAssembly = !options.doAssembly; // don't assemble by default
	        var copyMatrix = !options.duplicateAssemblyAtoms; //default true
	        var assemblyIndex = options.assemblyIndex ? options.assemblyIndex : 0; 
	        
	        var symmetries = [];
	        if(mmtfData.bioAssemblyList && mmtfData.bioAssemblyList.length > 0) {
	            var transforms = mmtfData.bioAssemblyList[assemblyIndex].transformList;
	            for(i = 0, n = transforms.length; i < n; i++) {
	                var matrix = new $3Dmol.Matrix4(transforms[i].matrix);
	                matrix.transpose();
	                symmetries.push(matrix);
	            }
	        }

	        var bondAtomListStart = 0; //for current model
	        //loop over models, 
	        for (m = 0; m < numModels; m++ ) {
	            var modelChainCount = mmtfData.chainsPerModel[m];
	            var matoms = atoms[atoms.length-1];
	            var serialToIndex = []; // map to matoms index, needed for noh

	            modelData.push({symmetries:symmetries});
	            for( i = 0; i < modelChainCount; ++i ){

	                var chainGroupCount = mmtfData.groupsPerChain[ chainIndex ];
	                var chainId = fromCharCode(
	                    mmtfData.chainIdList.subarray( chainIndex * 4, chainIndex * 4 + 4 )
	                );

	                var startGroup = groupIndex;
	                for( j = 0; j < chainGroupCount; ++j ){ //over residues (groups)

	                    var groupData = mmtfData.groupList[ mmtfData.groupTypeList[ groupIndex ] ];
	                    var groupAtomCount = groupData.atomNameList.length;
	                    var secStruct = 0;
	                    if( secStructList ){
	                        secStruct = secStructList[ groupIndex ];
	                    }
	                    var insCode = null;
	                    if( mmtfData.insCodeList ){
	                        insCode = String.fromCharCode( insCodeList[ groupIndex ] );
	                    }
	                    var sequenceIndex = null;
	                    if( sequenceIndexList ){
	                        sequenceIndex = sequenceIndexList[ groupIndex ];
	                    }

	                    var groupId = mmtfData.groupIdList[ groupIndex ];
	                    var groupName = groupData.groupName;
	                    var startAtom = atomIndex;

	                    for( k = 0; k < groupAtomCount; ++k ){

	                        var element = groupData.elementList[ k ];
	                        if(noH && element == 'H') {
	                            atomIndex += 1;
	                            continue;
	                        }
	                        
	                        var bFactor = '';
	                        if( bFactorList ){
	                            bFactor = bFactorList[ atomIndex ];
	                        }
	                        var altLoc = ' ';
	                        if( altLocList ){
	                            altLoc = String.fromCharCode( altLocList[ atomIndex ] );
	                        }
	                        var occupancy = '';
	                        if( occupancyList ){
	                            occupancy = occupancyList[ atomIndex ];
	                        }

	                        var atomId = mmtfData.atomIdList[ atomIndex ];
	                        var atomName = groupData.atomNameList[ k ];
	                        var atomCharge = groupData.atomChargeList[ k ];
	                        var xCoord = mmtfData.xCoordList[ atomIndex ];
	                        var yCoord = mmtfData.yCoordList[ atomIndex ];
	                        var zCoord = mmtfData.zCoordList[ atomIndex ];
	                            
	                        serialToIndex[atomIndex] = matoms.length;
	                        matoms.push({
	                            'resn' : groupName,
	                            'x' : xCoord,
	                            'y' : yCoord,
	                            'z' : zCoord,
	                            'elem' : element,
	                            'hetflag' : secStruct < 0,
	                            'chain' : chainId,
	                            'resi' : groupId,
	                            'icode' : altLoc,
	                            'rescode' : groupId + (altLoc != ' ' ? "^" + altLoc : ""), // combo
	                            // resi
	                            // and
	                            // icode
	                            'serial' : atomId,
	                            'atom' : atomName,
	                            'bonds' : [],
	                            'ss' : convertSS(secStruct),
	                            'bondOrder' : [],
	                            'properties' : {charge: atomCharge, occupancy:occupancy},
	                            'b' : bFactor,
	                        });

	                        atomIndex += 1;
	                    }
	                    
	                    // intra group bonds
	                    var groupBondAtomList = groupData.bondAtomList;
	                    for( k = 0, kl = groupData.bondOrderList.length; k < kl; ++k ){
	                        var atomIndex1 = startAtom + groupBondAtomList[ k * 2 ];
	                        var atomIndex2 = startAtom + groupBondAtomList[ k * 2 + 1 ];
	                        var bondOrder = groupData.bondOrderList[ k ];
	                        
	                        //I assume bonds are only recorded once
	                        var i1 = serialToIndex[atomIndex1];
	                        var i2 = serialToIndex[atomIndex2];
	                        var a1 = matoms[i1];
	                        var a2 = matoms[i2];
	                        if(a1 && a2) {
	                            a1.bonds.push(i2)
	                            a1.bondOrder.push(bondOrder);
	                            a2.bonds.push(i1);
	                            a2.bondOrder.push(bondOrder);         
	                        }
	                    }
	                    
	                    groupIndex += 1;
	                }
	                
	                //reset for bonds
	                groupIndex = startGroup;
	                for( j = 0; j < chainGroupCount; ++j ){ //over residues (groups)
	                    
	                    groupIndex += 1;

	                }

	                chainIndex += 1;
	            }

	            
	            // inter group bonds
	            if( bondAtomList ){
	                for( k = bondAtomListStart, kl = bondAtomList.length; k < kl; k += 2 ){
	                     var atomIndex1 = bondAtomList[ k ];
	                     var atomIndex2 = bondAtomList[ k + 1 ];
	                     var bondOrder = bondOrderList ? bondOrderList[ k / 2 ] : 1;
	                     
	                     if(atomIndex1 >= atomIndex) {
	                         bondAtomListStart = k;
	                         break; //on next model
	                     }
	                     //I assume bonds are only recorded once
	                     var i1 = serialToIndex[atomIndex1];
	                     var i2 = serialToIndex[atomIndex2];
	                     var a1 = matoms[i1];
	                     var a2 = matoms[i2];
	                     if(a1 && a2) {
	                         a1.bonds.push(i2)
	                         a1.bondOrder.push(bondOrder);
	                         a2.bonds.push(i1);
	                         a2.bondOrder.push(bondOrder);   
	                     }
	                }
	            }
	            
	            if (options.multimodel) {
	                if (!options.onemol) atoms.push([]);
	            }
	            modelIndex += 1;
	        } 
	                
	        
	        for (var n = 0; n < atoms.length; n++) {        
	            if (!noAssembly)
	                processSymmetries(modelData[n].symmetries, copyMatrix, atoms[n]);
	        }
	        
	        return atoms;
	    };
	    
	    return parsers;
	})();
	var $3Dmol = $3Dmol || {};

	//properties for mapping

	/* partial charges for proteins */
	$3Dmol.partialCharges = {
	"ALA:N": -0.15,
	"ALA:CA": 0.10,
	"ALA:CB": 0.00,
	"ALA:C": 0.60,
	"ALA:O": -0.55,
	"ARG:N": -0.15,
	"ARG:CA": 0.10,
	"ARG:CB": 0.00,
	"ARG:CG": 0.00,
	"ARG:CD": 0.10,
	"ARG:NE": -0.10,
	"ARG:CZ": 0.50,
	"ARG:NH1": 0.25,
	"ARG:NH2": 0.25,
	"ARG:C": 0.60,
	"ARG:O": -0.55,
	"ASN:N": -0.15,
	"ASN:CA": 0.10,
	"ASN:CB": 0.00,
	"ASN:CG": 0.55,
	"ASN:OD1": -0.55,
	"ASN:ND2": 0.00,
	"ASN:C": 0.60,
	"ASN:O": -0.55,
	"ASP:N": -0.15,
	"ASP:CA": 0.10,
	"ASP:CB": 0.00,
	"ASP:CG": 0.14,
	"ASP:OD1": -0.57,
	"ASP:OD2": -0.57,
	"ASP:C": 0.60,
	"ASP:O": -0.55,
	"CYS:N": -0.15,
	"CYS:CA": 0.10,
	"CYS:CB": 0.19,
	"CYS:SG": -0.19,
	"CYS:C": 0.60,
	"CYS:O": -0.55,
	"GLN:N": -0.15,
	"GLN:CA": 0.10,
	"GLN:CB": 0.00,
	"GLN:CG": 0.00,
	"GLN:CD": 0.55,
	"GLN:OE1": -0.55,
	"GLN:NE2": 0.00,
	"GLN:C": 0.60,
	"GLN:O": -0.55,
	"GLU:N": -0.15,
	"GLU:CA": 0.10,
	"GLU:CB": 0.00,
	"GLU:CG": 0.00,
	"GLU:CD": 0.14,
	"GLU:OE1": -0.57,
	"GLU:OE2": -0.57,
	"GLU:C": 0.60,
	"GLU:O": -0.55,
	"GLY:N": -0.15,
	"GLY:CA": 0.10,
	"GLY:C": 0.60,
	"GLY:O": -0.55,
	"HIS:N": -0.15,
	"HIS:CA": 0.10,
	"HIS:CB": 0.00,
	"HIS:CG": 0.10,
	"HIS:ND1": -0.10,
	"HIS:CD2": 0.10,
	"HIS:NE2": -0.40,
	"HIS:CE1": 0.30,
	"HIS:C": 0.60,
	"HIS:O": -0.55,
	"ILE:N": -0.15,
	"ILE:CA": 0.10,
	"ILE:CB": 0.00,
	"ILE:CG2": 0.00,
	"ILE:CG1": 0.00,
	"ILE:CD": 0.00,
	"ILE:C": 0.60,
	"ILE:O": -0.55,
	"LEU:N": -0.15,
	"LEU:CA": 0.10,
	"LEU:CB": 0.00,
	"LEU:CG": 0.00,
	"LEU:CD1": 0.00,
	"LEU:CD2": 0.00,
	"LEU:C": 0.60,
	"LEU:O": -0.55,
	"LYS:N": -0.15,
	"LYS:CA": 0.10,
	"LYS:CB": 0.00,
	"LYS:CG": 0.00,
	"LYS:CD": 0.00,
	"LYS:CE": 0.25,
	"LYS:NZ": 0.75,
	"LYS:C": 0.60,
	"LYS:O": -0.55,
	"MET:N": -0.15,
	"MET:CA": 0.10,
	"MET:CB": 0.00,
	"MET:CG": 0.06,
	"MET:SD": -0.12,
	"MET:CE": 0.06,
	"MET:C": 0.60,
	"MET:O": -0.55,
	"PHE:N": -0.15,
	"PHE:CA": 0.10,
	"PHE:CB": 0.00,
	"PHE:CG": 0.00,
	"PHE:CD1": 0.00,
	"PHE:CD2": 0.00,
	"PHE:CE1": 0.00,
	"PHE:CE2": 0.00,
	"PHE:CZ": 0.00,
	"PHE:C": 0.60,
	"PHE:O": -0.55,
	"PRO:N": -0.25,
	"PRO:CD": 0.10,
	"PRO:CA": 0.10,
	"PRO:CB": 0.00,
	"PRO:CG": 0.00,
	"PRO:C": 0.60,
	"PRO:O": -0.55,
	"SER:N": -0.15,
	"SER:CA": 0.10,
	"SER:CB": 0.25,
	"SER:OG": -0.25,
	"SER:C": 0.60,
	"SER:O": -0.55,
	"THR:N": -0.15,
	"THR:CA": 0.10,
	"THR:CB": 0.25,
	"THR:OG1": -0.25,
	"THR:CG2": 0.00,
	"THR:C": 0.60,
	"THR:O": -0.55,
	"TRP:N": -0.15,
	"TRP:CA": 0.10,
	"TRP:CB": 0.00,
	"TRP:CG": -0.03,
	"TRP:CD2": 0.10,
	"TRP:CE2": -0.04,
	"TRP:CE3": -0.03,
	"TRP:CD1": 0.06,
	"TRP:NE1": -0.06,
	"TRP:CZ2": 0.00,
	"TRP:CZ3": 0.00,
	"TRP:CH2": 0.00,
	"TRP:C": 0.60,
	"TRP:O": -0.55,
	"TYR:N": -0.15,
	"TYR:CA": 0.10,
	"TYR:CB": 0.00,
	"TYR:CG": 0.00,
	"TYR:CD1": 0.00,
	"TYR:CE1": 0.00,
	"TYR:CD2": 0.00,
	"TYR:CE2": 0.00,
	"TYR:CZ": 0.25,
	"TYR:OH": -0.25,
	"TYR:C": 0.60,
	"TYR:O": -0.55,
	"VAL:N": -0.15,
	"VAL:CA": 0.10,
	"VAL:CB": 0.00,
	"VAL:CG1": 0.00,
	"VAL:CG2": 0.00,
	"VAL:C": 0.60,
	"VAL:O": -0.55
	};
	    
	//this can be supplied to mapAtomProperties
	$3Dmol.applyPartialCharges = function(atom, keepexisting) {
	    if(!keepexisting || typeof(atom.partialCharge) === "undefined") {
	        if(atom.resn && atom.atom) {
	            var key = atom.resn+":"+atom.atom;
	            atom.properties['partialCharge'] = $3Dmol.partialCharges[key];
	        }
	    }
	};// Specifications for various object types used in 3Dmol.js
	// This is primarily for documentation 
	(function() {
	/**
	 * GLViewer input specification
	 * @typedef ViewerSpec
	 * @prop {Object} defaultcolors - map of elements to colors
	 * @prop {boolean} nomouse - if true, disable handling of mouse events
	 * @prop {ColorSpec} backgroundColor - color of background
	 */

	/**
	 * Atom representation. Depending on the input file format, not all fields may be defined.
	 * @typedef AtomSpec
	 * @prop {string} resn - Parent residue name
	 * @prop {number} x - Atom's x coordinate
	 * @prop {number} y - Atom's y coordinate
	 * @prop {number} z - Atom's z coordinate
	 * @prop {ColorSpec} color - Atom's color, as hex code or built-in color string
	 * @prop {ColorSpec} surfaceColor - Hex code for color to be used for surface patch over this atom
	 * @prop {string} elem - Element abbreviation (e.g. 'H', 'Ca', etc)
	 * @prop {boolean} hetflag - Set to true if atom is a heteroatom
	 * @prop {string} chain - Chain this atom belongs to, if specified in input file (e.g 'A' for chain A)
	 * @prop {number} resi - Residue number 
	 * @prop {number} icode
	 * @prop {number} rescode
	 * @prop {number} serial - Atom's serial id number
	 * @prop {string} atom - Atom name; may be more specific than 'elem' (e.g 'CA' for alpha carbon)
	 * @prop {Array.<number>} bonds - Array of atom ids this atom is bonded to
	 * @prop {string} ss - Secondary structure identifier (for cartoon render; e.g. 'h' for helix)
	 * @prop {boolean} singleBonds - true if this atom forms only single bonds or no bonds at all
	 * @prop {Array.<number>} bondOrder - Array of this atom's bond orders, corresponding to bonds identfied by 'bonds'
	 * @prop {Object} properties - Optional mapping of additional properties
	 * @prop {number} b - Atom b factor data
	 * @prop {string} pdbline - If applicable, this atom's record entry from the input PDB file (used to output new PDB from models)
	 * @prop {boolean} clickable - Set this flag to true to enable click selection handling for this atom
	 * @prop {function(this, $3Dmol.GLViewer)} callback - Callback click handler function to be executed on this atom and its parent viewer
	 * @prop {boolean} invert - for selection, inverts the meaning of the selection
	 */


	/**
	 * Atom selection object. Used to specify what atoms should be selected.  Can include
	 * any field from {@link AtomSpec} in which case atoms must equal the specified value.  
	 * All fields must match for the selection to hold. If values
	 * are provided as a list, then only one value of the list must match.
	 * 
	 * @example
	 * viewer.addResLabels({resi: [1,2,3,4,5], atom: 'CA'}); // will label alpha carbons (CA) of residues 1-5
	 * 
	 * @typedef AtomSelectionSpec
	 * @prop {AtomSpec} ... - any field from {@link AtomSpec}, values may be singletons or lists
	 * @prop {GLModel} model - a single model or list of models from which atoms should be selected
	 * @prop {number} bonds - overloaded to select number of bonds, e.g. {bonds: 0} will select all nonbonded atoms
	 * @prop {function} predicate - user supplied function that gets passed an {AtomSpec} and should return true if the atom should be selected
	 * @prop {boolean} invert - if set, inverts the meaning of the selection
	 * @prop {boolean} byres - if set, expands the selection to include all atoms of any residue that has any atom selected
	 * @prop {number} expand - expands the selection to include all atoms within a given distance from the selection
	 * @prop {WithinSelectionSpec} within - intersects the selection with the set of atoms within a given distance from another selection
	 */

	/**
	 * Within selection object. Used to find the subset of an atom selection that is within
	 * some distance from another atom selection. When added as a field of an {@link AtomSelectionSpec},
	 * intersects the set of atoms in that selection with the set of atoms within a given
	 * distance from the given {@link AtomSelectionSpec}.
	 *
	 * @example
	 * viewer.setStyle({chain: 'A', within:{distance: 10, sel:{chain: 'B'}}}, {sphere:{}}); // stylizes atoms in chain A that are within 10 angstroms of an atom in chain B
	 *
	 * @typedef WithinSelectionSpec
	 * @prop {number} distance - the distance in angstroms away from the atom selection to include atoms in the parent selection
	 * @prop {AtomSelectionSpec} sel - the selection of atoms against which to measure the distance from the parent atom selection
	 */



	/** 
	 * @typedef AtomStyleSpec
	 * @prop {LineStyleSpec} line - draw bonds as lines
	 * @prop {CrossStyleSpec} cross - draw atoms as crossed lines (aka stars)
	 * @prop {StickStyleSpec} stick  - draw bonds as capped cylinders
	 * @prop {SphereStyleSpec} sphere - draw atoms as spheres
	 * @prop {CartoonStyleSpec} cartoon - draw cartoon representation of secondary structure
	 */

	/** 
	 * @typedef SurfaceStyleSpec
	 * @prop {number} opacity - sets the transparency: 0 to hide, 1 for fully opaque
	 * @prop {ColorschemeSpec} colorscheme - element based coloring
	 * @prop {ColorSpec} color - fixed coloring, overrides colorscheme
	 * @prop {$3Dmol.VolumeData} voldata - volumetric data for vertex coloring
	 * @prop {$3Dmol.Gradient} volscheme - coloring scheme for mapping volumetric data to vertex color
	 * @prop {Object} map - specifies a numeric atom property (prop) and color mapping (scheme) such as {@link $3Dmol.Gradient.RWB}.  Deprecated, use colorscheme instead.
	 * 
	 * @example
	 * viewer.addSurface($3Dmol.SurfaceType.MS, {map:{prop:'partialCharge',scheme:new $3Dmol.Gradient.RWB(-.6,.6)}, opacity:0.85});

	 */

	/** 
	 * Isosurface style specification
	 * @typedef IsoSurfaceSpec
	 * @prop {number} isoval - specifies the isovalue to draw surface at
	 * @propr {boolean} voxel - if true uses voxel style rendering
	 * @prop {ColorSpec} color - solid color
	 * @prop {number} opacity - transparency, between 0 and 1
	 * @prop {boolean} wireframe - draw as wireframe, not surface
	 * @prop {number} linewidth - width of line for wireframe rendering
	 * @prop {number} smoothness - amount to smooth surface (default 1)
	 * @prop {boolean} clickable - if true, user can click on object to trigger callback
	 * @prop {function} callback - function to call on click 
	 */

	/** 
	 * GLShape style specification
	 * @typedef ShapeSpec
	 * @prop {ColorSpec} color - solid color
	 * @prop {number} alpha - transparency
	 * @prop {boolean} wireframe - draw as wireframe, not surface
	 * @prop {number} linewidth - width of line for wireframe rendering
	 * @prop {boolean} clickable - if true, user can click on object to trigger callback
	 * @prop {function} callback - function to call on click 
	 */


	/**
	 * Specification for adding custom shape. Extends {@link ShapeSpec}.
	 * @typedef CustomShapeSpec
	 * @augments ShapeSpec
	 * @prop {Array.<$3Dmol.Vector3>} vertexArr - List of vertex positions
	 * @prop {Array.<$3Dmol.Vector3>} normalArr - List of normal vectors for each vertex
	 * @prop {Array.<number>} faceArr - List of triangles to build the custom shape. Each triangle is defined by the indices of 3 vertices in vertexArr, so the array length should be 3 times the number of faces.
	 * @prop {ColorSpec | Array.<ColorSpec>} color - Either a single color for the whole object or an array specifying the color at each vertex.
	 */

	/**
	 * Sphere shape specification. Extends {@link ShapeSpec}  
	 * 
	 * @typedef SphereSpec   
	 * @prop {$3Dmol.Vector3} center
	 * @prop {number} radius
	 * 
	 */


	/**
	 * Arrow shape specification.  Extends {@link ShapeSpec}  
	 * @typedef ArrowSpec
	 * @prop {$3Dmol.Vector3} start
	 * @prop {$3Dmol.Vector3} end
	 * @prop {number} radius
	 * @prop {number} radiusRatio - ratio of arrow base to cylinder (1.618034 default)
	 * @prop {number} mid - relative position of arrow base (0.618034 default)
	 */


	/**
	 * Cylinder shape specification.  Extends {@link ShapeSpec}  
	 * @typedef CylinderSpec
	 * @prop {$3Dmol.Vector3} start
	 * @prop {$3Dmol.Vector3} end
	 * @prop {number} radius
	 * @prop {boolean} fromCap
	 * @prop {boolean} toCap
	 */

	/**
	 * Line shape specification.  Extends {@link ShapeSpec}  (but defaults to wireframe)
	 * @typedef LineSpec
	 * @prop {$3Dmol.Vector3} start
	 * @prop {$3Dmol.Vector3} end
	 */

	});
	/**
	 * $3Dmol.VolumeData stores volumetric data. This includes file parsing
	 * functionality.
	 * 
	 * @class
	 * @param {string} str - volumetric data
	 * @param {string} format - format of supplied data (cube)
	 * @param {Object} options - normalize (zero mean, unit variance), negate
	 */
	$3Dmol.VolumeData = function(str, format, options) {

	    this.unit = {
	        x : 1,
	        y : 1,
	        z : 1
	    }; // scale of each voxel
	    this.origin = {
	        x : 0,
	        y : 0,
	        z : 0
	    }; // origin (bottom "left", not center)
	    this.size = {
	        x : 0,
	        y : 0,
	        z : 0
	    }; // number of voxels in each direction
	    this.data = new Float32Array([]); // actual floating point data, arranged
	                                        // x->y->z

	    this.matrix = null; //if set must transform data
	    format = format.toLowerCase();
	    
	    if(/\.gz$/.test(format)) {
	        //unzip gzipped files
	        format = format.replace(/\.gz$/,'');
	        try {
	            str = pako.inflate(str);
	        } catch(err) {
	            console.log(err);
	        }
	    }
	    
	    if (this[format]) {
	        this[format](str);
	    }
	    
	    if(options) {
	        if(options.negate) {
	            for(var i = 0, n = this.data.length; i < n; i++) {
	                this.data[i] = -this.data[i];
	            }
	        }
	        if(options.normalize) {
	            var total = 0.0;
	            for(var i = 0, n = this.data.length; i < n; i++) {
	                total += this.data[i];
	            }
	            var mean = total/this.data.length;
	            console.log("computed mean: "+mean);
	            total = 0;
	            for(var i = 0, n = this.data.length; i < n; i++) {
	                var diff = this.data[i]-mean;
	                total += diff*diff; //variance is ave of squared difference with mean
	            }
	            var variance = total/this.data.length;
	            console.log("Computed variance: "+variance);
	            //now normalize
	            for(var i = 0, n = this.data.length; i < n; i++) {
	                this.data[i] = (this.data[i]-mean)/variance;
	            }
	        }
	    }
	};

	/**
	 * @function $3Dmol.VolumeData.getVal
	 * @param {number} x,y,z - the coordinates
	 * @returns - value closest to provided coordinate; zero if coordinate invalid
	 */
	$3Dmol.VolumeData.prototype.getVal = function(x,y,z) {
	    x -= this.origin.x;
	    y -= this.origin.y;
	    z -= this.origin.z;
	    
	    x /= this.unit.x;
	    y /= this.unit.y;
	    z /= this.unit.z;
	    
	    x = Math.round(x);
	    y = Math.round(y);
	    z = Math.round(z);
	    
	    if(x < 0 || x >= this.size.x) return 0;
	    if(y < 0 || y >= this.size.y) return 0;
	    if(z < 0 || z >= this.size.z) return 0;
	    
	    return this.data[x*this.size.y*this.size.z + y*this.size.z + z];
	};

	/*
	 * parse vasp data
	 * Essentially this parser converts the CHGCAR data into
	 * cube data. It has been adapted from 'chg2cube.pl' found in
	 * http://theory.cm.utexas.edu/vtsttools/
	 */
	$3Dmol.VolumeData.prototype.vasp = function(str) {

	    var lines = str.replace(/^\s+/, "").split(/[\n\r]/);

	    var atomicData = $3Dmol.Parsers.vasp(str)[0];
	    var natoms = atomicData.length;

	    if (natoms == 0) {
	      console.log("No good formating of CHG or CHGCAR file, not atomic information provided in the file.");
	      this.data = [];
	      return;
	    }



	    // Assume atomic units 
	    var unittype = "bohr/hartree";
	    var l_units = 1.889725992;
	    var e_units = 0.036749309;

	    // copied from $3Dmol.Parsers.vasp
	    var convFactor = parseFloat(lines[1]);
	    // This is how Vasp reads in the basis We need the l_units in order to
	    // compute the volume of the cell. Afterwards to obtain the axis for the
	    // voxels we have to remove this unit and divide by the number of voxels in
	    // each dimension
	    var v;
	    v=lines[2].replace(/^\s+/, "").split(/\s+/);
	    var xVec = new $3Dmol.Vector3(parseFloat(v[0]),parseFloat(v[1]),parseFloat(v[2])).multiplyScalar(convFactor*l_units);
	    v=lines[3].replace(/^\s+/, "").split(/\s+/);
	    var yVec = new $3Dmol.Vector3(parseFloat(v[0]),parseFloat(v[1]),parseFloat(v[2])).multiplyScalar(convFactor*l_units);
	    v=lines[4].replace(/^\s+/, "").split(/\s+/);
	    var zVec = new $3Dmol.Vector3(parseFloat(v[0]),parseFloat(v[1]),parseFloat(v[2])).multiplyScalar(convFactor*l_units);

	    // correct volume for non-orthognal box (expansion by minors)
	    var vol = xVec.x*(yVec.y*zVec.z - zVec.y*yVec.z) - yVec.x*(xVec.y*zVec.z - zVec.y*xVec.z) + zVec.x*(xVec.y*yVec.z - yVec.y*xVec.z);

	    vol = Math.abs(vol)/(Math.pow(l_units,3));
	    var vol_scale = 1.0/(vol); //This Only for CHGCAR files

	    // We splice the structure information
	    // 2 (header) + 3 (vectors) + 2 (atoms) + 1 (vaspMode) + natoms (coords) + 1 (blank line) 
	    lines.splice(0,2+3+2+1+natoms+1);


	    var lineArr = lines[0].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");

	    var nX = Math.abs(lineArr[0]);
	    var nY = Math.abs(lineArr[1]);
	    var nZ = Math.abs(lineArr[2]);

	    var origin = this.origin = new $3Dmol.Vector3(0,0,0);

	    this.size = {x:nX, y:nY, z:nZ};
	    this.unit = new $3Dmol.Vector3(xVec.x, yVec.y, zVec.z);

	    // resize the vectors accordingly
	    xVec = xVec.multiplyScalar(1/(l_units*nX));
	    yVec = yVec.multiplyScalar(1/(l_units*nY));
	    zVec = zVec.multiplyScalar(1/(l_units*nZ));

	    if (xVec.y != 0 || xVec.z != 0 || yVec.x != 0 || yVec.z != 0 || zVec.x != 0
	            || zVec.y != 0) {
	        //need a transformation matrix
	        this.matrix =  new $3Dmol.Matrix4(xVec.x, yVec.x, zVec.x, 0, xVec.y, yVec.y, zVec.y, 0, xVec.z, yVec.z, zVec.z, 0, 0,0,0,1);
	        //include translation in matrix
	        this.matrix = this.matrix.multiplyMatrices(this.matrix, 
	                new $3Dmol.Matrix4().makeTranslation(origin.x, origin.y, origin.z));
	        //all translation and scaling done by matrix, so reset origin and unit
	        this.origin = new $3Dmol.Vector3(0,0,0);
	        this.unit = new $3Dmol.Vector3(1,1,1);
	    }


	    lines.splice(0,1); //Remove the dimension line 
	    var raw = lines.join(" ");

	    raw = raw.replace(/^\s+/,'');
	    raw = raw.split(/[\s\r]+/);
	    raw.splice(nX*nY*nZ+1);

	    var preConvertedData = new Float32Array(raw); //We still have to format it to get the density

	    for (var i = 0; i< preConvertedData.length; i++){
	      preConvertedData[i] = preConvertedData[i]*vol_scale*e_units;
	    }

	    this.data = preConvertedData;

	    //console.log(xVec);
	    //console.log(yVec);
	    //console.log(zVec);
	    //console.log(this.unit);
	    //console.log(this.origin);
	    //console.log(this.matrix);
	    //console.log(this.data);

	};

	// parse cube data
	$3Dmol.VolumeData.prototype.cube = function(str) {
	    var lines = str.replace(/^\s+/, "").split(/[\n\r]+/);

	    if (lines.length < 6)
	        return;

	    var lineArr = lines[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");

	    var atomsnum = parseFloat(lineArr[0]); //includes sign, which indicates presence of oribital line in header
	    var natoms = Math.abs(atomsnum);

	    var origin = this.origin = new $3Dmol.Vector3(parseFloat(lineArr[1]),
	            parseFloat(lineArr[2]), parseFloat(lineArr[3]));

	    lineArr = lines[3].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");

	    // might have to convert from bohr units to angstroms
	    // there is a great deal of confusion here:
	    // n>0 means angstroms: http://www.gaussian.com/g_tech/g_ur/u_cubegen.htm
	    // n<0 means angstroms: http://paulbourke.net/dataformats/cube/
	    // always assume bohr: openbabel source code
	    // always assume angstrom: http://www.ks.uiuc.edu/Research/vmd/plugins/molfile/cubeplugin.html
	    // we are going to go with n<0 means angstrom - note this is just the first n
	    var convFactor = (lineArr[0] > 0) ? 0.529177 : 1;
	    origin.multiplyScalar(convFactor);

	    var nX = Math.abs(lineArr[0]);
	    var xVec = new $3Dmol.Vector3(parseFloat(lineArr[1]),
	            parseFloat(lineArr[2]), parseFloat(lineArr[3]))
	            .multiplyScalar(convFactor);

	    lineArr = lines[4].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
	    var nY = Math.abs(lineArr[0]);
	    var yVec = new $3Dmol.Vector3(parseFloat(lineArr[1]),
	            parseFloat(lineArr[2]), parseFloat(lineArr[3]))
	            .multiplyScalar(convFactor);

	    lineArr = lines[5].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
	    var nZ = Math.abs(lineArr[0]);
	    var zVec = new $3Dmol.Vector3(parseFloat(lineArr[1]),
	            parseFloat(lineArr[2]), parseFloat(lineArr[3]))
	            .multiplyScalar(convFactor);

	    this.size = {x:nX, y:nY, z:nZ};
	    this.unit = new $3Dmol.Vector3(xVec.x, yVec.y, zVec.z);
	    
	    if (xVec.y != 0 || xVec.z != 0 || yVec.x != 0 || yVec.z != 0 || zVec.x != 0
	            || zVec.y != 0) {
	        //need a transformation matrix
	        this.matrix =  new $3Dmol.Matrix4(xVec.x, yVec.x, zVec.x, 0, xVec.y, yVec.y, zVec.y, 0, xVec.z, yVec.z, zVec.z, 0, 0,0,0,1);
	        //include translation in matrix
	        this.matrix = this.matrix.multiplyMatrices(this.matrix, 
	                new $3Dmol.Matrix4().makeTranslation(origin.x, origin.y, origin.z));
	        //all translation and scaling done by matrix, so reset origin and unit
	        this.origin = new $3Dmol.Vector3(0,0,0);
	        this.unit = new $3Dmol.Vector3(1,1,1);
	    }
	    
	    var headerlines = 6;
	    if(atomsnum < 0) headerlines++; //see: http://www.ks.uiuc.edu/Research/vmd/plugins/molfile/cubeplugin.html
	    var raw = lines.splice(natoms + headerlines).join(" ");
	    raw = raw.replace(/^\s+/,'');
	    raw = raw.split(/[\s\r]+/);
	    this.data = new Float32Array(raw);

	};

	//parse cp4 files
	$3Dmol.VolumeData.prototype.ccp4 = function(bin) {

	    // http://www.ccp4.ac.uk/html/maplib.html#description
	    //code from ngl: https://github.com/arose/ngl/blob/master/js/ngl/parser.js
	    var header = {};
	    bin = new Int8Array(bin);
	    var intView = new Int32Array( bin.buffer, 0, 56 );
	    var floatView = new Float32Array( bin.buffer, 0, 56 );
	    var dv = new DataView( bin.buffer );
	    

	    // 53  MAP         Character string 'MAP ' to identify file type
	    header.MAP = String.fromCharCode(
	        dv.getUint8( 52 * 4 ), dv.getUint8( 52 * 4 + 1 ),
	        dv.getUint8( 52 * 4 + 2 ), dv.getUint8( 52 * 4 + 3 )
	    );

	    // 54  MACHST      Machine stamp indicating machine type which wrote file
	    //                 17 and 17 for big-endian or 68 and 65 for little-endian
	    header.MACHST = [ dv.getUint8( 53 * 4 ), dv.getUint8( 53 * 4 + 1 ) ];

	    // swap byte order when big endian
	    if( header.MACHST[ 0 ] === 17 && header.MACHST[ 1 ] === 17 ){
	        var n = bin.byteLength;
	        for( var i = 0; i < n; i+=4 ){
	            dv.setFloat32( i, dv.getFloat32( i ), true );
	        }
	    }

	    header.NX = intView[ 0 ];  // NC - columns (fastest changing)
	    header.NY = intView[ 1 ];  // NR - rows
	    header.NZ = intView[ 2 ];  // NS - sections (slowest changing)

	    // mode
	    //  0 image : signed 8-bit bytes range -128 to 127
	    //  1 image : 16-bit halfwords
	    //  2 image : 32-bit reals
	    //  3 transform : complex 16-bit integers
	    //  4 transform : complex 32-bit reals
	    //  6 image : unsigned 16-bit range 0 to 65535
	    // 16 image: unsigned char * 3 (for rgb data, non-standard)
	    //
	    // Note: Mode 2 is the normal mode used in the CCP4 programs.
	    //       Other modes than 2 and 0 may NOT WORK
	    header.MODE = intView[ 3 ];

	    // start
	    header.NXSTART = intView[ 4 ];  // NCSTART - first column
	    header.NYSTART = intView[ 5 ];  // NRSTART - first row
	    header.NZSTART = intView[ 6 ];  // NSSTART - first section

	    // intervals
	    header.MX = intView[ 7 ];  // intervals along x
	    header.MY = intView[ 8 ];  // intervals along y
	    header.MZ = intView[ 9 ];  // intervals along z

	    // cell length (Angstroms in CCP4)
	    header.xlen = floatView[ 10 ];
	    header.ylen = floatView[ 11 ];
	    header.zlen = floatView[ 12 ];

	    // cell angle (Degrees)
	    header.alpha = floatView[ 13 ];
	    header.beta  = floatView[ 14 ];
	    header.gamma = floatView[ 15 ];

	    // axis correspondence (1,2,3 for X,Y,Z)
	    header.MAPC = intView[ 16 ];  // column
	    header.MAPR = intView[ 17 ];  // row
	    header.MAPS = intView[ 18 ];  // section

	    // density statistics
	    header.DMIN  = floatView[ 19 ];
	    header.DMAX  = floatView[ 20 ];
	    header.DMEAN = floatView[ 21 ];

	    // space group number 0 or 1 (default=0)
	    header.ISPG = intView[ 22 ];

	    // number of bytes used for symmetry data (0 or 80)
	    header.NSYMBT = intView[ 23 ];

	    // Flag for skew transformation, =0 none, =1 if foll
	    header.LSKFLG = intView[ 24 ];

	    // 26-34  SKWMAT  Skew matrix S (in order S11, S12, S13, S21 etc) if
	    //                LSKFLG .ne. 0.
	    // 35-37  SKWTRN  Skew translation t if LSKFLG != 0.
	    //                Skew transformation is from standard orthogonal
	    //                coordinate frame (as used for atoms) to orthogonal
	    //                map frame, as Xo(map) = S * (Xo(atoms) - t)

	    // 38      future use       (some of these are used by the MSUBSX routines
	    //  .          "              in MAPBRICK, MAPCONT and FRODO)
	    //  .          "   (all set to zero by default)
	    //  .          "
	    // 52          "

	    // 50-52 origin in X,Y,Z used for transforms
	    header.originX = floatView[ 49 ];
	    header.originY = floatView[ 50 ];
	    header.originZ = floatView[ 51 ];

	    // 53  MAP         Character string 'MAP ' to identify file type
	    // => see top of this parser

	    // 54  MACHST      Machine stamp indicating machine type which wrote file
	    // => see top of this parser

	    // Rms deviation of map from mean density
	    header.ARMS = floatView[ 54 ];

	    // 56      NLABL           Number of labels being used
	    // 57-256  LABEL(20,10)    10  80 character text labels (ie. A4 format)
	    console.log("Map has min,mean,average,rmsddv: "+header.DMIN+","+header.DMAX+","+header.DMEAN+","+header.ARMS);

	    //create transformation matrix, code mostly copied from ngl
	    var h = header;
	    var basisX = [
	          h.xlen,
	          0,
	          0
	      ];

	      var basisY = [
	          h.ylen * Math.cos( Math.PI / 180.0 * h.gamma ),
	          h.ylen * Math.sin( Math.PI / 180.0 * h.gamma ),
	          0
	      ];

	      var basisZ = [
	          h.zlen * Math.cos( Math.PI / 180.0 * h.beta ),
	          h.zlen * (
	                  Math.cos( Math.PI / 180.0 * h.alpha )
	                  - Math.cos( Math.PI / 180.0 * h.gamma )
	                  * Math.cos( Math.PI / 180.0 * h.beta )
	              ) / Math.sin( Math.PI / 180.0 * h.gamma ),
	          0
	      ];
	      basisZ[ 2 ] = Math.sqrt(
	          h.zlen * h.zlen * Math.sin( Math.PI / 180.0 * h.beta ) *
	          Math.sin( Math.PI / 180.0 * h.beta ) - basisZ[ 1 ] * basisZ[ 1 ]
	      );

	      var basis = [ 0, basisX, basisY, basisZ ];
	      var nxyz = [ 0, h.MX, h.MY, h.MZ ];
	      var mapcrs = [ 0, h.MAPC, h.MAPR, h.MAPS ];

	      this.matrix = new $3Dmol.Matrix4();

	      this.matrix.set(

	          basis[ mapcrs[1] ][0] / nxyz[ mapcrs[1] ],
	          basis[ mapcrs[2] ][0] / nxyz[ mapcrs[2] ],
	          basis[ mapcrs[3] ][0] / nxyz[ mapcrs[3] ],
	          0,

	          basis[ mapcrs[1] ][1] / nxyz[ mapcrs[1] ],
	          basis[ mapcrs[2] ][1] / nxyz[ mapcrs[2] ],
	          basis[ mapcrs[3] ][1] / nxyz[ mapcrs[3] ],
	          0,

	          basis[ mapcrs[1] ][2] / nxyz[ mapcrs[1] ],
	          basis[ mapcrs[2] ][2] / nxyz[ mapcrs[2] ],
	          basis[ mapcrs[3] ][2] / nxyz[ mapcrs[3] ],
	          0,

	          0, 0, 0, 1

	      );
	      //include translation in matrix
	      this.matrix = this.matrix.multiplyMatrices(this.matrix, 
	              new $3Dmol.Matrix4().makeTranslation(
	                      h.NXSTART + h.originX,
	                      h.NYSTART + h.originY,
	                      h.NZSTART + h.originZ));
	      //all translation and scaling done by matrix, so reset origin and unit
	      this.origin = new $3Dmol.Vector3(0,0,0);
	      this.unit = new $3Dmol.Vector3(1,1,1); 
	      this.size = {x:header.NX, y:header.NY, z:header.NZ};
	      var data = new Float32Array(bin.buffer, 1024 + header.NSYMBT);
	      //data must by (slowest changing) x,y,z (fastest changing)

	      var NX = header.NX, NY = header.NY, NZ = header.NZ;
	      this.data = new Float32Array(NX*NY*NZ);
	      for(var i = 0; i < NX; i++) {
	          for(var j = 0; j < NY; j++) {
	              for(var k = 0; k < NZ; k++) {
	                  //should I be concerned that I'm not using mapc?
	                  this.data[((i*NY)+j)*NZ+k] = data[((k*NY)+j)*NX+i];
	              }
	          }
	      }

	};
	//Hackish way to create webworker (independent of $3Dmol namespace) within minified file
	$3Dmol.workerString = function(){

	    self.onmessage = function(oEvent) {
	        var obj = oEvent.data;
	        var type = obj.type;
	        if (type < 0) // sending atom data, initialize
	        {
	            self.atomData = obj.atoms;
	            self.volume = obj.volume;
	            self.ps = new ProteinSurface();
	        } else {
	            var ps = self.ps;
	            ps.initparm(obj.expandedExtent, (type == 1) ? false : true, self.volume);
	            ps.fillvoxels(self.atomData, obj.extendedAtoms);
	            ps.buildboundary();
	            if (type === 4 || type === 2) {
	                ps.fastdistancemap();
	                ps.boundingatom(false);
	                ps.fillvoxelswaals(self.atomData, obj.extendedAtoms);    
	            }        
	            ps.marchingcube(type);
	            var VandF = ps.getFacesAndVertices(obj.atomsToShow);
	            self.postMessage(VandF);
	        }
	    };
	    
	}.toString().replace(/(^.*?\{|\}$)/g, "");

	$3Dmol.workerString += "; var ProteinSurface=" + $3Dmol.ProteinSurface.toString().replace(/\$3Dmol.MarchingCube./g, "MarchingCube.");
	$3Dmol.workerString += ",MarchingCube=("+$3Dmol.MarchingCubeInitializer.toString() +")();";

	$3Dmol.SurfaceWorker = window.URL.createObjectURL(new Blob([$3Dmol.workerString],{type: 'text/javascript'}));

	$3Dmol['workerString'] = $3Dmol.workerString;
	$3Dmol['SurfaceWorker'] = $3Dmol.SurfaceWorker;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);
	var $3Dmol = __webpack_require__(134);

	/**
	 * Utility class to initialize the 3D mutation visualizer with 3Dmol.js
	 *
	 * Note: This class is assumed to have the same interface
	 * (the same signature for all public functions) with the JmolWrapper.
	 *
	 * @author Selcuk Onur Sumer
	 */
	function Mol3DWrapper()
	{
		// TODO default options
		var defaultOpts = {};

		var _options = null;
		var _viewer = null;

		/**
		 * Initializes the visualizer.
		 *
		 * @param name      name of the application
		 * @param options   app options
		 */
		function init(name, options)
		{
			_options = jQuery.extend(true, {}, defaultOpts, options);

			// update wrapper reference
			$(options.el).append("<div id='" + name + "' " +
				"style='width: " + _options.width + "px; height: " + _options.height +
				"px; margin: 0; padding: 0; border: 0;'></div>");
			var wrapper = $("#" + name);
			wrapper.hide();

			var viewer = $3Dmol.createViewer(wrapper,
				{defaultcolors: $3Dmol.elementColors.rasmol});
			viewer.setBackgroundColor(0xffffff);

			_viewer = viewer;
		}

		/**
		 * Updates the container of the visualizer object.
		 *
		 * @param container container selector
		 */
		function updateContainer(container)
		{
			// move visualizer into its new container
			if (_viewer != null)
			{
				_viewer.setContainer(container);
			}
		}

		/**
		 * Runs the given command as a script on the 3D visualizer object.
		 *
		 * @param command   command to send
		 * @param callback  function to call after execution of the script
		 */
		function script(command, callback)
		{
			if (command != null &&
			    _viewer != null)
			{
				// render after running the script
				_viewer.render();
			}

			// call the callback function after script completed
			if(_.isFunction(callback))
			{
				callback();
			}
		}

		function getViewer()
		{
			return _viewer;
		}

		return {
			init: init,
			updateContainer: updateContainer,
			getViewer: getViewer,
			script: script
		};
	}

	module.exports = Mol3DWrapper;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var JmolScriptGenerator = __webpack_require__(137);

	/**
	 * PymolScriptGenerator class (extends JmolScriptGenerator)
	 *
	 * Script generator for the PyMOL application.
	 *
	 * @author Selcuk Onur Sumer
	 */
	function PymolScriptGenerator()
	{
		// Predefined style scripts for Jmol
		var _styleScripts = {
			ballAndStick: "hide everything; show spheres; show sticks; alter all, vdw=0.50",
			spaceFilling: "hide everything; show spheres;",
			ribbon: "hide everything; show ribbon;",
			cartoon: "hide everything; show cartoon;",
			// TODO there is no "trace" in PyMOL, ribbon is the most similar one
			trace: "hide everything; show ribbon;"
		};

		function reinitialize()
		{
			return "reinitialize;";
		}

		function bgColor(color)
		{
			return "bg_color " + formatColor(color) + ";";
		}

		function loadPdb(pdbId)
		{
			return "fetch " + pdbId + ", async=0;";
		}

		function setScheme(schemeName)
		{
			return _styleScripts[schemeName];
		}

		function setColor (color)
		{
			return "color " + formatColor(color) + ", sele;";
		}

		function selectChain(chainId)
		{
			return "select chain " + chainId + ";";
		}

		function selectAlphaHelix(chainId)
		{
			return "select (chain " + chainId + ") and (ss h);";
		}

		function selectBetaSheet(chainId)
		{
			return "select (chain " + chainId + ") and (ss s);";
		}

		function selectPositions(scriptPositions, chainId)
		{
			return "select (resi " + scriptPositions.join(",") + ") and (chain " + chainId + ");";
		}

		function selectSideChains(scriptPositions, chainId)
		{
			return "select ((resi " + scriptPositions.join(",") + ") and (chain " + chainId + ") and (not name c+n+o));";
		}

		function setTransparency(transparency)
		{
			// TODO cartoon_transparency doesn't work for chain or residue selections
			// see issue:  http://sourceforge.net/p/pymol/bugs/129/
			return ("set transparency, " + (transparency / 10) + ", sele;\n" +
			        "set cartoon_transparency, " + (transparency / 10) + ", sele;\n" +
			        "set sphere_transparency, " + (transparency / 10) + ", sele;\n" +
			        "set stick_transparency, " + (transparency / 10) + ", sele;");
		}

		function enableBallAndStick()
		{
			return "show spheres, sele; show sticks, sele; alter sele, vdw=0.50;";
		}

		function disableBallAndStick()
		{
			return "hide spheres, sele; hide sticks, sele;";
		}

		function rainbowColor(chainId)
		{
			return "spectrum count, rainbow_rev, sele";
		}

		function cpkColor(chainId)
		{
			return "util.cbaw sele;";
		}

		function hideBoundMolecules()
		{
			// restrict to protein only
			return "hide everything," +
			       "not resn asp+glu+arg+lys+his+asn+thr+cys+gln+tyr+ser+gly+ala+leu+val+ile+met+trp+phe+pro";
		}

		function formatColor(color)
		{
			// this is for Pymol compatibility
			// (colors should start with an "0x" instead of "#")
			return color.replace("#", "0x");
		}

		// override required functions
		this.loadPdb = loadPdb;
		this.setScheme = setScheme;
		this.setColor = setColor;
		this.selectChain = selectChain;
		this.selectAlphaHelix = selectAlphaHelix;
		this.selectBetaSheet = selectBetaSheet;
		this.rainbowColor = rainbowColor;
		this.cpkColor = cpkColor;
		this.hideBoundMolecules = hideBoundMolecules;
		this.setTransparency = setTransparency;
		this.selectPositions = selectPositions;
		this.selectSideChains = selectSideChains;
		this.enableBallAndStick = enableBallAndStick;
		this.disableBallAndStick = disableBallAndStick;
		this.reinitialize = reinitialize;
		this.bgColor = bgColor;
	}

	// PymolScriptGenerator extends JmolScriptGenerator...
	PymolScriptGenerator.prototype = new JmolScriptGenerator();
	PymolScriptGenerator.prototype.constructor = PymolScriptGenerator;

	module.exports = PymolScriptGenerator;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MolScriptGenerator = __webpack_require__(133);

	/**
	 * JmolScriptGenerator class (extends MolScriptGenerator)
	 *
	 * Script generator for Jmol/JSmol applications.
	 *
	 * @author Selcuk Onur Sumer
	 */
	function JmolScriptGenerator()
	{
		// Predefined style scripts for Jmol
		var _styleScripts = {
			ballAndStick: "wireframe ONLY; wireframe 0.15; spacefill 20%;",
			spaceFilling: "spacefill ONLY; spacefill 100%;",
			ribbon: "ribbon ONLY;",
			cartoon: "cartoon ONLY;",
			trace: "trace ONLY;"
		};

		function loadPdb(pdbId)
		{
			return "load=" + pdbId + ";";
		}

		function selectAll()
		{
			return "select all;";
		}

		function selectNone()
		{
			return "select none;";
		}

		function setScheme(schemeName)
		{
			return _styleScripts[schemeName];
		}

		function setColor (color)
		{
			return "color [" + formatColor(color) + "];"
		}

		function selectChain(chainId)
		{
			return "select :" + chainId + ";";
		}

		function selectAlphaHelix(chainId)
		{
			return "select :" + chainId + " and helix;";
		}

		function selectBetaSheet(chainId)
		{
			return "select :" + chainId + " and sheet;";
		}

		function rainbowColor(chainId)
		{
			// min atom no within the selected chain
			var rangeMin = "@{{:" + chainId + "}.atomNo.min}";
			// max atom no within the selected chain
			var rangeMax = "@{{:" + chainId + "}.atomNo.max}";

			// max residue no within the selected chain
			//var rangeMin = "@{{:" + chain.chainId + "}.resNo.min}";
			// max residue no within the selected chain
			//var rangeMax = "@{{:" + chain.chainId + "}.resNo.max}";

			// color the chain by rainbow coloring scheme (gradient coloring)
			return 'color atoms property atomNo "roygb" ' +
				'range ' + rangeMin + ' ' + rangeMax + ';';
		}

		function cpkColor(chainId)
		{
			return "color atoms CPK;";
		}

		function hideBoundMolecules()
		{
			return "restrict protein;";
		}

		function setTransparency(transparency)
		{
			// TODO we should use the given transparency value...
			if (transparency > 0)
			{
				return "color translucent;";
			}
			else
			{
				return "color opaque;";
			}
		}

		/**
		 * Generates a position string for Jmol scripting.
		 *
		 * @position object containing PDB position info
		 * @return {string} position string for Jmol
		 */
		function scriptPosition(position)
		{
			var insertionStr = function(insertion) {
				var posStr = "";

				if (insertion != null &&
				    insertion.length > 0)
				{
					posStr += "^" + insertion;
				}

				return posStr;
			};

			var startPdbPos = position.start.pdbPos || position.start.pdbPosition;
			var endPdbPos = position.end.pdbPos || position.end.pdbPosition;

			var posStr = startPdbPos +
			             insertionStr(position.start.insertion);

			if (endPdbPos > startPdbPos)
			{
				posStr += "-" + endPdbPos +
				          insertionStr(position.end.insertion);
			}

			return posStr;
		}

		function selectPositions(scriptPositions, chainId)
		{
			return "select (" + scriptPositions.join(", ") + ") and :" + chainId + ";";
		}

		function selectSideChains(scriptPositions, chainId)
		{
			return "select ((" + scriptPositions.join(", ") + ") and :" + chainId + " and sidechain) or " +
			"((" + scriptPositions.join(", ") + ") and :" + chainId + " and *.CA);"
		}

		function enableBallAndStick()
		{
			return "wireframe 0.15; spacefill 25%;";
		}

		function disableBallAndStick()
		{
			return "wireframe OFF; spacefill OFF;";
		}

		function center(position, chainId)
		{
			var self = this;
			var scriptPos = self.scriptPosition(position);
			return "center " + scriptPos + ":" + chainId + ";"
		}

		function defaultCenter()
		{
			return "center;";
		}

		function zoom(zoomValue)
		{
			// center and zoom to the selection
			return "zoom " + zoomValue + ";";
		}

		function defaultZoomIn()
		{
			return "zoom in;"
		}

		function defaultZoomOut()
		{
			return "zoom out;"
		}

		function spin(value)
		{
			return "spin " + value + ";";
		}

		/**
		 * Generates highlight script by using the converted highlight positions.
		 *
		 * @param scriptPositions   script positions
		 * @param color             highlight color
		 * @param options           visual style options
		 * @param chain             a PdbChainModel instance
		 * @return {Array} script lines as an array
		 */
		function highlightScript(scriptPositions, color, options, chain)
		{
			var self = this;
			var script = [];

			// add highlight color
			// "select (" + scriptPositions.join(", ") + ") and :" + chain.chainId + ";"
			script.push(self.selectPositions(scriptPositions, chain.chainId));
			script.push(self.setColor(color));

			var displaySideChain = options.displaySideChain != "none";

			// show/hide side chains
			script = script.concat(
				self.generateSideChainScript(scriptPositions, displaySideChain, options, chain));

			return script;
		}

		function formatColor(color)
		{
			// this is for Jmol compatibility
			// (colors should start with an "x" instead of "#")
			return color.replace("#", "x");
		}

		// override required functions
		this.loadPdb = loadPdb;
		this.selectAll = selectAll;
		this.selectNone = selectNone;
		this.setScheme = setScheme;
		this.setColor = setColor;
		this.selectChain = selectChain;
		this.selectAlphaHelix = selectAlphaHelix;
		this.selectBetaSheet = selectBetaSheet;
		this.rainbowColor = rainbowColor;
		this.cpkColor = cpkColor;
		this.hideBoundMolecules = hideBoundMolecules;
		this.setTransparency = setTransparency;
		this.scriptPosition = scriptPosition;
		this.selectPositions = selectPositions;
		this.selectSideChains = selectSideChains;
		this.enableBallAndStick = enableBallAndStick;
		this.disableBallAndStick = disableBallAndStick;
		this.highlightScript = highlightScript;
		this.center = center;
		this.defaultZoomIn = defaultZoomIn;
		this.defaultZoomOut = defaultZoomOut;
		this.defaultCenter = defaultCenter;
		this.spin = spin;
	}

	// JmolScriptGenerator extends MolScriptGenerator...
	JmolScriptGenerator.prototype = new MolScriptGenerator();
	JmolScriptGenerator.prototype.constructor = JmolScriptGenerator;

	module.exports = JmolScriptGenerator;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var Mutation3dVisInfoView = __webpack_require__(139);
	var MutationDetailsEvents = __webpack_require__(22);
	var PdbDataUtil = __webpack_require__(10);
	var BackboneTemplateCache = __webpack_require__(23);

	var cbio = {
		download: __webpack_require__(141)
	};

	var loaderImage = __webpack_require__(85);
	var helpImage = __webpack_require__(143);

	var Backbone = __webpack_require__(12);
	var _ = __webpack_require__(5);
	var $ = __webpack_require__(7);
	var jQuery = $;
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(8);
	__webpack_require__(9);

	/**
	 * Actual 3D Visualizer view. This view is designed to contain the 3D
	 * structure visualizer app and its control buttons.
	 *
	 * options: {el: [target container],
	 *           mut3dVis: reference to the Mutation3dVis instance,
	 *           pdbProxy: PDB data proxy,
	 *           mutationProxy: mutation data proxy
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var Mutation3dVisView = Backbone.View.extend({
		initialize : function (options) {
			var defaultOpts = {
				config: {
					loaderImage: loaderImage,
					helpImage: helpImage,
					border: {
						top: 0,
						left: 0
					}
				}
			};

			this.options = jQuery.extend(true, {}, defaultOpts, options);

			// custom event dispatcher
			this.dispatcher = {};
			_.extend(this.dispatcher, Backbone.Events);
		},
		render: function()
		{
			var self = this;

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_3d_vis_template");

			var template = templateFn({
				loaderImage: self.options.config.loaderImage,
				helpImage: self.options.config.helpImage
			});

			// load the compiled HTML into the Backbone "el"
			self.$el.html(template);

			// format after rendering
			self.format();
		},
		format: function()
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			var container3d = self.$el;

			// initially hide the residue warning message
			self.hideResidueWarning();
			self.hideNoMapWarning();

			// initially hide the help content
			var helpContent = self.$el.find(".mutation-3d-vis-help-content");

			// TODO use the self.options.viewer object to determine which content to display!
			var helpTemplateFn = BackboneTemplateCache.getTemplateFn("3Dmol_basic_interaction");
			helpContent.html(helpTemplateFn({}));
			helpContent.hide();

			// update the container of 3d visualizer
			if (mut3dVis != null)
			{
				mut3dVis.updateContainer(container3d);
				mut3dVis.show();
			}

			// add listeners to panel (header) buttons

			self.$el.find(".mutation-3d-close").click(function() {
				self.hideView();
			});

			self.$el.find(".mutation-3d-minimize").click(function(){
				if (mut3dVis != null)
				{
					mut3dVis.toggleSize();
				}
			});

			// format toolbar elements

			// mutation style controls
			self._initMutationControls();

			// protein style controls
			self._initProteinControls();

			// zoom slider
			//self._initZoomSlider();

			// init buttons
			self._initButtons();

			self.showMainLoader();

			// make the main container draggable
			container3d.draggable({
				handle: ".mutation-3d-info-title",
	//			start: function(event, ui) {
	//				// fix the width to prevent resize during drag
	//				var width = container3d.css("width");
	//				container3d.css("width", width);
	//			},
				stop: function(event, ui) {
					var top = parseInt(container3d.css("top"));
					var left = parseInt(container3d.css("left"));
					//var width = parseInt(container3d.css("width"));

					// if the panel goes beyond the visible area, get it back!

					if (top < parseInt(self.options.config.border.top))
					{
						container3d.css("top", self.options.config.border.top);
					}

					//if (left < -width)
					if (left < parseInt(self.options.config.border.left))
					{
						container3d.css("left", self.options.config.border.left);
					}

					// TODO user can still take the panel out by dragging it to the bottom or right
				}
			});

			//TODO something like this might be safer for "alsoResize" option:
			// container3d.find(".mutation-3d-vis-container,.mutation-3d-vis-container div:eq(0)")

			// make the container resizable
			container3d.resizable({
				alsoResize: ".mutation-3d-vis-container,.mutation-3d-vis-container div:eq(0)",
				//alsoResize: ".mutation-3d-vis-container",
				handles: "sw, s, w",
				minWidth: 400,
				minHeight: 300,
				start: function(event, ui) {
					// a workaround to properly redraw the 3d-info area
					container3d.find(".mutation-3d-vis-help-content").css("width", "auto");

					// a workaround to prevent position to be set to absolute
					container3d.css("position", "fixed");
				},
				stop: function(event, ui) {
					// a workaround to properly redraw the 3d-info area
					container3d.css("height", "auto");

					// a workaround to prevent position to be set to absolute
					container3d.css("position", "fixed");
				},
				resize: function(event, ui) {
					// this is to prevent window resize event to trigger
					event.stopPropagation();

					// resize (redraw) the 3D viewer
					// (since we don't propagate resize event up to window anymore)
					mut3dVis.resizeViewer();
				}
			})
			.on('resize', function(event) {
				// this is to prevent window resize event to trigger
				event.stopPropagation();
			});
		},
		/**
		 * Initializes the control buttons.
		 */
		_initButtons: function()
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			// init help text controls

			var helpContent = self.$el.find(".mutation-3d-vis-help-content");
			var helpInit = self.$el.find(".mutation-3d-vis-help-init");
			var helpInitLink = self.$el.find(".mutation-3d-vis-help-open");
			var helpClose = self.$el.find(".mutation-3d-vis-help-close");
			var pymolDownload = self.$el.find(".mutation-3d-pymol-dload");

			// add listener to help link
			helpInitLink.click(function(event) {
				event.preventDefault();
				helpContent.slideToggle();
				helpInit.slideToggle();
			});

			// add listener to help close button
			helpClose.click(function(event) {
				event.preventDefault();
				helpContent.slideToggle();
				helpInit.slideToggle();
			});

			// add listener to download link
			pymolDownload.click(function(event) {
				event.preventDefault();

				var script = mut3dVis.generatePymolScript();
				var filename = self.$el.find(".mutation-3d-pdb-id").text().trim() + "_" +
				               self.$el.find(".mutation-3d-chain-id").text().trim() + ".pml";

				var downloadOpts = {
					filename: filename,
					contentType: "text/plain;charset=utf-8",
					preProcess: false};

				// send download request with filename & file content info
				cbio.download.initDownload(script, downloadOpts);
			});

			pymolDownload.qtip(self._generateTooltipOpts("Download PyMOL script"));
		},
		/**
		 * Initializes the mutation style options UI and
		 * the corresponding event handlers.
		 */
		_initMutationControls: function()
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			var sideChain = self.$el.find(".mutation-3d-side-chain-select");

			// handler for side chain checkbox
			sideChain.change(function() {
				//var display = sideChain.is(":checked");
				var selected = $(this).val();

				if (mut3dVis)
				{
					// update flag
					mut3dVis.updateOptions({displaySideChain: selected});
					mut3dVis.reapplyStyle();
				}
			});

			var colorMenu = self.$el.find(".mutation-3d-mutation-color-select");

			colorMenu.change(function() {
				var selected = $(this).val();

				if (mut3dVis)
				{
					// update color options
					mut3dVis.updateOptions({colorMutations: selected});
					// refresh view with new options
					mut3dVis.reapplyStyle();
				}
			});

			// add info tooltip for the color and side chain checkboxes
			self._initMutationColorInfo();
			self._initSideChainInfo();
		},
		/**
		 * Initializes the protein style options UI and
		 * the corresponding event handlers.
		 */
		_initProteinControls: function()
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			var displayNonProtein = self.$el.find(".mutation-3d-display-non-protein");

			// handler for hide non protein checkbox
			displayNonProtein.change(function() {
				var display = displayNonProtein.is(":checked");

				if (mut3dVis)
				{
					// update flag
					mut3dVis.updateOptions({restrictProtein: !display});
					// refresh view with new options
					mut3dVis.reapplyStyle();
				}
			});

			// add info tooltip for the checkbox
			self._initHideNonProteinInfo();

			// protein scheme selector
			self._initProteinSchemeSelector();

			// protein color selector
			self._initProteinColorSelector();
		},
		/**
		 * Initializes the protein color selector drop-down menu
		 * with its default action handler.
		 */
		_initProteinColorSelector: function()
		{
			var self = this;
			var colorMenu = self.$el.find(".mutation-3d-protein-color-select");
			var mut3dVis = self.options.mut3dVis;

			colorMenu.change(function() {
				var selected = $(this).val();

				// update color options
				mut3dVis.updateOptions({colorProteins: selected});

				// refresh view with new options
				mut3dVis.reapplyStyle();
			});
		},
		/**
		 * Initializes the protein scheme selector dropdown menu
		 * with its default action handler.
		 */
		_initProteinSchemeSelector: function()
		{
			var self = this;

			var mut3dVis = self.options.mut3dVis;

			// selection menus
			var styleMenu = self.$el.find(".mutation-3d-protein-style-select");
			var colorMenu = self.$el.find(".mutation-3d-protein-color-select");

			// TODO chosen is somehow problematic...
			//styleMenu.chosen({width: 120, disable_search: true});

			// add info tooltip for the color selector
			self._initProteinColorInfo();

			// bind the change event listener
			styleMenu.change(function() {

				var selectedScheme = $(this).val();
				var selectedColor = false;

				// re-enable every color selection for protein
				colorMenu.find("option").removeAttr("disabled");

				var toDisable = [];

				// find the option to disable
				if (selectedScheme == "spaceFilling")
				{
					// disable color by secondary structure option
					toDisable.push(colorMenu.find("option[value='bySecondaryStructure']"));
					toDisable.push(colorMenu.find("option[value='byChain']"));
				}
				else
				{
					// disable color by atom type option
					toDisable.push(colorMenu.find("option[value='byAtomType']"));
				}

				_.each(toDisable, function(ele, idx) {
					// if the option to disable is currently selected, select the default option
					if (ele.is(":selected"))
					{
						ele.removeAttr("selected");
						colorMenu.find("option[value='uniform']").attr("selected", "selected");
						selectedColor = "uniform";
					}

					ele.attr("disabled", "disabled");
				});

				if (mut3dVis)
				{
					var opts = {};

					opts.proteinScheme = selectedScheme;

					if (selectedColor)
					{
						opts.colorProteins = selectedColor;
					}

					mut3dVis.updateOptions(opts);

					// reapply view with new settings
					//mut3dVis.changeStyle(selectedScheme);
					mut3dVis.reapplyStyle();
				}
			});
		},
		/**
		 * Updates the 3D visualizer content for the given gene,
		 * pdb id, and chain.
		 *
		 * @param geneSymbol    hugo gene symbol
		 * @param pdbId         pdb id
		 * @param chain         PdbChainModel instance
		 */
		updateView: function(geneSymbol, pdbId, chain)
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;
			var pdbProxy = self.options.pdbProxy;

			var mapCallback = function(positionMap) {
				// update position map of the chain
				chain.positionMap = positionMap;

				// reload the selected pdb and chain data
				self.refreshView(pdbId, chain);

				// store pdb id and chain for future reference
				self.pdbId = pdbId;
				self.chain = chain;
			};

			var infoCallback = function(pdbInfo) {
				var model = {pdbId: pdbId,
					chainId: chain.chainId,
					pdbInfo: "",
					molInfo: ""};

				if (pdbInfo && pdbInfo[pdbId])
				{
					var summary = PdbDataUtil.generatePdbInfoSummary(
						pdbInfo[pdbId], chain.chainId);

					model.pdbInfo = summary.title;
					model.molInfo = summary.molecule;
				}

				self.hideMainLoader();

				// init info view
				var infoView = new Mutation3dVisInfoView(
					{el: self.$el.find(".mutation-3d-info"), model: model});
				infoView.render();

				// update positionMap for the chain
				// (retrieve data only once)
				pdbProxy.getPositionMap(geneSymbol, chain, mapCallback);
			};

			self.showMainLoader();
			mut3dVis.show();
			pdbProxy.getPdbInfo(pdbId, infoCallback);
		},
		/**
		 * Refreshes (reloads) the 3D visualizer for the given
		 * pdb id and chain.
		 *
		 * If no pdb id and chain provided, then reloads with
		 * the last known pdb id and chain.
		 *
		 * @param pdbId     pdb id
		 * @param chain     PdbChainModel instance
		 */
		refreshView: function(pdbId, chain)
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			// hide warning messages
			self.hideResidueWarning();
			self.hideNoMapWarning();

			// helper function to show/hide mapping information
			var showMapInfo = function(mapped)
			{
				if (mapped.length == 0)
				{
					// show the warning text
					self.showNoMapWarning();
				}
				else
				{
					// TODO display exactly what is mapped?
	//				var proxy = self.options.mutationProxy;
	//				var types = [];
	//
	//				_.each(mapped, function(id, idx) {
	//					var mutation = proxy.getMutationUtil().getMutationIdMap()[id];
	//					types.push(mutation.mutationType);
	//				});
	//
	//				types = _.unique(types);

					// hide the warning text
					self.hideNoMapWarning();
				}
			};

			// do not reload (just refresh) if no pdb id or chain is provided,
			// or the provided chain and the previous chain are the same
			if ((pdbId == null && chain == null) ||
			    (pdbId == self.pdbId && chain == self.chain))
			{
				// just refresh
				var mapped = mut3dVis.refresh();

				// update mapping info
				showMapInfo(mapped);

				// trigger corresponding event
				self.dispatcher.trigger(
					MutationDetailsEvents.VIEW_3D_STRUCTURE_RELOADED);
			}
			// reload the new pdb structure
			else
			{
				// show loader image
				self.showLoader();

				// set a short delay to allow loader image to appear
				setTimeout(function() {
					// reload the visualizer
					var mapped = mut3dVis.reload(pdbId, chain, function() {
						// hide the loader image after reload complete
						self.hideLoader();
						// trigger corresponding event
						self.dispatcher.trigger(
							MutationDetailsEvents.VIEW_3D_STRUCTURE_RELOADED);
					});
					// update mapping info if necessary
					showMapInfo(mapped);
				}, 50);
			}
		},
		/**
		 * Initializes the mutation color information as a tooltip
		 * for the corresponding checkbox.
		 */
		_initMutationColorInfo: function()
		{
			var self = this;

			var info = self.$el.find(".mutation-type-color-help");

			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_3d_type_color_tip_template");
			var content = templateFn({});
			var options = self._generateTooltipOpts(content);

			// make it wider
			options.style.classes += " qtip-wide";

			info.qtip(options);
		},
		/**
		 * Initializes the protein structure color information as a tooltip
		 * for the corresponding selection menu.
		 */
		_initProteinColorInfo: function()
		{
			var self = this;

			var info = self.$el.find(".protein-struct-color-help");

			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_3d_structure_color_tip_template");
			var content = templateFn({});
			var options = self._generateTooltipOpts(content);

			// make it wider
			options.style.classes += " qtip-wide";

			info.qtip(options);
		},
		/**
		 * Initializes the side chain information as a tooltip
		 * for the corresponding checkbox.
		 */
		_initSideChainInfo: function()
		{
			var self = this;

			var info = self.$el.find(".display-side-chain-help");

			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_3d_side_chain_tip_template");
			var content = templateFn({});

			var options = self._generateTooltipOpts(content);
			info.qtip(options);
		},
		/**
		 * Initializes the side chain information as a tooltip
		 * for the corresponding checkbox.
		 */
		_initHideNonProteinInfo: function()
		{
			var self = this;

			var info = self.$el.find(".display-non-protein-help");

			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_3d_non_protein_tip_template");
			var content = templateFn({});

			var options = self._generateTooltipOpts(content);
			info.qtip(options);
		},
		/**
		 * Generates the default tooltip (qTip) options for the given
		 * tooltip content.
		 *
		 * @param content  actual tooltip content
		 * @return {Object}    qTip options for the given content
		 */
		_generateTooltipOpts: function(content)
		{
			return {content: {text: content},
				hide: {fixed: true, delay: 100, event: 'mouseout'},
				show: {event: 'mouseover'},
				style: {classes: 'qtip-light qtip-rounded qtip-shadow'},
				position: {my:'top right', at:'bottom center', viewport: $(window)}};
		},
		/**
		 * Minimizes the 3D visualizer panel.
		 */
		minimizeView: function()
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			if (mut3dVis)
			{
				mut3dVis.minimize();
			}
		},
		/**
		 * Restores the 3D visualizer panel to its full size.
		 */
		maximizeView: function()
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			if (mut3dVis)
			{
				mut3dVis.maximize();
			}
		},
		/**
		 * Resets the position of the 3D panel to its initial state.
		 */
		resetPanelPosition: function()
		{
			var self = this;
			var container3d = self.$el;

			container3d.css({"left": "", position: "", "top": self.options.config.border.top});
		},
		/**
		 * Hides the 3D visualizer panel.
		 */
		hideView: function()
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			// hide the vis pane
			if (mut3dVis != null)
			{
				mut3dVis.hide();
			}

			// trigger corresponding event
			self.dispatcher.trigger(
				MutationDetailsEvents.VIEW_3D_PANEL_CLOSED);
		},
		/**
		 * Shows the 3D visualizer panel.
		 */
		showView: function()
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			// hide the vis pane
			if (mut3dVis != null)
			{
				mut3dVis.show();
			}
		},
		isVisible: function()
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			return mut3dVis.isVisible();
		},
		/**
		 * Focuses the 3D visualizer on the residue
		 * corresponding to the given pileup of mutations.
		 *
		 * If this function is invoked without a parameter,
		 * then resets the focus to the default state.
		 *
		 * @param pileup    Pileup instance
		 * @return {boolean} true if focus successful, false otherwise
		 */
		focusView: function(pileup)
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			if (pileup)
			{
				return mut3dVis.focusOn(pileup);
			}
			else
			{
				mut3dVis.resetFocus();
				return true;
			}
		},
		/**
		 * Highlights the 3D visualizer for the residue
		 * corresponding to the given array of pileups of mutations.
		 *
		 * @param pileups   an array of Pileup instances
		 * @param reset     whether to reset previous highlights
		 * @return {Number} number of mapped residues
		 */
		highlightView: function(pileups, reset)
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			return mut3dVis.highlight(pileups, reset);
		},
		/**
		 * Resets all residue highlights.
		 */
		resetHighlight: function()
		{
			var self = this;
			var mut3dVis = self.options.mut3dVis;

			mut3dVis.resetHighlight();
		},
		/**
		 * Shows the loader image for the 3D vis container.
		 */
		showLoader: function()
		{
			var self = this;
			var loaderImage = self.$el.find(".mutation-3d-vis-loader");
			var container = self.$el.find(".mutation-3d-vis-container");

			// hide actual vis container
			// (jQuery.hide function is problematic with 3D visualizer,
			// instead we are changing height)
			var height = container.css("height");

			if (!(height === 0 || height === "0px"))
			{
				self._actualHeight = height;
				container.css("height", 0);
			}

			// show image
			loaderImage.show();
		},
		/**
		 * Hides the loader image and shows the actual 3D visualizer content.
		 */
		hideLoader: function()
		{
			var self = this;
			var loaderImage = self.$el.find(".mutation-3d-vis-loader");
			var container = self.$el.find(".mutation-3d-vis-container");

			// hide image
			loaderImage.hide();

			// show actual vis container
			container.css("height", self._actualHeight);
		},
		/**
		 * Shows the loader for the entire panel body.
		 */
		showMainLoader: function()
		{
			var self = this;
			var loaderImage = self.$el.find(".mutation-3d-vis-main-loader");
			var mainContent = self.$el.find(".mutation-3d-vis-body");

			// show the image
			loaderImage.show();

			// hide the main body
			mainContent.hide();
		},
		/**
		 * Hides the loader image and shows the main content (panel body).
		 */
		hideMainLoader: function()
		{
			var self = this;
			var loaderImage = self.$el.find(".mutation-3d-vis-main-loader");
			var mainContent = self.$el.find(".mutation-3d-vis-body");

			// show the image
			loaderImage.hide();

			// hide the main body
			mainContent.show();
		},
		/**
		 * Shows a warning message for unmapped residues.
		 *
		 * @param unmappedCount  number of unmapped selections
		 * @param selectCount    total number of selections
		 */
		showResidueWarning: function(unmappedCount, selectCount)
		{
			var self = this;
			var warning = self.$el.find(".mutation-3d-residue-warning");
			var unmapped = self.$el.find(".mutation-3d-unmapped-info");

			// show warning only if no other warning is visible
			if (!self.$el.find(".mutation-3d-nomap-warning").is(":visible"))
			{
				if (selectCount > 1)
				{
					unmapped.text(unmappedCount + " of the selections");
				}
				else
				{
					unmapped.text("Selected mutation");
				}

				warning.show();
			}
		},
		/**
		 * Hides the residue warning message.
		 */
		hideResidueWarning: function()
		{
			var self = this;
			var warning = self.$el.find(".mutation-3d-residue-warning");

			warning.hide();
		},
		/**
		 * Shows a warning message for unmapped residues.
		 */
		showNoMapWarning: function()
		{
			var self = this;
			var warning = self.$el.find(".mutation-3d-nomap-warning");

			warning.show();
		},
		/**
		 * Hides the residue warning message.
		 */
		hideNoMapWarning: function()
		{
			var self = this;
			var warning = self.$el.find(".mutation-3d-nomap-warning");

			warning.hide();
		}
	});

	module.exports = Mutation3dVisView;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var BackboneTemplateCache = __webpack_require__(23);

	var Backbone = __webpack_require__(12);
	var $ = __webpack_require__(7);
	__webpack_require__(140);

	/**
	 * Information view for the 3D Visualization panel.
	 *
	 * options: {el: [target container],
	 *           model: {pdbId: String,
	 *                   chainId: String,
	 *                   pdbInfo: String,
	 *                   molInfo: String}
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var Mutation3dVisInfoView = Backbone.View.extend({
		render: function()
		{
			var self = this;

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_3d_vis_info_template");
			var template = templateFn(self.model);

			// load the compiled HTML into the Backbone "el"
			self.$el.html(template);

			// format after rendering
			self.format();
		},
		format: function()
		{
			var self = this;
			var pdbInfo = self.model.pdbInfo;
			var molInfo = self.model.molInfo;

			// if no info provided, then hide the corresponding span
			if (pdbInfo == null ||
			    pdbInfo.length == 0)
			{
				self.$el.find(".mutation-3d-pdb-info").hide();
			}
			else
			{
				// make information text expandable/collapsible
				self._addExpander(".mutation-3d-pdb-info");
			}

			if (molInfo == null ||
			    molInfo.length == 0)
			{
				self.$el.find(".mutation-3d-mol-info").hide();
			}
			else
			{
				// make information text expandable/collapsible
				self._addExpander(".mutation-3d-mol-info");
			}
		},
		/**
		 * Applies expander plugin to the PDB info area. The options are
		 * optimized to have 1 line of description at init.
		 */
		_addExpander: function(selector)
		{
			var self = this;

			var expanderOpts = {slicePoint: 40, // default is 100
				widow: 2,
				expandPrefix: ' ',
				expandText: '[...]',
				//collapseTimer: 5000, // default is 0, so no re-collapsing
				userCollapseText: '[^]',
				moreClass: 'expander-read-more',
				lessClass: 'expander-read-less',
				detailClass: 'expander-details',
				// do not use default effects
				// (see https://github.com/kswedberg/jquery-expander/issues/46)
				expandEffect: 'fadeIn',
				collapseEffect: 'fadeOut'};

			//self.$el.find(".mutation-3d-info-main").expander(expanderOpts);
			self.$el.find(selector).expander(expanderOpts);
		}
	});

	module.exports = Mutation3dVisInfoView;

/***/ },
/* 140 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_140__;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	if (cbio === undefined)
	{
		var cbio = {};
	}

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);
	cbio.util = __webpack_require__(6);
	var saveAs = __webpack_require__(142).saveAs;

	/**
	 * Singleton utility class for download related tasks.
	 *
	 * @author Selcuk Onur Sumer
	 */
	cbio.download = (function() {

		// Default client-side download options
		var _defaultOpts = {
			filename: "download.svg", // download file name
			contentType: "application/svg+xml", // download data type,
			dataType: null,      // servlet data type
			servletName: null,   // name of the data/conversion servlet (optional)
			servletParams: null, // servlet parameters (optional)
			preProcess: addSvgHeader,   // pre-process function for the provided data
			postProcess: cbio.util.b64ToByteArrays // post-process function for the data returned by the server (optional)
		};

		/**
		 * Submits the download form.
		 * This will send a request to the server.
		 *
		 * @param servletName       name of the action servlet
		 * @param servletParams     params to send with the form submit
		 * @param form              jQuery selector for the download form
		 */
		function submitDownload(servletName, servletParams, form)
		{
			// remove all previous input fields (if any)
			$(form).find("input").remove();

			// add new input fields
			for (var name in servletParams)
			{
				var value = servletParams[name];
				$(form).append('<input type="hidden" name="' + name + '">');
				$(form).find('input[name="' + name + '"]').val(value);
			}

			// update target servlet for the action
			$(form).attr("action", servletName);
			// submit the form
			$(form).submit();
		}

		/**
		 * Sends a download request to the hidden frame dedicated to file download.
		 *
		 * This function is implemented as a workaround to prevent JSmol crash
		 * due to window.location change after a download request.
		 *
		 * @param servletName
		 * @param servletParams
		 */
		function requestDownload(servletName, servletParams)
		{
			// TODO this is a workaround, frame download doesn't work for IE
			if (cbio.util.browser.msie)
			{
				initDownloadForm();
				submitDownload(servletName, servletParams, "#global_file_download_form");
				return;
			}

			initDownloadFrame(function() {
				var targetWindow = cbio.util.getTargetWindow("global_file_download_frame");

				targetWindow.postMessage(
					{servletName: servletName,
						servletParams: servletParams},
					getOrigin());
			});
		}

		/**
		 * Initializes the hidden download frame for the entire document.
		 * This is to isolate download requests from the main window.
		 */
		function initDownloadFrame(callback)
		{
			var frame = '<iframe id="global_file_download_frame" ' +
			            'src="file_download_frame.jsp" ' +
			            'seamless="seamless" width="0" height="0" ' +
			            'frameBorder="0" scrolling="no">' +
			            '</iframe>';

			// only initialize if the frame doesn't exist
			if ($("#global_file_download_frame").length === 0)
			{
				$(document.body).append(frame);

				// TODO a workaround to enable target frame to get ready to listen messages
				setTimeout(callback, 500);
			}
			else
			{
				callback();
			}
		}

		/**
		 * This form is initialized only for IE
		 */
		function initDownloadForm()
		{
			var form = '<form id="global_file_download_form"' +
			           'style="display:inline-block"' +
			           'action="" method="post" target="_blank">' +
			           '</form>';

			// only initialize if the form doesn't exist
			if ($("#global_file_download_form").length === 0)
			{
				$(document.body).append(form);
			}
		}

		/**
		 * Initiates a client side download for the given content array.
		 *
		 * @param content   data array to download
		 * @param filename  download file name
		 * @param type      download type
		 */
		function clientSideDownload(content, filename, type)
		{
			if (type == null)
			{
				// text by default
				type = "text/plain;charset=utf-8"
			}

			if (filename == null)
			{
				filename = "download.txt";
			}

			var blob = new Blob(content, {type: type});

			saveAs(blob, filename);
		}

		/**
		 * Serializes the given html element into a string.
		 *
		 * @param element       html element
		 * @returns {string}    serialized string
		 */
		function serializeHtml(element)
		{
			// convert html element to string
			var xmlSerializer = new XMLSerializer();
			return xmlSerializer.serializeToString(element);
		}

		/**
		 * Adds missing xml and svg headers to the provided svg string
		 *
		 * @param xml   xml as a string
		 * @returns {string}    new xml string with additional headers
		 */
		function addSvgHeader(xml)
		{
			var svg = xml;

			var xmlHeader = "<?xml version='1.0'?>";
			var xmlVersion = "<?xml version=";

			// add xml header if not exist
			if(svg.indexOf(xmlVersion) == -1)
			{
				svg = xmlHeader + xml;
			}

			// add svg header if not exist
			if(svg.indexOf("svg xmlns") == -1)
			{
				svg = svg.replace(
					"<svg", "<svg xmlns='http://www.w3.org/2000/svg' version='1.1'");
			}

			return svg;
		}

		/**
		 * Initializes a client side download for the given content.
		 *
		 * @param content   data content, either string or DOM element
		 * @param options   download options (see _defaultOpts)
		 */
		function initDownload(content, options)
		{
			options = jQuery.extend(true, {}, _defaultOpts, options);

			// try to serialize only if content is not string...
			if (!_.isString(content))
			{
				content = serializeHtml(content);
			}

			if (_.isFunction(options.preProcess))
			{
				content = options.preProcess(content);
			}

			if (options.contentType.toLowerCase().indexOf("pdf") != -1)
			{
				// if no servlet params provided, use default ones for pdf...
				options.servletParams = options.servletParams || {
					filetype: "pdf_data",
					svgelement: content
				};
			}

			// check if a servlet name provided
			if (options.servletName != null)
			{
				$.ajax({url: options.servletName,
						type: "POST",
						data: options.servletParams,
						dataType: options.dataType,
						success: function(servletData){
							var downloadData = servletData;

							if (_.isFunction(options.postProcess))
							{
								downloadData = options.postProcess(servletData);
							}

							clientSideDownload(downloadData, options.filename, options.contentType);
						}
				});
			}
			else
			{
				clientSideDownload([content], options.filename, options.contentType);
			}
		}

	    return {
		    submitDownload: submitDownload,
		    requestDownload: requestDownload,
		    clientSideDownload: clientSideDownload,
		    initDownload: initDownload,
		    serializeHtml: serializeHtml,
		    addSvgHeader: addSvgHeader
	    };
	})();

	module.exports = cbio.download;

/***/ },
/* 142 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_142__;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "images/help.png";

/***/ },
/* 144 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_144__;

/***/ },
/* 145 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_145__;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var PdbPanelView = __webpack_require__(147);
	var MutationSummaryView = __webpack_require__(164);
	var Mutation3dView = __webpack_require__(165);
	var MutationDiagramView = __webpack_require__(166);
	var MutationDetailsTableView = __webpack_require__(174);
	var MutationInfoPanelView = __webpack_require__(180);
	var MutationDetailsEvents = __webpack_require__(22);
	var BackboneTemplateCache = __webpack_require__(23);

	var loaderImage = __webpack_require__(85);

	var Backbone = __webpack_require__(12);
	var _ = __webpack_require__(5);
	var $ = __webpack_require__(7);
	var jQuery = $;

	/**
	 * Default mutation view for a single gene.
	 *
	 * options: {el: [target container],
	 *           model: {geneSymbol: [hugo gene symbol],
	 *                   mutationData: [mutation data for a specific gene]
	 *                   dataProxies: [all available data proxies],
	 *                   dataManager: global mutation data manager,
	 *                   uniprotId: uniprot identifier,
	 *                   sampleArray: [list of case ids as an array of strings]}
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MainMutationView = Backbone.View.extend({
		initialize : function (options) {
			var defaultOpts = {
				config: {
					loaderImage: loaderImage
				}
			};

			this.options = jQuery.extend(true, {}, defaultOpts, options);

			// custom event dispatcher
			this.dispatcher = {};
			_.extend(this.dispatcher, Backbone.Events);
		},
		render: function() {
			var self = this;

			// pass variables in using Underscore.js template
			var variables = {geneSymbol: self.model.geneSymbol,
				uniprotId: self.model.uniprotId};

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_view_template");
			var template = templateFn(variables);

			// load the compiled HTML into the Backbone "el"
			self.$el.html(template);

			// format after rendering
			self.format();
		},
		format: function() {
			var self = this;

			// initially hide all components by default
			// they will be activated wrt selected options
			self.$el.find(".mutation-details-filter-info").hide();
			self.$el.find(".mutation-details-no-data-info").hide();
			self.$el.find(".mutation-3d-initializer").hide();
			self.$el.find(".mutation-info-panel-container").hide();
			self.$el.find(".mutation-summary-view").hide();
			self.$el.find(".mutation-table-container").hide();
			self.$el.find(".mutation-diagram-view").hide();
		},
		initPdbPanelView: function(renderOpts, panelOpts, tableOpts, pdbColl)
		{
			var self = this;
			var diagram = null;

			// diagram can be null/disabled
			if (self.diagramView && self.diagramView.mutationDiagram)
			{
				diagram = self.diagramView.mutationDiagram;
			}

			// TODO we should not be overwriting the render options...
			renderOpts.loaderImage = self.options.config.loaderImage;

			// allow initializing the pdb panel even if there is no diagram
			var viewOpts = {
				//el: "#mutation_pdb_panel_view_" + gene.toUpperCase(),
				el: self.$el.find(".mutation-pdb-panel-view"),
				config: renderOpts,
				model: {geneSymbol: self.model.geneSymbol,
					pdbColl: pdbColl,
					pdbProxy: self.model.dataProxies.pdbProxy,
					pdbPanelOpts: panelOpts,
					pdbTableOpts: tableOpts},
				diagram: diagram
			};

			var pdbPanelView = new PdbPanelView(viewOpts);
			pdbPanelView.render();

			self._pdbPanelView = pdbPanelView;

			return pdbPanelView;
		},
		initSummaryView: function()
		{
			var self = this;
			var target = self.$el.find(".mutation-summary-view");
			target.show();

			var summaryOpts = {
				el: target,
				model: {
					mutationProxy: self.model.dataProxies.mutationProxy,
					clinicalProxy: self.model.dataProxies.clinicalProxy,
					geneSymbol: self.model.geneSymbol,
					sampleArray: self.model.sampleArray
				}
			};

			var summaryView = new MutationSummaryView(summaryOpts);
			summaryView.render();

			self.summaryView = summaryView;

			return summaryView;
		},
		init3dView: function(mut3dVisView)
		{
			var self = this;

			return self._init3dView(self.model.geneSymbol,
				self.model.uniprotId,
				self.model.dataProxies.pdbProxy,
				mut3dVisView);
		},
		/**
		 * Initializes the 3D view initializer.
		 *
		 * @param gene
		 * @param uniprotId
		 * @param pdbProxy
		 * @param mut3dVisView
		 * @return {Object}     a Mutation3dView instance
		 */
		_init3dView: function(gene, uniprotId, pdbProxy, mut3dVisView)
		{
			var self = this;

			var target = self.$el.find(".mutation-3d-initializer");
			target.show();

			// init the 3d view (button)
			var view3d = new Mutation3dView({
				el: target,
				model: {uniprotId: uniprotId,
					geneSymbol: gene,
					pdbProxy: pdbProxy}
			});

			view3d.render();

			// also reset (init) the 3D view if the 3D panel is already active
			if (mut3dVisView &&
			    mut3dVisView.isVisible())
			{
				view3d.resetView();
			}

			return view3d;
		},
		/**
		 * Initializes the mutation diagram view for the given diagram options
		 * and sequence data.
		 *
		 * @param options   mutation diagram options
		 * @param sequence  PFAM sequence data
		 * @returns {MutationDiagramView} mutation diagram view instance
		 */
		initMutationDiagramView: function(options, sequence)
		{
			var self = this;

			//mutationData = mutationData || self.model.mutationData;

			self.diagramView = self._initMutationDiagramView(
				self.model.geneSymbol,
				self.model.mutationData,
				sequence,
				self.model.dataProxies,
			    options);

			if (!self.diagramView)
			{
				console.log("Error initializing mutation diagram: %s", self.model.geneSymbol);
			}
			else
			{
				self.dispatcher.trigger(
					MutationDetailsEvents.DIAGRAM_INIT,
					self.diagramView.mutationDiagram);
			}

			return self.diagramView;
		},
		/**
		 * Initializes the mutation diagram view.
		 *
		 * @param gene          hugo gene symbol
		 * @param mutationData  mutation data (array of JSON objects)
		 * @param sequenceData  sequence data (as a JSON object)
		 * @param dataProxies   all available data proxies
		 * @param options       [optional] diagram options
		 * @return {Object}     initialized mutation diagram view
		 */
		_initMutationDiagramView: function (gene, mutationData, sequenceData, dataProxies, options)
		{
			var self = this;
			var target = self.$el.find(".mutation-diagram-view");
			target.show();

			var model = {mutations: mutationData,
				sequence: sequenceData,
				geneSymbol: gene,
				dataProxies: dataProxies,
				diagramOpts: options};

			var diagramView = new MutationDiagramView({
				el: target,
				model: model});

			diagramView.render();

			return diagramView;
		},
		initMutationTableView: function(options)
		{
			var self = this;

			self.tableView = self._initMutationTableView(self.model.geneSymbol,
				self.model.mutationData,
				self.model.dataProxies,
				self.model.dataManager,
			    options);

			if (!self.tableView)
			{
				console.log("Error initializing mutation table: %s", self.model.geneSymbol);
			}
			else
			{
				self.dispatcher.trigger(
					MutationDetailsEvents.MUTATION_TABLE_INITIALIZED,
					self.tableView.mutationTable);
			}

			return self.tableView;
		},
		/**
		 * Initializes the mutation table view.
		 *
		 * @param gene          hugo gene symbol
		 * @param mutationData  mutation data (array of JSON objects)
		 * @param dataProxies   all available data proxies
		 * @param dataManager   global mutation data manager
		 * @param options       [optional] table options
		 * @return {Object}     initialized mutation table view
		 */
		_initMutationTableView: function(gene, mutationData, dataProxies, dataManager, options)
		{
			var self = this;
			var target = self.$el.find(".mutation-table-container");
			target.show();

			var mutationTableView = new MutationDetailsTableView({
				el: target,
				config: {loaderImage: self.options.config.loaderImage},
				model: {geneSymbol: gene,
					mutations: mutationData,
					dataProxies: dataProxies,
					dataManager: dataManager,
					tableOpts: options}
			});

			mutationTableView.render();

			return mutationTableView;
		},
		initMutationInfoView: function(options)
		{
			var self = this;
			var target = self.$el.find(".mutation-info-panel-container");
			target.show();

			var model = {
				mutations: self.model.mutationData,
				infoPanelOpts: options
			};

			var infoView = new MutationInfoPanelView({
				el: target,
				model: model
			});

			infoView.render();

			self.infoView = infoView;

			self.dispatcher.trigger(
				MutationDetailsEvents.INFO_PANEL_INIT,
				self.infoView);

			return infoView;
		},
		/**
		 * Initializes the filter reset link, which is a part of filter info
		 * text on top of the diagram, with the given callback function.
		 *
		 * @param callback      function to be invoked on click
		 */
		addResetCallback: function(callback) {
			var self = this;
			var resetLink = self.$el.find(".mutation-details-filter-reset");

			// add listener to diagram reset link
			resetLink.click(callback);
		},
		showFilterInfo: function() {
			this.$el.find(".mutation-details-filter-info").slideDown();
		},
		hideFilterInfo: function() {
			this.$el.find(".mutation-details-filter-info").slideUp();
		},
		showNoDataInfo: function() {
			this.$el.find(".mutation-details-no-data-info").slideDown();
		},
		hideNoDataInfo: function() {
			this.$el.find(".mutation-details-no-data-info").slideUp();
		}
	});

	module.exports = MainMutationView;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationPdbPanel = __webpack_require__(148);
	var PdbTableView = __webpack_require__(151);
	var BackboneTemplateCache = __webpack_require__(23);

	var loaderImage = __webpack_require__(85);

	var Backbone = __webpack_require__(12);
	var $ = __webpack_require__(7);
	var jQuery = $;
	__webpack_require__(163);

	/**
	 * PDB Panel View.
	 *
	 * This view is designed to function in parallel with the 3D visualizer.
	 *
	 * options: {el: [target container],
	 *           model: {geneSymbol: hugo gene symbol,
	 *                   pdbColl: collection of PdbModel instances,
	 *                   pdbProxy: pdb data proxy,
	 *                   pdbPanelOpts: MutationPdbPanel options,
	 *                   pdbTableOpts: MutationPdbTable options},
	 *           diagram: [optional] reference to the MutationDiagram instance
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var PdbPanelView = Backbone.View.extend({
		initialize : function (options) {
			var defaultOpts = {
				config: {
					loaderImage: loaderImage,
					autoExpand: true
				}
			};

			this.options = jQuery.extend(true, {}, defaultOpts, options);
			this.collapseTimer = null;
			this.expandTimer = null;
		},
		render: function()
		{
			var self = this;

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("pdb_panel_view_template");
			var template = templateFn({});

			// load the compiled HTML into the Backbone "el"
			self.$el.html(template);

			// init pdb panel
			self.pdbPanel = self._initPdbPanel();

			// format after rendering
			self.format();
		},
		format: function()
		{
			var self = this;

			// hide view initially
			self.$el.hide();

			// format panel controls
			var expandButton = self.$el.find(".expand-collapse-pdb-panel");
			var pdbTableInit = self.$el.find(".init-pdb-table");
			var pdbTableControls = self.$el.find(".pdb-table-controls");
			var triangleDown = self.$el.find(".triangle-down");
			var triangle = self.$el.find(".triangle");

			// format the expand button if there are more chains to show
			if (self.pdbPanel.hasMoreChains())
			{
				expandButton.button({
					icons: {primary: "ui-icon-triangle-2-n-s"},
					text: false});
				expandButton.css({width: "300px", height: "12px"});

				expandButton.click(function() {
					self.pdbPanel.toggleHeight();
				});
			}

			// initially hide controls
			expandButton.hide();
			pdbTableControls.hide();

			triangleDown.hide();

			// make triangles clickable
			triangle.click(function(event) {
				// same as clicking on the link
				pdbTableInit.click();
			});

			if (self.options.config.autoExpand)
			{
				self.$el.find(".mutation-pdb-main-container").mouseenter(function(evt) {
					self.autoExpand();
				});

				self.$el.find(".mutation-pdb-main-container").mouseleave(function(evt) {
					self.autoCollapse();
				});
			}
		},
		hideView: function()
		{
			var self = this;
			self.$el.slideUp();
		},
		showView: function()
		{
			var self = this;
			self.$el.slideDown();
		},
		initPdbTableView: function(pdbColl, callback)
		{
			var self = this;

			var tableOpts = {
				el: self.$el.find(".mutation-pdb-table-view"),
				config: {loaderImage: self.options.config.loaderImage},
				model: {geneSymbol: self.model.geneSymbol,
					pdbColl: pdbColl,
					pdbProxy: self.model.pdbProxy}
			};

			tableOpts = jQuery.extend(true, {}, self.model.pdbTableOpts, tableOpts);
			var pdbTableView = new PdbTableView(tableOpts);
			self.pdbTableView = pdbTableView;

			pdbTableView.render(callback);

			return pdbTableView;
		},
		/**
		 * Adds a callback function for the PDB table init button.
		 *
		 * @param callback  function to be invoked on click
		 */
		addInitCallback: function(callback) {
			var self = this;
			var pdbTableInit = self.$el.find(".init-pdb-table");

			// add listener to pdb table init button
			pdbTableInit.click(function(event) {
				event.preventDefault();
				callback(event);
			});
		},
		toggleTableControls: function()
		{
			var self = this;

			// just toggle triangle orientation
			self.$el.find(".triangle").toggle();
		},
		/**
		 * Selects the default pdb and chain for the 3D visualizer.
		 * Default chain is one of the chains in the first row.
		 */
		selectDefaultChain: function()
		{
			var self = this;
			var panel = self.pdbPanel;
			var gChain = panel.getDefaultChainGroup();

			// clear previous timers
			self.clearTimers();

			// restore chain positions
			panel.restoreChainPositions(function() {
				// highlight the default chain
				panel.highlight(gChain);
			});
		},
		/**
		 * Selects the given pdb and chain for the 3D visualizer.
		 *
		 * @param pdbId     pdb to be selected
		 * @param chainId   chain to be selected
		 */
		selectChain: function(pdbId, chainId)
		{
			var self = this;
			var panel = self.pdbPanel;

			// clear previous timers
			self.clearTimers();

			// restore to original positions & highlight the chain
			panel.restoreChainPositions(function() {
				// expand the panel up to the level of the given chain
				panel.expandToChainLevel(pdbId, chainId);

				// get the chain group
				var gChain = panel.getChainGroup(pdbId, chainId);

				// highlight the chain group
				if (gChain)
				{
					panel.highlight(gChain);
				}
			});
		},
		getSelectedChain: function()
		{
			var self = this;
			var panel = self.pdbPanel;

			return panel.getHighlighted();
		},
		/**
		 * Initializes the auto collapse process.
		 *
		 * @delay time to minimization
		 */
		autoCollapse: function(delay)
		{
			if (delay == null)
			{
				delay = 2000;
			}

			var self = this;
			var expandButton = self.$el.find(".expand-collapse-pdb-panel");
			var pdbTableControls = self.$el.find(".pdb-table-controls");
			var pdbTableWrapper = self.$el.find(".pdb-table-wrapper");

			// clear previous timers
			self.clearTimers();

			// set new timer
			self.collapseTimer = setTimeout(function() {
				self.pdbPanel.minimizeToHighlighted();
				expandButton.slideUp();
				pdbTableControls.slideUp();
				pdbTableWrapper.slideUp();
			}, delay);
		},
		/**
		 * Initializes the auto expand process.
		 *
		 * @delay time to minimization
		 */
		autoExpand: function(delay)
		{
			if (delay == null)
			{
				delay = 400;
			}

			var self = this;
			var expandButton = self.$el.find(".expand-collapse-pdb-panel");
			var pdbTableControls = self.$el.find(".pdb-table-controls");
			var pdbTableWrapper = self.$el.find(".pdb-table-wrapper");

			// clear previous timers
			self.clearTimers();

			// set new timer
			self.expandTimer = setTimeout(function() {
				self.pdbPanel.restoreToFull();

				if (self.pdbPanel.hasMoreChains())
				{
					expandButton.slideDown();
				}

				pdbTableControls.slideDown();
				pdbTableWrapper.slideDown();

				if (self.pdbTableView != null)
				{
					self.pdbTableView.refreshView();
				}
			}, delay);
		},
		/**
		 * Limits the size of the panel by the given max height value,
		 * and adds a scroll bar for the y-axis. If max height is not
		 * a valid value, then disables the scroll bar.
		 *
		 * @param maxHeight desired max height value
		 */
		toggleScrollBar: function(maxHeight)
		{
			var self = this;
			var container = self.$el.find(".mutation-pdb-panel-container");

			if (maxHeight > 0)
			{
				container.css("max-height", maxHeight);
				container.css("overflow", "");
				container.css("overflow-y", "scroll");
			}
			else
			{
				container.css("max-height", "");
				container.css("overflow-y", "");
				container.css("overflow", "hidden");
			}
		},
		/**
		 * Moves the scroll bar to the selected chain's position.
		 */
		scrollToSelected: function()
		{
			var self = this;
			var container = self.$el.find(".mutation-pdb-panel-container");

			// TODO make scroll parameters customizable?
			container.scrollTo($(".pdb-selection-rectangle-group"),
			                   {axis: 'y', duration: 800, offset: -150});
		},
		clearTimers: function()
		{
			var self = this;

			if (self.collapseTimer != null)
			{
				clearTimeout(self.collapseTimer);
			}

			if (self.expandTimer != null)
			{
				clearTimeout(self.expandTimer);
			}
		},
		/**
		 * Initializes the PDB chain panel.
		 *
		 * @return {MutationPdbPanel}   panel instance
		 */
		_initPdbPanel: function()
		{
			var self = this;

			var pdbColl = self.model.pdbColl;
			var pdbProxy = self.model.pdbProxy;
			var mutationDiagram = self.options.diagram;

			var options = {el: self.$el.find(".mutation-pdb-panel-container"),
					maxHeight: 200};
			var xScale = null;

			// if mutation diagram is enabled,
			// get certain values from mutation diagram for consistent rendering!
			if (mutationDiagram != null)
			{
				xScale = mutationDiagram.xScale;

				// set margin same as the diagram margin for correct alignment with x-axis

				options.marginLeft = mutationDiagram.options.marginLeft;
				options.marginRight = mutationDiagram.options.marginRight;
			}

			// init panel
			options = jQuery.extend(true, {}, self.model.pdbPanelOpts, options);
			var panel = new MutationPdbPanel(options, pdbColl, pdbProxy, xScale);
			panel.init();

			return panel;
		}
	});

	module.exports = PdbPanelView;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var PdbDataUtil = __webpack_require__(10);
	var BackboneTemplateCache = __webpack_require__(23);
	var MergedAlignmentSegmentor = __webpack_require__(149);
	var PdbChainTipView = __webpack_require__(150);
	var MutationDetailsEvents = __webpack_require__(22);

	var helpImage = __webpack_require__(143);

	var cbio = {
		util: __webpack_require__(6)
	};

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);
	var Backbone = __webpack_require__(12);
	var d3 = __webpack_require__(19);

	/**
	 * Constructor for the MutationPdbPanel class.
	 *
	 * @param options   visual options object
	 * @param data      PDB data (collection of PdbModel instances)
	 * @param proxy     PDB data proxy
	 * @param xScale    scale function for the x axis
	 * @constructor
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationPdbPanel(options, data, proxy, xScale)
	{
		/**
		 * Default visual options.
		 */
		var _defaultOpts = {
			el: "#mutation_pdb_panel_d3", // id of the container
			elWidth: 740,       // width of the container
			elHeight: "auto",   // height of the container
			maxHeight: 200,     // max height of the container
			numRows: [Infinity], // number of rows to be to be displayed for each expand request
			marginLeft: 45,     // left margin
			marginRight: 30,    // right margin
			marginTop: 2,       // top margin
			marginBottom: 0,    // bottom margin
			chainHeight: 6,     // height of a rectangle representing a single pdb chain
			chainPadding: 3,    // padding between chain rectangles
			labelY: ["PDB", "Chains"],  // label of the y-axis. use array for multi lines, false: "do not draw"
			labelYFont: "sans-serif",   // font type of the y-axis label
			labelYFontColor: "#2E3436", // font color of the y-axis label
			labelYFontSize: "12px",     // font size of y-axis label
			labelYFontWeight: "normal", // font weight of y-axis label
			labelYPaddingRightH: 45, // padding between y-axis and its label (horizontal alignment)
			labelYPaddingTopH: 7,    // padding between y-axis and its label (horizontal alignment)
			labelYPaddingRightV: 25, // padding between y-axis and its label (vertical alignment)
			labelYPaddingTopV: 20,   // padding between y-axis and its label (vertical alignment)
			labelAlignThreshold: 5,  // threshold to determine horizontal or vertical alignment
			chainBorderColor: "#666666", // border color of the chain rectangles
			chainBorderWidth: 0.5,       // border width of the chain rectangles
			highlightBorderColor: "#FF9900", // color of the highlight rect border
			highlightBorderWidth: 2.0,       // width of the highlight rect border
			colors: ["#3366cc"],  // rectangle colors
			animationDuration: 1000, // transition duration (in ms) used for resize animations
			/**
			 * Default chain tooltip function.
			 *
			 * @param element   target svg element (rectangle)
			 */
			chainTipFn: function (element) {
				var datum = element.datum();

				proxy.getPdbInfo(datum.pdbId, function(pdbInfo) {
					var summary = null;

					if (pdbInfo)
					{
						summary = PdbDataUtil.generatePdbInfoSummary(
							pdbInfo[datum.pdbId], datum.chain.chainId);
					}

					// init tip view
					var tipView = new PdbChainTipView({model: {
						pdbId: datum.pdbId,
						pdbInfo: summary.title,
						molInfo: summary.molecule,
						chain: datum.chain
					}});

					var content = tipView.compileTemplate();

					var options = {content: {text: content},
						hide: {fixed: true, delay: 100},
						style: {classes: 'qtip-light qtip-rounded qtip-shadow qtip-lightyellow'},
						position: {my:'bottom left', at:'top center',viewport: $(window)}};

					//$(element).qtip(options);
					cbio.util.addTargetedQTip(element, options);
				});
			},
			/**
			 * Default y-axis help tooltip function.
			 *
			 * @param element   target svg element (help icon)
			 */
			yHelpTipFn: function (element) {
				var templateFn = BackboneTemplateCache.getTemplateFn(
					"mutation_details_pdb_help_tip_template");

				var content = templateFn({});

				var options = {content: {text: content},
					hide: {fixed: true, delay: 100},
					style: {classes: 'qtip-light qtip-rounded qtip-shadow qtip-lightyellow qtip-wide'},
					position: {my:'bottom left', at:'top center',viewport: $(window)}};

				//$(element).qtip(options);
				cbio.util.addTargetedQTip(element, options);
			}
		};

		// event listeners
		var _listeners = {};

		// custom event dispatcher
		var _dispatcher = {};
		_.extend(_dispatcher, Backbone.Events);

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		// reference to the main svg element
		var _svg = null;

		// row data (allocation of chains wrt rows)
		var _rowData = null;

		// default chain group svg element
		var _defaultChainGroup = null;

		// expansion level indicator (initially 0)
		var _expansion = 0;

		// max expansion level:
		// assume numRows = [0, 100, 500], and number of total rows = 20
		// in this case max level should be 2 (although numRows has 3 elements)
		var _maxExpansionLevel = null;

		// number of total rectangles drawn (initially 0)
		// this number is being updated after each panel expand
		var _rectCount = 0;

		// indicator for an expansion level whether the rectangles drawn
		var _levelDrawn = [];

		// <pdbId:chainId> to <chain group (svg element)> map
		var _chainMap = {};

		// <pdbId:chainId> to <row index> map
		var _rowMap = {};

		// previous height before auto collapse
		var _levelHeight = 0;

		// currently highlighted chain
		var _highlighted = null;

		/**
		 * Draws the actual content of the panel, by drawing a rectangle
		 * for each chain
		 *
		 * @param svg       svg element (D3)
		 * @param options   visual options object
		 * @param data      row data
		 * @param xScale    scale function for the x-axis
		 * @param rowStart  starting index for the first row
		 */
		function drawPanel(svg, options, data, xScale, rowStart)
		{
			// chain counter
			var count = _rectCount;

			// add a rectangle group for each chain
			_.each(data, function(allocation, rowIdx) {
				_.each(allocation, function(datum, idx) {
					var chain = datum.chain;

					// create the rectangle group
					if (chain.alignments.length > 0)
					{
						// assign a different color to each chain
						var color = options.colors[idx % options.colors.length];
						//datum.color = color;

						var y = options.marginTop +
						        (rowStart + rowIdx) * (options.chainHeight + options.chainPadding);

						var gChain = drawChainRectangles(svg, chain, color, options, xScale, y);
						gChain.datum(datum);
						_chainMap[PdbDataUtil.chainKey(datum.pdbId, datum.chain.chainId)] = gChain;

						// set the first drawn chain as the default chain
						if (_defaultChainGroup == null)
						{
							_defaultChainGroup = gChain;
						}

						// increment chain counter
						count++;
					}
				});
			});

			// update global rectangle counter in the end
			_rectCount = count;

			// add chain tooltips
			addChainTooltips(data, options);
		}

		/**
		 * Adds tooltips to the chain rectangles.
		 *
		 * @param data      row data containing pdb and chain information
		 * @param options   visual options object
		 */
		function addChainTooltips(data, options)
		{
			// this is to prevent chain tooltip functions to send
			// too many separate requests to the server

			var pdbIds = [];
			var chains = [];

			// collect pdb ids and chains
			_.each(data, function(allocation, rowIdx) {
				_.each(allocation, function(datum, idx) {
					pdbIds.push(datum.pdbId);
					chains.push(_chainMap[
						PdbDataUtil.chainKey(datum.pdbId, datum.chain.chainId)]);
				});
			});

			// this caches pdb info before adding the tooltips
			proxy.getPdbInfo(pdbIds.join(" "), function(data) {
				// add tooltip to the chain groups
				_.each(chains, function(chain, idx) {
					var addTooltip = options.chainTipFn;
					addTooltip(chain);
				});
			});
		}

		/**
		 * Draws a group of rectangles for a specific chain.
		 *
		 * @param svg       svg element (D3)
		 * @param chain     a PdbChainModel instance
		 * @param color     rectangle color
		 * @param options   visual options object
		 * @param xScale    scale function for the x-axis
		 * @param y         y coordinate of the rectangle group
		 * @return {object} group for the chain (svg element)
		 */
		function drawChainRectangles(svg, chain, color, options, xScale, y)
		{
			var gChain = svg.append("g")
				.attr("class", "pdb-chain-group")
				.attr("opacity", 1);

			var height = options.chainHeight;

			// init the segmentor for the merged alignment object
			var segmentor = new MergedAlignmentSegmentor(chain.mergedAlignment);

			// iterate all segments for this merged alignment
			while (segmentor.hasNextSegment())
			{
				var segment = segmentor.getNextSegment();

				var width = Math.abs(xScale(segment.start) - xScale(segment.end));
				var x = xScale(segment.start);

				// draw a line (instead of a rectangle) for an alignment gap
				if (segment.type == PdbDataUtil.ALIGNMENT_GAP)
				{
					var line = gChain.append('line')
						.attr('stroke', options.chainBorderColor)
						.attr('stroke-width', options.chainBorderWidth)
						.attr('x1', x)
						.attr('y1', y + height/2)
						.attr('x2', x + width)
						.attr('y2', y + height/2);

					// store initial position for future use
					// TODO this is not a good way of using datum
					line.datum({initPos: {x: x, y: (y + height/2)}});
				}
				// draw a rectangle for any other segment type
				else
				{
					var rect = gChain.append('rect')
						.attr('fill', color)
						.attr('opacity', chain.mergedAlignment.identityPerc)
						.attr('stroke', options.chainBorderColor)
						.attr('stroke-width', options.chainBorderWidth)
						.attr('x', x)
						.attr('y', y)
						.attr('width', width)
						.attr('height', height);

					// store initial position for future use
					// TODO this is not a good way of using datum
					rect.datum({initPos: {x: x, y: y}});
				}
			}

			return gChain;
		}

		/**
		 * Draws the label of the y-axis.
		 *
		 * @param svg       svg to append the label element
		 * @param options   general options object
		 * @return {object} label group (svg element)
		 */
		function drawYAxisLabel(svg, options)
		{
			// default (vertical) orientation
			var x = options.marginLeft - options.labelYPaddingRightV;
			var y =  options.marginTop + options.labelYPaddingTopV;
			var textAnchor = "middle";
			var rotation = "rotate(270, " + x + "," + y +")";
			var orient = "vertical";

			// horizontal orientation for small number of rows
			if (_rowData.length < options.labelAlignThreshold)
			{
				x = options.marginLeft - options.labelYPaddingRightH;
				y = options.marginTop + options.labelYPaddingTopH;
				textAnchor = "start";
				rotation = "rotate(0, " + x + "," + y +")";
				orient = "horizontal";
			}

			var gLabel = svg.append("g")
				.attr("class", "pdb-panel-y-axis-label-group")
				.attr("opacity", 1);

			// append label
			var label = gLabel.append("text")
				.attr("fill", options.labelYFontColor)
				.attr("text-anchor", textAnchor)
				.attr("x", x)
				.attr("y", y)
				.attr("class", "pdb-panel-y-axis-label")
				.attr("transform", rotation)
				.style("font-family", options.labelYFont)
				.style("font-size", options.labelYFontSize)
				.style("font-weight", options.labelYFontWeight);

			// for an array, create multi-line label
			if (_.isArray(options.labelY))
			{
				_.each(options.labelY, function(text, idx) {
					var dy = (idx == 0) ? 0 : 10;

					// TODO this is an adjustment to fit the help icon image
					var dx = (idx == 0 && orient == "vertical") ? -5 : 0;

					label.append('tspan')
						.attr('x', x + dx)
						.attr('dy', dy).
						text(text);
				});
			}
			// regular string, just set the text
			else
			{
				label.text(options.labelY);
			}

			var help = drawYAxisHelp(gLabel, x, y, orient, options);

			var addTooltip = options.yHelpTipFn;
			addTooltip(help);

			return label;
		}

		/**
		 *
		 * @param svg       svg to append the label element
		 * @param labelX    x coord of y-axis label
		 * @param labelY    y coord of y-axis label
		 * @param orient    orientation of the label (vertical or horizontal)
		 * @param options   general options object
		 * @return {object} help image (svg element)
		 */
		function drawYAxisHelp(svg, labelX, labelY, orient, options)
		{
			// TODO all these values are fine tuned for the label "PDB Chains",
			// ...setting another label text would probably mess things up
			var w = 12;
			var h = 12;
			var x = labelX - w + 2;
			var y = options.marginTop;

			if (orient == "horizontal")
			{
				x = options.marginLeft - w - 5;
				y = labelY - h + 2;
			}

			return svg.append("svg:image")
				.attr("xlink:href", helpImage)
				.attr("class", "pdb-panel-y-axis-help")
				.attr("x", x)
				.attr("y", y)
				.attr("width", w)
				.attr("height", h);
		}

		/**
		 * Returns the group svg element for the default chain.
		 *
		 * @return chain group for the default chain.
		 */
		function getDefaultChainGroup()
		{
			return _defaultChainGroup;
		}

		/**
		 * Returns the group svg element for the given pdb id
		 * and chain id pair.
		 *
		 * @param pdbId
		 * @param chainId
		 * @return chain group for the specified chain.
		 */
		function getChainGroup(pdbId, chainId)
		{
			return _chainMap[pdbId + ":" + chainId];
		}

		/**
		 * Calculates the max expansion level for the given data.
		 *
		 * @param totalNumRows      total number of rows
		 * @param expansionLevels   expansion level array
		 *                          (number of rows to be displayed for each level)
		 * @return {number}     max level for the current data
		 */
		function calcMaxExpansionLevel(totalNumRows, expansionLevels)
		{
			var max = -1;

			// try to find the first value within the level array
			// which is bigger than the total number of rows
			for (var i=0; i < expansionLevels.length; i++)
			{

				if (expansionLevels[i] > totalNumRows)
				{
					max = i;
					break;
				}
			}

			// if the total number of rows is bigger than all values
			// than max should be the highest available level
			if (max == -1)
			{
				max = expansionLevels.length - 1;
			}

			return max;
		}

		/**
		 * Calculates the full height of the panel wrt to provided elHeight option.
		 *
		 * @param elHeight  provided height value
		 * @return {number}
		 */
		function calcHeight(elHeight)
		{
			var height = 0;
			var rowCount = _rowData.length;

			// if not auto, then just copy the value
			if (elHeight != "auto")
			{
				height = elHeight;
			}
			else
			{
				height = _options.marginTop + _options.marginBottom +
					rowCount * (_options.chainHeight + _options.chainPadding) -
					(_options.chainPadding / 2); // no need for the full padding for the last row
			}

			return height;
		}

		/**
		 * Calculates the collapsed height of the panel wrt to provided
		 * maxChain option.
		 *
		 * @param maxChain  maximum number of rows to be displayed
		 * @return {number} calculated collapsed height
		 */
		function calcCollapsedHeight(maxChain)
		{
			var height = 0;
			var rowCount = _rowData.length;

			if (maxChain < rowCount)
			{
				height = _options.marginTop +
					maxChain * (_options.chainHeight + _options.chainPadding) -
					(_options.chainPadding / 2); // no need for full padding for the last row
			}
			// total number of chains is less than max, set to full height
			else
			{
				height = calcHeight("auto");
			}

			return height;
		}

		/**
		 * Creates the main svg element.
		 *
		 * @param container target container (html element)
		 * @param width     widht of the svg
		 * @param height    height of the svg
		 * @return {object} svg instance (D3)
		 */
		function createSvg(container, width, height)
		{
			var svg = container.append("svg");

			svg.attr('width', width);
			svg.attr('height', height);

			return svg;
		}

		function xScaleFn(data)
		{
			var width = _options.elWidth -
			        (_options.marginLeft + _options.marginRight);

			var x = _options.marginLeft;

			return d3.scale.linear()
				.domain([0, calcXMax(data)])
				.range([x, x + width]);
		}

		function calcXMax(data)
		{
			var values = [];

			_.each(data, function(row) {
				_.each(row, function(pdb) {
					values.push(pdb.chain.mergedAlignment.uniprotTo);
				});
			});

			return _.max(values);
		}

		/**
		 * Initializes the panel.
		 */
		function init()
		{
			// TODO get pdbRowData (or uniprot id?) as a model parameter
			// generate row data (one row may contain more than one chain)
			_rowData = PdbDataUtil.allocateChainRows(data);
			_maxExpansionLevel = calcMaxExpansionLevel(_rowData.length, _options.numRows);

			// in case no xScale function provided, generate the scale by using the row data
			if (xScale == null)
			{
				xScale = xScaleFn(_rowData);
			}

			// selecting using jQuery node to support both string and jQuery selector values
			var node = $(_options.el)[0];
			var container = d3.select(node);

			// number of rows to be shown initially
			var numRows = _options.numRows[0];
			_levelHeight = calcCollapsedHeight(numRows);

			// create svg element & update its reference
			var svg = createSvg(container,
			                    _options.elWidth,
			                    _levelHeight);

			_svg = svg;

			// (partially) draw the panel
			drawPanel(svg, _options, _rowData.slice(0, numRows), xScale, 0);
			_levelDrawn[0] = true;

			// draw the labels
			if (_options.labelY != false)
			{
				drawYAxisLabel(svg, _options);
			}

			// build row map
			_rowMap = buildRowMap(_rowData);

			// add default listeners
			addDefaultListeners();
		}

		/**
		 * Builds a map of <pdbId:chainId>, <row index> pairs
		 * for the given row data.
		 *
		 * @param rowData   rows of chain data
		 * @return {Object} <pdbId:chainId> to <row index> map
		 */
		function buildRowMap(rowData)
		{
			var map = {};

			// add a rectangle group for each chain
			_.each(rowData, function(allocation, rowIdx) {
				_.each(allocation, function(datum, idx) {
					map[PdbDataUtil.chainKey(datum.pdbId, datum.chain.chainId)] = rowIdx;
				});
			});

			return map;
		}

		/**
		 * Adds an event listener for specific diagram elements.
		 *
		 * @param selector  selector string for elements
		 * @param event     name of the event
		 * @param handler   event handler function
		 */
		function addListener(selector, event, handler)
		{
			_svg.selectAll(selector).on(event, handler);

			// save the listener for future reference
			if (_listeners[selector] == null)
			{
				_listeners[selector] = {};
			}

			_listeners[selector][event] = handler;
		}

		/**
		 * Removes an event listener for specific diagram elements.
		 *
		 * @param selector  selector string for elements
		 * @param event     name of the event
		 */
		function removeListener(selector, event)
		{
			_svg.selectAll(selector).on(event, null);

			// remove listener from the map
			if (_listeners[selector] &&
			    _listeners[selector][event])
			{
				delete _listeners[selector][event];
			}
		}

		function addDefaultListeners()
		{
			addListener(".pdb-chain-group", "click", function(datum, index) {
				// highlight the selected chain on the pdb panel
				highlight(d3.select(this));
			});
		}

		/**
		 * Reapplies current listeners to the diagram. This function should be
		 * called while adding new diagram elements after initialization.
		 */
		function reapplyListeners()
		{
			_.each(_.keys(_listeners), function(selector) {
				var target = _svg.selectAll(selector);

				_.each(_.keys(_listeners[selector]), function(event) {
					target.on(event, _listeners[selector][event]);
				});
			});
		}

		/**
		 * Shows the panel.
		 */
		function showPanel()
		{
			$(_options.el).show();
		}

		/**
		 * Hides the panel.
		 */
		function hidePanel()
		{
			$(_options.el).hide();
		}

		/**
		 * Resizes the panel height to show only a limited number of chains.
		 *
		 * @param index level index
		 */
		function resizePanel(index)
		{
			// resize to collapsed height
			var collapsedHeight = calcCollapsedHeight(_options.numRows[index]);
			var prevHeight = _svg.attr("height");

			dispatchResizeStartEvent(collapsedHeight, prevHeight);

			_svg.transition()
				.duration(_options.animationDuration)
				.attr("height", collapsedHeight)
				.each("end", function() {
					dispatchResizeEndEvent(collapsedHeight, prevHeight);
				});

			_levelHeight = collapsedHeight;
		}

		/**
		 * Resizes the panel to its full height (to show all chains).
		 */
		function expandPanel()
		{
			// resize to full size
			var fullHeight = calcHeight(_options.elHeight);
			_svg.transition().duration(_options.animationDuration).attr("height", fullHeight);
		}

		/**
		 * Expands/Collapses the panel.
		 */
		function toggleHeight()
		{
			 var nextLevel = drawNextLevel();

			// resize panel
			resizePanel(nextLevel);
		}

		/**
		 * Draws the next level of rectangles.
		 *
		 * @return {Number} next level number
		 */
		function drawNextLevel()
		{
			// do not try to draw any further levels than max level
			// (no rectangle to draw beyond max level)
			var nextLevel = (_expansion + 1) % (_maxExpansionLevel + 1);

			// draw the rectangles if not drawn yet
			if (!_levelDrawn[nextLevel])
			{
				// draw rectangles for the next level
				drawPanel(_svg,
				          _options,
				          _rowData.slice(_options.numRows[_expansion], _options.numRows[nextLevel]),
				          xScale,
				          _options.numRows[_expansion]);

				// also reapply the listeners for the new elements
				reapplyListeners();

				// mark the indicator for the next level
				_levelDrawn[nextLevel] = true;
			}

			// update expansion level
			_expansion = nextLevel;

			return nextLevel;
		}

		/**
		 * Expands the panel to a specific level.
		 *
		 * @param level
		 */
		function expandToLevel(level)
		{
			var nextLevel = -1;

			// expand until desired level
			for (var i = _expansion;
			     i < level && i < _maxExpansionLevel;
			     i++)
			{
				nextLevel = drawNextLevel();
			}

			// if already expanded (or beyond) that level,
			// no need to update or resize
			if (nextLevel !== -1)
			{
				// resize panel
				resizePanel(nextLevel);
			}
		}

		/**
		 * Expands the panel to the level of the specified chain.
		 *
		 * @param pdbId
		 * @param chainId
		 */
		function expandToChainLevel(pdbId, chainId)
		{
			var chainLevel = -1;
			var chainRow = _rowMap[PdbDataUtil.chainKey(pdbId, chainId)];

			for (var i=0; i < _options.numRows.length; i++)
			{
				if (chainRow < _options.numRows[i])
				{
					chainLevel = i;
					break;
				}
			}

			// TODO chainLevel is beyond the visible levels, expand all?
			if (chainLevel !== -1)
			{
				expandToLevel(chainLevel);
			}
		}

		/**
		 * Checks if there are more chains (more rows) to show. This function
		 * returns true if the number of total rows exceeds the initial number
		 * of rows to be displayed (which is determined by numRows option).
		 *
		 * @return {boolean} true if there are more rows to show, false otherwise
		 */
		function hasMoreChains()
		{
			return (_rowData.length > _options.numRows[0]);
		}

		/**
		 * Highlights a group of chain rectangles by drawing an outline
		 * border around the bounding box of all group elements.
		 *
		 * @param chainGroup    a group of rectangles representing the pdb chain
		 */
		function highlight(chainGroup)
		{
			// update the reference
			_highlighted = chainGroup;

			// calculate the bounding box
			var bbox = boundingBox(chainGroup);

			// remove the previous selection rectangle(s)
			_svg.selectAll(".pdb-selection-rectangle-group").remove();
			var gRect = _svg.append('g')
				.attr('class', "pdb-selection-rectangle-group")
				.attr('opacity', 0);

			// add the selection rectangle
			var rect = gRect.append('rect')
				.attr('fill', "none")
				.attr('stroke', _options.highlightBorderColor)
				.attr('stroke-width', _options.highlightBorderWidth)
				.attr('x', bbox.x)
				.attr('y', bbox.y)
				.attr('width', bbox.width)
				.attr('height', bbox.height);

			gRect.transition().duration(_options.animationDuration).attr('opacity', 1);

			// store initial position for future use
			// TODO this is not a good way of using datum
			rect.datum({initPos: {x: bbox.x, y: bbox.y}});

			// ...alternatively we can just use a yellowish color
			// to highlight the whole background

			// trigger corresponding event
			_dispatcher.trigger(
				MutationDetailsEvents.PANEL_CHAIN_SELECTED,
				chainGroup);
		}

		function boundingBox(rectGroup)
		{
			var left = Infinity;
			var right = -1;
			var y = -1;
			var height = -1;

			rectGroup.selectAll("rect").each(function(datum, idx) {
				var rect = d3.select(this);
				// assuming height and y are the same for all rects
				y = parseFloat(rect.attr("y"));
				height = parseFloat(rect.attr("height"));

				var x = parseFloat(rect.attr("x"));
				var width = parseFloat(rect.attr("width"));

				if (x < left)
				{
					left = x;
				}

				if (x + width > right)
				{
					right = x + width;
				}
			});

			return {x: left,
				y: y,
				width: right - left,
				height: height};
		}

		/**
		 * Collapses the view to the currently highlighted chain group
		 *
		 * @param callback  function to invoke after the transition
		 */
		function minimizeToHighlighted(callback)
		{
			if (_highlighted != null)
			{
				minimizeToChain(_highlighted, callback);
			}
		}

		/**
		 * Collapses the view to the given chain group by hiding
		 * everything other than the given chain. Also reduces
		 * the size of the diagram to fit only a single row.
		 *
		 * @param chainGroup    chain group (svg element)
		 * @param callback      function to invoke after the transition
		 */
		function minimizeToChain(chainGroup, callback)
		{
			var duration = _options.animationDuration;

			// 3 transitions in parallel:

			// TODO shifting all chains causes problems with multiple transitions
			// 1) shift all chains up, such that selected chain will be on top
			//shiftToChain(chainGroup);

			// 1) reposition the given chain..
			moveToFirstRow(chainGroup, callback);

			//..and the selection rectangle if the chain is highlighted
			if (chainGroup == _highlighted)
			{
				moveToFirstRow(_svg.selectAll(".pdb-selection-rectangle-group"));
			}

			// 2) fade-out all chains (except selected) and labels
			fadeOutOthers(chainGroup);

			// 3) resize the panel to a single row size
			var collapsedHeight = calcCollapsedHeight(1);
			var prevHeight = _svg.attr("height");

			dispatchResizeStartEvent(collapsedHeight, prevHeight);

			_svg.transition().duration(duration)
				.attr("height", collapsedHeight)
				.each("end", function(){
					dispatchResizeEndEvent(collapsedHeight, prevHeight);
				});
		}

		/**
		 * Shift all the chain rectangles, such that the given chain
		 * will be in the first row.
		 *
		 * @param chainGroup    chain group (svg element)
		 * @param callback      function to invoke after the transition
		 */
		function shiftToChain(chainGroup, callback)
		{
			var duration = _options.animationDuration;
			var datum = chainGroup.datum();
			var key = PdbDataUtil.chainKey(datum.pdbId, datum.chain.chainId);
			var chainRow = _rowMap[key];

			// if chains are not at their original positions, then shift value should be different
	//		var shift = chainRow * (_options.chainHeight + _options.chainPadding);

			// calculate shift value relative to the current position of the given chain group
			var shift = 0;

			chainGroup.selectAll("rect").each(function(datum, idx) {
				var rect = d3.select(this);
				shift = parseInt(rect.attr("y")) - _options.marginTop;
			});

			var shiftFn = function(target, d, attr) {
				var ele = d3.select(target);
				return (parseInt(ele.attr(attr)) - shift);
			};

			// shift up every chain on the y-axis
			yShiftRect(".pdb-chain-group rect", shiftFn, duration);
			yShiftRect(".pdb-selection-rectangle-group rect", shiftFn, duration);
			yShiftLine(".pdb-chain-group line", shiftFn, duration);

			// TODO it is better to bind this to a d3 transition
			// ..safest way is to call after the selected chain's transition ends
			setTimeout(callback, duration + 50);
		}

		/**
		 * Moves the given chainGroup to the first row.
		 *
		 * @param chainGroup
		 * @param callback
		 */
		function moveToFirstRow(chainGroup, callback)
		{
			var duration = _options.animationDuration;

			// first row coordinates...
			// (we can also use the default chain coordinates)
			var y = _options.marginTop;
			var height = _options.chainHeight;

			// move chain group rectangles and lines
			chainGroup.selectAll("line")
				.transition().duration(duration)
				.attr('y1', y + height/2)
				.attr('y2', y + height/2);

			chainGroup.selectAll("rect")
				.transition().duration(duration)
				.attr('y', y)
				.each("end", function() {
	                if (_.isFunction(callback)) {
						callback();
					}
				});
		}

		/**
		 * Fades out all other element except the ones in
		 * the given chain group.
		 *
		 * @param chainGroup    chain group to exclude from fade out
		 * @param callback      function to invoke after the transition
		 */
		function fadeOutOthers(chainGroup, callback)
		{
			var duration = _options.animationDuration;
			var datum = chainGroup.datum();
			var key = PdbDataUtil.chainKey(datum.pdbId, datum.chain.chainId);

			// fade out all chain rectangles but the given
			_svg.selectAll(".pdb-chain-group")
				.transition().duration(duration)
				.attr("opacity", function(datum) {
					if (PdbDataUtil.chainKey(datum.pdbId, datum.chain.chainId) === key) {
						// do not hide the provided chain
						return 1;
					} else {
						// hide all the others
						return 0;
					}
				});

			// also fade out selection rectangle if the given chain is not selected
			_svg.selectAll(".pdb-selection-rectangle-group")
				.transition().duration(duration)
				.attr("opacity", function(datum) {
					if (_highlighted == chainGroup) {
						// do not hide the selection rectangle
						return 1;
					} else {
						// hide the selection rectangle
						return 0;
					}
				});

			_svg.select(".pdb-panel-y-axis-label-group")
				.transition().duration(duration)
				.attr("opacity", 0)
				.each("end", function() {
					if (_.isFunction(callback)) {
						callback();
					}
				});
		}

		function yShiftLine(selector, shiftFn, duration)
		{
			_svg.selectAll(selector)
				.transition().duration(duration)
				.attr("y1", function(d) {
					return shiftFn(this, d, "y1");
				})
				.attr("y2", function(d) {
					return shiftFn(this, d, "y2");
				});
		}

		function yShiftRect(selector, shiftFn, duration)
		{
			_svg.selectAll(selector)
				.transition().duration(duration)
				.attr("y", function(d) {
					return shiftFn(this, d, "y");
				});
		}

		/**
		 * Reverses the changes back to the state before calling
		 * the minimizeToChain function.
		 *
		 * @param callback  function to invoke after the transition
		 */
		function restoreToFull(callback)
		{
			var duration = _options.animationDuration;

			// put everything back to its original position
			restoreChainPositions();

			// fade-in hidden elements
			fadeInAll();

			var prevHeight = _svg.attr("height");

			dispatchResizeStartEvent(_levelHeight, prevHeight);

			// restore to previous height
			_svg.transition().duration(duration)
				.attr("height", _levelHeight)
				.each("end", function(){
					if (_.isFunction(callback)) {
						callback();
					}
					dispatchResizeEndEvent(_levelHeight, prevHeight);
				});
		}

		/**
		 * Restores all chains back to their initial positions.
		 */
		function restoreChainPositions(callback)
		{
			var duration = _options.animationDuration;

			var shiftFn = function(target, d, attr) {
				return d.initPos.y;
			};

			// put everything back to its original position
			yShiftRect(".pdb-chain-group rect", shiftFn, duration);
			yShiftLine(".pdb-chain-group line", shiftFn, duration);
			yShiftRect(".pdb-selection-rectangle-group rect", shiftFn, duration);

			// TODO it is better to bind this to a d3 transition
			// ..safest way is to call after the selected chain's transition ends
			setTimeout(callback, duration + 50);
		}

		/**
		 * Fades in all hidden components.
		 */
		function fadeInAll(callback)
		{
			var duration = _options.animationDuration;

			// fade-in hidden elements

			_svg.selectAll(".pdb-chain-group")
				.transition().duration(duration)
				.attr("opacity", 1);

			_svg.selectAll(".pdb-selection-rectangle-group")
				.transition().duration(duration)
				.attr("opacity", 1);

			_svg.selectAll(".pdb-panel-y-axis-label-group")
				.transition().duration(duration)
				.attr("opacity", 1)
				.each("end", function(){
					if (_.isFunction(callback)) {
						callback();
					}
				});
		}

		function getHighlighted()
		{
			return _highlighted;
		}

		function dispatchResizeStartEvent(newHeight, prevHeight)
		{
			_dispatcher.trigger(
				MutationDetailsEvents.PDB_PANEL_RESIZE_STARTED,
				newHeight, prevHeight, _options.maxHeight);
		}

		function dispatchResizeEndEvent(newHeight, prevHeight)
		{
			_dispatcher.trigger(
				MutationDetailsEvents.PDB_PANEL_RESIZE_ENDED,
				newHeight, prevHeight, _options.maxHeight);
		}

		return {init: init,
			addListener: addListener,
			removeListener: removeListener,
			getChainGroup: getChainGroup,
			getDefaultChainGroup: getDefaultChainGroup,
			show: showPanel,
			hide: hidePanel,
			toggleHeight: toggleHeight,
			expandToChainLevel: expandToChainLevel,
			minimizeToChain: minimizeToChain,
			minimizeToHighlighted: minimizeToHighlighted,
			restoreToFull: restoreToFull,
			restoreChainPositions: restoreChainPositions,
			fadeInAll: fadeInAll,
			hasMoreChains: hasMoreChains,
			highlight: highlight,
			getHighlighted: getHighlighted,
			dispatcher: _dispatcher};
	}

	module.exports = MutationPdbPanel;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var PdbDataUtil = __webpack_require__(10);

	/**
	 * Utility class to create segments from a merged alignment.
	 * (See PdbChainModel.mergeAlignments function for details of merged alignments)
	 *
	 * @param mergedAlignment   merged alignment object (see PdbChainModel.mergedAlignment field)
	 * @constructor
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MergedAlignmentSegmentor(mergedAlignment)
	{
		var _mergedAlignment = mergedAlignment;

		// start position (initially zero)
		var _start = 0;

		/**
		 * Checks if there are more segments in this merged alignment.
		 *
		 * @return {boolean}
		 */
		function hasNextSegment()
		{
			return (_start < _mergedAlignment.mergedString.length);
		}

		/**
		 * Extracts the next segment from the merged alignment string. Returns
		 * the segment as an object with the actual segment string,
		 * start (uniprot) position, and end (uniprot) position.
		 *
		 * @return {object} segment with string, start, and end info
		 */
		function getNextSegment()
		{
			var str = _mergedAlignment.mergedString;

			var segment = {};
			segment.start = _start + _mergedAlignment.uniprotFrom;
			var symbol = str[_start];
			var end = _start;

			// for each special symbol block, a new segment is created
			if (isSpecialSymbol(symbol))
			{
				segment.type = symbol;

				while (str[end] == symbol &&
				       end <= str.length)
				{
					end++;
				}
			}
			else
			{
				segment.type = "regular";

				while (!isSpecialSymbol(str[end]) &&
				       end <= str.length)
				{
					end++;
				}
			}

			segment.end = end + _mergedAlignment.uniprotFrom;
			segment.str = str.substring(_start, end);

			// update start for the next segment
			_start = end;

			return segment;
		}

		function isSpecialSymbol(symbol)
		{
			// considering symbols other than GAP as special
			// results in too many segments...
	//		return (symbol == PdbDataUtil.ALIGNMENT_GAP) ||
	//		       (symbol == PdbDataUtil.ALIGNMENT_MINUS) ||
	//		       (symbol == PdbDataUtil.ALIGNMENT_PLUS) ||
	//		       (symbol == PdbDataUtil.ALIGNMENT_SPACE);

			return (symbol == PdbDataUtil.ALIGNMENT_GAP);
		}

		return {
			hasNextSegment: hasNextSegment,
			getNextSegment: getNextSegment
		};
	}

	module.exports = MergedAlignmentSegmentor;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var BackboneTemplateCache = __webpack_require__(23);

	var Backbone = __webpack_require__(12);

	/**
	 * Tooltip view for the PDB panel chain rectangles.
	 *
	 * options: {el: [target container],
	 *           model: {pdbId, chain, pdbInfo, molInfo}
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var PdbChainTipView = Backbone.View.extend({
		render: function()
		{
			// compile the template
			var template = this.compileTemplate();

			// load the compiled HTML into the Backbone "el"
			this.$el.html(template);
			this.format();
		},
		format: function()
		{
			// implement if necessary...
		},
		compileTemplate: function()
		{
			var self = this;
			var pdbInfo = self.model.pdbInfo;
			var molInfo = self.model.molInfo;

			// pass variables in using Underscore.js template
			var variables = {pdbId: self.model.pdbId,
				chainId: self.model.chain.chainId,
				pdbInfo: "",
				molInfo: ""};

			// TODO this can be implemented in a better way

			if (pdbInfo != null &&
			    pdbInfo.length > 0)
			{
				variables.pdbInfo = ": " + pdbInfo;
			}

			if (molInfo != null &&
			    molInfo.length > 0)
			{
				variables.molInfo = ": " + molInfo;
			}

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_details_pdb_chain_tip_template");
			return templateFn(variables);
		}
	});

	module.exports = PdbChainTipView;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationPdbTable = __webpack_require__(152);
	var PdbDataUtil = __webpack_require__(10);
	var BackboneTemplateCache = __webpack_require__(23);

	var loaderImage = __webpack_require__(85);

	var Backbone = __webpack_require__(12);
	var _ = __webpack_require__(5);
	var $ = __webpack_require__(7);
	var jQuery = $;
	__webpack_require__(163);

	/**
	 * PDB Table View.
	 *
	 * This view is designed to function in parallel with the 3D visualizer.
	 *
	 * options: {el: [target container],
	 *           model: {geneSymbol: hugo gene symbol,
	 *                   pdbColl: collection of PdbModel instances,
	 *                   pdbProxy: pdb data proxy,
	 *                   tableOpts: pdb table options (optional)},
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var PdbTableView = Backbone.View.extend({
		initialize : function (options) {
			var defaultOpts = {
				config: {
					loaderImage: loaderImage
				}
			};

			this.options = jQuery.extend(true, {}, defaultOpts, options);
		},
		render: function(callback)
		{
			var self = this;

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("pdb_table_view_template");
			var template = templateFn({loaderImage: self.options.config.loaderImage});

			// load the compiled HTML into the Backbone "el"
			self.$el.html(template);

			// init pdb table
			self._initPdbTable(callback);

			// format after rendering
			self.format();
		},
		format: function()
		{
			var self = this;

			// hide view initially
			self.$el.hide();
		},
		hideView: function()
		{
			var self = this;
			self.$el.slideUp();
		},
		showView: function()
		{
			var self = this;
			self.$el.slideDown();
		},
		toggleView: function()
		{
			var self = this;
			self.$el.slideToggle();
		},
		refreshView: function()
		{
			var self = this;
			self.pdbTable.getDataTable().fnAdjustColumnSizing();
		},
		/**
		 * Resets all table filters (rolls back to initial state)
		 */
		resetFilters: function()
		{
			var self = this;

			// TODO do not clean filters if not filtered
			self.pdbTable.cleanFilters();
		},
		selectChain: function(pdbId, chainId)
		{
			var self = this;

			if (self.pdbTable != null)
			{
				self.pdbTable.selectRow(pdbId, chainId);
			}
		},
		/**
		 * Moves the scroll bar to the selected chain's position.
		 */
		scrollToSelected: function()
		{
			var self = this;
			var selected = self.pdbTable.getSelectedRow();

			var container = self.$el.find(".dataTables_scrollBody");

			// TODO make scroll parameters customizable?
			container.scrollTo($(selected),
			                   {axis: 'y', duration: 800});
		},
		/**
		 * Initializes the PDB chain table.
		 *
		 * @return {MutationPdbTable}   table instance
		 */
		_initPdbTable: function(callback)
		{
			var self = this;

			var pdbColl = self.model.pdbColl;
			var pdbProxy = self.model.pdbProxy;

			var options = jQuery.extend(true, {}, self.model.tableOpts);
			options.el = options.el || self.$el.find(".pdb-chain-table");

			var table = new MutationPdbTable(options);
			self.pdbTable = table;

			if (_.isFunction(callback))
			{
				callback(self, table);
			}

			self._generateRowData(table.getColumnOptions(), pdbColl, pdbProxy, function(rowData) {
				// init table with the row data
				table.renderTable(rowData);
				// hide loader image
				self.$el.find(".pdb-chain-table-loader").hide();
			});

			return table;
		},
		_generateRowData: function(headers, pdbColl, pdbProxy, callback)
		{
			var rows = [];
			var pdbIds = [];

			pdbColl.each(function(pdb) {
				pdbIds.push(pdb.pdbId);
			});

			pdbProxy.getPdbInfo(pdbIds.join(" "), function(data) {
				pdbColl.each(function(pdb) {
					pdb.chains.each(function(chain) {
						// this is the data of the hidden column "datum"
						var datum = {
							pdbId: pdb.pdbId,
							chain: chain,
							organism: PdbDataUtil.getOrganism(data[pdb.pdbId], chain.chainId),
							summary: PdbDataUtil.generatePdbInfoSummary(data[pdb.pdbId], chain.chainId)
						};

						// only set the datum
						var row = [datum];

						// set everything else to null...
						for (var i=0; i < _.size(headers) - 1; i++)
						{
							row.push(null);
						}

						rows.push(row);
					})
				});

				callback(rows);
			});
		}
	});

	module.exports = PdbTableView;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var PdbDataUtil = __webpack_require__(10);
	var DataTableUtil = __webpack_require__(153);
	var BackboneTemplateCache = __webpack_require__(23);
	var MutationViewsUtil = __webpack_require__(129);
	var MutationDetailsTableFormatter = __webpack_require__(154);
	var MutationDetailsEvents = __webpack_require__(22);
	var AdvancedDataTable = __webpack_require__(155);

	var cbio = {
		util: __webpack_require__(6)
	};

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);

	/**
	 * MutationPdbTable class (extends AdvancedDataTable)
	 *
	 * Highly customizable table view built on DataTables plugin.
	 * See default options object (_defaultOpts) for details.
	 *
	 * With its default configuration, following events are dispatched by this class:
	 * - MutationDetailsEvents.TABLE_CHAIN_SELECTED:
	 *   dispatched when a PDB chain selected on the table
	 * - MutationDetailsEvents.PDB_TABLE_READY:
	 *   dispatched when the table initialization complete
	 *
	 * @param options   visual options object
	 * @constructor
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationPdbTable(options)
	{
		var self = this;

		// default options object
		var _defaultOpts = {
			el: "#mutation_pdb_table_d3",
			elWidth: 740, // width of the container
			// default column options
			//
			// name: internal name used to define column specific properties
			// sTitle: display value
			// tip: tooltip value
			// [data table options]: sType, sClass, sWidth, asSorting, ...
			columns: {
				datum: {sTitle: "datum",
					tip:""},
				pdbId: {sTitle: "PDB Id",
					tip:"",
					sType: "string"},
				chain: {sTitle: "Chain",
					tip:"",
					sType: "string"},
				uniprotPos: {sTitle: "Uniprot Positions",
					tip:"",
					sType: "numeric"},
				identityPercent: {sTitle: "Identity Percent",
					tip:"",
					sType: "numeric"},
				organism: {sTitle: "Organism",
					tip:"",
					sType: "string"},
				summary: {sTitle: "Summary",
					tip:"",
					sType: "string",
					sWidth: "65%"}
			},
			// display order of column headers
			columnOrder: ["datum", "pdbId", "chain", "uniprotPos",
				"identityPercent", "organism", "summary"],
			// Indicates the visibility of columns
			//
			// - Valid string constants:
			// "visible": column will be visible initially
			// "hidden":  column will be hidden initially,
			// but user can unhide the column via show/hide option
			// "excluded": column will be hidden initially,
			// and the user cannot unhide the column via show/hide option
			//
			// - Custom function: It is also possible to set a custom function
			// to determine the visibility of a column. A custom function
			// should return one of the valid string constants defined above.
			// For any unknown visibility value, column will be hidden by default.
			//
			// All other columns will be initially hidden by default.
			columnVisibility: {
				"pdbId": "visible",
				"chain": "visible",
				"uniprotPos": "visible",
				"identityPercent": "hidden",
				"organism": "visible",
				"summary": "visible",
				"datum": "excluded"
			},
			// Indicates whether a column is searchable or not.
			// Should be a boolean value or a function.
			//
			// All other columns will be initially non-searchable by default.
			columnSearch: {
				"pdbId": true,
				"organism": true,
				"summary": true
			},
			// renderer function for each column
			columnRender: {
				identityPercent: function(datum) {
					// format as a percentage value
					return Math.round(datum.chain.mergedAlignment.identityPerc * 100);
				},
				pdbId: function(datum) {
					// format using the corresponding template
					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_pdb_table_pdb_cell_template");
					return templateFn({pdbId: datum.pdbId});
				},
				chain: function(datum) {
					// format using the corresponding template
					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_pdb_table_chain_cell_template");
					return templateFn({chainId: datum.chain.chainId});
				},
				organism: function(datum) {
					return datum.organism;
				},
				summary: function(datum) {
					var vars = {summary: datum.summary.title,
						molecule: datum.summary.molecule};

					// format using the corresponding template
					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_pdb_table_summary_cell_template");
					return templateFn(vars);
				},
				uniprotPos: function(datum) {
					// there is no data (null) for uniprot positions,
					// so set the display value by using the hidden
					// column "datum"
					return datum.chain.mergedAlignment.uniprotFrom + "-" +
					       datum.chain.mergedAlignment.uniprotTo;
				}
			},
			// default tooltip functions
			columnTooltips: {
				"simple": function(selector) {
					var qTipOptions = MutationViewsUtil.defaultTableTooltipOpts();
					//$(selector).find('.simple-tip').qtip(qTipOptions);
					cbio.util.addTargetedQTip($(selector).find('.simple-tip'), options);
				}
			},
			// default event listener config
			// TODO add more params if necessary
			eventListeners: {
				"pdbLink": function(dataTable, dispatcher, indexMap) {
					$(dataTable).on("click", ".pbd-chain-table-chain-cell a", function (event) {
						event.preventDefault();

						// remove previous highlights
						removeAllSelection();

						// get selected row via event target
						var selectedRow = $(event.target).closest("tr.pdb-chain-table-data-row");

						// highlight selected row
						selectedRow.addClass('row_selected');

						//var data = _dataTable.fnGetData(this);
						var data = dataTable.fnGetData(selectedRow[0]);
						var datum = data[indexMap["datum"]];

						// trigger corresponding event
						dispatcher.trigger(
							MutationDetailsEvents.TABLE_CHAIN_SELECTED,
							datum.pdbId,
							datum.chain.chainId);
					});
				}
			},
			// column sort functions
			columnSort: {
				identityPercent: function(datum) {
					return MutationDetailsTableFormatter.assignFloatValue(
						Math.round(datum.chain.mergedAlignment.identityPerc * 100));
				},
				pdbId: function(datum) {
					return datum.pdbId;
				},
				chain: function(datum) {
					return datum.chain.chainId;
				},
				organism: function(datum) {
					return datum.organism;
				},
				summary: function(datum) {
					return datum.summary.title + datum.summary.molecule;
				},
				uniprotPos: function(datum) {
					return MutationDetailsTableFormatter.assignIntValue(
						datum.chain.mergedAlignment.uniprotFrom);
				}
			},
			// column filter functions
			columnFilter: {
				identityPercent: function(datum) {
					return Math.round(datum.chain.mergedAlignment.identityPerc * 100);
				},
				summary: function(datum) {
					return datum.summary.title + " " + datum.summary.molecule;
				},
				uniprotPos: function(datum) {
					return datum.chain.mergedAlignment.uniprotFrom + "-" +
					       datum.chain.mergedAlignment.uniprotTo;
				}
			},
			// delay amount before applying the user entered filter query
			filteringDelay: 0,
			// WARNING: overwriting advanced DataTables options such as
			// aoColumnDefs, oColVis, and fnDrawCallback may break column
			// visibility, sorting, and filtering. Proceed wisely ;)
			dataTableOpts: {
				//"sDom": '<"H"<"mutation_datatables_filter"f>C<"mutation_datatables_info"i>>t',
				"sDom": '<"H"<"mutation_pdb_datatable_info"i><"mutation_pdb_datatable_filter"f>>t',
				"bJQueryUI": true,
				"bPaginate": false,
				"bFilter": true,
				"sScrollY": "200px",
				"bScrollCollapse": true,
				"oLanguage": {
					"sInfo": "Showing _TOTAL_ PDB chain(s)",
					"sInfoFiltered": "(out of _MAX_ total chains)",
					"sInfoEmpty": "No chains to show"
				}
			}
		};

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		// call super constructor to init options and other params
		AdvancedDataTable.call(this, _options);
		_options = self._options;

		// custom event dispatcher
		var _dispatcher = self._dispatcher;

		var _rowMap = {};

		var _selectedRow = null;

		/**
		 * Generates the data table options for the given parameters.
		 *
		 * @param tableSelector jQuery selector for the target table
		 * @param rows          data rows
		 * @param columnOpts    column options
		 * @param nameMap       map of <column display name, column name>
		 * @param indexMap      map of <column name, column index>
		 * @param hiddenCols    indices of the hidden columns
		 * @param excludedCols  indices of the excluded columns
		 * @param nonSearchableCols    indices of the columns excluded from search
		 * @return {object}     DataTable options
		 * @private
		 */
		function initDataTableOpts(tableSelector, rows, columnOpts, nameMap,
			indexMap, hiddenCols, excludedCols, nonSearchableCols)
		{
			// generate column options for the data table
			var columns = DataTableUtil.getColumnOptions(columnOpts,
				indexMap);

			// these are the parametric data tables options
			var tableOpts = {
		        "aaData" : rows,
		        "aoColumns" : columns,
				"aoColumnDefs":[
					{"bVisible": false,
						"aTargets": hiddenCols},
					{"bSearchable": false,
						"aTargets": nonSearchableCols}
				],
				"oColVis": {"aiExclude": excludedCols}, // columns to always hide
				"fnDrawCallback": function(oSettings) {
					self._addColumnTooltips();
				},
				"fnHeaderCallback": function(nHead, aData, iStart, iEnd, aiDisplay) {
					$(nHead).find('th').addClass("mutation-pdb-table-header");
				},
				"fnRowCallback": function(nRow, aData, iDisplayIndex, iDisplayIndexFull ) {
					var datum = aData[indexMap["datum"]];
					var key = PdbDataUtil.chainKey(datum.pdbId,
					                               datum.chain.chainId);
					_rowMap[key] = nRow;
					$(nRow).addClass("pdb-chain-table-data-row");
				},
				"fnInitComplete": function(oSettings, json) {
					// trigger corresponding event
					_dispatcher.trigger(
						MutationDetailsEvents.PDB_TABLE_READY);
				}
			};

			return tableOpts;
		}

		/**
		 * Determines the visibility value for the given column name
		 *
		 * @param columnName    name of the column (header)
		 * @return {String}     visibility value for the given column
		 */
		function visibilityValue(columnName)
		{
			var vis = _options.columnVisibility[columnName];
			var value = vis;

			// if not in the list, hidden by default
			if (!vis)
			{
				value = "hidden";
			}
			// if function, then evaluate the value
			else if (_.isFunction(vis))
			{
				// TODO determine function params (if needed)
				value = vis();
			}

			return value;
		}

		/**
		 * Determines the search value for the given column name
		 *
		 * @param columnName    name of the column (header)
		 * @return {Boolean}    whether searchable or not
		 */
		function searchValue(columnName)
		{
			var searchVal = _options.columnSearch[columnName];
			var value = searchVal;

			// if not in the list, hidden by default
			if (searchVal == null)
			{
				value = false;
			}
			// if function, then evaluate the value
			else if (_.isFunction(searchVal))
			{
				// TODO determine function params (if needed)
				value = searchVal();
			}

			return value;
		}

		function addEventListeners(indexMap)
		{
			// super.addEventListeners(indexMap);

			// TODO mouse over/out actions do not work as desired

	//		$(_options.el).on("mouseleave", "table", function (event) {
	//			//var data = _dataTable.fnGetData(this);
	//
	//			// trigger corresponding event
	//			_dispatcher.trigger(
	//				MutationDetailsEvents.TABLE_CHAIN_MOUSEOUT);
	//		});
	//
	//		$(_options.el).on("mouseenter", "tr", function (event) {
	//			var data = _dataTable.fnGetData(this);
	//
	//			// trigger corresponding event
	//			_dispatcher.trigger(
	//				MutationDetailsEvents.TABLE_CHAIN_MOUSEOVER,
	//				data[indexMap["pdb id"]],
	//				data[indexMap["chain"]]);
	//		});
		}

		function cleanFilters()
		{
			// just show everything
			self.getDataTable().fnFilter("");
		}

		function selectRow(pdbId, chainId)
		{
			var key = PdbDataUtil.chainKey(pdbId, chainId);

			// remove previous highlights
			removeAllSelection();

			// highlight selected
			var nRow = _rowMap[key];
			$(nRow).addClass("row_selected");

			_selectedRow = nRow;
		}

		function removeAllSelection()
		{
			$(_options.el).find("tr").removeClass("row_selected");
		}

		function getSelectedRow()
		{
			return _selectedRow;
		}

		// override required functions
		this._initDataTableOpts = initDataTableOpts;
		this._visibilityValue = visibilityValue;
		this._searchValue = searchValue;

		// additional public functions
		this.selectRow = selectRow;
		this.cleanFilters = cleanFilters;
		this.getSelectedRow = getSelectedRow;
		this.dispatcher = this._dispatcher;
	}

	// MutationPdbTable extends AdvancedDataTable...
	MutationPdbTable.prototype = new AdvancedDataTable();
	MutationPdbTable.prototype.constructor = MutationPdbTable;

	module.exports = MutationPdbTable;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var $ = __webpack_require__(7);
	var _ = __webpack_require__(5);

	/**
	 * Singleton utility class for DataTables related tasks.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var DataTableUtil = (function()
	{
		/**
		 * Creates a mapping for the given column headers. The mapped values
		 * will be the array indices for each element.
		 *
		 * @param headers   column header names
		 * @return {object} map of <column name, column index>
		 * @private
		 */
		function buildColumnIndexMap(headers)
		{
			var map = {};

			_.each(headers, function(header, index)
			{
				if (map[header] == null)
				{
					map[header] = index;
				}
			});

			return map;
		}

		/**
		 * Creates a mapping for the given column headers.
		 *
		 * @param columns   column options
		 * @return {object} map of <column display name, column name>
		 * @private
		 */
		function buildColumnNameMap(columns)
		{
			var map = {};

			_.each(_.pairs(columns), function(pair, index)
			{
				var name = pair[0];
				var options = pair[1];

				if (options.sTitle != null &&
				    options.sTitle.length > 0)
				{
					map[options.sTitle] = name;
				}
			});

			return map;
		}

		/**
		 * Creates a mapping for the given column headers. The mapped values
		 * will be one of these visibility values: visible, hidden, excluded.
		 *
		 * @param headers           column header names
		 * @param visibilityValue   function to determine visibility value (returns string)
		 * @return {object} map of <column name, visibility value>
		 * @private
		 */
		function buildColumnVisMap(headers, visibilityValue)
		{
			var map = {};

			_.each(headers, function(header, idx) {
				if (map[header] == null)
				{
					// TODO sanitize return value of the custom function
					if (_.isFunction(visibilityValue))
					{
						map[header] = visibilityValue(header);
					}
					else
					{
						map[header] = "hidden";
					}
				}
			});

			return map;
		}

		/**
		 * Creates a mapping for the given column headers. The mapped values
		 * will be a boolean.
		 *
		 * @param headers       column header names
		 * @param searchValue   function to determine search value (returns boolean)
		 * @return {object} map of <column name, search value>
		 * @private
		 */
		function buildColumnSearchMap(headers, searchValue)
		{
			var map = {};

			_.each(headers, function(header, idx) {
				if (map[header] == null)
				{
					map[header] = _.isFunction(searchValue) && searchValue(header);
				}
			});

			return map;
		}

		/**
		 * Creates an array of indices for the columns to be hidden.
		 *
		 * @param headers   column header names
		 * @param indexMap  map of <column name, column index>
		 * @param visMap    map of <column name, column visibility value>
		 * @return {Array}  an array of column indices
		 * @private
		 */
		function getHiddenColumns(headers, indexMap, visMap)
		{
			// set hidden column indices
			var hiddenCols = [];

			// process all headers
			_.each(headers, function(header, idx) {
				// determine visibility
				if (visMap[header] != "visible")
				{
					// include in hidden columns list if not visible
					hiddenCols.push(indexMap[header]);
				}
			});

			return hiddenCols;
		}

		/**
		 * Creates an array of indices for the columns to be completely excluded.
		 *
		 * @param headers   column header names
		 * @param indexMap  map of <column name, column index>
		 * @param visMap    map of <column name, column visibility value>
		 * @return {Array}  an array of column indices
		 * @private
		 */
		function getExcludedColumns(headers, indexMap, visMap)
		{
			// excluded column indices
			var excludedCols = [];

			// check all headers
			_.each(headers, function(header, idx) {
				// determine visibility
				if (visMap[header] == "excluded")
				{
					excludedCols.push(indexMap[header]);
				}
			});

			return excludedCols;
		}

		/**
		 * Creates an array of indices for the columns to be ignored during search.
		 *
		 * @param headers   column header names
		 * @param indexMap  map of <column name, column index>
		 * @param searchMap map of <column name, column search value>
		 * @return {Array}  an array of column indices
		 */
		function getNonSearchableColumns(headers, indexMap, searchMap)
		{
			// nonSearchableCols column indices
			var nonSearchableCols = [];

			// check all headers
			_.each(headers, function(header, idx) {
				// check if searchable
				if (searchMap[header] === false)
				{
					nonSearchableCols.push(indexMap[header]);
				}
			});

			return nonSearchableCols;
		}

		/**
		 * Generates renderer functions for each column.
		 *
		 * @param renderers map of <column name, renderer>
		 * @param indexMap  map of <column name, column index>
		 * @returns {Array} array of renderer functions
		 */
		function getColumnRenderers(renderers, indexMap)
		{
			var columnRenderers = [];

			_.each(_.pairs(renderers), function(pair) {
				var columnName = pair[0];
				var renderFn = pair[1];

				var columnIdx = indexMap[columnName];

				if (columnIdx != null)
				{
					var renderer = {
						"fnRender": function(obj) {
							// assuming the data table has a datum column
							var datum = obj.aData[indexMap["datum"]];

							// assuming renderFn takes these 2 parameters
							return renderFn(obj, datum);
						},
						"aTargets": [columnIdx]
					};

					columnRenderers.push(renderer);
				}
			});

			return columnRenderers;
		}

		/**
		 * Generates "mData" functions for each column.
		 *
		 * @param indexMap  map of <column name, column index>
		 * @param columnRender map of <column name, renderer>
		 * @param columnSort map of <column name, sort function>
		 * @param columnFilter map of <column name, filter function>
		 * @param columnData map of <column name, mData function>
		 *
		 * @returns {Array} array of mData functions
		 */
		function getColumnData(indexMap, columnRender, columnSort, columnFilter, columnData)
		{
			var mData = {};

			// iterate over list of renderers
			// (assuming each column has its corresponding renderer)
			_.each(_.pairs(columnRender), function(pair) {
				var columnName = pair[0];
				var renderFn = pair[1];
				var sortFn = columnSort[columnName];
				var filterFn = columnFilter[columnName];

				var columnIdx = indexMap[columnName];

				var sortValue = function(datum)
				{
					// try to use a sort function
					if (sortFn != null)
					{
						return sortFn(datum);
					}
					// if no sort function defined,
					// use the render function
					{
						return renderFn(datum);
					}
				};

				if (columnIdx != null)
				{
					var def = {
						"mData": function(source, type, val) {
							var datum = source[indexMap["datum"]];

							if (type === "set") {
								return null;
							}
							else if (type === "display")
							{
								return renderFn(datum);
							}
							else if (type === "sort")
							{
								return sortValue(datum);
							}
							else if (type === "filter")
							{
								if (filterFn != null)
								{
									return filterFn(datum);
								}
								else
								{
									return sortValue(datum);
								}
							}
	//						else if (type === "type")
	//						{
	//							return 0.0;
	//						}

							return source[columnIdx];
						},
						"aTargets": [columnIdx]
					};

					mData[columnName] = def;
				}
			});

			// now process columnData ("mData") functions
			// (this will override prev definition, if any)
			_.each(_.pairs(columnData), function(pair) {
				var columnName = pair[0];
				var mDataFn = pair[1];
				var columnIdx = indexMap[columnName];

				var def = {
					"mData": function(source, type, val) {
						return mDataFn(source, type, val, indexMap);
					},
					"aTargets": [columnIdx]
				};

				mData[columnName] = def;
			});

			// return an array of values (not a map)
			return _.values(mData);
		}

		/**
		 * Generates basic column options for the given headers.
		 *
		 * @param columns   column options object
		 * @param indexMap  map of <column name, column index>
		 * @returns {Array} array of column options
		 */
		function getColumnOptions(columns, indexMap)
		{
			var columnOpts = [];

			// set column options
			_.each(_.pairs(columns), function(pair) {
				var name = pair[0];
				var column = pair[1];

				// TODO column may have non-datatable options

				var idx = indexMap[name];

				if (idx > 0)
				{
					columnOpts[idx] = column;
				}
			});

			return columnOpts;
		}

		function getAltTextValue(a)
		{
			var altValue = $(a).attr("alt");
			var value = parseFloat(altValue);

			if (isNaN(value))
			{
				value = "";
			}

			return value;
		}

		/**
		 * Helper function for sorting string values within label tag.
		 */
		function getLabelTextValue(a)
		{
			if (a.indexOf("label") != -1)
			{
				// TODO temp workaround
				return $(a).find("label").text().trim() || $(a).text().trim();
			}
			else
			{
				return -1;
			}
		}

		/**
		 * Helper function for sorting int values within label tag.
		 */
		function getLabelTextIntValue(a)
		{
			if (a.indexOf("label") != -1)
			{
				return parseInt($(a).text());
			}
			else
			{
				return -1;
			}
		}

		/**
		 * Helper function for sorting float values within label tag.
		 */
		function getLabelTextFloatValue(a)
		{
			if (a.indexOf("label") != -1)
			{
				return parseFloat($(a).text());
			}
			else
			{
				return -1;
			}
		}

		/**
		 * Comparison function for ascending sort operations.
		 *
		 * @param a
		 * @param b
		 * @param av
		 * @param bv
		 * @return
		 */
		function compareSortAsc(a, b, av, bv)
		{
			if (av >= 0) {
				if (bv >= 0) {
					return av==bv ? 0 : (av<bv ? -1:1);
				} else {
					return -1;
				}
			} else {
				if (bv >= 0) {
					return 1;
				} else {
					return a==b ? 0 : (a<b ? 1:-1);
				}
			}
		}

		/**
		 * Comparison function for descending sort operations.
		 *
		 * @param a
		 * @param b
		 * @param av
		 * @param bv
		 * @return
		 */
		function compareSortDesc(a, b, av, bv)
		{
			if (av >= 0) {
				if (bv >= 0) {
					return av==bv ? 0 : (av<bv ? 1:-1);
				} else {
					return -1;
				}
			} else {
				if (bv >= 0) {
					return 1;
				} else {
					return a==b ? 0 : (a<b ? -1:1);
				}
			}
		}

		return {
			buildColumnIndexMap: buildColumnIndexMap,
			buildColumnNameMap: buildColumnNameMap,
			buildColumnVisMap: buildColumnVisMap,
			buildColumnSearchMap: buildColumnSearchMap,
			getHiddenColumns: getHiddenColumns,
			getExcludedColumns: getExcludedColumns,
			getNonSearchableColumns: getNonSearchableColumns,
			getColumnOptions: getColumnOptions,
			getColumnRenderers: getColumnRenderers,
			getColumnData: getColumnData,
			compareSortAsc: compareSortAsc,
			compareSortDesc: compareSortDesc,
			getAltTextValue: getAltTextValue,
			getLabelTextValue: getLabelTextValue,
			getLabelTextIntValue: getLabelTextIntValue,
			getLabelTextFloatValue: getLabelTextFloatValue
		};
	})();

	module.exports = DataTableUtil;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationViewsUtil = __webpack_require__(129);

	/**
	 * Singleton utility class to format Mutation Details Table View content.
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationDetailsTableFormatter = (function()
	{
		var _visualStyleMaps = MutationViewsUtil.getVisualStyleMaps();

		var _mutationTypeMap = _visualStyleMaps.mutationType;
		var _validationStatusMap = _visualStyleMaps.validationStatus;
		var _mutationStatusMap = _visualStyleMaps.mutationStatus;
		var _omaScoreMap = _visualStyleMaps.omaScore;
		var _cnaMap = _visualStyleMaps.cna;

		// TODO identify similar get functions to avoid code duplication

		function getCNA(value)
		{
			return _getCNA(_cnaMap, value);
		}

		function _getCNA(map, value)
		{
			var style, label, tip;

			if (map[value] != null)
			{
				style = map[value].style;
				label = map[value].label;
				tip = map[value].tooltip;
			}
			else
			{
				style = map.unknown.style;
				label = map.unknown.label;
				tip = map.unknown.tooltip;
			}

			return {style: style, tip: tip, text: label};
		}

	    /**
	     * Returns the text content, the css class, and the tooltip
	     * for the given case id value. If the length of the actual
	     * case id string is too long, then creates a short form of
	     * the case id ending with an ellipsis.
	     *
	     * @param caseId    actual case id string
	     * @return {{style: string, text: string, tip: string}}
	     * @private
	     */
		function getCaseId(caseId)
		{
			// TODO customize this length?
			var maxLength = 16;

			var text = caseId;
			var style = ""; // no style for short case id strings
			var tip = caseId; // display full case id as a tip

			// no need to bother with clipping the text for 1 or 2 chars.
			if (caseId != null &&
			    caseId.length > maxLength + 2)
			{
				text = caseId.substring(0, maxLength) + "...";
				style = "simple-tip"; // enable tooltip for long strings
			}

			return {style: style, tip: tip, text: text};
		}

		function getMutationType(value)
		{
			return _getMutationType(_mutationTypeMap, value);
		}

	    /**
	     * Returns the text content and the css class for the given
	     * mutation type value.
	     *
	     * @param map   map of <mutationType, {label, style}>
	     * @param value actual string value of the mutation type
	     * @return {{style: string, text: string}}
	     * @private
	     */
		function _getMutationType(map, value)
		{
			var style, text;

			if (value != null)
			{
				value = value.toLowerCase();
			}

			if (map[value] != null)
			{
				style = map[value].style;
				text = map[value].label;
			}
			else
			{
				style = map.other.style;
				text = value;
			}

			return {style: style, text: text};
		}

		function getMutationStatus(value)
		{
			return _getMutationStatus(_mutationStatusMap, value);
		}

		/**
	     * Returns the text content, the css class, and the tooltip
		 * for the given mutation type value.
	     *
	     * @param map   map of <mutationStatus, {label, style, tooltip}>
	     * @param value actual string value of the mutation status
	     * @return {{style: string, text: string, tip: string}}
	     * @private
	     */
		function _getMutationStatus(map, value)
		{
			var style = "simple-tip";
			var text = value;
			var tip = "";

			if (value != null)
			{
				value = value.toLowerCase();
			}

			if (map[value] != null)
			{
				style = map[value].style;
				text = map[value].label;
				tip = map[value].tooltip;
			}

			return {style: style, tip: tip, text: text};
		}

		function getValidationStatus(value)
		{
			return _getValidationStatus(_validationStatusMap, value);
		}

		/**
		 * Returns the text content, the css class, and the tooltip
		 * for the given validation status value.
		 *
		 * @param map   map of <validationStatus, {label, style, tooltip}>
		 * @param value actual string value of the validation status
		 * @return {{style: string, text: string, tip: string}}
		 * @private
		 */
		function _getValidationStatus(map, value)
		{
			var style, label, tip;

			if (value != null)
			{
				value = value.toLowerCase();
			}

			if (map[value] != null)
			{
				style = map[value].style;
				label = map[value].label;
				tip = map[value].tooltip;
			}
			else
			{
				style = map.unknown.style;
				label = map.unknown.label;
				tip = map.unknown.tooltip;
			}

			return {style: style, tip: tip, text: label};
		}

		function getFis(fis, fisValue)
		{
			return _getFis(_omaScoreMap, fis, fisValue);
		}

		/**
		 * Returns the text content, the css classes, and the tooltip
		 * for the given string and numerical values of a
		 * functional impact score.
		 *
		 * @param map       map of <FIS, {label, style, tooltip}>
		 * @param fis       string value of the functional impact (h, l, m or n)
		 * @param fisValue  numerical value of the functional impact score
		 * @return {{fisClass: string, omaClass: string, value: string, text: string}}
		 * @private
		 */
		function _getFis(map, fis, fisValue)
		{
			var text = "";
			var fisClass = "";
			var omaClass = "";
			var value = "";

			if (fis != null)
			{
				fis = fis.toLowerCase();
			}

			if (map[fis] != null)
			{
				value = map[fis].tooltip;

				if (fisValue != null)
				{
					value = fisValue.toFixed(2);
				}

				text = map[fis].label;
				fisClass = map[fis].style;
				omaClass = "oma_link";
			}

			return {fisClass: fisClass, omaClass: omaClass, value: value, text: text};
		}

		/**
		 * Returns the text content, the css classes, and the total
		 * allele count for the given allele frequency.
		 *
		 * @param frequency allele frequency
		 * @param alt       alt allele count
		 * @param ref       ref allele count
		 * @param tipClass  css class for the tooltip
		 * @return {{text: string, total: number, style: string, tipClass: string}}
		 * @private
		 */
		function getAlleleFreq(frequency, alt, ref, tipClass)
		{
			var text = "NA";
			var total = alt + ref;
			var style = "";
			var tipStyle = "";

			if (frequency)
			{
				style = "mutation_table_allele_freq";
				text = frequency.toFixed(2);
				tipStyle = tipClass;
			}

			return {text: text, total: total, style: style, tipClass: tipStyle};
		}

		function getPdbMatchLink(mutation)
		{
			return getLink(mutation.get("pdbMatch"));
		}

		function getIgvLink(mutation)
		{
			return getLink(mutation.get("igvLink"));
		}

		function getLink(value)
		{
			if (value)
			{
				// this is not a real link,
				// actual action is performed by an event listener
				// "#" indicates that this is a valid link
				return "#";
			}
			else
			{
				// an empty string indicates that this is not a valid link
				// invalid links are removed by the view itself after rendering
				return "";
			}
		}

		function getProteinChange(mutation)
		{
			var style = "mutation-table-protein-change";
			var tip = "click to highlight the position on the diagram";
			var additionalTip = "";

			// TODO additional tooltips are enabled (hardcoded) only for msk-impact study for now
			// this is cBioPortal specific implementation, we may want to make it generic in the future
			if (mutation.get("aminoAcidChange") != null &&
			    mutation.get("aminoAcidChange").length > 0 &&
				mutation.get("aminoAcidChange") !== "NA" &&
				mutation.get("cancerStudyShort") != null &&
				mutation.get("cancerStudyShort").toLowerCase().indexOf("msk-impact") != -1 &&
			    isDifferentProteinChange(mutation.get("proteinChange"), mutation.get("aminoAcidChange")))
			{
				additionalTip = "The original annotation file indicates a different value: <b>" +
				                normalizeProteinChange(mutation.get("aminoAcidChange")) + "</b>";
			}

			// TODO disabled temporarily, enable when isoform support completely ready
	//        if (!mutation.canonicalTranscript)
	//        {
	//            style = "best_effect_transcript " + style;
	//            // TODO find a better way to display isoform information
	//            tip = "Specified protein change is for the best effect transcript " +
	//                "instead of the canonical transcript.<br>" +
	//                "<br>RefSeq mRNA id: " + "<b>" + mutation.refseqMrnaId + "</b>" +
	//                "<br>Codon change: " + "<b>" + mutation.codonChange + "</b>" +
	//                "<br>Uniprot id: " + "<b>" + mutation.uniprotId + "</b>";
	//        }

			return {text: normalizeProteinChange(mutation.get("proteinChange")),
				style : style,
				tip: tip,
				additionalTip: additionalTip};
		}

		/**
		 * Checks if given 2 protein changes are completely different from each other.
		 *
		 * @param proteinChange
		 * @param aminoAcidChange
		 * @returns {boolean}
		 */
		function isDifferentProteinChange(proteinChange, aminoAcidChange)
		{
			var different = false;

			proteinChange = normalizeProteinChange(proteinChange);
			aminoAcidChange = normalizeProteinChange(aminoAcidChange);

			// if the normalized strings are exact, no need to do anything further
			if (aminoAcidChange !== proteinChange)
			{
				// assuming each uppercase letter represents a single protein
				var proteinMatch1 = proteinChange.match(/[A-Z]/g);
				var proteinMatch2 = aminoAcidChange.match(/[A-Z]/g);

				// assuming the first numeric value is the location
				var locationMatch1 = proteinChange.match(/[0-9]+/);
				var locationMatch2 = aminoAcidChange.match(/[0-9]+/);

				// assuming first lowercase value is somehow related to
				var typeMatch1 = proteinChange.match(/([a-z]+)/);
				var typeMatch2 = aminoAcidChange.match(/([a-z]+)/);

				if (locationMatch1 && locationMatch2 &&
				    locationMatch1.length > 0 && locationMatch2.length > 0 &&
				    locationMatch1[0] != locationMatch2[0])
				{
					different = true;
				}
				else if (proteinMatch1 && proteinMatch2 &&
				         proteinMatch1.length > 0 && proteinMatch2.length > 0 &&
				         proteinMatch1[0] !== "X" && proteinMatch2[0] !== "X" &&
				         proteinMatch1[0] !== proteinMatch2[0])
				{
					different = true;
				}
				else if (proteinMatch1 && proteinMatch2 &&
				         proteinMatch1.length > 1 && proteinMatch2.length > 1 &&
				         proteinMatch1[1] !== proteinMatch2[1])
				{
					different = true;
				}
				else if (typeMatch1 && typeMatch2 &&
				         typeMatch1.length > 0 && typeMatch2.length > 0 &&
				         typeMatch1[0] !== typeMatch2[0])
				{
					different = true;
				}
			}

			return different;
		}

		function normalizeProteinChange(proteinChange)
		{
			var prefix = "p.";

			if (proteinChange.indexOf(prefix) != -1)
			{
				proteinChange = proteinChange.substr(proteinChange.indexOf(prefix) + prefix.length);
			}

			return proteinChange;
		}

		function getTumorType(mutation)
		{
			var style = "tumor_type";
			var tip = "";

			return {text: mutation.get("tumorType"),
				style : style,
				tip: tip};
		}

		/**
		 * Returns the css class and text for the given cosmic count.
		 *
		 * @param count number of occurrences
		 * @return {{style: string, count: string}}
		 * @private
		 */
		function getCosmic(count)
		{
			var style = "";
			var text = "";

			if (count > 0)
			{
				style = "mutation_table_cosmic";
				text = count;
			}

			return {style: style,
				count: text};
	    }

		/**
		 * Returns the css class and text for the given cosmic count.
		 *
		 * @param frequency frequency value in cbio portal
		 * @return {{style: string, frequency: string}}
		 * @private
		 */
		function getCbioPortal(frequency)
		{
			var style = "";
			var text = "";

			if (frequency > 0)
			{
				style = "mutation_table_cbio_portal";
				text = frequency;
			}

			return {style: style,
				frequency: text};
		}

		/**
		 * Returns the text and css class values for the given integer value.
		 *
		 * @param value an integer value
		 * @return {{text: *, style: string}}
		 * @private
		 */
		function getIntValue(value)
		{
			var text = value;
			var style = "mutation_table_int_value";

			if (value == null)
			{
				text = "NA";
				style = "";
			}

			return {text: text, style: style};
		}

		/**
		 * Returns the text and css class values for the given allele count value.
		 *
		 * @param count an integer value
		 * @return {{text: *, style: string}}
		 * @private
		 */
		function getAlleleCount(count)
		{
			var text = count;
			var style = "mutation_table_allele_count";

			if (count == null)
			{
				text = "NA";
				style = "";
			}

			return {text: text, style: style};
	    }


		/**
		 * Helper function for predicted impact score sorting.
		 */
		function assignValueToPredictedImpact(text, score)
		{
			// using score by itself may be sufficient,
			// but sometimes we have no numerical score value

			var value;

			if (text != null)
			{
				text = text.toLowerCase();
			}

			if (text == "low" || text == "l") {
				value = 2;
			} else if (text == "medium" || text == "m") {
				value = 3;
			} else if (text == "high" || text == "h") {
				value = 4;
			} else if (text == "neutral" || text == "n") {
				value = 1;
			} else {
				value = -1;
			}

			if (value > 0 && !isNaN(score))
			{
				//assuming FIS values cannot exceed 1000
				value += score / 1000;
			}

			return value;
		}

		function assignIntValue(value)
		{
			var val = parseInt(value);

			if (isNaN(val))
			{
				val = -Infinity;
			}

			return val;
		}

		function assignFloatValue(value)
		{
			var val = parseFloat(value);

			if (isNaN(val))
			{
				val = -Infinity;
			}

			return val;
		}

		return {
			getCaseId: getCaseId,
			getProteinChange: getProteinChange,
			getPdbMatchLink: getPdbMatchLink,
			getIgvLink: getIgvLink,
			getAlleleCount: getAlleleCount,
			getAlleleFreq: getAlleleFreq,
			getCNA: getCNA,
			getMutationType: getMutationType,
			getMutationStatus: getMutationStatus,
			getValidationStatus: getValidationStatus,
			getFis: getFis,
			getTumorType: getTumorType,
			getCosmic: getCosmic,
			getCbioPortal: getCbioPortal,
			getIntValue: getIntValue,
			assignValueToPredictedImpact: assignValueToPredictedImpact,
			assignIntValue: assignIntValue,
			assignFloatValue: assignFloatValue
		}
	})();

	module.exports = MutationDetailsTableFormatter;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDataManager = __webpack_require__(2);
	var DataTableUtil = __webpack_require__(153);

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);
	var Backbone = __webpack_require__(12);

	__webpack_require__(156);
	__webpack_require__(158);
	__webpack_require__(159);
	__webpack_require__(160);
	__webpack_require__(161);
	__webpack_require__(162);


	/**
	 * Designed as a base (abstract) class for an advanced implementation of data tables
	 * with additional and more flexible options.
	 *
	 * @param options   table options
	 * @constructor
	 *
	 * @author Selcuk Onur Sumer
	 */
	function AdvancedDataTable(options)
	{
		// global reference to this instance
		// (using "this" is sometimes dangerous)
		var self = this;

		// column index map
		var _indexMap = null;

		self._defaultOpts = {
			// target container
			el: "",
			// default column options
			//
			// sTitle: display value
			// tip: tooltip value of the column header
			//
			// [data table options]: sType, sClass, sWidth, asSorting, ...
			columns: {},
			// display order of column headers
			columnOrder: [],
			// Indicates the visibility of columns
			//
			// - Valid string constants:
			// "visible": column will be visible initially
			// "hidden":  column will be hidden initially,
			// but user can unhide the column via show/hide option
			// "excluded": column will be hidden initially,
			// and the user cannot unhide the column via show/hide option
			//
			// - Custom function: It is also possible to set a custom function
			// to determine the visibility of a column. A custom function
			// should return one of the valid string constants defined above.
			// For any unknown visibility value, column will be hidden by default.
			//
			// All other columns will be initially hidden by default.
			columnVisibility: {},
			// Indicates whether a column is searchable or not.
			// Should be a boolean value or a function.
			//
			// All other columns will be initially non-searchable by default.
			columnSearch: {},
			// renderer functions:
			// returns the display value for a column (may contain html elements)
			// if no render function is defined for a column,
			// then we rely on a custom "mData" function.
			columnRender: {},
			// column sort functions:
			// returns the value to be used for column sorting purposes.
			// if no sort function is defined for a column,
			// then uses the render function for sorting purposes.
			columnSort: {},
			// column filter functions:
			// returns the value to be used for column sorting purposes.
			// if no filter function is defined for a column,
			// then uses the sort function value for filtering purposes.
			// if no sort function is defined either, then uses
			// the value returned by the render function.
			columnFilter: {},
			// native "mData" function for DataTables plugin. if this is implemented,
			// functions defined in columnRender and columnSort will be ignored.
			// in addition to the default source, type, and val parameters,
			// another parameter "indexMap" will also be passed to the function.
			columnData: {},
			// default tooltip functions
			columnTooltips: {},
			// default event listener config
			eventListeners: {},
			// sort functions for custom types
			customSort: {},
			// delay amount before applying the user entered filter query
			filteringDelay: 0,
			// WARNING: overwriting advanced DataTables options such as
			// aoColumnDefs, oColVis, and fnDrawCallback may break column
			// visibility, sorting, and filtering. Proceed wisely ;)
			dataTableOpts: {}
		};

		// merge options with default options to use defaults for missing values
		self._options = jQuery.extend(true, {}, self._defaultOpts, options);

		// custom event dispatcher
		self._dispatcher = {};
		_.extend(self._dispatcher, Backbone.Events);

		// reference to the data table object
		self._dataTable = null;

		/**
		 * Determines the visibility value for the given column name
		 *
		 * @param columnName    name of the column (header)
		 * @return {String}     visibility value for the given column
		 */
		self._visibilityValue = function(columnName)
		{
			// method body should be overridden by subclasses
			return "hidden";
		};

		/**
		 * Determines the search value for the given column name
		 *
		 * @param columnName    name of the column (header)
		 * @return {Boolean}    whether searchable or not
		 */
		self._searchValue = function(columnName)
		{
			// method body should be overridden by subclasses
			return false;
		};

		/**
		 * Formats the table with data tables plugin for the given
		 * row data array (each element represents a single row).
		 *
		 * @rows    row data as an array
		 */
		self.renderTable = function(rows)
		{
			var columnOrder = self._options.columnOrder;

			// build a map, to be able to use string constants
			// instead of integer constants for table columns
			var indexMap = _indexMap = DataTableUtil.buildColumnIndexMap(columnOrder);
			var nameMap = DataTableUtil.buildColumnNameMap(self._options.columns);

			// build a visibility map for column headers
			var visibilityMap = DataTableUtil.buildColumnVisMap(columnOrder, self._visibilityValue);
			self._visiblityMap = visibilityMap;

			// build a map to determine searchable columns
			var searchMap = DataTableUtil.buildColumnSearchMap(columnOrder, self._searchValue);

			// determine hidden and excluded columns
			var hiddenCols = DataTableUtil.getHiddenColumns(columnOrder, indexMap, visibilityMap);
			var excludedCols = DataTableUtil.getExcludedColumns(columnOrder, indexMap, visibilityMap);

			// determine columns to exclude from filtering (through the search box)
			var nonSearchableCols = DataTableUtil.getNonSearchableColumns(columnOrder, indexMap, searchMap);

			// add custom sort functions for specific columns
			self._addSortFunctions();

			// actual initialization of the DataTables plug-in
			self._dataTable = self._initDataTable(
				$(self._options.el), rows, self._options.columns, nameMap,
				indexMap, hiddenCols, excludedCols, nonSearchableCols);

			//self._dataTable.css("width", "100%");

			self._addEventListeners(indexMap);

			// add a delay to the filter
			if (self._options.filteringDelay > 0)
			{
				self._dataTable.fnSetFilteringDelay(self._options.filteringDelay);
			}
		};

		/**
		 * Generates the data table options for the given parameters.
		 *
		 * @param tableSelector jQuery selector for the target table
		 * @param rows          data rows
		 * @param columnOpts    column options
		 * @param nameMap       map of <column display name, column name>
		 * @param indexMap      map of <column name, column index>
		 * @param hiddenCols    indices of the hidden columns
		 * @param excludedCols  indices of the excluded columns
		 * @param nonSearchableCols    indices of the columns excluded from search
		 * @return {object}     DataTable options
		 */
		self._initDataTableOpts = function(tableSelector, rows, columnOpts, nameMap,
			indexMap, hiddenCols, excludedCols, nonSearchableCols)
		{
			// method body should be overridden by subclasses
			return null;
		};

		/**
		 * Initializes the data tables plug-in for the given table selector.
		 *
		 * @param tableSelector jQuery selector for the target table
		 * @param rows          data rows
		 * @param columnOpts    column options
		 * @param nameMap       map of <column display name, column name>
		 * @param indexMap      map of <column name, column index>
		 * @param hiddenCols    indices of the hidden columns
		 * @param excludedCols  indices of the excluded columns
		 * @param nonSearchableCols    indices of the columns excluded from search
		 * @return {object}     DataTable instance
		 */
		self._initDataTable = function(tableSelector, rows, columnOpts, nameMap,
			indexMap, hiddenCols, excludedCols, nonSearchableCols)
		{
			var tableOpts = self._initDataTableOpts(tableSelector, rows, columnOpts, nameMap,
				indexMap, hiddenCols, excludedCols, nonSearchableCols);

			// also add mData definitions (rendering, sort, etc.)
			var mData = DataTableUtil.getColumnData(indexMap,
				self._options.columnRender,
				self._options.columnSort,
				self._options.columnFilter,
				self._options.columnData);

			tableOpts.aoColumnDefs = tableOpts.aoColumnDefs.concat(mData);

			// merge with the one in the main options object
			//tableOpts = jQuery.extend(true, {}, _defaultOpts.dataTableOpts, tableOpts);
			tableOpts = jQuery.extend(true, {}, self._options.dataTableOpts, tableOpts);

			// format the table with the dataTable plugin and return the table instance
			return tableSelector.dataTable(tableOpts);
		};

		/**
		 * Adds custom DataTables sort function for specific columns.
		 */
		self._addSortFunctions = function()
		{
			_.each(_.pairs(self._options.customSort), function(pair) {
				var fnName = pair[0];
				var sortFn = pair[1];

				jQuery.fn.dataTableExt.oSort[fnName] = sortFn;
			});
		};

		/**
		 * Adds event listeners provided within the options object.
		 *
		 * @param indexMap  map of <column name, column index>
		 */
		self._addEventListeners = function(indexMap)
		{
			// add listeners only if the data table is initialized
			if (self.getDataTable() != null)
			{
				_.each(self._options.eventListeners, function(listenerFn) {
					listenerFn(self.getDataTable(), self._dispatcher, indexMap);
				});
			}
		};

		/**
		 * Adds column (data) tooltips provided within the options object.
		 *
		 * @param helper    may contain additional info, functions, etc.
		 */
		self._addColumnTooltips = function(helper)
		{
			helper = helper || {};

			var tableSelector = $(self._options.el);

			_.each(_.keys(self._options.columnTooltips), function(key) {
				// do not add tooltip for excluded columns
				if (self._visiblityMap[key] != "excluded")
				{
					var tooltipFn = self._options.columnTooltips[key];

					if (_.isFunction(tooltipFn))
					{
						tooltipFn(tableSelector, helper);
					}
				}
			});
		};

		self.getColumnOptions = function()
		{
			return self._options.columns;
		};

		self.getDataTable = function()
		{
			return self._dataTable;
		};

		self.setDataTable = function(dataTable)
		{
			self._dataTable = dataTable;
		};

		self.getIndexMap = function()
		{
			return _indexMap;
		};
	}

	module.exports = AdvancedDataTable;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Modules such as datatables-tabletools and datatables-colvis require 'datatables' as a module,
	 * but we actually have "datatables.net", so this module is designed as an alias to 'datatables'
	 *
	 * This module also makes sure that datatables pluging is properly registered
	 * as a jQuery plugin, by passing the window and $
	 *
	 * @author Selcuk Onur Sumer
	*/

	var dt = __webpack_require__(157);
	var $ = __webpack_require__(7);

	// this is for external lib compatibility
	// initialize datatables with $ only once
	if (dt && $.fn.DataTable == null) {
		dt(window, $);
	}

	module.exports = dt;

/***/ },
/* 157 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_157__;

/***/ },
/* 158 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_158__;

/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_159__;

/***/ },
/* 160 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_160__;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($, jQuery) {jQuery.fn.dataTableExt.oApi.fnSetFilteringDelay = function ( oSettings, iDelay ) {
	    /*
	     * Type:        Plugin for DataTables (www.datatables.net) JQuery plugin.
	     * Name:        dataTableExt.oApi.fnSetFilteringDelay
	     * Version:     2.2.1
	     * Description: Enables filtration delay for keeping the browser more
	     *              responsive while searching for a longer keyword.
	     * Inputs:      object:oSettings - dataTables settings object
	     *              integer:iDelay - delay in miliseconds
	     * Returns:     JQuery
	     * Usage:       $('#example').dataTable().fnSetFilteringDelay(250);
	     * Requires:      DataTables 1.6.0+
	     *
	     * Author:      Zygimantas Berziunas (www.zygimantas.com) and Allan Jardine (v2)
	     * Created:     7/3/2009
	     * Language:    Javascript
	     * License:     GPL v2 or BSD 3 point style
	     * Contact:     zygimantas.berziunas /AT\ hotmail.com
	     */
	    var
	        _that = this,
	        iDelay = (typeof iDelay == 'undefined') ? 250 : iDelay;

	    this.each( function ( i ) {
	        $.fn.dataTableExt.iApiIndex = i;
	        var
	            $this = this,
	            oTimerId = null,
	            sPreviousSearch = null,
	            anControl = $( 'input', _that.fnSettings().aanFeatures.f );

	            //anControl.unbind( 'keyup' ).bind( 'keyup', function() {
		        anControl.off( 'keyup search input' ).on( 'keyup', function() {
	            var $$this = $this;

	            if (sPreviousSearch === null || sPreviousSearch != anControl.val()) {
	                window.clearTimeout(oTimerId);
	                sPreviousSearch = anControl.val();
	                oTimerId = window.setTimeout(function() {
	                    $.fn.dataTableExt.iApiIndex = i;
	                    _that.fnFilter( anControl.val() );
		                sPreviousSearch = null; // TODO this is a manual fix
	                }, iDelay);
	            }
	        });

	        return this;
	    } );
	    return this;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(7)))

/***/ },
/* 162 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_162__;

/***/ },
/* 163 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_163__;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2016 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var BackboneTemplateCache = __webpack_require__(23);

	var Backbone = __webpack_require__(12);

	/**
	 * Mutation Details Customization Panel View.
	 *
	 * This view is designed to provide a customization panel for Mutation Details page.
	 *
	 * options: {el: [target container],
	 *           model: {},
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationSummaryView = Backbone.View.extend({
		initialize : function (options) {
			this.options = options || {};

			// custom event dispatcher
			//this.dispatcher = {};
			//_.extend(this.dispatcher, Backbone.Events);
		},
		render: function()
		{
			var self = this;
	        var mutationSummary;

			self.model.clinicalProxy.getPatientData(self.model.sampleArray, function(data) {
				if (!data) {
					mutationSummary = self._mutationSummary();
				}
				else {
					mutationSummary = self._germlineMutationSummary(data);
				}

				var variables = {
					mutationSummary: mutationSummary,
					geneSymbol: self.model.geneSymbol
				};

				// compile the template using underscore
				var templateFn = BackboneTemplateCache.getTemplateFn('mutation_summary_view_template');
				var template = templateFn(variables);

				// load the compiled HTML into the Backbone "el"
				self.$el.html(template);

				self.format();
			});
		},
		format: function()
		{
			var self = this;
		},
		/**
		 * Generates a one-line summary of the mutation data.
		 *
		 * @return {string} summary string
		 */
		_mutationSummary: function()
		{
			var self = this;
			var mutationUtil = self.model.mutationProxy.getMutationUtil();
			var gene = self.model.geneSymbol;
			var cases = self.model.sampleArray;

			var summary = "";

			if (cases.length > 0)
			{
				// calculate somatic & germline mutation rates
				var mutationCount = mutationUtil.countMutations(gene, cases);
				// generate summary string for the calculated mutation count values
				summary = mutationUtil.generateSummary(mutationCount);
			}

			return summary;
		},
	    _germlineMutationSummary: function(clinicalGermlineData) {
	        var self = this;
	        var mutationUtil = self.model.mutationProxy.getMutationUtil();
	        var gene = self.model.geneSymbol;
	        var cases = self.model.sampleArray;
	        var numGermlineCases = 0;            
	        var summary = "";
	                    
	        if(cases.length > 0) {
	            var mutationCount = mutationUtil.countMutations(gene, cases);
	                        
	            for (var i = 0; i < clinicalGermlineData.length; i++) {
	                var clinicalData = clinicalGermlineData[i];
	                if (clinicalData.attr_val === "YES") {
	                    numGermlineCases++;
	                }
	            }
	                        
	            mutationCount.numGermlineCases = numGermlineCases;
	            summary = mutationUtil.generateSummary(mutationCount);
	        }
	                    
	        return summary;
	    }
	});

	module.exports = MutationSummaryView;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */


	var BackboneTemplateCache = __webpack_require__(23);

	var Backbone = __webpack_require__(12);
	var _ = __webpack_require__(5);
	var $ = __webpack_require__(7);

	__webpack_require__(8);
	__webpack_require__(9);

	/**
	 * 3D visualizer controls view.
	 *
	 * This view is designed to provide controls to initialize, show or hide
	 * the actual 3D visualizer panel.
	 *
	 * IMPORTANT NOTE: This view does not initialize the actual 3D visualizer.
	 * 3D visualizer is a global instance bound to MutationDetailsView
	 * and it is a part of Mutation3dVisView.
	 *
	 * options: {el: [target container],
	 *           model: {geneSymbol: hugo gene symbol,
	 *                   uniprotId: uniprot identifier for this gene,
	 *                   pdbProxy: pdb data proxy}
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var Mutation3dView = Backbone.View.extend({
		initialize : function (options) {
			this.options = options || {};

			// custom event dispatcher
			this.dispatcher = {};
			_.extend(this.dispatcher, Backbone.Events);
		},
		render: function()
		{
			var self = this;
			var gene = self.model.geneSymbol;

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_3d_view_template");
			var template = templateFn({});

			// load the compiled HTML into the Backbone "el"
			this.$el.html(template);

			// format after rendering
			this.format();
		},
		format: function()
		{
			var self = this;
			var button3d = self.$el.find(".mutation-3d-vis");

			// initially disable the 3D button
			button3d.attr("disabled", "disabled");

			var formatButton = function(hasData) {
				if (hasData)
				{
					// enable button if there is PDB data
					button3d.removeAttr("disabled");
				}
				else
				{
					var gene = self.model.geneSymbol;
					var content = "No structure data for " + gene;

					// set tooltip options
					var qtipOpts = {content: {text: content},
						hide: {fixed: true, delay: 100, event: 'mouseout'},
						show: {event: 'mouseover'},
						style: {classes: 'qtip-light qtip-rounded qtip-shadow cc-ui-tooltip'},
						position: {my:'bottom center', at:'top center', viewport: $(window)}};

					// disabled buttons do not trigger mouse events,
					// so add tooltip to the wrapper div instead
					self.$el.qtip(qtipOpts);
				}
			};

			var pdbProxy = self.model.pdbProxy;
			var uniprotId = self.model.uniprotId;

			pdbProxy.hasPdbData(uniprotId, formatButton);
		},
		/**
		 * Adds a callback function for the 3D visualizer init button.
		 *
		 * @param callback      function to be invoked on click
		 */
		addInitCallback: function(callback) {
			var self = this;
			var button3d = self.$el.find(".mutation-3d-vis");

			// add listener to 3D init button
			button3d.click(callback);
		},
		/**
		 * Resets the 3D view to its initial state.
		 */
		resetView: function()
		{
			var self = this;
			var button3d = self.$el.find(".mutation-3d-vis");

			// TODO this might not be safe, since we are relying on the callback function

			// just simulate click function on the 3d button to reset the view
			button3d.click();
		},
		isVisible: function()
		{
			var self = this;
			return self.$el.is(":visible");
		}
	});

	module.exports = Mutation3dView;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDataConverter = __webpack_require__(125);
	var MutationDiagram = __webpack_require__(167);
	var MutationCustomizePanelView = __webpack_require__(171);
	var MutationHelpPanelView = __webpack_require__(173);
	var BackboneTemplateCache = __webpack_require__(23);

	var cbio = {
		util: __webpack_require__(6),
		download: __webpack_require__(141)
	};

	var Backbone = __webpack_require__(12);
	var _ = __webpack_require__(5);
	var $ = __webpack_require__(7);

	/**
	 * Mutation Diagram view.
	 *
	 * options: {el: [target container],
	 *           model: {mutations: [mutation data as an array of JSON objects],
	 *                   sequence: [sequence data as an array of JSON objects],
	 *                   geneSymbol: [hugo gene symbol as a string],
	 *                   dataProxies: all available data proxies,
	 *                   diagramOpts: [mutation diagram options -- optional]}
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationDiagramView = Backbone.View.extend({
		initialize : function (options) {
			this.options = options || {};

			// custom event dispatcher
			this.dispatcher = {};
			_.extend(this.dispatcher, Backbone.Events);
		},
		render: function()
		{
			var self = this;

			// pass variables in using Underscore.js template
			var variables = {geneSymbol: self.model.geneSymbol,
				uniprotId: self.model.sequence.metadata.identifier};

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_diagram_view_template");
			var template = templateFn(variables);

			// load the compiled HTML into the Backbone "el"
			self.$el.html(template);

			// init the actual diagram component
			self.mutationDiagram = self._initMutationDiagram(
				self.model.geneSymbol,
				self.model.mutations,
				self.model.sequence,
				self.model.dataProxies,
				self.model.diagramOpts);

			self.format();
		},
		/**
		 * Formats the contents of the view after the initial rendering.
		 */
		format: function()
		{
			var self = this;

			// hide the toolbar & customization panel by default
			self.$el.find(".mutation-diagram-toolbar").hide();
			self.$el.find(".mutation-diagram-customize").hide();
			self.$el.find(".mutation-diagram-help").hide();
			self.$el.find(".mutation-diagram-toolbar-buttons").css("visibility", "hidden");

			// init toolbar if the diagram is initialized successfully
			if (self.mutationDiagram)
			{
				// init diagram toolbar
				self._initToolbar(self.mutationDiagram,
				                  self.model.geneSymbol);
			}
		},
		/**
		 * Initializes the mutation diagram view.
		 *
		 * @param gene          hugo gene symbol
		 * @param mutationData  mutation data (array of JSON objects)
		 * @param sequenceData  sequence data (as a JSON object)
		 * @param dataProxies   all available data proxies
		 * @param options       [optional] diagram options
		 * @return {Object}     initialized mutation diagram view
		 */
		_initMutationDiagram: function (gene, mutationData, sequenceData, dataProxies, options)
		{
			var self = this;

			// use defaults if no options provided
			if (!options)
			{
				options = {};
			}

			// do not draw the diagram if there is a critical error with
			// the sequence data
			if (sequenceData["length"] == "" ||
			    parseInt(sequenceData["length"]) <= 0)
			{
				// return null to indicate an error
				return null;
			}

			// overwrite container in any case (for consistency with the default view)
			options.el = self.$el.find(".mutation-diagram-container");

			// create a backbone collection for the given data
			var mutationColl = MutationDataConverter.convertToCollection(
				mutationData.getData());

			// create a data object
			var diagramData = {
				mutations: mutationColl,
				sequence: sequenceData
			};

			var mutationDiagram = new MutationDiagram(gene, options, diagramData, dataProxies);

			// if no sequence data is provided, try to get it from the servlet
			if (sequenceData == null)
			{
				// TODO use PfamDataProxy instance!!
				$.getJSON("getPfamSequence.json",
				{geneSymbol: self.geneSymbol},
					function(data) {
						if (data)
						{
							mutationDiagram.updateSequenceData(data[0]);
						}

						mutationDiagram.initDiagram();
				});
			}
			// if data is already there just init the diagram
			else
			{
				mutationDiagram.initDiagram();
			}

			return mutationDiagram;
		},
		/**
		 * Initializes the toolbar over the mutation diagram.
		 *
		 * @param diagram       the mutation diagram instance
		 * @param geneSymbol    gene symbol as a string
		 */
		_initToolbar: function(diagram, geneSymbol) {
			var self = this;

			var toolbar = self.$el.find(".mutation-diagram-toolbar");
			var pdfButton = self.$el.find(".diagram-to-pdf");
			var svgButton = self.$el.find(".diagram-to-svg");
			var customizeButton = self.$el.find(".diagram-customize");
			var helpButton = self.$el.find(".diagram-help");

			// helper function to trigger submit event for the svg and pdf button clicks
			var submitForm = function(alterFn, diagram, type)
			{
				var filename = "mutation_diagram_" + geneSymbol + "." + type;

				// alter diagram to have the desired output
				alterFn(diagram, false);

				if (type == "svg")
				{
					cbio.download.initDownload(diagram.svg[0][0], {filename: filename});
				}
				else if (type == "pdf")
				{
					var params = {filename: filename,
						contentType: "application/pdf",
						servletName: "svgtopdf.do"
					};

					cbio.download.initDownload(diagram.svg[0][0], params);
				}

				// restore previous settings after generating xml string
				alterFn(diagram, true);

	//			// set actual value of the form element (svgelement)
	//			var form = self.$el.find("." + formClass);
	//			form.find('input[name="svgelement"]').val(svgString);
	//
	//			// submit form
	//			form.submit();
			};

			// helper function to adjust SVG for file output
			var alterDiagramForSvg = function(diagram, rollback)
			{
				var topLabel = geneSymbol;

				if (rollback)
				{
					topLabel = "";
				}

				// adding a top left label (to include a label in the file)
				diagram.updateTopLabel(topLabel);
			};

			// helper function to adjust SVG for PDF output
			var alterDiagramForPdf = function(diagram, rollback)
			{
				// we also need the same changes (top label) in pdf
				alterDiagramForSvg(diagram, rollback);
			};

			//add listener to the svg button
			svgButton.click(function (event) {
				// submit svg form
				//submitForm(alterDiagramForSvg, diagram, "svg-to-file-form");
				submitForm(alterDiagramForSvg, diagram, "svg");
			});

			// add listener to the pdf button
			pdfButton.click(function (event) {
				// submit pdf form
				//submitForm(alterDiagramForPdf, diagram, "svg-to-pdf-form");
				submitForm(alterDiagramForPdf, diagram, "pdf");
			});

			// add listeners to customize button
			customizeButton.click(function(event) {
				var panel = self.customizePanelView;

				// init view if not init yet
				if (!panel)
				{
					panel = new MutationCustomizePanelView({
						el: self.$el.find(".mutation-diagram-customize"),
						diagram: diagram});
					panel.render();

					self.customizePanelView = panel;
				}

				// toggle view
				panel.toggleView();
			});

			// add listeners to customize button
			helpButton.click(function(event) {
				var panel = self.helpPanelView;

				// init view if not init yet
				if (!panel)
				{
					panel = new MutationHelpPanelView({
						el: self.$el.find(".mutation-diagram-help")});
					panel.render();

					self.helpPanelView = panel;
				}

				// toggle view
				panel.toggleView();
			});

			// hide buttons initially, show on mouse over
			self._autoHideToolbarButtons();

			toolbar.show();
		},
		/**
		 * Shows the toolbar buttons only on mouse over.
		 * And hides them on mouse out.
		 */
		_autoHideToolbarButtons: function()
		{
			var self = this;
			var buttons = self.$el.find(".mutation-diagram-toolbar-buttons");

			cbio.util.autoHideOnMouseLeave(self.$el, buttons);
		}
	});

	module.exports = MutationDiagramView;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var PileupUtil = __webpack_require__(128);
	var BackboneTemplateCache = __webpack_require__(23);
	var LollipopTipView = __webpack_require__(168);
	var RegionTipView = __webpack_require__(170);
	var MutationDetailsEvents = __webpack_require__(22);

	var cbio = {
		util: __webpack_require__(6)
	};

	var d3= __webpack_require__(19);
	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);
	var Backbone = __webpack_require__(12);

	/**
	 * Constructor for the MutationDiagram class.
	 *
	 * @param geneSymbol    hugo gene symbol
	 * @param options       visual options object
	 * @param data          object: {mutations: a MutationCollection instance,
	 *                               sequence: sequence data as a JSON object}
	 * @param dataProxies   all available data proxies
	 * @constructor
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationDiagram(geneSymbol, options, data, dataProxies)
	{
		var self = this;

		// event listeners
		self.listeners = {};

		// custom event dispatcher
		self.dispatcher = {};
		_.extend(self.dispatcher, Backbone.Events);

		// merge options with default options to use defaults for missing values
		self.options = jQuery.extend(true, {}, self.defaultOpts, options);

		self.dataProxies = dataProxies;
		self.geneSymbol = geneSymbol; // hugo gene symbol
		self.data = data; // processed initial (unfiltered) data
		self.pileups = (data == null) ? null : // current pileups (updated after each filtering)
			PileupUtil.convertToPileups(data.mutations, options.pileupConverter);
		self.initialPileups = self.pileups;
		self.highlighted = {}; // map of highlighted data points (initially empty)
		self.multiSelect = false; // indicates if multiple lollipop selection is active

		// init other class members as null, will be assigned later
		self.svg = null;    // svg element (d3)
		self.bounds = null; // bounds of the plot area
		self.gData = null; // svg group for lollipop data points
		self.gLine = null;   // svg group for lollipop lines
		self.gLabel = null;  // svg group for lollipop labels
		self.xScale = null;  // scale function for x-axis
		self.yScale = null;  // scale function for y-axis
		self.topLabel = null;   // label on top-left corner of the diagram
		self.xAxisLabel = null; // label for x-axis
		self.yAxisLabel = null; // label for y-axis
		self.xMax = null; // max value on the x-axis
		self.yMax = null; // max value on the y-axis
		self.maxCount = null; // mutation count of the highest data point

		// color mapping for mutations: <mutation id, (pileup) color> pairs
		self.mutationColorMap = {};

		// mutation id to pileup mapping: <mutation sid, pileup group> pairs
		self.mutationPileupMap = {};
	}

	// TODO use percent values instead of pixel values for some components?
	// TODO allow "auto" or a function as an option where applicable

	/**
	 * Default visual options.
	 */
	MutationDiagram.prototype.defaultOpts = {
		el: "#mutation_diagram_d3", // id of the container
		elWidth: 740,               // width of the container
		elHeight: 180,              // height of the container
		marginLeft: 45,             // left margin for the plot area
		marginRight: 30,            // right margin for the plot area
		marginTop: 30,              // top margin for the plot area
		marginBottom: 60,           // bottom margin for the plot area
		labelTop: "",                 // informative label on top of the diagram (false means "do not draw")
		labelTopFont: "sans-serif",   // font type of the top label
		labelTopFontColor: "#2E3436", // font color of the top label
		labelTopFontSize: "12px",     // font size of the top label
		labelTopFontWeight: "bold",   // font weight of the top label
		labelTopMargin: 2,            // left margin for the top label
		labelX: false,              // informative label of the x-axis (false means "do not draw")
		labelXFont: "sans-serif",   // font type of the x-axis label
		labelXFontColor: "#2E3436", // font color of the x-axis label
		labelXFontSize: "12px",     // font size of x-axis label
		labelXFontWeight: "normal", // font weight of x-axis label
		labelY: "# Mutations",      // informative label of the y-axis (false means "do not draw")
		labelYFont: "sans-serif",   // font type of the y-axis label
		labelYFontColor: "#2E3436", // font color of the y-axis label
		labelYFontSize: "12px",     // font size of y-axis label
		labelYFontWeight: "normal", // font weight of y-axis label
		minLengthX: 0,              // min value of the largest x value to show
		minLengthY: 5,              // min value of the largest y value to show
		maxLengthX: Infinity,       // max value of the largest x value to show (infinity: no upper value)
		maxLengthY: Infinity,       // max value of the largest y value to show (infinity: no upper value)
		seqFillColor: "#BABDB6",    // color of the sequence rectangle
		seqHeight: 14,              // height of the sequence rectangle
		seqPadding: 5,              // padding between sequence and plot area
		regionHeight: 24,           // height of a region (drawn on the sequence)
		regionFont: "sans-serif",   // font of the region text
		regionFontColor: "#FFFFFF", // font color of the region text
		regionFontSize: "12px",     // font size of the region text
		regionTextAnchor: "middle", // text anchor (alignment) for the region label
		showRegionText: true,       // show/hide region text
		showStats: false,           // show/hide mutation stats in the lollipop tooltip
		multiSelectKeycode: 16,     // shift (default multiple selection key)
		lollipopLabelCount: 1,          // max number of lollipop labels to display
		lollipopLabelThreshold: 2,      // y-value threshold: points below this value won't be labeled
		lollipopFont: "sans-serif",     // font of the lollipop label
		lollipopFontColor: "#2E3436",   // font color of the lollipop label
		lollipopFontSize: "10px",       // font size of the lollipop label
		lollipopTextAnchor: "auto",     // text anchor (alignment) for the lollipop label
		lollipopTextPadding: 8,         // padding between the label and the data point
		lollipopTextAngle: 0,           // rotation angle for the lollipop label
	//	lollipopFillColor: "#B40000",
		lollipopFillColor: {            // color of the lollipop data point
			missense: "#008000",
			truncating: "#000000",
			inframe: "#8B4513",
			fusion: "#8B00C9",
			other: "#8B00C9",       // all other mutation types
			default: "#BB0000"      // default is used when there is a tie
		},
		lollipopBorderColor: "#BABDB6", // border color of the lollipop data points
		lollipopBorderWidth: 0.5,       // border width of the lollipop data points
		lollipopSize: 30,               // size of the lollipop data points
		lollipopHighlightSize: 100,     // size of the highlighted lollipop data points
		lollipopStrokeWidth: 1,         // width of the lollipop lines
		lollipopStrokeColor: "#BABDB6", // color of the lollipop line
		lollipopShapeRegular: "circle", // shape of the regular lollipop data points
		lollipopShapeSpecial: "circle", // shape of the special lollipop data points
		xAxisPadding: 10,           // padding between x-axis and the sequence
		xAxisTickIntervals: [       // valid major tick intervals for x-axis
			100, 200, 400, 500, 1000, 2000, 5000, 10000, 20000, 50000
		],
		xAxisTicks: 8,              // maximum number of major ticks for x-axis
									// (a major tick may not be labeled if it is too close to the max)
		xAxisTickSize: 6,           // size of the major ticks of x-axis
		xAxisStroke: "#AAAAAA",     // color of the x-axis lines
		xAxisFont: "sans-serif",    // font type of the x-axis labels
		xAxisFontSize: "10px",      // font size of the x-axis labels
		xAxisFontColor: "#2E3436",  // font color of the x-axis labels
		yAxisPadding: 5,            // padding between y-axis and the plot area
		yAxisLabelPadding: 15,      // padding between y-axis and its label
		yAxisTicks: 10,             // maximum number of major ticks for y-axis
		yAxisTickIntervals: [       // valid major tick intervals for y-axis
			1, 2, 5, 10, 20, 50, 100, 200, 500
		],
		yAxisTickSize: 6,           // size of the major ticks of y-axis
		yAxisStroke: "#AAAAAA",     // color of the y-axis lines
		yAxisFont: "sans-serif",    // font type of the y-axis labels
		yAxisFontSize: "10px",      // font size of the y-axis labels
		yAxisFontColor: "#2E3436",  // font color of the y-axis labels
		yAxisAutoAdjust: true,      // indicates whether to adjust max y-axis value after plot update
		animationDuration: 1000,    // transition duration (in ms) used for highlight animations
		fadeDuration: 1500,         // transition duration (in ms) used for fade animations
		pileupConverter: false,
		/**
		 * Default lollipop tooltip function.
		 *
		 * @param element   target svg element (lollipop data point)
		 * @param pileup    a pileup model instance
	     * @param showStats whether to show cancer type distribution in the tooltip
		 */
		lollipopTipFn: function (element, pileup, showStats) {
			var tooltipView = new LollipopTipView({model: pileup});
	        tooltipView.setShowStats(showStats);
			var content = tooltipView.compileTemplate();

			var options = {content: {text: content},
				hide: {fixed: true, delay: 100, event: 'mouseout'},
				show: {event: 'mouseover'},
				style: {classes: 'qtip-light qtip-rounded qtip-shadow cc-ui-tooltip'},
				position: {my:'bottom left', at:'top center',viewport: $(window)}};

			//$(element).qtip(options);
			cbio.util.addTargetedQTip(element, options);
		},
		/**
		 * Default region tooltip function.
		 *
		 * @param element   target svg element (region rectangle)
		 * @param region    a JSON object representing the region
		 * @param maProxy   mutation aligner proxy for additional region data
		 */
		regionTipFn: function (element, region, maProxy) {
			var model = {identifier: region.metadata.identifier,
				type: region.type,
				description: region.metadata.description,
				start: region.metadata.start,
				end: region.metadata.end,
				pfamAccession: region.metadata.accession,
				mutationAlignerInfo: ""};

			maProxy.getMutationAlignerData(
				{pfamAccession: region.metadata.accession},
				function(data) {
					// if the link is valid update model.mutationAligner
					if (data != null &&
					    data.linkToMutationAligner != null &&
					    data.linkToMutationAligner.length > 0)
					{
						var templateFn = BackboneTemplateCache.getTemplateFn("mutation_aligner_info_template");
						model.mutationAlignerInfo = templateFn({
							linkToMutationAligner: data.linkToMutationAligner
						});
					}

					var tooltipView = new RegionTipView({model: model});
					var content = tooltipView.compileTemplate();

					var options = {content: {text: content},
						hide: {fixed: true, delay: 100, event: 'mouseout'},
						show: {event: 'mouseover'},
						style: {classes: 'qtip-light qtip-rounded qtip-shadow qtip-lightyellow'},
						position: {my:'bottom left', at:'top center',viewport: $(window)}};

					//$(element).qtip(options);
					cbio.util.addTargetedQTip(element, options);
				}
			);
		}
	};

	/**
	 * Updates the diagram options object with the given one.
	 * This function does not update (re-render) the actual view
	 * with the new options. only updates some class fields.
	 *
	 * @param options   diagram options object
	 */
	MutationDiagram.prototype.updateOptions = function(options)
	{
		var self = this;

		// merge options with current options to use existing ones for missing values
		self.options = jQuery.extend(true, {}, self.options, options);

		// recalculate global values
		self.updateGlobals();
	};

	/**
	 * Rescales the y-axis by using the updated options and
	 * latest (filtered) data.
	 *
	 * @param noUpdatePlot if set true, plot contents are NOT updated
	 */
	MutationDiagram.prototype.rescaleYAxis = function(noUpdatePlot)
	{
		var self = this;

		// recalculate global values
		self.updateGlobals();

		// remove & draw y-axis
		self.svg.select(".mut-dia-y-axis").remove();
		self.drawYAxis(self.svg, self.yScale, self.yMax, self.options, self.bounds);

		if (!noUpdatePlot)
		{
			// re-draw the plot with new scale
			self.updatePlot();
		}
	};


	/**
	 * Update global class fields such as bounds, scales, max, etc.
	 * wrt the given options.
	 *
	 * @param options   diagram options
	 */
	MutationDiagram.prototype.updateGlobals = function(options)
	{
		var self = this;
		options = options || self.options;

		var pileups = self.initialPileups; // initial pileup data

		// in case auto adjust is enabled,
		// use current pileup data instead of the initial pileup data
		if (options.yAxisAutoAdjust)
		{
			pileups = self.pileups;
		}

		var maxCount = self.maxCount = self.calcMaxCount(pileups);

		var xMax = self.xMax = self.calcXMax(options, self.data);
		var yMax = self.yMax = self.calcYMax(options, maxCount);

		self.bounds = this.calcBounds(options);
		self.xScale = this.xScaleFn(self.bounds, xMax);
		self.yScale = this.yScaleFn(self.bounds, yMax);
	};

	/**
	 * Updates the sequence data associated with this diagram.
	 *
	 * @param sequenceData  sequence data as a JSON object
	 */
	MutationDiagram.prototype.updateSequenceData = function(sequenceData)
	{
		var self = this;

		self.data.sequence = sequenceData;
	};

	/**
	 * Initializes the diagram with the given sequence data.
	 * If no sequence data is provided, then tries to retrieve
	 * the data from the default servlet.
	 */
	MutationDiagram.prototype.initDiagram = function()
	{
		var self = this;

		// selecting using jQuery node to support both string and jQuery selector values
		var node = $(self.options.el)[0];
		var container = d3.select(node);

		// calculate bounds & save a reference for future access
		var bounds = self.bounds = self.calcBounds(self.options);

		self.mutationPileupMap = PileupUtil.mapToMutations(self.initialPileups);

		// init svg container
		var svg = self.createSvg(container,
		                         self.options.elWidth,
		                         self.options.elHeight);

		// save a reference for future access
		self.svg = svg;

		// draw the whole diagram
		self.drawDiagram(svg,
		                 bounds,
		                 self.options,
		                 self.data);

		// add default listeners
		self.addDefaultListeners();
	};

	/**
	 * Calculates the bounds of the actual plot area excluding
	 * axes, sequence, labels, etc. So, this is the bounds for
	 * the data points (lollipops) only.
	 *
	 * @param options   options object
	 * @return {object} bounds as an object
	 */
	MutationDiagram.prototype.calcBounds = function(options)
	{
		var bounds = {};

		bounds.width = options.elWidth -
		               (options.marginLeft + options.marginRight);
		bounds.height = options.elHeight -
		                (options.marginBottom + options.marginTop);
		bounds.x = options.marginLeft;
		bounds.y = options.elHeight - options.marginBottom;

		return bounds;
	};

	/**
	 * Draws the mutation diagram.
	 *
	 * @param svg       svg container for the diagram
	 * @param bounds    bounds of the plot area {width, height, x, y}
	 *                  x, y is the actual position of the origin
	 * @param options   options object
	 * @param data      data to visualize
	 */
	MutationDiagram.prototype.drawDiagram = function (svg, bounds, options, data)
	{
		var self = this;
		var sequenceLength = parseInt(data.sequence["length"]);
		var pileups = self.initialPileups || PileupUtil.convertToPileups(data.mutations, options.pileupConverter);

		var maxCount = self.maxCount = self.calcMaxCount(pileups);
		var xMax = self.xMax = self.calcXMax(options, data);
		var yMax = self.yMax = self.calcYMax(options, maxCount);

		var regions = data.sequence.regions;
		var seqTooltip = self.generateSequenceTooltip(data);

		var xScale = self.xScale = self.xScaleFn(bounds, xMax);
		var yScale = self.yScale = self.yScaleFn(bounds, yMax);

		// draw x-axis
		self.drawXAxis(svg, xScale, xMax, options, bounds);

		if (options.labelX != false)
		{
			//TODO self.xAxisLabel = self.drawXAxisLabel(svg, options, bounds);
		}

		// draw y-axis
		self.drawYAxis(svg, yScale, yMax, options, bounds);

		if (options.labelY != false)
		{
			self.yAxisLabel = self.drawYAxisLabel(svg, options, bounds);
		}

		if (options.topLabel != false)
		{
			self.topLabel = self.drawTopLabel(svg, options, bounds);
		}

		// draw a fully transparent rectangle for proper background click handling
		var rect = svg.append('rect')
			.attr('fill', '#FFFFFF')
			.attr('opacity', 0)
			.attr('x', bounds.x)
			.attr('y', bounds.y - bounds.height)
			.attr('width', bounds.width)
			.attr('height', bounds.height)
			.attr('class', 'mut-dia-background');

		// draw the plot area content
		self.drawPlot(svg,
			pileups,
			options,
			bounds,
			xScale,
			yScale);

		// draw sequence
		var sequence = self.drawSequence(svg, options, bounds);
		// add a regular tooltip (not qtip)
		sequence.attr("title", seqTooltip);

		// draw regions
		for (var i = 0, size = regions.length; i < size; i++)
		{
			self.drawRegion(svg, regions[i], options, bounds, xScale);
		}
	};

	/**
	 * Generates an x-scale function for the current bounds
	 * and the max value of the x-axis.
	 *
	 * @param bounds    bounds of the plot area {width, height, x, y}
	 *                  x, y is the actual position of the origin
	 * @param max       maximum value for the x-axis
	 * @return {function} scale function for the x-axis
	 */
	MutationDiagram.prototype.xScaleFn = function(bounds, max)
	{
		return d3.scale.linear()
			.domain([0, max])
			.range([bounds.x, bounds.x + bounds.width]);
	};

	/**
	 * Generates a y-scale function for the current bounds
	 * and the max value of the y-axis.
	 *
	 * @param bounds    bounds of the plot area {width, height, x, y}
	 *                  x, y is the actual position of the origin
	 * @param max       maximum value for the y-axis
	 * @return {function} scale function for the y-axis
	 */
	MutationDiagram.prototype.yScaleFn = function(bounds, max)
	{
		return d3.scale.linear()
			.domain([0, max])
			.range([bounds.y, bounds.y - bounds.height]);
	};

	/**
	 * Finds out the maximum value for the x-axis.
	 *
	 * @param options   options object
	 * @param data      data to visualize
	 * @return {Number} maximum value for the x-axis
	 */
	MutationDiagram.prototype.calcXMax = function(options, data)
	{
		var sequenceLength = parseInt(data.sequence["length"]);

		return Math.min(options.maxLengthX,
			Math.max(sequenceLength, options.minLengthX));
	};

	/**
	 * Finds out the maximum value for the y-axis.
	 *
	 * @param options   options object
	 * @param maxCount  number of mutations in the highest data point
	 * @return {Number} maximum value for the y-axis
	 */
	MutationDiagram.prototype.calcYMax = function(options, maxCount)
	{
		return Math.min(options.maxLengthY,
			Math.max(maxCount, options.minLengthY));
	};

	/**
	 * Generates the tooltip content for the sequence rectangle.
	 *
	 * @param data      data to visualize
	 * @return {string} tooltip content
	 */
	MutationDiagram.prototype.generateSequenceTooltip = function(data)
	{
		var seqTooltip = "";
		var sequenceLength = parseInt(data.sequence["length"]);

		if (data.sequence.metadata.identifier)
		{
			seqTooltip += data.sequence.metadata.identifier;

			if (data.sequence.metadata.description)
			{
				seqTooltip += ", " + data.sequence.metadata.description;
			}
		}

		seqTooltip += " (" + sequenceLength + "aa)";

		return seqTooltip;
	};

	/**
	 * Draw lollipop lines, data points and labels on the plot area
	 * for the provided mutations (pileups).
	 *
	 * @param svg       svg container for the diagram
	 * @param pileups   array of mutations (pileups)
	 * @param options   options object
	 * @param bounds    bounds of the plot area {width, height, x, y}
	 *                  x, y is the actual position of the origin
	 * @param xScale    scale function for the x-axis
	 * @param yScale    scale function for the y-axis
	 */
	MutationDiagram.prototype.drawPlot = function(svg, pileups, options, bounds, xScale, yScale)
	{
		var self = this;

		// group for lollipop labels (draw labels first)
		var gText = self.gLabel;
		if (gText === null)
		{
			gText = svg.append("g").attr("class", "mut-dia-lollipop-labels");
			self.gLabel = gText;
		}

		// group for lollipop lines (lines should be drawn before the data point)
		var gLine = self.gLine;
		if (gLine === null)
		{
			gLine = svg.append("g").attr("class", "mut-dia-lollipop-lines");
			self.gLine = gLine;
		}

		// group for lollipop data points (points should be drawn later)
		var gData = self.gData;
		if (gData === null)
		{
			gData = svg.append("g").attr("class", "mut-dia-lollipop-points");
			self.gData = gData;
		}

		// draw lollipop lines and data points
		for (var i = 0; i < pileups.length; i++)
		{
			self.drawLollipop(gData,
					gLine,
					pileups[i],
					options,
					bounds,
					xScale,
					yScale);
		}

		// draw lollipop labels
		self.drawLollipopLabels(gText, pileups, options, xScale, yScale);
	};

	/**
	 * Creates the main svg (graphical) component.
	 *
	 * @param container main container (div, etc.)
	 * @param width     width of the svg area
	 * @param height    height of the svg area
	 * @return {object} svg component
	 */
	MutationDiagram.prototype.createSvg = function (container, width, height)
	{
		var svg = container.append("svg");

		svg.attr('width', width);
		svg.attr('height', height);

		return svg;
	};

	// helper function to calculate major tick interval for the axis
	/**
	 * Calculates major tick interval for the given possible interval values,
	 * maximum value on the axis, and the desired maximum tick count.
	 *
	 * @param intervals     possible interval values
	 * @param maxValue      highest value on the axis
	 * @param maxTickCount  desired maximum tick count
	 * @return {number}     interval value
	 */
	MutationDiagram.prototype.calcTickInterval = function(intervals, maxValue, maxTickCount)
	{
		var interval = -1;

		for (var i=0; i < intervals.length; i++)
		{
			interval = intervals[i];
			var count = maxValue / interval;

			//if (Math.round(count) <= maxLabelCount)
			if (count < maxTickCount - 1)
			{
				break;
			}
		}

		return interval;
	};

	/**
	 * Calculates all tick values for the given max and interval values.
	 *
	 * @param maxValue  maximum value for the axis
	 * @param interval  interval (increment) value
	 * @return {Array}  an array of all tick values
	 */
	MutationDiagram.prototype.getTickValues = function(maxValue, interval)
	{
		// determine tick values
		var tickValues = [];
		var value = 0;

		while (value < maxValue)
		{
			tickValues.push(value);
			// use half interval value for generating minor ticks
			// TODO change back to full value when there is a fix for d3 minor ticks
			value += interval / 2;
		}

		// add the max value in any case
		tickValues.push(maxValue);

		return tickValues;
	};

	/**
	 * Draws the x-axis on the bottom side of the plot area.
	 *
	 * @param svg       svg to append the axis
	 * @param xScale    scale function for the y-axis
	 * @param xMax      max y value for the axis
	 * @param options   general options object
	 * @param bounds    bounds of the plot area {width, height, x, y}
	 *                  x, y is the actual position of the origin
	 * @return {object} svg group containing all the axis components
	 */
	MutationDiagram.prototype.drawXAxis = function(svg, xScale, xMax, options, bounds)
	{
		var self = this;

		var interval = self.calcTickInterval(options.xAxisTickIntervals,
			xMax,
			options.xAxisTicks);

		var tickValues = self.getTickValues(xMax, interval);

		// formatter to hide labels
		var formatter = function(value) {
	//		var displayInterval = calcDisplayInterval(interval,
	//			xMax,
	//			options.xAxisMaxTickLabel);

			// always display max value
			if (value == xMax)
			{
				return value + " aa";
			}
			// do not display minor values
			// (this is custom implementation of minor ticks,
			// minor ticks don't work properly for custom values)
			else if (value % interval != 0)
			{
				return "";
			}
			// display major tick value if its not too close to the max value
			else if (xMax - value > interval / 3)
			{
				return value;
			}
			// hide remaining labels
			else
			{
				return "";
			}
		};

		var tickSize = options.xAxisTickSize;

		var xAxis = d3.svg.axis()
			.scale(xScale)
			.orient("bottom")
			.tickValues(tickValues)
			.tickFormat(formatter)
			//.tickSubdivide(true) TODO minor ticks have a problem with custom values
			.tickSize(tickSize, tickSize/2, 0);

		// calculate y-coordinate of the axis
		var position = bounds.y + options.regionHeight + options.xAxisPadding;

		// append axis
		var axis = svg.append("g")
			.attr("class", "mut-dia-x-axis")
			.attr("transform", "translate(0," + position + ")")
			.call(xAxis);

		// format axis
		self.formatAxis(".mut-dia-x-axis",
			options.xAxisStroke,
			options.xAxisFont,
			options.xAxisFontSize,
			options.xAxisFontColor);

		return axis;
	};

	/**
	 * Draws the y-axis on the left side of the plot area.
	 *
	 * @param svg       svg to append the axis
	 * @param yScale    scale function for the y-axis
	 * @param yMax      max y value for the axis
	 * @param options   general options object
	 * @param bounds    bounds of the plot area {width, height, x, y}
	 *                  x, y is the actual position of the origin
	 * @return {object} svg group containing all the axis components
	 */
	MutationDiagram.prototype.drawYAxis = function(svg, yScale, yMax, options, bounds)
	{
		var self = this;

		var interval = self.calcTickInterval(options.yAxisTickIntervals,
			yMax,
			options.yAxisTicks);

		// passing 2 * interval to avoid non-integer values
		// (this is also related to minor tick issue)
		var tickValues = self.getTickValues(yMax, 2 * interval);

		// formatter to hide all except first and last
		// also determines to put a '>' sign before the max value
		var formatter = function(value) {
			var formatted = '';

			if (value === yMax)
			{
				formatted = value;

				if (self.maxCount > yMax)
				{
					formatted = ">" + value;
				}
			}
			else if (value === 0)
			{
				formatted = value;
			}

			return formatted;
		};

		var tickSize = options.yAxisTickSize;

		var yAxis = d3.svg.axis()
			.scale(yScale)
			.orient("left")
			.tickValues(tickValues)
			.tickFormat(formatter)
			//.tickSubdivide(true) TODO minor ticks have a problem with custom values
			.tickSize(tickSize, tickSize/2, 0);

		// calculate y-coordinate of the axis
		var position = bounds.x - options.yAxisPadding;

		// append axis
		var axis = svg.append("g")
			.attr("class", "mut-dia-y-axis")
			.attr("transform", "translate(" + position + ",0)")
			.call(yAxis);

		// format axis
		self.formatAxis(".mut-dia-y-axis",
			options.yAxisStroke,
			options.yAxisFont,
			options.yAxisFontSize,
			options.yAxisFontColor);

		return axis;
	};

	/**
	 * Draws the label of the y-axis.
	 *
	 * @param svg       svg to append the label element
	 * @param options   general options object
	 * @param bounds    bounds of the plot area {width, height, x, y}
	 *                  x, y is the actual position of the origin
	 * @return {object} text label (svg element)
	 */
	MutationDiagram.prototype.drawTopLabel = function(svg, options, bounds)
	{
		// set x, y of the label as the middle of the top left margins
		var x = options.labelTopMargin;
		var y = options.marginTop / 2;

		// append label
		var label = svg.append("text")
			.attr("fill", options.labelTopFontColor)
			.attr("text-anchor", "start")
			.attr("x", x)
			.attr("y", y)
			.attr("class", "mut-dia-top-label")
			.style("font-family", options.labelTopFont)
			.style("font-size", options.labelTopFontSize)
			.style("font-weight", options.labelTopFontWeight)
			.text(options.labelTop);

		return label;
	};

	/**
	 * Draws the label of the y-axis.
	 *
	 * @param svg       svg to append the label element
	 * @param options   general options object
	 * @param bounds    bounds of the plot area {width, height, x, y}
	 *                  x, y is the actual position of the origin
	 * @return {object} text label (svg element)
	 */
	MutationDiagram.prototype.drawYAxisLabel = function(svg, options, bounds)
	{
		// set x, y of the label as the middle of the y-axis

		var x = bounds.x -
			options.yAxisPadding -
			options.yAxisTickSize -
			options.yAxisLabelPadding;

		var y =  bounds.y - (bounds.height / 2);

		// append label
		var label = svg.append("text")
			.attr("fill", options.labelYFontColor)
			.attr("text-anchor", "middle")
			.attr("x", x)
			.attr("y", y)
			.attr("class", "mut-dia-y-axis-label")
			.attr("transform", "rotate(270, " + x + "," + y +")")
			.style("font-family", options.labelYFont)
			.style("font-size", options.labelYFontSize)
			.style("font-weight", options.labelYFontWeight)
			.text(options.labelY);

		return label;
	};

	/**
	 * Formats the style of the plot axis defined by the given selector.
	 *
	 * @param axisSelector  selector for the axis components
	 * @param stroke        line color of the axis
	 * @param font          font type of the axis value labels
	 * @param fontSize      font size of the axis value labels
	 * @param fontColor     font color of the axis value labels
	 */
	MutationDiagram.prototype.formatAxis = function(axisSelector, stroke, font, fontSize, fontColor)
	{
		var selector = d3.selectAll(axisSelector + ' line');

		selector.style("fill", "none")
			.style("stroke", stroke)
			.style("shape-rendering", "crispEdges");

		selector = d3.selectAll(axisSelector + ' path');

		selector.style("fill", "none")
			.style("stroke", stroke)
			.style("shape-rendering", "crispEdges");

		selector = d3.selectAll(axisSelector + ' text');

		selector.attr("fill", fontColor)
			.style("font-family", font)
			.style("font-size", fontSize);
	};

	/**
	 * Draws the lollipop data point and its line (from sequence to the lollipop top)
	 * on the plot area.
	 *
	 * @param points    group (svg element) to append the lollipop data point
	 * @param lines     line group (svg element) to append the lollipop lines
	 * @param pileup    list (array) of mutations (pileup) at a specific location
	 * @param options   general options object
	 * @param bounds    bounds of the plot area {width, height, x, y}
	 *                  x, y is the actual position of the origin
	 * @param xScale    scale function for the x-axis
	 * @param yScale    scale function for the y-axis
	 * @return {object} lollipop data point & line as svg elements
	 */
	MutationDiagram.prototype.drawLollipop = function (points, lines, pileup, options, bounds, xScale, yScale)
	{
		var self = this;

		// default data point type is circle
		var type = options.lollipopShapeRegular;

		var count = pileup.count;
		var start = pileup.location;

		var x = xScale(start);
		var y = yScale(count);

		// check if y-value (count) is out of the range
		if (count > options.maxLengthY)
		{
			// set a different shape for out-of-the-range values
			//type = "triangle-up";
			type = options.lollipopShapeSpecial;

			// set y to the max value
			y = yScale(options.maxLengthY);
		}

		var lollipopFillColor = self.getLollipopFillColor(options, pileup);
		self.updateColorMap(pileup, lollipopFillColor);

		var dataPoint = points.append('path')
			.attr('d', d3.svg.symbol().size(options.lollipopSize).type(type))
			.attr("transform", "translate(" + x + "," + y + ")")
			.attr('fill', lollipopFillColor)
			.attr('stroke', options.lollipopBorderColor)
			.attr('stroke-width', options.lollipopBorderWidth)
			.attr('id', pileup.pileupId)
			.attr('class', 'mut-dia-data-point')
			.attr('opacity', 0);

		// TODO add transition for y value to have a nicer effect
		self.fadeIn(dataPoint);

		// bind pileup data with the lollipop data point
		dataPoint.datum(pileup);

		var addTooltip = options.lollipopTipFn;
		addTooltip(dataPoint, pileup, options.showStats);

		var line = lines.append('line')
			.attr('x1', x)
			.attr('y1', y)
			.attr('x2', x)
			.attr('y2', self.calcSequenceBounds(bounds, options).y)
			.attr('stroke', options.lollipopStrokeColor)
			.attr('stroke-width', options.lollipopStrokeWidth)
			.attr('class', 'mut-dia-data-line')
			.attr('opacity', 0);

		// TODO add transition for y2 value to have a nicer effect
		self.fadeIn(line);

		return {"dataPoint": dataPoint, "line": line};
	};

	/**
	 * Updates the mutation color map by adding a new entry for each mutation
	 * in the given pile up.
	 *
	 * Mapped color of a mutation is NOT determined by its type, instead it is
	 * determined by the color of the pileup. This is why we create a mapping
	 * based on the pileup, otherwise a simple mapping (based on mutation type)
	 * could be used.
	 *
	 * @param pileup    pileup of mutations
	 * @param color     color of the given pileup
	 */
	MutationDiagram.prototype.updateColorMap = function(pileup, color)
	{
		var self = this;

		// iterate all mutations in this pileup
		for (var i=0; i < pileup.mutations.length; i++)
		{
			// assign the same color to all mutations in this pileup
			self.mutationColorMap[pileup.mutations[i].get("mutationId")] = color;
		}
	};

	/**
	 * Returns the shape (type) function to determine the shape of a
	 * data point in the diagram. This implementation is required in order
	 * to access "options" class member within the returned function.
	 *
	 * @return {Function}   shape function (for d3 symbol type)
	 */
	MutationDiagram.prototype.getLollipopShapeFn = function()
	{
		var self = this;

		// actual function to use with d3.symbol.type(...)
		var shapeFunction = function(datum)
		{
			var type = self.options.lollipopShapeRegular;

			// set a different shape for out-of-the-range values
			if (datum.count > self.options.maxLengthY)
			{
				type = self.options.lollipopShapeSpecial;
			}

			return type;
		};

		return shapeFunction;
	};

	/**
	 * Returns the fill color of the lollipop data point for the given pileup
	 * of mutations.
	 *
	 * @param options   general options object
	 * @param pileup    list (array) of mutations (pileup) at a specific location
	 * @return {String} fill color
	 */
	MutationDiagram.prototype.getLollipopFillColor = function(options, pileup)
	{
		var self = this;
		var color = options.lollipopFillColor;
		var value;

		if (_.isFunction(color))
		{
			value = color(pileup);
		}
		// check if the color is fixed
		else if (_.isString(color))
		{
			value = color;
		}
		// assuming color is an object
		else
		{
			var mutationsByMainType = PileupUtil.groupMutationsByMainType(pileup);

			// no main type for the given mutations (this should not happen)
			if (mutationsByMainType.length === 0)
			{
				// use default color
				value = color.default;
			}
			// color with the main type color
			else
			{
				// mutationsByMainType array is sorted by mutation count,
				// under tie condition certain types have priority over others
				value = color[mutationsByMainType[0].type];
			}
		}

		return value;
	};

	/**
	 * Put labels over the lollipop data points. The number of labels to be displayed is defined
	 * by options.lollipopLabelCount.
	 *
	 * @param labels        text group (svg element) for labels
	 * @param pileups       array of mutations (pileups)
	 * @param options       general options object
	 * @param xScale        scale function for the x-axis
	 * @param yScale        scale function for the y-axis
	 */
	MutationDiagram.prototype.drawLollipopLabels = function (labels, pileups, options, xScale, yScale)
	{
		var self = this;

		// helper function to adjust text position to prevent overlapping with the y-axis
		var getTextAnchor = function(text, textAnchor)
		{
			var anchor = textAnchor;

			// adjust if necessary and (if it is set to auto only)
			if (anchor.toLowerCase() == "auto")
			{
				// calculate distance of the label to the y-axis (assuming the anchor will be "middle")
				var distance = text.attr("x") - (text.node().getComputedTextLength() / 2);

				// adjust label to prevent overlapping with the y-axis
				if (distance < options.marginLeft)
				{
					anchor = "start";
				}
				else
				{
					anchor = "middle";
				}
			}

			return anchor;
		};

		var count = options.lollipopLabelCount;
		var maxAllowedTie = 2; // TODO refactor as an option?

		// do not show any label if there are too many ties
		// exception: if there is only one mutation then display the label in any case
		if (pileups.length > 1)
		{
			var max = pileups[0].count;

			// at the end of this loop, numberOfTies will be the number of points with
			// max y-value (number of tied points)
			for (var numberOfTies = 0; numberOfTies < pileups.length; numberOfTies++)
			{
				if (pileups[numberOfTies].count < max)
				{
					break;
				}
			}

			// do not display any label if there are too many ties
			if (count < numberOfTies &&
			    numberOfTies > maxAllowedTie)
			{
				count = 0;
			}

		}

		// show (lollipopLabelCount) label(s)
		for (var i = 0;
		     i < count && i < pileups.length;
		     i++)
		{
			// check for threshold value
			if (pileups.length > 1 &&
			    pileups[i].count < options.lollipopLabelThreshold)
			{
				// do not processes remaining values below threshold
				// (assuming mutations array is sorted)
				break;
			}

			var x = xScale(pileups[i].location);
			var y = yScale(Math.min(pileups[i].count, options.maxLengthY)) -
			        (options.lollipopTextPadding);

			// init text
			var text = labels.append('text')
				.attr("fill", options.lollipopFontColor)
				.attr("x", x)
				.attr("y", y)
				.attr("class", "mut-dia-lollipop-text")
				.attr("transform", "rotate(" + options.lollipopTextAngle + ", " + x + "," + y +")")
				.style("font-size", options.lollipopFontSize)
				.style("font-family", options.lollipopFont)
				.text(pileups[i].label)
				.attr("opacity", 0);

			self.fadeIn(text);

			// adjust anchor
			var textAnchor = getTextAnchor(text, options.lollipopTextAnchor);
			text.attr("text-anchor", textAnchor);
		}
	};

	/**
	 * Draws the given region on the sequence.
	 *
	 * @param svg       target svg to append region rectangle
	 * @param region    region data
	 * @param options   general options object
	 * @param bounds    bounds of the plot area {width, height, x, y}
	 *                  x, y is the actual position of the origin
	 * @param xScale    scale function for the x-axis
	 * @return {object} region rectangle & its text (as an svg group element)
	 */
	MutationDiagram.prototype.drawRegion = function(svg, region, options, bounds, xScale)
	{
		var self = this;

		var start = region.metadata.start;
		var end = region.metadata.end;
		var label = region.text;
		var color = region.colour;

		var width = Math.abs(xScale(start) - xScale(end));
		var height = options.regionHeight;
		var y = bounds.y + options.seqPadding;
		var x = xScale(start);

		// group region and its label
		var group = svg.append("g")
			.attr("class", "mut-dia-region")
			.attr("transform", "translate(" + x + "," + y +")");

		var rect = group.append('rect')
			.attr('fill', color)
			.attr('x', 0)
			.attr('y', 0)
			.attr('width', width)
			.attr('height', height);

		var addTooltip = options.regionTipFn;

		// add tooltip to the rect
		addTooltip(rect, region, self.dataProxies.mutationAlignerProxy);

		if (options.showRegionText)
		{
			var text = self.drawRegionText(label, group, options, width);

			// add tooltip if the text fits
			if (text)
			{
				// add tooltip to the text
				addTooltip(text, region, self.dataProxies.mutationAlignerProxy);
			}
		}

		return group;
	};

	/**
	 * Draws the text for the given svg group (which represents the region).
	 * Returns null if neither the text nor its truncated version fits
	 * into the region rectangle.
	 *
	 * @param label     text contents
	 * @param group     target svg group to append the text
	 * @param options   general options object
	 * @param width     width of the region rectangle
	 * @return {object} region text (svg element)
	 */
	MutationDiagram.prototype.drawRegionText = function(label, group, options, width)
	{
		var xText = width/2;
		var height = options.regionHeight;

		if (options.regionTextAnchor === "start")
		{
			xText = 0;
		}
		else if (options.regionTextAnchor === "end")
		{
			xText = width;
		}

		// truncate or hide label if it is too long to fit
		var fits = true;

		// init text
		var text = group.append('text')
			.style("font-size", options.regionFontSize)
			.style("font-family", options.regionFont)
			.text(label)
			.attr("text-anchor", options.regionTextAnchor)
			.attr("fill", options.regionFontColor)
			.attr("x", xText)
			.attr("y", 2*height/3)
			.attr("class", "mut-dia-region-text");

		// check if the text fits into the region rectangle
		// adjust it if necessary
		if (text.node().getComputedTextLength() > width)
		{
			// truncate text if not fits
			label = label.substring(0,3) + "..";
			text.text(label);

			// check if truncated version fits
			if (text.node().getComputedTextLength() > width)
			{
				// remove if the truncated version doesn't fit either
				text.remove();
				text = null;
			}
		}

		return text;
	};

	/**
	 * Draws the sequence just below the plot area.
	 *
	 * @param svg       target svg to append sequence rectangle
	 * @param options   general options object
	 * @param bounds    bounds of the plot area {width, height, x, y}
	 *                  x, y is the actual position of the origin
	 * @return {object} sequence rectangle (svg element)
	 */
	MutationDiagram.prototype.drawSequence = function(svg, options, bounds)
	{
		var seqBounds = this.calcSequenceBounds(bounds, options);

		return svg.append('rect')
			.attr('fill', options.seqFillColor)
			.attr('x', seqBounds.x)
			.attr('y', seqBounds.y)
			.attr('width', seqBounds.width)
			.attr('height', seqBounds.height)
			.attr('class', 'mut-dia-sequence');
	};

	/**
	 * Returns the number of mutations at the hottest spot.
	 *
	 * @param pileups array of piled up mutation data
	 * @return {Number} number of mutations at the hottest spot
	 */
	MutationDiagram.prototype.calcMaxCount = function(pileups)
	{
		var maxCount = -1;
	//
	//	for (var i = 0; i < mutations.length; i++)
	//	{
	//		if (mutations[i].count >= maxCount)
	//		{
	//			maxCount = mutations[i].count;
	//		}
	//	}
	//
	//	return maxCount;

		// assuming the list is sorted (descending)
		if (pileups.length > 0)
		{
			maxCount = pileups[0].count;
		}

		return maxCount;
	};

	/**
	 * Calculates the bounds of the sequence.
	 *
	 * @param bounds    bounds of the plot area
	 * @param options   diagram options
	 */
	MutationDiagram.prototype.calcSequenceBounds = function (bounds, options)
	{
		var x = bounds.x;
		var y = bounds.y +
		        Math.abs(options.regionHeight - options.seqHeight) / 2 +
		        options.seqPadding;
		var width = bounds.width;
		var height = options.seqHeight;

		return {x: x,
			y: y,
			width: width,
			height: height};
	};

	/**
	 * Updates the plot area of the diagram for the given set of pileup data.
	 * This function assumes that the provided mutation data is a subset
	 * of the original data. Therefore this function only modifies the plot area
	 * elements (lollipops, labels, etc.). If the provided data set is not a subset
	 * of the original data, then the behavior of this function is unpredicted.
	 *
	 * If the number of mutations provided in pileupData is less than the number
	 * mutation in the original data set, this function returns true to indicate
	 * the provided data set is a subset of the original data. If the number of
	 * mutations is the same, then returns false.
	 *
	 * @param mutationColl  a MutationCollection instance
	 * @return {boolean}  true if the diagram is filtered, false otherwise
	 */
	MutationDiagram.prototype.updatePlot = function(mutationColl)
	{
		var self = this;
		var pileups = self.pileups;

		// TODO for a safer update, verify the provided data
		var pileupData = [];

		// update current data & pileups
		if (mutationColl)
		{
			pileupData = PileupUtil.convertToPileups(mutationColl, self.options.pileupConverter);
			self.pileups = pileups = pileupData;
			self.mutationPileupMap = PileupUtil.mapToMutations(pileups);
		}

		// remove all elements in the plot area
		self.cleanPlotArea();

		// reset color mapping (for the new data we may have different pileup colors)
		self.mutationColorMap = {};

		if (self.options.yAxisAutoAdjust)
		{
			// rescale y-axis without updating the plot,
			// otherwise... infinite recursion!
			self.rescaleYAxis(true);
		}

		// re-draw plot area contents for new data
		self.drawPlot(self.svg,
		              pileups,
		              self.options,
		              self.bounds,
		              self.xScale,
		              self.yScale);

		// also re-add listeners
		//for (var selector in self.listeners)
		_.each(_.keys(self.listeners), function(selector) {
			var target = self.svg.selectAll(selector);

			//for (var event in self.listeners[selector])
			_.each(_.keys(self.listeners[selector]), function(event) {
				target.on(event,
					self.listeners[selector][event]);
			});
		});

		// reset highlight map
		self.highlighted = {};

		// trigger corresponding event
		self.dispatcher.trigger(
			MutationDetailsEvents.DIAGRAM_PLOT_UPDATED);

		return self.isFiltered();
	};

	/**
	 * Removes all elements of the plot area.
	 */
	MutationDiagram.prototype.cleanPlotArea = function()
	{
		var self = this;

		// select all plot area elements
		var labels = self.gLabel.selectAll("text");
		var lines = self.gLine.selectAll("line");
		var dataPoints = self.gData.selectAll(".mut-dia-data-point");

		// remove all plot elements (no animation)
	//	labels.remove();
	//	lines.remove();
	//	dataPoints.remove();

		self.fadeOut(labels, function(element) {
			$(element).remove();
		});

		self.fadeOut(lines, function(element) {
			$(element).remove();
		});

		self.fadeOut(dataPoints, function(element) {
			$(element).remove();
		});

		// alternative animated version:
		// fade out and then remove all
	//	labels.transition()
	//		.style("opacity", 0)
	//		.duration(1000)
	//		.each("end", function() {
	//			$(this).remove();
	//		});
	//
	//	lines.transition()
	//		.style("opacity", 0)
	//		.duration(1000)
	//		.each("end", function() {
	//			$(this).remove();
	//		});
	//
	//	points.transition()
	//		.style("opacity", 0)
	//		.duration(1000)
	//		.each("end", function() {
	//			$(this).remove();
	//		});

		// for the alternative animated version
		// plot re-drawing should also be delayed to have a nicer effect
	};

	/**
	 * Resets the plot area back to its initial state.
	 */
	MutationDiagram.prototype.resetPlot = function()
	{
		var self = this;

		self.updatePlot(self.data.mutations);

		// trigger corresponding event
		self.dispatcher.trigger(
			MutationDetailsEvents.DIAGRAM_PLOT_RESET);
	};

	/**
	 * Updates the text of the top label.
	 *
	 * @param text  new text to set as the label value
	 */
	MutationDiagram.prototype.updateTopLabel = function(text)
	{
		var self = this;

		// if no text value is passed used gene symbol to update the value
		if (text == undefined || text == null)
		{
			text = "";
		}

		self.topLabel.text(text);
	};

	/**
	 * Adds an event listener for specific diagram elements.
	 *
	 * @param selector  selector string for elements
	 * @param event     name of the event
	 * @param handler   event handler function
	 */
	MutationDiagram.prototype.addListener = function(selector, event, handler)
	{
		var self = this;

		self.svg.selectAll(selector).on(event, handler);

		// save the listener for future reference
		if (self.listeners[selector] == null)
		{
			self.listeners[selector] = {};
		}

		self.listeners[selector][event] = handler;

	};

	/**
	 * Removes an event listener for specific diagram elements.
	 *
	 * @param selector  selector string for elements
	 * @param event     name of the event
	 */
	MutationDiagram.prototype.removeListener = function(selector, event)
	{
		var self = this;

		self.svg.selectAll(selector).on(event, null);

		// remove listener from the map
		if (self.listeners[selector] &&
		    self.listeners[selector][event])
		{
			delete self.listeners[selector][event];
		}
	};

	MutationDiagram.prototype.addDefaultListeners = function()
	{
		var self = this;

		// diagram background click
		self.addListener(".mut-dia-background", "click", function(datum, index) {
			// ignore the action (do not dispatch an event) if multi selection mode is on
			if (!self.multiSelect)
			{
				// remove all diagram highlights
				self.clearHighlights();

				// trigger corresponding event
				self.dispatcher.trigger(
					MutationDetailsEvents.ALL_LOLLIPOPS_DESELECTED);
			}
		});

		// lollipop circle click
		self.addListener(".mut-dia-data-point", "click", function(datum, index) {
			if (self.multiSelect)
			{
				// trigger corresponding event
				self.dispatcher.trigger(
					MutationDetailsEvents.LOLLIPOP_MULTI_SELECT,
					datum, index);
			}
			else
			{
				// trigger corresponding event
				self.dispatcher.trigger(
					MutationDetailsEvents.LOLLIPOP_SINGLE_SELECT,
					datum, index);
			}
		});

		// lollipop circle mouse out
		self.addListener(".mut-dia-data-point", "mouseout", function(datum, index) {
			// trigger corresponding event
			self.dispatcher.trigger(
				MutationDetailsEvents.LOLLIPOP_MOUSEOUT,
				datum, index);
		});

		// lollipop circle mouse over
		self.addListener(".mut-dia-data-point", "mouseover", function(datum, index) {
			// trigger corresponding event
			self.dispatcher.trigger(
				MutationDetailsEvents.LOLLIPOP_MOUSEOVER,
				datum, index);
		});

		// listener that prevents text selection
		// when multi selection is activated by the shift key
		var preventSelection = function (datum, index)
		{
			if (self.multiSelect)
			{
				// current event is stored under d3.event
				d3.event.preventDefault();
			}
		};

		self.addListener(".mut-dia-data-point", "mousedown", preventSelection);
		self.addListener(".mut-dia-background", "mousedown", preventSelection);

		// TODO listen to the key events only on the diagram (if possible)
		// ...it might be better to bind window key event handlers in a global util class

		$(window).on("keydown", function(event) {
			if (event.keyCode == self.options.multiSelectKeycode)
			{
				self.multiSelect = true;
			}
		});

		$(window).on("keyup", function(event) {
			if (event.keyCode == self.options.multiSelectKeycode)
			{
				self.multiSelect = false;
			}
		});
	};

	/**
	 * Checks whether a diagram data point is highlighted or not.
	 * If no selector provided, then checks if the there is
	 * at least one highlighted data point.
	 *
	 * @param selector  [optional] selector for a specific data point element
	 * @return {boolean} true if highlighted, false otherwise
	 * @deprecated
	 */
	MutationDiagram.prototype.isHighlighted = function(selector)
	{
		var self = this;
		var highlighted = false;

		if (selector == undefined)
		{
			highlighted = !(_.isEmpty(self.highlighted));
		}
		else
		{
			var element = d3.select(selector);
			var location = element.datum().location;

			if (self.highlighted[location] != undefined)
			{
				highlighted = true;
			}
		}

		return highlighted;
	};

	/**
	 * Resets all highlighted data points back to their original state.
	 */
	MutationDiagram.prototype.clearHighlights = function()
	{
		var self = this;
		var dataPoints = self.gData.selectAll(".mut-dia-data-point");

		self.resizeLollipop(dataPoints, self.options.lollipopSize);
		self.highlighted = {};
	};

	/**
	 * Highlights the pileup containing the given mutation.
	 *
	 * @param mutationSid    id of the mutation
	 */
	MutationDiagram.prototype.highlightMutation = function(mutationSid)
	{
		var self = this;

		var pileupId = self.mutationPileupMap[mutationSid];

		// there may not be a pileup corresponding to the given sid,
		// because not every mutation is mapped onto the diagram
		if (pileupId != null)
		{
			var pileup = self.svg.select("#" + pileupId);

			if (pileup.length > 0)
			{
				self.highlight(pileup[0][0]);
			}
		}
	};

	/**
	 * Highlights a single data point. This function assumes that the provided
	 * selector is a selector for one of the SVG data point elements on the
	 * diagram.
	 *
	 * @param selector  selector for a specific data point element
	 */
	MutationDiagram.prototype.highlight = function(selector)
	{
		var self = this;
		var element = d3.select(selector);

		// resize lollipop to the highlight size
		self.resizeLollipop(element, self.options.lollipopHighlightSize);

		// add data point to the map
		var location = element.datum().location;
		self.highlighted[location] = element;
	};

	/**
	 * Removes highlight of a single data point. This function assumes that
	 * the provided selector is a selector for one of the SVG data point
	 * elements on the diagram.
	 *
	 * @param selector  selector for a specific data point element
	 */
	MutationDiagram.prototype.removeHighlight = function(selector)
	{
		var self = this;
		var element = d3.select(selector);

		// resize lollipop to the regular size
		self.resizeLollipop(element, self.options.lollipopSize);

		// remove data point from the map
		var location = element.datum().location;
		delete self.highlighted[location];
	};

	MutationDiagram.prototype.resizeLollipop = function(lollipop, size)
	{
		var self = this;

		lollipop.transition()
			.ease("elastic")
			.duration(self.options.animationDuration)
			// TODO see if it is possible to update ONLY size, not the whole 'd' attr
			.attr("d", d3.svg.symbol()
				.size(size)
				.type(self.getLollipopShapeFn()));
	};

	MutationDiagram.prototype.fadeIn = function(element, callback)
	{
		var self = this;

		element.transition()
			.style("opacity", 1)
			.duration(self.options.fadeDuration)
			.each("end", function() {
				      if(_.isFunction(callback)) {
					      callback(this);
				      }
			      });
	};

	MutationDiagram.prototype.fadeOut = function(element, callback)
	{
		var self = this;

		element.transition()
			.style("opacity", 0)
			.duration(self.options.fadeDuration)
			.each("end", function() {
				      if(_.isFunction(callback)) {
					      callback(this);
				      }
			      });
	};

	/**
	 * Returns selected (highlighted) elements as a list of svg elements.
	 *
	 * @return {Array}  a list of SVG elements
	 * @deprecated
	 */
	MutationDiagram.prototype.getSelectedElements = function()
	{
		var self = this;

		return _.values(self.highlighted);
	};

	/**
	 * Checks the diagram for filtering. If the current data set
	 * is a subset of the initial data set, then it means
	 * the diagram is filtered. If the current data set is the
	 * initial data set, then the diagram is not filtered.
	 *
	 * @return {boolean} true if current view is filtered, false otherwise
	 */
	MutationDiagram.prototype.isFiltered = function()
	{
		var self = this;
		var filtered = false;

		if (PileupUtil.countMutations(self.pileups) <
		    PileupUtil.countMutations(self.initialPileups))
		{
			filtered = true;
		}

		return filtered;
	};

	MutationDiagram.prototype.getThreshold = function()
	{
		return Math.max(this.maxCount, this.options.minLengthY);
	};

	MutationDiagram.prototype.getMaxY = function()
	{
		return this.yMax;
	};

	MutationDiagram.prototype.getInitialMaxY = function()
	{
		var self = this;

		if (!self.initialYMax)
		{
			var maxCount = self.calcMaxCount(self.initialPileups);
			self.initialYMax = self.calcYMax(self.options, maxCount);
		}

		return self.initialYMax;
	};

	MutationDiagram.prototype.getMinY = function()
	{
		return this.options.minLengthY;
	};

	module.exports = MutationDiagram;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var LollipopTipStatsView = __webpack_require__(169);
	var BackboneTemplateCache = __webpack_require__(23);

	var Backbone = __webpack_require__(12);
	var $ = __webpack_require__(7);

	/**
	 * Tooltip view for the mutation diagram's lollipop circles.
	 *
	 * options: {el: [target container],
	 *           model: {count: [number of mutations],
	 *                   label: [info for that location]}
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var LollipopTipView = Backbone.View.extend({
		render: function()
		{
			// compile the template
			var template = this.compileTemplate();

			// load the compiled HTML into the Backbone "el"
			this.$el.html(template);
			this.format();
		},
		format: function()
		{
			// implement if necessary...
		},

	    showStats: false,
	    setShowStats: function(showStats) {
	        this.showStats = showStats;
	    },
	    getShowStats: function(showStats) {
	        return this.showStats;
	    },

	    compileTemplate: function()
		{
	        var thatModel = this.model;
	        var mutationStr = thatModel.count > 1 ? "mutations" : "mutation";

			// pass variables in using Underscore.js template
			var variables = {count: thatModel.count,
				mutationStr: mutationStr,
				label: thatModel.label
	        };

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_details_lollipop_tip_template");
	        var compiledEl = $(templateFn(variables));

	        var statsEl = compiledEl.find(".lollipop-stats");
	        if(this.showStats)
	        {
	            (new LollipopTipStatsView({ el: statsEl, model: thatModel.stats })).render();
	            statsEl.find("table").dataTable({
	                "sDom": 't',
	                "bJQueryUI": true,
	                "bDestroy": true,
	                "aaSorting": [[ 1, "desc" ]],
	                "aoColumns": [
	                    { "bSortable": false },
	                    { "bSortable": false }
	                ]
	            });
	        } else {
	            statsEl.hide();
	        }

	        return compiledEl.html();
		}
	});

	module.exports = LollipopTipView;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var BackboneTemplateCache = __webpack_require__(23);

	var Backbone = __webpack_require__(12);
	var _ = __webpack_require__(5);

	/**
	 * This view will add new columns to the mutation stats table
	 * model: { cancerType: "", count: 0 }
	 */
	var LollipopTipStatsView = Backbone.View.extend({
		initialize: function()
		{

		},
	    render: function()
	    {
	        var templateFn = BackboneTemplateCache.getTemplateFn("mutation_details_lollipop_tip_stats_template");
	        var thatEl = this.$el.find("table tbody");
	        _.each(this.model, function(statItem) {
	            thatEl.append(templateFn(statItem));
	        });
	        return this;
	    }
	});

	module.exports = LollipopTipStatsView;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var BackboneTemplateCache = __webpack_require__(23);

	var Backbone = __webpack_require__(12);

	/**
	 * Tooltip view for the mutation diagram's region rectangles.
	 *
	 * options: {el: [target container],
	 *           model: {identifier: [region identifier],
	 *                   type: [region type],
	 *                   description: [region description],
	 *                   start: [start position],
	 *                   end: [end position]}
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var RegionTipView = Backbone.View.extend({
		render: function()
		{
			// compile the template
			var template = this.compileTemplate();

			// load the compiled HTML into the Backbone "el"
			this.$el.html(template);
			this.format();
		},
		format: function()
		{
			// implement if necessary...
		},
		compileTemplate: function()
		{
			// pass variables in using Underscore.js template
			var variables = {identifier: this.model.identifier,
				type: this.model.type.toLowerCase(),
				description: this.model.description,
				start: this.model.start,
				end: this.model.end,
				pfamAccession: this.model.pfamAccession,
				mutationAlignerInfo: this.model.mutationAlignerInfo};

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_details_region_tip_template");
			return templateFn(variables);
		}
	});

	module.exports = RegionTipView;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var BackboneTemplateCache = __webpack_require__(23);

	var Backbone = __webpack_require__(12);
	var $ = __webpack_require__(7);
	__webpack_require__(172);

	/**
	 * Mutation Details Customization Panel View.
	 *
	 * This view is designed to provide a customization panel for Mutation Details page.
	 *
	 * options: {el: [target container],
	 *           model: {},
	 *           diagram: reference to the MutationDiagram instance
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationCustomizePanelView = Backbone.View.extend({
		initialize : function (options) {
			this.options = options || {};
		},
		render: function()
		{
			var self = this;
			var diagram = self.options.diagram;

			// template vars
			var variables = {minY: 2,
				maxY: diagram.getInitialMaxY()};

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_customize_panel_template");
			var template = templateFn(variables);

			// load the compiled HTML into the Backbone "el"
			self.$el.html(template);

			// format after rendering
			self.format();
		},
		format: function()
		{
			var self = this;
			var diagram = self.options.diagram;

			// hide the view initially
			self.$el.hide();

			// format panel controls

			var customizeClose = self.$el.find(".diagram-customize-close");
			var yAxisSlider = self.$el.find(".diagram-y-axis-slider");
			var yAxisInput = self.$el.find(".diagram-y-axis-limit-input");

			// add listener to close button
			customizeClose.click(function(event) {
				event.preventDefault();
				self.toggleView();
			});

			// set initial value of the input field
			yAxisInput.val(diagram.getMaxY());

			// init y-axis slider controls
			yAxisSlider.slider({
				value: diagram.getMaxY(), // set value to current max
				min: 2, // anything below 2 doesn't make much sense
				max: diagram.getInitialMaxY(), // set max value to initial max
				change: function(event, ui) {
					var value = ui.value;

					// adjust the slider value to the threshold
					// and stop execution, because this will trigger
					// this event (change event) again...
					if (value > diagram.getThreshold()) {
						value = diagram.getThreshold();
						$(this).slider('value', value);
						return;
					}

					// update input field
					yAxisInput.val(value);

					// update diagram
					diagram.updateOptions({maxLengthY: value});
					diagram.rescaleYAxis();
				},
				slide: function(event, ui) {
					// update input field only
					yAxisInput.val(ui.value);
				}
			});

			yAxisInput.keypress(function(event) {
				var enterCode = 13;

				if (event.keyCode == enterCode)
				{
					var input = yAxisInput.val();
					var value = input;

					// not a valid value, update with defaults
					if (isNaN(value) ||
					    value > diagram.getThreshold())
					{
						value = diagram.getThreshold();
					}
					else if (input < 2)
					{
						value = 2;
					}

					// update weight slider and input value
					yAxisInput.val(value);
					yAxisSlider.slider("option", "value", Math.floor(value));
				}
			});
		},
		toggleView: function() {
			var self = this;
			self.$el.slideToggle();
		}
	});

	module.exports = MutationCustomizePanelView;

/***/ },
/* 172 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_172__;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var BackboneTemplateCache = __webpack_require__(23);

	var Backbone = __webpack_require__(12);

	/**
	 * Mutation Details Legend Panel View.
	 *
	 * This view is designed to provide a legend panel for Mutation Details page.
	 *
	 * options: {el: [target container],
	 *           model: {},
	 *           diagram: reference to the MutationDiagram instance
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationHelpPanelView = Backbone.View.extend({
		initialize : function (options) {
			this.options = options || {};
		},
		render: function()
		{
			var self = this;

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_help_panel_template");
			var template = templateFn({});

			// load the compiled HTML into the Backbone "el"
			self.$el.html(template);

			// format after rendering
			self.format();
		},
		format: function()
		{
			var self = this;

			// format panel controls
			var helpClose = self.$el.find(".diagram-help-close");

			// add listener to close button
			helpClose.click(function(event) {
				event.preventDefault();
				self.toggleView();
			});
		},
		toggleView: function() {
			var self = this;
			self.$el.slideToggle();
		}
	});

	module.exports = MutationHelpPanelView;

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDetailsUtil = __webpack_require__(114);
	var MutationDetailsTable = __webpack_require__(175);
	var MutationModel = __webpack_require__(113);
	var MutationDataConverter = __webpack_require__(125);
	var BackboneTemplateCache = __webpack_require__(23);

	var loaderImage = __webpack_require__(85);

	var Backbone = __webpack_require__(12);
	var _ = __webpack_require__(5);
	var $ = __webpack_require__(7);
	var jQuery = $;

	/**
	 * Default table view for the mutations.
	 *
	 * options: {el: [target container],
	 *           model: {mutations: mutation data as an array of JSON objects,
	 *                   dataProxies: all available data proxies,
	 *                   dataManager: global mutation data manager
	 *                   geneSymbol: hugo gene symbol as a string,
	 *                   tableOpts: mutation table options (optional)}
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationDetailsTableView = Backbone.View.extend({
		initialize : function (options) {
			var defaultOpts = {
				config: {
					loaderImage: loaderImage
				}
			};

			this.options = jQuery.extend(true, {}, defaultOpts, options);

			// custom event dispatcher
			this.dispatcher = {};
			_.extend(this.dispatcher, Backbone.Events);
		},
		render: function()
		{
			var self = this;

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_details_table_template");
			// TODO customize loader image
			var template = templateFn({loaderImage: self.options.config.loaderImage});

			// load the compiled HTML into the Backbone "el"
			self.$el.html(template);

			// init mutation table
			self._initMutationTable();

			// format after rendering
			self.format();
		},
		/**
		 * Initializes the PDB chain table.
		 *
		 * @return {MutationDetailsTable}   table instance
		 */
		_initMutationTable: function(callback)
		{
			var self = this;

			var options = jQuery.extend(true, {}, self.model.tableOpts);
			options.el = options.el || self.$el.find(".mutation_details_table");

			var mutationColl = MutationDataConverter.convertToCollection(
				self.model.mutations.getData());
			var mutationUtil = new MutationDetailsUtil(mutationColl);

			var table = new MutationDetailsTable(
				options,
				self.model.geneSymbol,
				mutationUtil,
				self.model.dataProxies,
				self.model.dataManager);

			self.mutationTable = table;

			if (_.isFunction(callback))
			{
				callback(self, table);
			}

			self._generateRowData(table, table.getColumnOptions(), mutationColl, function(rowData) {
				// init table with the row data
				table.renderTable(rowData);
				// hide loader image
				//self.$el.find(".mutation-details-table-loader").hide();
			});

			return table;
		},
		_generateRowData: function(table, headers, mutationColl, callback)
		{
			var rows = [];

			mutationColl.each(function(mutation) {
				// only set the datum
				var datum = {
					table: table, // reference to the actual table instance
					mutation: mutation // actual mutation corresponding to the row
				};
				var row = [datum];

				// set everything else to null...
				for (var i=0; i < _.size(headers) - 1; i++)
				{
					row.push(null);
				}

				rows.push(row);
			});

			callback(rows);
		},
		format: function()
		{
			// TODO format table if required
		},
		hideView: function()
		{
			var self = this;
			self.$el.hide();
		},
		showView: function()
		{
			var self = this;
			self.$el.show();
		},
		/**
		 * Highlights the given mutations in the table.
		 *
		 * @param mutations mutations to highlight
		 */
		highlight: function(mutations)
		{
			var self = this;
			var tableSelector = self.$el.find('.mutation_details_table');

			for (var i = 0; i < mutations.length; i++)
			{
				//var row = tableSelector.find("#" + mutations[i].mutationId);
	            var row = tableSelector.find("tr." + mutations[i].get("mutationSid"));
	            row.addClass("mutation-table-highlight");
			}
		},
		/**
		 * Clears all highlights from the mutation table.
		 */
		clearHighlights: function()
		{
			var self = this;
			var tableSelector = self.$el.find('.mutation_details_table');

			// TODO this depends on highlight function
			tableSelector.find('tr').removeClass("mutation-table-highlight");
		},
		/**
		 * Filters out all other mutations than the given mutations.
		 *
		 * @param mutations mutations to keep
		 * @param updateBox [optional] show the filter text in the search box
		 * @param limit     [optional] column to limit filtering to
		 */
		filter: function(mutations, updateBox, limit)
		{
			var self = this;
			var oTable = self.mutationTable.getDataTable();

			// construct regex
			var ids = [];

			for (var i = 0; i < mutations.length; i++)
			{
				ids.push(mutations[i].get("mutationSid"));
			}

			var regex = "(" + ids.join("|") + ")";
			var asRegex = true;

			// empty mutation list, just show everything
			if (ids.length == 0)
			{
				regex = "";
				asRegex = false;
			}

			// disable event triggering before filtering, otherwise it creates a chain reaction
			self.mutationTable.setFilterEventActive(false);

			// apply filter
			self._applyFilter(oTable, regex, asRegex, updateBox, limit);

			// enable events after filtering
			self.mutationTable.setFilterEventActive(true);
		},
		/**
		 * Resets all table filters (rolls back to initial state)
		 */
		resetFilters: function()
		{
			var self = this;
			// pass an empty array to show everything
			self.filter([], true);
			// also clean filter related variables
			self.mutationTable.cleanFilters();
		},
		/**
		 * Rolls back the table to the last state where a manual search
		 * (manual filtering) performed. This function is required since
		 * we also filter the table programmatically.
		 */
		rollBack: function()
		{
			var self = this;
			var oTable = self.mutationTable.getDataTable();

			// disable event triggering before filtering, otherwise it creates a chain reaction
			self.mutationTable.setFilterEventActive(false);

			// re-apply last manual filter string
			var searchStr = self.mutationTable.getManualSearch();
			self._applyFilter(oTable, searchStr, false);

			// enable events after filtering
			self.mutationTable.setFilterEventActive(true);
		},
		clearSearchBox: function() {
			var self = this;
			var searchBox = self.$el.find(".mutation_datatables_filter input[type=search]");
			searchBox.val("");
		},
		/**
		 * Filters the given data table with the provided filter string.
		 *
		 * @param oTable    target data table to be filtered
		 * @param filterStr filter string to apply with the filter
		 * @param asRegex   indicates if the given filterStr is a regex or not
		 * @param updateBox [optional] show the filter text in the search box
		 * @param limit     [optional] column to limit filtering to
		 * @private
		 */
		_applyFilter: function(oTable, filterStr, asRegex, updateBox, limit)
		{
			var self = this;

			if (limit == undefined)
			{
				limit = null;
			}

			// TODO not updating the filter text in the box may be confusing
			if (updateBox == undefined)
			{
				updateBox = false;
			}

			var smartFilter = true;
			var caseInsensitive = true;

			var searchBox = self.$el.find(".mutation_datatables_filter input[type=search]");
			var prevValue = searchBox.val();

			oTable.fnFilter(filterStr, limit, asRegex, smartFilter, updateBox, caseInsensitive);

			// reset to previous value if updateBox is set to false
			if (!updateBox)
			{
				searchBox.val(prevValue);
			}
		}
	});

	module.exports = MutationDetailsTableView;

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDetailsTableFormatter = __webpack_require__(154);
	var BackboneTemplateCache = __webpack_require__(23);
	var MutationViewsUtil = __webpack_require__(129);
	var CosmicTipView = __webpack_require__(176);
	var PredictedImpactTipView = __webpack_require__(177);
	var PancanMutationHistTipView = __webpack_require__(178);
	var MutationDetailsEvents = __webpack_require__(22);
	var AdvancedDataTable = __webpack_require__(155);
	var DataTableUtil = __webpack_require__(153);

	var cbio = {
		util: __webpack_require__(6),
		download: __webpack_require__(141)
	};

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);

	/**
	 * MutationDetailsTable class (extends AdvancedDataTable)
	 *
	 * Highly customizable table view built on DataTables plugin.
	 * See default options object (_defaultOpts) for details.
	 *
	 * With its default configuration, following events are dispatched by this class:
	 * - MutationDetailsEvents.PDB_LINK_CLICKED:
	 *   dispatched when clicked on a 3D link (in the protein change column)
	 * - MutationDetailsEvents.PROTEIN_CHANGE_LINK_CLICKED:
	 *   dispatched when clicked on the protein change link (in the protein change column)
	 * - MutationDetailsEvents.MUTATION_TABLE_FILTERED:
	 *   dispatched when the table is filter by a user input (via the search box)
	 *
	 * @param options       visual options object
	 * @param gene          hugo gene symbol
	 * @param mutationUtil  mutation details util
	 * @param dataProxies   all available data proxies
	 * @param dataManager   mutation data manager for additional data requests
	 * @constructor
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationDetailsTable(options, gene, mutationUtil, dataProxies, dataManager)
	{
		var self = this;

		// default options object
		var _defaultOpts = {
			el: "#mutation_details_table_d3",
			//elWidth: 740, // width of the container
			// default column options
			//
			// sTitle: display value
			// tip: tooltip value of the column header
			//
			// [data table options]: sType, sClass, sWidth, asSorting, ...
			columns: {
				datum: {sTitle: "datum",
					tip: ""},
				mutationId: {sTitle: "Mutation ID",
					tip: "Mutation ID",
					sType: "string"},
				mutationSid: {sTitle: "Mutation SID",
					tip: "",
					sType: "string"},
				caseId: {sTitle: "Sample ID",
					tip: "Sample ID",
					sType: "string"},
				cancerStudy: {sTitle: "Cancer Study",
					tip: "Cancer Study",
					sType: "string"},
				tumorType: {sTitle: "Cancer Type",
					tip: "Cancer Type",
					sType: "string"},
				proteinChange: {sTitle: "AA change",
					tip: "Protein Change",
					sType: "numeric"},
				mutationType: {sTitle: "Type",
					tip: "Mutation Type",
					sType: "string",
					sClass: "center-align-td"},
				cna: {sTitle: "Copy #",
					tip: "Copy-number status of the mutated gene",
					sType: "numeric",
					sClass: "center-align-td"},
				cosmic: {sTitle: "COSMIC",
					tip: "Overlapping mutations in COSMIC",
					sType: "numeric",
					sClass: "right-align-td",
					asSorting: ["desc", "asc"]},
				mutationStatus: {sTitle: "MS",
					tip: "Mutation Status",
					sType: "string",
					sClass: "center-align-td"},
				validationStatus: {sTitle: "VS",
					tip: "Validation Status",
					sType: "string",
					sClass: "center-align-td"},
				mutationAssessor: {sTitle: "Mutation Assessor",
					tip: "Predicted Functional Impact Score (via Mutation Assessor) for missense mutations",
					sType: "numeric",
					sClass: "center-align-td",
					asSorting: ["desc", "asc"],
					sWidth: "2%"},
				sequencingCenter: {sTitle: "Center",
					tip: "Sequencing Center",
					sType: "string",
					sClass: "center-align-td"},
				chr: {sTitle: "Chr",
					tip: "Chromosome",
					sType: "string"},
				startPos: {sTitle: "Start Pos",
					tip: "Start Position",
					sType: "numeric",
					sClass: "right-align-td"},
				endPos: {sTitle: "End Pos",
					tip: "End Position",
					sType: "numeric",
					sClass: "right-align-td"},
				referenceAllele: {sTitle: "Ref",
					tip: "Reference Allele",
					sType: "string"},
				variantAllele: {sTitle: "Var",
					tip: "Variant Allele",
					sType: "string"},
				tumorFreq: {sTitle: "Allele Freq (T)",
					tip: "Variant allele frequency<br> in the tumor sample",
					sType: "numeric",
					sClass: "right-align-td",
					asSorting: ["desc", "asc"]},
				normalFreq: {sTitle: "Allele Freq (N)",
					tip: "Variant allele frequency<br> in the normal sample",
					sType: "numeric",
					sClass: "right-align-td",
					asSorting: ["desc", "asc"]},
				tumorRefCount: {sTitle: "Var Ref",
					tip: "Variant Ref Count",
					sType: "numeric",
					sClass: "right-align-td",
					asSorting: ["desc", "asc"]},
				tumorAltCount: {sTitle: "Var Alt",
					tip: "Variant Alt Count",
					sType: "numeric",
					sClass: "right-align-td",
					asSorting: ["desc", "asc"]},
				normalRefCount: {sTitle: "Norm Ref",
					tip: "Normal Ref Count",
					sType: "numeric",
					sClass: "right-align-td",
					asSorting: ["desc", "asc"]},
				normalAltCount: {sTitle: "Norm Alt",
					tip: "Normal Alt Count",
					sType: "numeric",
					sClass: "right-align-td",
					asSorting: ["desc", "asc"]},
				igvLink: {sTitle: "BAM",
					tip: "Link to BAM file",
					sType: "string",
					sClass: "center-align-td"},
				mutationCount: {sTitle: "#Mut in Sample",
					tip: "Total number of<br> nonsynonymous mutations<br> in the sample",
					sType: "numeric",
					sClass: "right-align-td",
					asSorting: ["desc", "asc"],
					sWidth: "2%"},
				cBioPortal: {sTitle: "cBioPortal",
					tip: "Mutation frequency in cBioPortal",
					sType: "numeric",
					sClass: "right-align-td",
					asSorting: ["desc", "asc"]}
			},
			// display order of column headers
			columnOrder: [
				"datum", "mutationId", "mutationSid", "caseId", "cancerStudy", "tumorType",
				"proteinChange", "mutationType", "cna", "cBioPortal", "cosmic", "mutationStatus",
				"validationStatus", "mutationAssessor", "sequencingCenter", "chr",
				"startPos", "endPos", "referenceAllele", "variantAllele", "tumorFreq",
				"normalFreq", "tumorRefCount", "tumorAltCount", "normalRefCount",
				"normalAltCount", "igvLink", "mutationCount"
			],
			// Indicates the visibility of columns
			//
			// - Valid string constants:
			// "visible": column will be visible initially
			// "hidden":  column will be hidden initially,
			// but user can unhide the column via show/hide option
			// "excluded": column will be hidden initially,
			// and the user cannot unhide the column via show/hide option
			//
			// - Custom function: It is also possible to set a custom function
			// to determine the visibility of a column. A custom function
			// should return one of the valid string constants defined above.
			// For any unknown visibility value, column will be hidden by default.
			//
			// All other columns will be initially hidden by default.
			columnVisibility: {
				"datum": "excluded",
				"proteinChange": "visible",
				"caseId": function (util, gene) {
					if (util.containsCaseId(gene)) {
						return "visible";
					}
					else {
						return "hidden";
					}
				},
				"mutationType": function (util, gene) {
					if (util.containsMutationType(gene)) {
						return "visible";
					}
					else {
						return "hidden";
					}
				},
				"mutationAssessor": function (util, gene) {
					if (util.containsFis(gene)) {
						return "visible";
					}
					else {
						return "hidden";
					}
				},
	//			"cosmic": function (util, gene) {
	//				if (util.containsCosmic(gene)) {
	//					return "visible";
	//				}
	//				else {
	//					return "hidden";
	//				}
	//			},
				"cosmic": "visible",
				"mutationCount": function (util, gene) {
					if (util.containsMutationCount(gene)) {
						return "visible";
					}
					else {
						return "hidden";
					}
				},
				"mutationId": "excluded",
				"mutationSid": "excluded",
				"cancerStudy": "excluded",
				// TODO we may need more parameters than these two (util, gene)
				"cna" : function (util, gene) {
					if (util.containsCnaData(gene)) {
						return "visible";
					}
					else {
						return "hidden";
					}
				},
				"tumorFreq": function (util, gene) {
					if (util.containsAlleleFreqT(gene)) {
						return "visible";
					}
					else {
						return "hidden";
					}
				},
				"igvLink": function (util, gene) {
					if (util.containsIgvLink(gene)) {
						return "visible";
					}
					else {
						//return "excluded";
						return "hidden";
					}
				},
				"mutationStatus": function (util, gene) {
					if (util.containsGermline(gene)) {
						return "visible";
					}
					else {
						return "hidden";
					}
				},
				"validationStatus": function (util, gene) {
					if (util.containsValidStatus(gene)) {
						return "visible";
					}
					else {
						return "hidden";
					}
				},
				"tumorType": function (util, gene) {
					var count = util.distinctTumorTypeCount(gene);

					if (count > 1) {
						return "visible";
					}
					else if (count > 0) {
						return "hidden";
					}
					else { // if (count <= 0)
						//return "excluded";
						return "hidden";
					}
				},
				//"cBioPortal": function (util, gene) {
				//	if (util.containsKeyword(gene) ||
				//	    util.containsMutationEventId(gene))
				//	{
				//		return "visible";
				//	}
				//	else {
				//		return "excluded";
				//	}
				//}
				"cBioPortal": "excluded"
			},
			// Indicates whether a column is searchable or not.
			// Should be a boolean value or a function.
			//
			// All other columns will be initially non-searchable by default.
			columnSearch: {
				"caseId": true,
				"mutationId": true,
				"mutationSid": true,
				"cancerStudy": true,
				"proteinChange": true,
				"tumorType": true,
				"mutationType": true
			},
			// renderer functions:
			// returns the display value for a column (may contain html elements)
			// if no render function is defined for a column,
			// then we rely on a custom "mData" function.
			columnRender: {
				"mutationId": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("mutationId");
					if (value === undefined) {
						return "";
					}
					return value;
					//return (mutation.mutationId + "-" + mutation.mutationSid);
				},
				"mutationSid": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("mutationSid");
					if (value === undefined) {
						return "";
					}
					return value;
				},
				"caseId": function(datum) {
					var mutation = datum.mutation;
					var caseIdFormat = MutationDetailsTableFormatter.getCaseId(mutation.get("caseId"));
					var vars = {};
					vars.linkToPatientView = mutation.get("linkToPatientView");
					vars.caseId = caseIdFormat.text;
					vars.caseIdClass = caseIdFormat.style;
					vars.caseIdTip = caseIdFormat.tip;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_case_id_template");
					return templateFn(vars);
				},
				"proteinChange": function(datum) {
					var mutation = datum.mutation;

					// check if data exists,
					// if not we need to retrieve it from the data manager
					if (_.isUndefined(mutation.get("proteinChange")))
					{
						self.requestColumnData("variantAnnotation", "proteinChange");
						return MutationViewsUtil.renderTablePlaceHolder();
					}
					else
					{
						var proteinChange = MutationDetailsTableFormatter.getProteinChange(mutation);
						var vars = {};

						vars.proteinChange = proteinChange.text;
						vars.proteinChangeClass = proteinChange.style;
						vars.proteinChangeTip = proteinChange.tip;
						vars.additionalProteinChangeTip = proteinChange.additionalTip;

						// check if pdbMatch data exists,
						// if not we need to retrieve it from the data manager
						if (_.isUndefined(mutation.get("pdbMatch")))
						{
							self.requestColumnData("pdbMatch", "proteinChange");
						}

						vars.pdbMatchLink = MutationDetailsTableFormatter.getPdbMatchLink(mutation);

						var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_protein_change_template");
						return templateFn(vars);
					}
				},
				"cancerStudy": function(datum) {
					var mutation = datum.mutation;
					var vars = {};
					//vars.cancerType = mutation.cancerType;
					vars.cancerStudy = mutation.get("cancerStudy");
					vars.cancerStudyShort = mutation.get("cancerStudyShort");
					vars.cancerStudyLink = mutation.get("cancerStudyLink");

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_cancer_study_template");
					return templateFn(vars);
				},
				"tumorType": function(datum) {
					var mutation = datum.mutation;
					var tumorType = MutationDetailsTableFormatter.getTumorType(mutation);
					var vars = {};
					vars.tumorType = tumorType.text;
					vars.tumorTypeClass = tumorType.style;
					vars.tumorTypeTip = tumorType.tip;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_tumor_type_template");
					return templateFn(vars);
				},
				"mutationType": function(datum) {
					var mutation = datum.mutation;

					// check if data exists,
					// if not we need to retrieve it from the data manager
					if (_.isUndefined(mutation.get("mutationType")))
					{
						self.requestColumnData("variantAnnotation", "mutationType");
						return MutationViewsUtil.renderTablePlaceHolder();
					}
					else
					{
						var mutationType = MutationDetailsTableFormatter.getMutationType(mutation.get("mutationType"));
						var vars = {};
						vars.mutationTypeClass = mutationType.style;
						vars.mutationTypeText = mutationType.text;

						var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_mutation_type_template");
						return templateFn(vars);
					}
				},
				"cosmic": function(datum) {
					var mutation = datum.mutation;
					var cosmic = MutationDetailsTableFormatter.getCosmic(mutation.getCosmicCount());
					var vars = {};
					vars.cosmicClass = cosmic.style;
					vars.cosmicCount = cosmic.count;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_cosmic_template");
					return templateFn(vars);
				},
				"cna": function(datum) {
					var mutation = datum.mutation;
					var cna = MutationDetailsTableFormatter.getCNA(mutation.get("cna"));
					var vars = {};
					vars.cna = cna.text;
					vars.cnaClass = cna.style;
					vars.cnaTip = cna.tip;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_cna_template");
					return templateFn(vars);
				},
				"mutationCount": function(datum) {
					var mutation = datum.mutation;
					var mutationCount = MutationDetailsTableFormatter.getIntValue(mutation.get("mutationCount"));
					var vars = {};
					vars.mutationCount = mutationCount.text;
					vars.mutationCountClass = mutationCount.style;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_mutation_count_template");
					return templateFn(vars);
				},
				"normalFreq": function(datum) {
					var mutation = datum.mutation;
					var alleleCount = MutationDetailsTableFormatter.getAlleleCount(mutation.get("normalAltCount"));
					var normalFreq = MutationDetailsTableFormatter.getAlleleFreq(mutation.get("normalFreq"),
						mutation.get("normalAltCount"),
						mutation.get("normalRefCount"),
						"simple-tip");
					var vars = {};
					vars.normalFreq = normalFreq.text;
					vars.normalFreqClass = normalFreq.style;
					vars.normalFreqTipClass = normalFreq.tipClass;
					vars.normalTotalCount = normalFreq.total;
					vars.normalAltCount = alleleCount.text;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_normal_freq_template");
					return templateFn(vars);
				},
				"tumorFreq": function(datum) {
					var mutation = datum.mutation;
					var alleleCount = MutationDetailsTableFormatter.getAlleleCount(mutation.get("tumorAltCount"));
					var tumorFreq = MutationDetailsTableFormatter.getAlleleFreq(mutation.get("tumorFreq"),
						mutation.get("tumorAltCount"),
						mutation.get("tumorRefCount"),
						"simple-tip");
					var vars = {};
					vars.tumorFreq = tumorFreq.text;
					vars.tumorFreqClass = tumorFreq.style;
					vars.tumorFreqTipClass = tumorFreq.tipClass;
					vars.tumorTotalCount = tumorFreq.total;
					vars.tumorAltCount = alleleCount.text;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_tumor_freq_template");
					return templateFn(vars);
				},
				"mutationAssessor": function(datum) {
					var mutation = datum.mutation;
					var fis = MutationDetailsTableFormatter.getFis(
						mutation.get("functionalImpactScore"), mutation.get("fisValue"));
					var vars = {};
					vars.fisClass = fis.fisClass;
					vars.omaClass = fis.omaClass;
					vars.fisText = fis.text;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_mutation_assessor_template");
					return templateFn(vars);
				},
				"mutationStatus": function(datum) {
					var mutation = datum.mutation;
					var mutationStatus = MutationDetailsTableFormatter.getMutationStatus(mutation.get("mutationStatus"));
					var vars = {};
					vars.mutationStatusTip = mutationStatus.tip;
					vars.mutationStatusClass = mutationStatus.style;
					vars.mutationStatusText = mutationStatus.text;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_mutation_status_template");
					return templateFn(vars);
				},
				"validationStatus": function(datum) {
					var mutation = datum.mutation;
					var validationStatus = MutationDetailsTableFormatter.getValidationStatus(mutation.get("validationStatus"));
					var vars = {};
					vars.validationStatusTip = validationStatus.tip;
					vars.validationStatusClass = validationStatus.style;
					vars.validationStatusText = validationStatus.text;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_validation_status_template");
					return templateFn(vars);
				},
				"normalRefCount": function(datum) {
					var mutation = datum.mutation;
					var alleleCount = MutationDetailsTableFormatter.getAlleleCount(mutation.get("normalRefCount"));
					var vars = {};
					vars.normalRefCount = alleleCount.text;
					vars.normalRefCountClass = alleleCount.style;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_normal_ref_count_template");
					return templateFn(vars);
				},
				"normalAltCount": function(datum) {
					var mutation = datum.mutation;
					var alleleCount = MutationDetailsTableFormatter.getAlleleCount(mutation.get("normalAltCount"));
					var vars = {};
					vars.normalAltCount = alleleCount.text;
					vars.normalAltCountClass = alleleCount.style;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_normal_alt_count_template");
					return templateFn(vars);
				},
				"tumorRefCount": function(datum) {
					var mutation = datum.mutation;
					var alleleCount = MutationDetailsTableFormatter.getAlleleCount(mutation.get("tumorRefCount"));
					var vars = {};
					vars.tumorRefCount = alleleCount.text;
					vars.tumorRefCountClass = alleleCount.style;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_tumor_ref_count_template");
					return templateFn(vars);
				},
				"tumorAltCount": function(datum) {
					var mutation = datum.mutation;
					var alleleCount = MutationDetailsTableFormatter.getAlleleCount(mutation.get("tumorAltCount"));
					var vars = {};
					vars.tumorAltCount = alleleCount.text;
					vars.tumorAltCountClass = alleleCount.style;

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_tumor_alt_count_template");
					return templateFn(vars);
				},
				"startPos": function(datum) {
					var mutation = datum.mutation;

					// check if data exists,
					// if not we need to retrieve it from the data manager
					if (_.isUndefined(mutation.get("startPos")))
					{
						self.requestColumnData("variantAnnotation", "startPos");
						return MutationViewsUtil.renderTablePlaceHolder();
					}
					else
					{
						var startPos = MutationDetailsTableFormatter.getIntValue(mutation.get("startPos"));
						var vars = {};
						vars.startPos = startPos.text;
						vars.startPosClass = startPos.style;

						var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_start_pos_template");
						return templateFn(vars);
					}
				},
				"endPos": function(datum) {
					var mutation = datum.mutation;

					// check if data exists,
					// if not we need to retrieve it from the data manager
					if (_.isUndefined(mutation.get("endPos")))
					{
						self.requestColumnData("variantAnnotation", "endPos");
						return MutationViewsUtil.renderTablePlaceHolder();
					}
					else
					{
						var endPos = MutationDetailsTableFormatter.getIntValue(mutation.get("endPos"));
						var vars = {};
						vars.endPos = endPos.text;
						vars.endPosClass = endPos.style;

						var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_end_pos_template");
						return templateFn(vars);
					}
				},
				"sequencingCenter": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("sequencingCenter");
					if (value === undefined) {
						return "";
					}
					return value;
				},
				"chr": function(datum) {
					var mutation = datum.mutation;

					// check if data exists,
					// if not we need to retrieve it from the data manager
					if (_.isUndefined(mutation.get("chr")))
					{
						self.requestColumnData("variantAnnotation", "chr");
						return MutationViewsUtil.renderTablePlaceHolder();
					}
					else
					{
						return mutation.get("chr") || "";
					}
				},
				"referenceAllele": function(datum) {
					var mutation = datum.mutation;

					// check if data exists,
					// if not we need to retrieve it from the data manager
					if (_.isUndefined(mutation.get("referenceAllele")))
					{
						self.requestColumnData("variantAnnotation", "referenceAllele");
						return MutationViewsUtil.renderTablePlaceHolder();
					}
					else
					{
						return mutation.get("referenceAllele") || "";
					}
				},
				"variantAllele": function(datum) {
					var mutation = datum.mutation;

					// check if data exists,
					// if not we need to retrieve it from the data manager
					if (_.isUndefined(mutation.get("variantAllele")))
					{
						self.requestColumnData("variantAnnotation", "variantAllele");
						return MutationViewsUtil.renderTablePlaceHolder();
					}
					else
					{
						return mutation.get("variantAllele") || "";
					}
				},
				"igvLink": function(datum) {
					//vars.xVarLink = mutation.xVarLink;
					//vars.msaLink = mutation.msaLink;
					//vars.igvLink = mutation.igvLink;
					var mutation = datum.mutation;
					var vars = {};
					vars.igvLink = MutationDetailsTableFormatter.getIgvLink(mutation);

					var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_igv_link_template");
					return templateFn(vars);
				},
				"cBioPortal": function(datum) {
					var mutation = datum.mutation;

					// check if cBioPortal data exists,
					// if not we need to retrieve it from the data manager
					if (_.isUndefined(mutation.get("cBioPortal")))
					{
						self.requestColumnData("cBioPortal");
						// TODO make the image customizable?
						return MutationViewsUtil.renderTablePlaceHolder();
					}
					else
					{
						var portal = MutationDetailsTableFormatter.getCbioPortal(mutation.get("cBioPortal"));

						var vars = {};
						vars.portalFrequency = portal.frequency;
						vars.portalClass = portal.style;

						var templateFn = BackboneTemplateCache.getTemplateFn("mutation_table_cbio_portal_template");
						return templateFn(vars);
					}
				}
			},
			// default tooltip functions
			columnTooltips: {
				"simple": function(selector, helper) {
					var qTipOptions = MutationViewsUtil.defaultTableTooltipOpts();
					cbio.util.addTargetedQTip($(selector).find('.simple-tip'), qTipOptions);

					//tableSelector.find('.best_effect_transcript').qtip(qTipOptions);
					//tableSelector.find('.cc-short-study-name').qtip(qTipOptions);
					//$('#mutation_details .mutation_details_table td').qtip(qTipOptions);
				},
				"cosmic": function(selector, helper) {
					var gene = helper.gene;
					var mutationUtil = helper.mutationUtil;
					var qTipOptions = MutationViewsUtil.defaultTableTooltipOpts();

					// add tooltip for COSMIC value
					$(selector).find('.mutation_table_cosmic').each(function() {
						var label = this;
						var mutationId = $(label).closest("tr.mutation-table-data-row").attr("id");
						var mutation = mutationUtil.getMutationIdMap()[mutationId];

						// copy default qTip options and modify "content" to customize for cosmic
						var qTipOptsCosmic = {};
						jQuery.extend(true, qTipOptsCosmic, qTipOptions);

						qTipOptsCosmic.content = {text: "NA"}; // content is overwritten on render
						qTipOptsCosmic.events = {render: function(event, api) {
							var model = {cosmic: mutation.get("cosmic"),
								keyword: mutation.get("keyword"),
								geneSymbol: gene,
								total: $(label).text()};

							var container = $(this).find('.qtip-content');

							// create & render cosmic tip view
							var cosmicView = new CosmicTipView({el: container, model: model});
							cosmicView.render();
						}};

						cbio.util.addTargetedQTip(label, qTipOptsCosmic);
					});
				},
				"mutationAssessor": function(selector, helper) {
					var gene = helper.gene;
					var mutationUtil = helper.mutationUtil;
					var qTipOptions = MutationViewsUtil.defaultTableTooltipOpts();

					// add tooltip for Predicted Impact Score (FIS)
					$(selector).find('.oma_link').each(function() {
						var mutationId = $(this).closest("tr.mutation-table-data-row").attr("id");
						var mutation = mutationUtil.getMutationIdMap()[mutationId];
						var fis = MutationDetailsTableFormatter.getFis(
							mutation.get("functionalImpactScore"), mutation.get("fisValue"));

						// copy default qTip options and modify "content"
						// to customize for predicted impact score
						var qTipOptsOma = {};
						jQuery.extend(true, qTipOptsOma, qTipOptions);

						qTipOptsOma.content = {text: "NA"}; // content is overwritten on render
						qTipOptsOma.events = {render: function(event, api) {
							// TODO this is a quickfix for dead getma.org links,
							// need to update corresponding data sources properly
							var model = {
								impact: fis.value,
								xvia: mutation.get("xVarLink").replace("getma.org", "mutationassessor.org/r2"),
								msaLink: mutation.get("msaLink").replace("getma.org", "mutationassessor.org/r2"),
								pdbLink: mutation.get("pdbLink").replace("getma.org", "mutationassessor.org/r2")
							};

							var container = $(this).find('.qtip-content');

							// create & render FIS tip view
							var fisTipView = new PredictedImpactTipView({el:container, model: model});
							fisTipView.render();
						}};

						cbio.util.addTargetedQTip(this, qTipOptsOma);
					});
				},
				"cBioPortal": function(selector, helper) {
					var gene = helper.gene;
					var mutationUtil = helper.mutationUtil;
					var portalProxy = helper.dataProxies.portalProxy;
					var mutationTable = helper.table;

					var addTooltip = function (frequencies, cancerStudyMetaData, cancerStudyName)
					{
						$(selector).find('.mutation_table_cbio_portal').each(function(idx, ele) {
							var mutationId = $(this).closest("tr.mutation-table-data-row").attr("id");
							var mutation = mutationUtil.getMutationIdMap()[mutationId];
							var cancerStudy = cancerStudyName || mutation.get("cancerStudy");

							cbio.util.addTargetedQTip(ele, {
								content: {text: 'pancancer mutation bar chart is broken'},
								events: {
									render: function(event, api) {
										var model = {pancanMutationFreq: frequencies,
											cancerStudyMetaData: cancerStudyMetaData,
											cancerStudyName: cancerStudy,
											geneSymbol: gene,
											keyword: mutation.get("keyword"),
											proteinPosStart: mutation.get("proteinPosStart"),
											mutationType: mutation.get("mutationType"),
											qtipApi: api};

										//var container = $(this).find('.qtip-content');
										var container = $(this);

										// create & render the view
										var pancanTipView = new PancanMutationHistTipView({el:container, model: model});
										pancanTipView.render();
									}
								},
								hide: {fixed: true, delay: 100 },
								style: {classes: 'qtip-light qtip-rounded qtip-shadow', tip: true},
								position: {my:'center right',at:'center left',viewport: $(window)}
							});
						});
					};

					if (mutationTable.getCustomData()["cBioPortal"] != null)
					{
						// TODO always get the cancerStudyName from the mutation data?
						portalProxy.getPortalData(
							{cancerStudyMetaData: true, cancerStudyName: true}, function(portalData) {
								addTooltip(mutationTable.getCustomData()["cBioPortal"],
								           portalData.cancerStudyMetaData,
								           portalData.cancerStudyName);
						});
					}
				}
			},
			// default event listener config
			// TODO add more params if necessary
			eventListeners: {
				"windowResize": function(dataTable, dispatcher, mutationUtil, gene) {
					// add resize listener to the window to adjust column sizing
					$(window).one('resize', function () {
						if (dataTable.is(":visible"))
						{
							dataTable.fnAdjustColumnSizing();
						}
					});
				},
				"igvLink": function(dataTable, dispatcher, mutationUtil, gene) {
					// add click listener for each igv link to get the actual parameters
					// from another servlet
					$(dataTable).find('.igv-link').off("click").on("click", function(evt) {
						evt.preventDefault();

						var mutationId = $(this).closest("tr.mutation-table-data-row").attr("id");
						var mutation = mutationUtil.getMutationIdMap()[mutationId];
						var url = mutation.get("igvLink");

						// get parameters from the server and call related igv function
						$.getJSON(url, function(data) {
							prepIGVLaunch(data.bamFileUrl,
							              data.encodedLocus,
							              data.referenceGenome,
							              data.trackName);
						});
					});
				},
				"proteinChange3d": function(dataTable, dispatcher, mutationUtil, gene) {
					// add click listener for each 3D link
					$(dataTable).find('.mutation-table-3d-link').off("click").on("click", function(evt) {
						evt.preventDefault();

						var mutationId = $(this).closest("tr.mutation-table-data-row").attr("id");

						dispatcher.trigger(
							MutationDetailsEvents.PDB_LINK_CLICKED,
							mutationId);
					});
				},
				"proteinChange": function(dataTable, dispatcher, mutationUtil, gene) {
					// add click listener for each protein change link
					$(dataTable).find('.mutation-table-protein-change a').off("click").on("click", function(evt) {
						evt.preventDefault();

						var mutationId = $(this).closest("tr.mutation-table-data-row").attr("id");

						dispatcher.trigger(
							MutationDetailsEvents.PROTEIN_CHANGE_LINK_CLICKED,
							mutationId);
					});
				}
			},
			// column sort functions:
			// returns the value to be used for column sorting purposes.
			// if no sort function is defined for a column,
			// then uses the render function for sorting purposes.
			columnSort: {
				"mutationId": function(datum) {
					var mutation = datum.mutation;
					if (mutation.get("mutationId") === undefined) {
						return "";
					}
					return mutation.get("mutationId");
				},
				"mutationSid": function(datum) {
					var mutation = datum.mutation;
					if (mutation.get("mutationSid") === undefined) {
						return "";
					}
					return mutation.get("mutationSid");
				},
				"caseId": function(datum) {
					var mutation = datum.mutation;
					if (mutation.get("caseId") === undefined) {
						return "";
					}
					return mutation.get("caseId");
				},
				"proteinChange": function(datum) {
					var proteinChange = datum.mutation.get("proteinChange");
					//var matched = proteinChange.match(/.*[A-Z]([0-9]+)[^0-9]+/);
					var alleleAndPosition = /[A-Za-z][0-9]+./g;
					var position = /[0-9]+/g;
					var nonNumerical = /[^0-9]+/g;

					var extractNonNumerical = function(matched) {
						// this is to sort alphabetically
						// in case the protein position values are the same
						var buffer = matched[0].match(nonNumerical);

						if (buffer && buffer.length > 0)
						{
							var str = buffer.join("");
							buffer = [];

							// since we are returning a float value
							// assigning numerical value for each character.
							// we have at most 2 characters, so this should be safe...
							for (var i=0; i<str.length; i++)
							{
								buffer.push(str.charCodeAt(i));
							}
						}

						return buffer;
					};

					// first priority is to match values like V600E , V600, E747G, E747, X37_, X37, etc.
					var matched = proteinChange.match(alleleAndPosition);
					var buffer = [];

					// if no match, then search for numerical (position) match only
					if (!matched || matched.length === 0)
					{
						matched = proteinChange.match(position);
					}
					// if match, then extract the first numerical value for sorting purposes
					else
					{
						// this is to sort alphabetically
						buffer = extractNonNumerical(matched);
						matched = matched[0].match(position);
					}

					// if match, then use the first integer value as sorting data
					if (matched && matched.length > 0)
					{
						var toParse =  matched[0];

						// this is to sort alphabetically
						if (buffer && buffer.length > 0)
						{
							// add the alphabetical information as the decimal part...
							// (not the best way to ensure alphabetical sorting,
							// but in this method we are only allowed to return a numerical value)
							toParse += "." + buffer.join("");
						}

						return parseFloat(toParse);
					}
					else
					{
						// no match at all: do not sort
						return -Infinity;
					}
				},
				"cancerStudy": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("cancerStudy");
					if (value === undefined) {
						return "";
					}
					return value;
				},
				"tumorType": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("tumorType");
					if (value === undefined) {
						return "";
					}
					return value;
				},
				"mutationType": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("mutationType");
					if (value === undefined) {
						return "";
					}
					return value;
				},
				"cosmic": function(datum) {
					var mutation = datum.mutation;
					return MutationDetailsTableFormatter.assignIntValue(mutation.getCosmicCount());
				},
				"cna": function(datum) {
					var mutation = datum.mutation;
					return MutationDetailsTableFormatter.assignIntValue(mutation.get("cna"));
				},
				"mutationCount": function(datum) {
					var mutation = datum.mutation;
					return MutationDetailsTableFormatter.assignIntValue(mutation.get("mutationCount"));
				},
				"normalFreq": function(datum) {
					var mutation = datum.mutation;
					return MutationDetailsTableFormatter.assignFloatValue(mutation.get("normalFreq"));
				},
				"tumorFreq": function(datum) {
					var mutation = datum.mutation;
					return MutationDetailsTableFormatter.assignFloatValue(mutation.get("tumorFreq"));
				},
				"mutationAssessor": function(datum) {
					var mutation = datum.mutation;

					return MutationDetailsTableFormatter.assignValueToPredictedImpact(
						mutation.get("functionalImpactScore"),
						mutation.get("fisValue"));
				},
				"mutationStatus": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("mutationStatus");
					if (value === undefined) {
						return "";
					}
					return value;
				},
				"validationStatus": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("validationStatus");
					if (value === undefined) {
						return "";
					}
					return value;
				},
				"normalRefCount": function(datum) {
					var mutation = datum.mutation;
					return MutationDetailsTableFormatter.assignIntValue(mutation.get("normalRefCount"));
				},
				"normalAltCount": function(datum) {
					var mutation = datum.mutation;
					return MutationDetailsTableFormatter.assignIntValue(mutation.get("normalAltCount"));
				},
				"tumorRefCount": function(datum) {
					var mutation = datum.mutation;
					return MutationDetailsTableFormatter.assignIntValue(mutation.get("tumorRefCount"));
				},
				"tumorAltCount": function(datum) {
					var mutation = datum.mutation;
					return MutationDetailsTableFormatter.assignIntValue(mutation.get("tumorAltCount"));
				},
				"startPos": function(datum) {
					var mutation = datum.mutation;
					return MutationDetailsTableFormatter.assignIntValue(mutation.get("startPos"));
				},
				"endPos": function(datum) {
					var mutation = datum.mutation;
					return MutationDetailsTableFormatter.assignIntValue(mutation.get("endPos"));
				},
				"sequencingCenter": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("sequencingCenter");
					if (value === undefined) {
						value = "";
					}
					return value;
				},
				"chr": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("chr");
					if (value === undefined) {
						return "";
					}
					return value;
				},
				"referenceAllele": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("referenceAllele");
					if (value === undefined) {
						return "";
					}
					return value;
				},
				"variantAllele": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("variantAllele");
					if (value === undefined) {
						return "";
					}
					return value;
				},
				"igvLink": function(datum) {
					var mutation = datum.mutation;
					var value = mutation.get("igvLink");
					if (value === undefined) {
						return "";
					}
					return value;
				},
				"cBioPortal": function(datum) {
					var portal = datum.cBioPortal;

					// portal value may be null,
					// because we are retrieving it through another ajax call...
					return portal || 0;
				}
			},
			// column filter functions:
			// returns the value to be used for column sorting purposes.
			// if no filter function is defined for a column,
			// then uses the sort function value for filtering purposes.
			// if no sort function is defined either, then uses
			// the value returned by the render function.
			columnFilter: {
				"proteinChange": function(datum) {
					return datum.mutation.get("proteinChange") || "";
				},
				"mutationType": function(datum) {
					// use display value for mutation type, not the sort value
					var mutationType = MutationDetailsTableFormatter.getMutationType(
						datum.mutation.get("mutationType"));

					return mutationType.text;
				},
				"cosmic": function(datum) {
					return datum.mutation.getCosmicCount() || "";
				},
				"cna": function(datum) {
					return datum.mutation.get("cna") || "";
				},
				"mutationCount": function(datum) {
					return datum.mutation.get("mutationCount") || "";
				},
				"normalFreq": function(datum) {
					return datum.mutation.get("normalFreq") || "";
				},
				"tumorFreq": function(datum) {
					return datum.mutation.get("tumorFreq") || "";
				},
				"mutationAssessor": function(datum) {
					return datum.mutation.get("functionalImpactScore") || "";
				},
				"normalRefCount": function(datum) {
					return datum.mutation.get("normalRefCount") || "";
				},
				"normalAltCount": function(datum) {
					return datum.mutation.get("normalAltCount") || "";
				},
				"tumorRefCount": function(datum) {
					return datum.mutation.get("tumorRefCount") || "";
				},
				"tumorAltCount": function(datum) {
					return datum.mutation.get("tumorAltCount") || "";
				},
				"startPos": function(datum) {
					return datum.mutation.get("startPos") || "";
				},
				"endPos": function(datum) {
					return datum.mutation.get("endPos") || "";
				}
			},
			// native "mData" function for DataTables plugin. if this is implemented,
			// functions defined in columnRender and columnSort will be ignored.
			// in addition to default source, type, and val parameters,
			// another parameter "indexMap" will also be passed to the function.
			columnData: {
				// not implemented by default:
				// default config relies on columnRender,
				// columnSort, and columnFilter functions
			},
			// delay amount before applying the user entered filter query
			filteringDelay: 600,
			// WARNING: overwriting advanced DataTables options such as
			// aoColumnDefs, oColVis, and fnDrawCallback may break column
			// visibility, sorting, and filtering. Proceed wisely ;)
			dataTableOpts: {
				"sDom": '<"H"<"mutation_datatables_filter"f>C<"mutation_datatables_info"i>>t<"F"<"mutation_datatables_download"T>>',
				"bJQueryUI": true,
				"bPaginate": false,
				//"sPaginationType": "two_button",
				"bFilter": true,
				"sScrollY": "600px",
				"bScrollCollapse": true,
				"oLanguage": {
					"sInfo": "Showing _TOTAL_ mutation(s) in <span class='mutation-table-samples-info'></span> sample(s)",
					"sInfoFiltered": "(out of _MAX_ total mutations)",
					"sInfoEmpty": "No mutations to show"
				}
			}
		};

		// merge options with default options to use defaults for missing values
		var _options = jQuery.extend(true, {}, _defaultOpts, options);

		// call super constructor to init options and other params
		AdvancedDataTable.call(this, _options);
		_options = self._options;

		// custom event dispatcher
		var _dispatcher = self._dispatcher;

		// flag used to switch filter event on/off
		var _filterEventActive = true;

		// this is used to check if search string is changed after each redraw
		var _prevSearch = "";

		// last search string manually entered by the user
		var _manualSearch = "";

		var _rowMap = {};

		var _selectedRow = null;

		// optional table specific data
		var _customData = {};

		/**
		 * Generates the data table options for the given parameters.
		 *
		 * @param tableSelector jQuery selector for the target table
		 * @param rows          data rows
		 * @param columnOpts    column options
		 * @param nameMap       map of <column display name, column name>
		 * @param indexMap      map of <column name, column index>
		 * @param hiddenCols    indices of the hidden columns
		 * @param excludedCols  indices of the excluded columns
		 * @param nonSearchableCols    indices of the columns excluded from search
		 * @return {object}     DataTable options
		 * @private
		 */
		function initDataTableOpts(tableSelector, rows, columnOpts, nameMap,
			indexMap, hiddenCols, excludedCols, nonSearchableCols)
		{
			// generate column options for the data table
			var columns = DataTableUtil.getColumnOptions(columnOpts,
				indexMap);

			// these are the parametric data tables options
			var tableOpts = {
				"aaData" : rows,
				"aoColumns" : columns,
				"aoColumnDefs":[
					{"bVisible": false,
						"aTargets": hiddenCols},
					{"bSearchable": false,
						"aTargets": nonSearchableCols}
				],
				"oColVis": {"aiExclude": excludedCols}, // columns to always hide
				"oTableTools": {
					"aButtons": [{
						"sExtends": "text",
						"sButtonText": "Download",
						"mColumns": getExportColumns(columnOpts, excludedCols),
						"fnCellRender": function(sValue, iColumn, nTr, iDataIndex) {
							// return actual data value for sample id column,
							// since we show truncated data values when it is too long
							if (iColumn === indexMap["caseId"])
							{
								var rowData = self.getDataTable().fnGetData()[iDataIndex];
								return rowData[0].mutation.get("caseId");
							}

							var value = sValue;

							// strip HTML content and use the main (visible) text only
							if(sValue.indexOf("<") != -1 &&
							   sValue.indexOf(">") != -1)
							{
								value = $(sValue).text();
							}

							// also remove the text of "3D" link from the protein change column
							if (iColumn === indexMap["proteinChange"])
							{
								value = value.replace(/(\s)3D/, '');
							}

							return value.trim();
						},
						"fnClick": function(nButton, oConfig) {
							// get the file data (formatted by 'fnCellRender' function)
							var content = this.fnGetTableData(oConfig);

							var downloadOpts = {
								filename: "mutation_table_" + gene + ".tsv",
								contentType: "text/plain;charset=utf-8",
								preProcess: false};

							// send download request with filename & file content info
							cbio.download.initDownload(content, downloadOpts);
						}
					}]
				},
				"fnDrawCallback": function(oSettings) {
					self._addColumnTooltips({gene: gene,
						mutationUtil: mutationUtil,
						dataProxies: dataProxies,
						table: self});
					self._addEventListeners(indexMap);

					var currSearch = oSettings.oPreviousSearch.sSearch;

					// trigger the event only if the corresponding flag is set
					// and there is a change in the search term
					if (_filterEventActive &&
					    _prevSearch != currSearch)
					{
						// trigger corresponding event
						// TODO attach self instead of selector to the event
						_dispatcher.trigger(
							MutationDetailsEvents.MUTATION_TABLE_FILTERED,
							tableSelector);

						// assuming events are active for only manual filtering
						// so update manual search string only after triggering the event
						_manualSearch = currSearch;
					}

					// update prev search string reference for future use
					_prevSearch = currSearch;

					// trigger redraw event
					_dispatcher.trigger(
						MutationDetailsEvents.MUTATION_TABLE_REDRAWN,
						self);

					// get the unique number of samples for the current visible data
					var rowData = $(tableSelector).DataTable().rows({filter: "applied"}).data();
					$(oSettings.nTableWrapper).find('.mutation-table-samples-info').text(
						_.size(uniqueSamples(rowData)));

					// TODO this may not be safe: prevent rendering of invalid links in the corresponding render function
					// remove invalid links
					$(tableSelector).find('a[href=""]').remove();

					// remove invalid protein change tips
					$(tableSelector).find('span.mutation-table-additional-protein-change[alt=""]').remove();
				},
				"fnRowCallback": function(nRow, aData, iDisplayIndex, iDisplayIndexFull ) {
					var mutation = aData[indexMap["datum"]].mutation;
					// TODO mapping on mutationId and mutationSid...
					//var key = mutation.mutationId;
					//_rowMap[key] = nRow;
					$(nRow).attr("id", mutation.get("mutationId"));
					$(nRow).addClass(mutation.get("mutationSid"));
					$(nRow).addClass("mutation-table-data-row");
				},
				//"fnCreatedRow": function(nRow, aData, iDataIndex) {
				//
				//},
				"fnInitComplete": function(oSettings, json) {
					//$(tableSelector).find('a[href=""]').remove();
					//$(tableSelector).find('a[alt=""]').remove();
					//$(tableSelector).find('a.igv-link[alt=""]').remove();

					// TODO append the footer
					// (there is no API to init the footer, we need a custom function)
					//$(tableSelector).append('<tfoot></tfoot>');
					//$(tableSelector).find('thead tr').clone().appendTo($(tableSelector).find('tfoot'));

					// set the data table instance as soon as the table is initialized
					self.setDataTable(this);

					// 508 compliance: add a title to each of the checkboxes provided by
					// the ColVis library. As the offending checkboxes don't become visible
					// until the button is clicked, bind it to the click event
					$(oSettings.nTableWrapper).find(".ColVis_MasterButton").one("click", function() {
						jQuery.each($(".ColVis_radio"), function(key, value) {
							// title is the first sibling's text
							var title = $(value).siblings(':first').text();
							$(value).children(':first').attr('title', title);
						});
					});

					// trigger corresponding event
					_dispatcher.trigger(
						MutationDetailsEvents.MUTATION_TABLE_INITIALIZED,
						self);
				},
				"fnHeaderCallback": function(nHead, aData, iStart, iEnd, aiDisplay) {
				    $(nHead).find('th').addClass("mutation-details-table-header");
					self._addHeaderTooltips(nHead, nameMap);

					//Trigger fnHeader callback function
					_dispatcher.trigger(
						MutationDetailsEvents.MUTATION_TABLE_HEADER_CREATED,
						self);
			    }
	//		    "fnFooterCallback": function(nFoot, aData, iStart, iEnd, aiDisplay) {
	//			    addFooterTooltips(nFoot, nameMap);
	//		    }
			};

			return tableOpts;
		}

		/**
		 * Creates an array of indices for the columns to be exported for download.
		 *
		 * @param columnOpts    basic column options
		 * @param excludedCols  indices of the excluded columns
		 * @returns {Array}     an array of column indices
		 */
		function getExportColumns(columnOpts, excludedCols)
		{
			var exportCols = [];

			for (var i = 0; i <= _.keys(columnOpts).length; i++) {
				exportCols.push(i);
			}

			return _.difference(exportCols, excludedCols);
		}

		/**
		 * Determines the visibility value for the given column name
		 *
		 * @param columnName    name of the column (header)
		 * @return {String}     visibility value for the given column
		 */
		function visibilityValue(columnName)
		{
			var vis = _options.columnVisibility[columnName];
			var value = vis;

			// if not in the list, hidden by default
			if (!vis)
			{
				value = "hidden";
			}
			// if function, then evaluate the value
			else if (_.isFunction(vis))
			{
				value = vis(mutationUtil, gene);
			}

			return value;
		}

		/**
		 * Determines the search value for the given column name
		 *
		 * @param columnName    name of the column (header)
		 * @return {Boolean}    whether searchable or not
		 */
		function searchValue(columnName)
		{
			var searchVal = _options.columnSearch[columnName];
			var value = searchVal;

			// if not in the list, hidden by default
			if (searchVal == null)
			{
				value = false;
			}
			// if function, then evaluate the value
			else if (_.isFunction(searchVal))
			{
				// TODO determine function params (if needed)
				value = searchVal();
			}

			return value;
		}

		/**
		 * Adds default event listeners for the table.
		 *
		 * @param indexMap  column index map
		 */
		function addEventListeners(indexMap)
		{
			// add listeners only if the data table is initialized
			if (self.getDataTable() != null)
			{
				_.each(_options.eventListeners, function(listenerFn) {
					listenerFn(self.getDataTable(), _dispatcher, mutationUtil, gene);
				});
			}
		}

		function selectRow(mutationId)
		{
			// remove previous highlights
			removeAllSelection();

			// highlight selected
			var nRow = _rowMap[mutationId];
			$(nRow).addClass("row_selected");

			_selectedRow = nRow;
		}

		function removeAllSelection()
		{
			$(_options.el).find("tr").removeClass("row_selected");
		}

		function getSelectedRow()
		{
			return _selectedRow;
		}

		/**
		 * Enables/disables event triggering.
		 *
		 * @param active    boolean value
		 */
		function setFilterEventActive(active)
		{
			_filterEventActive = active;
		}

		/**
		 * Resets filtering related variables to their initial state.
		 * Does not remove actual table filters.
		 */
		function cleanFilters()
		{
			_prevSearch = "";
			_manualSearch = "";
		}

		function getManualSearch()
		{
			return _manualSearch;
		}

		/**
		 * Adds tooltips for the table header cells.
		 *
		 * @param nHead     table header
		 * @param nameMap   map of <column display name, column name>
		 * @private
		 */
		function addHeaderTooltips(nHead, nameMap)
		{
			var qTipOptions = MutationViewsUtil.defaultTableTooltipOpts();

			var qTipOptionsHeader = {};
			jQuery.extend(true, qTipOptionsHeader, qTipOptions);
			qTipOptionsHeader.position = {my:'bottom center', at:'top center', viewport: $(window)};

			//tableSelector.find('thead th').qtip(qTipOptionsHeader);
			$(nHead).find("th").each(function(){
				var displayName = $(this).text();
				var colName = nameMap[displayName];

				if (colName != null)
				{
					var tip = _options.columns[colName].tip;
					var opts = {};

					// if string, convert to an object
					if(_.isString(tip))
					{
						//$(this).attr("alt", tip);
						tip = {content: tip};
					}

					// merge qTip options with the provided options object
					jQuery.extend(true, opts, qTipOptionsHeader, tip);

					//$(this).qtip(opts);
					cbio.util.addTargetedQTip(this, opts);
				}
			});
		}

		/**
		 * Adds tooltips for the table footer cells.
		 *
		 * @param nFoot table footer
		 * @private
		 */
		function addFooterTooltips(nFoot)
		{
			var qTipOptions = MutationViewsUtil.defaultTableTooltipOpts();

			var qTipOptionsFooter = {};
			jQuery.extend(true, qTipOptionsFooter, qTipOptions);
			qTipOptionsFooter.position = {my:'top center', at:'bottom center', viewport: $(window)};

			cbio.util.addTargetedQTip($(nFoot).find("th"), qTipOptionsFooter);
		}

		// class instance to keep track of previous requests
		var _requestHistory = {};

		/**
		 * Requests column data from the data manager for the given data field name,
		 * and updates the corresponding column.
		 *
		 * @param dataFnName    data function name for data manager request
		 * @param columnName    name of the column to be updated/rendered
		 * @param callback      [optional] callback to be invoked after data retrieval
		 */
		function requestColumnData(dataFnName, columnName, callback)
		{
			columnName = columnName || dataFnName;

			// do not request data at all for excluded columns, and
			// only request once for the same dataFnName and columnName combination
			if (self._visiblityMap[columnName] === "excluded" ||
				_requestHistory[dataFnName + ":" + columnName])
			{
				return;
			}
			else
			{
				_requestHistory[dataFnName + ":" + columnName] = true;
			}

			callback = callback || function(params, data) {
				var mutationTable = params.mutationTable;

				// TODO is this the right place to store the custom table data?
				if (data)
				{
					self.getCustomData()[dataFnName] = data;
				}

				MutationViewsUtil.refreshTableColumn(
					mutationTable.getDataTable(),
					mutationTable.getIndexMap(),
					columnName);
			};

			function getColumnData()
			{
				_dispatcher.off(
					MutationDetailsEvents.MUTATION_TABLE_INITIALIZED,
					getColumnData);

				// get the pdb data for the entire table
				dataManager.getData(dataFnName,
					{mutationTable: self},
					// TODO instead of a callback,
					// listen to the data change/update events, and update the corresponding column?
				    callback
				);
			}

			// if table is not initialized yet, wait for the init event
			if (self.getDataTable() == null)
			{
				_dispatcher.on(
					MutationDetailsEvents.MUTATION_TABLE_INITIALIZED,
					getColumnData);
			}
			else
			{
				getColumnData();
			}
		}

		function uniqueSamples(rowData)
		{
			var samples = {};

			_.each(rowData, function(data, index) {
				// assuming only the first element contains the datum
				var mutation = data[0].mutation;

				if (mutation &&
				    !_.isEmpty(mutation.get('caseId')))
				{
					samples[mutation.get('caseId').toLowerCase()] = true;
				}
			});

			return samples;
		}

		function getMutations()
		{
			var mutations = null;

			if (mutationUtil)
			{
				mutations = mutationUtil.getMutations();
			}

			return mutations;
		}

		function getCustomData()
		{
			return _customData;
		}

		function getMutationUtil()
		{
			return mutationUtil;
		}

		function getGene()
		{
			return gene;
		}

		// override required functions
		this._initDataTableOpts = initDataTableOpts;
		this._visibilityValue = visibilityValue;
		this._searchValue = searchValue;
		this._addEventListeners = addEventListeners;
		this._addHeaderTooltips = addHeaderTooltips;

		// additional public functions
		this.setFilterEventActive = setFilterEventActive;
		this.getManualSearch = getManualSearch;
		this.cleanFilters = cleanFilters;
		this.requestColumnData = requestColumnData;
		this.getCustomData = getCustomData;
		this.getMutations = getMutations;
		this.getMutationUtil = getMutationUtil;
		this.getGene = getGene;

		//this.selectRow = selectRow;
		//this.getSelectedRow = getSelectedRow;
		this.dispatcher = this._dispatcher;
	}

	// MutationDetailsTable extends AdvancedDataTable...
	MutationDetailsTable.prototype = new AdvancedDataTable();
	MutationDetailsTable.prototype.constructor = MutationDetailsTable;

	module.exports = MutationDetailsTable;

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var BackboneTemplateCache = __webpack_require__(23);

	var Backbone = __webpack_require__(12);

	/**
	 * Tooltip view for the mutation table's cosmic column.
	 *
	 * options: {el: [target container],
	 *           model: {cosmic: [raw cosmic text],
	 *                   geneSymbol: [hugo gene symbol],
	 *                   keyword: [mutation keyword],
	 *                   total: [number of total cosmic occurrences]}
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var CosmicTipView = Backbone.View.extend({
		render: function()
		{
			// compile the template
			var template = this.compileTemplate();

			// load the compiled HTML into the Backbone "el"
			this.$el.html(template);
			this.format();
		},
		format: function()
		{
			// initialize cosmic details table
			this.$el.find(".cosmic-details-table").dataTable({
				"aaSorting" : [[2, "desc"]], // sort by count at init
				"sDom": 'pt', // show the table and the pagination buttons
				"aoColumnDefs": [
					{"mRender": function ( data, type, full ) {
							// TODO move this link into the template
	                        return '<a href="http://cancer.sanger.ac.uk/cosmic/mutation/overview?id='+data+'">'+data+'</a>';
	                    }, "aTargets": [0]},
					{"sType": "aa-change-col", "sClass": "left-align-td", "aTargets": [1]},
					{"sType": "numeric", "sClass": "left-align-td", "aTargets": [2]}],
				"bDestroy": false,
				"bPaginate": true,
				"bJQueryUI": true,
				"bFilter": false});
		},
		_parseCosmic: function(cosmic)
		{
			var dataRows = [];
			// TODO create a backbone template for the cosmic table row
			// COSMIC data (as AA change & frequency pairs)
			cosmic.forEach(function(c) {
	                        dataRows.push(c[0]+"</td><td>"+c[1]+"</td><td>"+c[2]);
	                    });

			return "<tr><td>" + dataRows.join("</td></tr><tr><td>") + "</td></tr>";
		},
		compileTemplate: function()
		{
			var dataRows = this._parseCosmic(this.model.cosmic);

			// pass variables in using Underscore.js template
			var variables = {cosmicDataRows: dataRows,
				cosmicTotal: this.model.total,
				mutationKeyword: this.model.keyword};

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_details_cosmic_tip_template");
			return templateFn(variables);
		}
	});

	module.exports = CosmicTipView;

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var BackboneTemplateCache = __webpack_require__(23);

	var Backbone = __webpack_require__(12);

	/**
	 * Tooltip view for the mutation table's FIS column.
	 *
	 * options: {el: [target container],
	 *           model: {xvia: [link to Mutation Assessor],
	 *                   impact: [impact text or value]}
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var PredictedImpactTipView = Backbone.View.extend({
		render: function()
		{
			// compile the template
			var template = this.compileTemplate();

			// load the compiled HTML into the Backbone "el"
			this.$el.html(template);
			this.format();
		},
		format: function()
		{
			var isValidLink = function(url)
			{
				var valid = true;

				if (url == null || url == "NA" || url.length == 0)
				{
					valid = false;
				}

				return valid;
			};

			var xvia = this.model.xvia;

			if (!isValidLink(xvia))
			{
				this.$el.find(".mutation-assessor-main-link").hide();
			}

			var pdbLink = this.model.pdbLink;

			if (!isValidLink(pdbLink))
			{
				this.$el.find(".mutation-assessor-3d-link").hide();
			}

			var msaLink = this.model.msaLink;

			if (!isValidLink(msaLink))
			{
				this.$el.find(".mutation-assessor-msa-link").hide();
			}
		},
		compileTemplate: function()
		{
			// pass variables in using Underscore.js template
			var variables = {linkOut: this.model.xvia,
				msaLink: this.model.msaLink,
				pdbLink: this.model.pdbLink,
				impact: this.model.impact};

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_details_fis_tip_template");
			return templateFn(variables);
		}
	});

	module.exports = PredictedImpactTipView;

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var PancanMutationHistogram = __webpack_require__(179);
	var BackboneTemplateCache = __webpack_require__(23);

	var cbio = {
		download: __webpack_require__(141)
	};

	var Backbone = __webpack_require__(12);
	var $ = __webpack_require__(7);
	__webpack_require__(8);
	__webpack_require__(9);

	/**
	 * Tooltip view for the mutation table's cBioPortal column.
	 *
	 * options: {el: [target container],
	 *           model: {pancanMutationFreq: [pancan mutation frequency map]
	 *                   cancerStudyMetaData: [cancer study meta data],
	 *                   cancerStudyName: [cancer study name],
	 *                   geneSymbol: [hugo gene symbol],
	 *                   keyword: [mutation keyword],
	 *                   qtipApi: [api reference for the rendered qtip]}
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var PancanMutationHistTipView = Backbone.View.extend({
		render: function()
		{
	//		var gene = $thumbnail.attr('gene');
	//		var keyword = $thumbnail.attr('keyword');
	//		var metaData = window.cancer_study_meta_data;
	//		var cancerStudy = window.cancerStudyName;
	//		var byKeywordData = genomicEventObs.pancan_mutation_frequencies[keyword];
	//		var byHugoData = genomicEventObs.pancan_mutation_frequencies[gene];

			var self = this;

			var variables = {
				gene: self.model.geneSymbol
			};

			// render view
			var templateFn = BackboneTemplateCache.getTemplateFn("pancan_mutation_hist_tip_template");
			var content = templateFn(variables);

			self.model.qtipApi.set('content.text', content);

			// format after rendering
			this.format();
		},
		format: function()
		{
			var self = this;

			var gene = self.model.geneSymbol;
			//var keyword = self.model.keyword;
			var proteinPosStart = self.model.proteinPosStart;
			var metaData = self.model.cancerStudyMetaData;
			var cancerStudy = self.model.cancerStudyName;

			//var byKeywordData = self.model.pancanMutationFreq[keyword];
			var byProteinPosData = self.model.pancanMutationFreq[proteinPosStart];
			var byHugoData = self.model.pancanMutationFreq[gene];

			var container = self.$el.find(".pancan-histogram-container");

			// init the histogram
			var histogram = PancanMutationHistogram(byProteinPosData,
			                                        byHugoData,
			                                        metaData,
			                                        container[0],
			                                        {this_cancer_study: cancerStudy});

			// update the overall count text
			self.$el.find(".overall-count").html(histogram.overallCountText());

			// correct the qtip width
			var svgWidth = $(container).find('svg').attr('width');
			self.$el.css('max-width', parseInt(svgWidth));

			// add histogram tooltips (inner tooltips)
			var svg = self.$el.find('svg')[0];
			histogram.qtip(svg);

			// add click functionality for the buttons
			$(".cross-cancer-download").click(function() {
				var fileType = $(this).attr("file-type");
				var filename = gene + "_mutations." + fileType;

				if (fileType == "pdf")
				{
					cbio.download.initDownload(svg, {
						filename: filename,
						contentType: "application/pdf",
						servletName: "svgtopdf.do"
					});
				}
				else // svg
				{
					cbio.download.initDownload(svg, {
						filename: filename
					});
				}
			});
		}
	});

	module.exports = PancanMutationHistTipView;

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var $ = __webpack_require__(7);
	var _ = __webpack_require__(5);
	var d3 = __webpack_require__(19);

	__webpack_require__(8);
	__webpack_require__(9);

	/**
	 * Makes a Pancancer Mutation Histogram on the DOM el.
	 *
	 * @param byProteinPosData          [list of {cancer_study, cancer_type, hugo, protein_pos_start, count} ]
	 * @param byGeneData                [list of {cancer_study, cancer_type, hugo, count} ]
	 * @param cancer_study_meta_data    [list of {cancer_study, cancer_type, num_sequenced_samples} ]
	 * @param el                        DOM element
	 * @param params                    overrides default parameters: { margin: { top, bottom, right, left }, width, height, this_cancer_study }
	 * @return  an object {el, qtip} where qtip is a function: svg ->
	 *          undefined, creates qtips and their corresponding `rect .mouseOver`
	 *          elements
	 *
	 * @author Gideon Dresdner <dresdnerg@cbio.mskcc.org>
	 * September 2013
	 */
	// TODO make the histogram compatible for different data types (keyword, position data, mutation type, etc)
	function PancanMutationHistogram(byProteinPosData, byGeneData, cancer_study_meta_data, el, params) {

	    params = params || {};
	    if (params.sparkline) {
	        params = _.extend({
	            margin: {top: -12, right: 0, bottom: 0, left: 0},
	            width: 30,
	            height: 12,
	            this_cancer_study: undefined
	        }, params);
	    } else {
	        params = _.extend({
	            margin: {top:6, right: 10, bottom: 20, left: 40},
	            width: 600,
	            height: 300,
	            this_cancer_study: undefined
	        }, params);
	    }

	    var cancer_study2meta_data = generate_cancer_study2datum(cancer_study_meta_data);
	    var all_cancer_studies = _.keys(cancer_study2meta_data);

	    // --- data munging --- //

	    // copy
	    var bykeyword_data = deep_copy(byProteinPosData);
	    var bygene_data = deep_copy(byGeneData);

	    // extend
		//var keyword = bykeyword_data[0].keyword;
		var keyword = bykeyword_data[0].hugo + " " + bykeyword_data[0].protein_pos_start;

	    bykeyword_data = extend_by_zero_set(bykeyword_data)
	        .map(function(d) { d.keyword = keyword; return d; });     // make sure everything has a key.  TODO: remove this extra list traversal
	    bygene_data = extend_by_zero_set(bygene_data);

	    var cancer_study2datum = {
	        bykeyword: generate_cancer_study2datum(bykeyword_data),
	        bygene: generate_cancer_study2datum(bygene_data)
	    };
	    
	    var commonKeys = _.intersection( _.keys(cancer_study2datum.bykeyword), _.keys(cancer_study2datum.bygene) );
	    bykeyword_data = [];
	    bygene_data = [];
	    _.each(commonKeys, function(aKey) {
		bykeyword_data.push(cancer_study2datum.bykeyword[aKey]);
	        bygene_data.push(cancer_study2datum.bygene[aKey]);
	    });


	    if (bygene_data.length !== bykeyword_data.length) {
	        throw new Error("must be same length");
	    }

	    if (bygene_data.length !== all_cancer_studies.length) {
	        throw new Error("there must be a datum for every cancer study and visa versa");
	    }

	    // subtract off counts in bykeyword_data from bygene_data
	    // because the counts in bygene_data include the ones in bykeyword_data
	    // and we don't want to count the same thing twice.
	    bygene_data.forEach(function(bygene_datum) {
	        var bykeyword_datum = cancer_study2datum.bykeyword[bygene_datum.cancer_study];
	        var new_count = bygene_datum.count - bykeyword_datum.count;

	        if (new_count < 0) {
	            throw new Error("more mutations for a particular keyword than "
	                + "for all keywords of a particular gene");
	        }

	        bygene_datum.count = new_count;
	    });
	    
	    var totalByGene = _.reduce(bygene_data, function(memo, datum){ return memo + datum.count; }, 0);
	    var totalByKeyword = _.reduce(bykeyword_data, function(memo, datum){ return memo + datum.count; }, 0);
	    var totalSequenced = _.reduce(cancer_study2meta_data, function(memo, datum){ return memo + datum.num_sequenced_samples; }, 0);

	    _.mixin({
	        unzip: function(array) {
	            return _.zip.apply(_, array);
	        }
	    });

	    var all_data = bykeyword_data.concat(bygene_data);
	    try {
	        all_data = _.chain(all_data)
	            .map(compute_frequency)
	            .groupBy(function(d) {
	                return d.cancer_study;
	            })
	            .map(_.identity)    // extract groups
	            .sortBy(cancer_type)
	            .unzip()            // turn into layers for d3.stack
	            .value();
	    } catch(e) {
	        throw new Error(e);
	    }

	    function deep_copy(list_of_objects) {
	        return list_of_objects.map(_.clone);
	    }

	    function generate_cancer_study2datum(data) {
	        return _.reduce(data, function(acc, next) {
	            acc[next.cancer_study] = next;
	            return acc;
	        }, {});
	    }

	    function compute_frequency(d) {
	        var num_sequenced_samples = cancer_study2meta_data[d.cancer_study].num_sequenced_samples;
	        d.num_sequenced_samples = num_sequenced_samples;
	        d.frequency = d.count / num_sequenced_samples;
	        return d;
	    }

	    // takes a list of cancer studies (presumably one which contains all the
	    // cancer studies for a cancer type) and returns the total frequency in
	    // that list
	    //
	    // *signature:* `array -> number`
	    function total_frequency(group) {
	        var total_frequency = _.reduce(group, function(acc, next) { return acc + next.frequency }, 0);
	        return -1 * total_frequency;
	    }

	    // returns the cancer type of a group
	    // *throws* error if not all elements in the list have the same cancer type
	    //
	    // *signature:* `array -> string`
	    function cancer_type(group) {
	        var cancerType = group[0].cancer_type;
	        if (!_.every(group, function(d) { return d.cancer_type === cancerType; })) {
	            throw new Error("not all data in a group have the same cancer type");
	        }

	        return cancerType;
	    }

	    // add in missing cancer studies as data points with count = 0
	    function zero_set(data) {
	        var cancer_study2datum = generate_cancer_study2datum(data);
	        // TODO: this could be optimized by referring to the `cancer_study2datum` object

	        function zero_datum(cancer_study) {
	            return {
	                cancer_study: cancer_study,
	                count: 0,
	                cancer_type: cancer_study2meta_data[cancer_study].cancer_type,
	                num_sequenced_samples: cancer_study2meta_data[cancer_study].num_sequenced_samples
	            };
	        }

	        return _.chain(all_cancer_studies)
	            .reduce(function(acc, study) {
	                if (!_.has(cancer_study2datum, study)) {
	                    // do all_cancer_studies *setminus* cancer_study2datum
	                    acc.push(study);
	                }
	                return acc;
	            }, [])
	            .map(zero_datum)
	            .value();
	    }

	    function extend_by_zero_set(data) {
	        return data.concat(zero_set(data));
	    }

	    // --- visualization --- //

	    // margin conventions http://bl.ocks.org/mbostock/3019563
	    var width = params.width - params.margin.left - params.margin.left;
	    var height = params.height - params.margin.top - params.margin.bottom;

	    var svg = d3.select(el).append("svg")
	        .attr("width", params.width)
	        .attr("height", params.height)
	        .append("g")
	        .attr("transform", "translate(" + params.margin.left + "," + params.margin.top + ")");

	    var stack = d3.layout.stack()
	            .x(function(d) { return d.cancer_study; })
	            .y(function(d) { return d.frequency; })
	        ;

	    var layers = stack(all_data);
	//    console.log(layers);

	    var x = d3.scale.ordinal()
	        .domain(all_data[0].map(function(d) { return d.cancer_study; }))
	        .rangeBands([0, width], .1);

	    // sparkline y axis does not scale: will always be from 0 to 1
	    var sparkline_y_threshold = .2
	    var yStackMax = params.sparkline ? sparkline_y_threshold
	        : d3.max(layers, function(layer) { return d3.max(layer, function(d) { return d.y0 + d.y; }); });

	    var y = d3.scale.linear()
	        .domain([0, yStackMax])
	        .range([height, 0])
	        .clamp(true)
	        ;

	    // --- bar chart ---

	    var googleblue = "LimeGreen";
	    var googlered = "Green";

	    var layer = svg.selectAll(".layer")
	        .data(layers)
	        .enter().append("g")
	        .attr("class", "layer")
	        .style("fill", function(d, i) { return [googlered, googleblue][i]; });

	    var rect = layer.selectAll("rect")
	        .data(function(d) { return d; })
	        .enter().append("rect")
	        .attr("x", function(d) { return x(d.cancer_study); })
	        .attr("y", function(d) { return y(d.y0 + d.y); })
	        .attr("width", function(d) { return x.rangeBand(); })
	        .attr("height", function(d) { return y(d.y0) - y(d.y0 + d.y); })

	    // *** kill process, do nothing more ***
	    if (params.sparkline) {
	        return {
	            el: el,
	            qtip: function() { throw new Error("don't qtip a sparkline"); }
	        };
	    }

	    // --- axises --- //

	    var percent_format = d3.format(yStackMax > .1 ? ".0%" : ".1%");
	    var yAxis = d3.svg.axis()
	        .scale(y)
	        .tickFormat(percent_format)
	        .orient("left");
	    yAxis.tickSize(yAxis.tickSize(), 0, 0);

	    // list of element that represent the start and end of each cancer type in
	    // the sorted list of cancer studies
	    var study_start_ends = (function() {
	        var first = all_data[0][0];

	        function new_element_from_datum(d) {
	            return {
	                cancer_type: d.cancer_type,
	                start: d.cancer_study,
	                end: d.cancer_study,
	                color: cancer_study2meta_data[d.cancer_study].color
	            };
	        }

	        return _.chain(all_data[0])
	            .reduce(function(acc, next) {
	                var last = _.last(acc);

	                // beginning of a new cancer type, create a first cancer_study
	                if (last.cancer_type !== next.cancer_type) {
	                    return acc.concat(new_element_from_datum(next));
	                }

	                // within a cancer type, continue updating the last
	                // cancer_study
	                if (last.cancer_type === next.cancer_type) {
	                    last.end = next.cancer_study;
	                    return acc;
	                }

	            }, [ new_element_from_datum(first) ])
	            .value();
	    }());

	    // add the cancer type axis
	    svg.selectAll('line')
	        .data(study_start_ends)
	        .enter()
	        .append('line')
	        .attr('x1', function(d) { return x(d.start); })
	        .attr('x2', function(d) { return x(d.end) + x.rangeBand(); })
	        .attr('y1', height + params.margin.bottom / 3)
	        .attr('y2', height + params.margin.bottom / 3)
	        .style('stroke-width', 5)
	        .style('stroke', function(d) { return d.color; })
	    ;

	    // append y axis

	    var yAxisEl = svg.append("g")
	        .call(yAxis)
	        .attr('stroke', '#000')
	        .attr('shape-rendering', 'crispEdges');

	    var hugo_gene_name = _.find(layers[0], function(d) { return d.hugo !== undefined; }).hugo;
	    var keyword = _.find(layers[0], function(d) { return d.keyword !== undefined; }).keyword;

	    // star the current cancer study if this_cancer_study is provided.
	    if (!_.isUndefined(params.this_cancer_study)) {
	        star_this_cancer_study();
	    }

	    function star_this_cancer_study() {
	        var this_cancer_study_data = _.find(all_data[0], function(d) {
	            return d.cancer_study === params.this_cancer_study;
	        });

	        var this_cancer_type;
	        try {
	            this_cancer_type = this_cancer_study_data.cancer_type;
	        } catch(e) {
	            throw new Error(e + ": could not find this the corresponding datum for this cancer study, [" + params.this_cancer_study + "]");
	        }

	        var find_this_cancer_studdy_datum = function(group) {
	            return _.find(group, function(d) {
	                return d.cancer_study === params.this_cancer_study;
	            });
	        };

	        var this_cancer_type_group = _.zip.apply(null, all_data);
	        this_cancer_type_group = _.find(this_cancer_type_group, find_this_cancer_studdy_datum);

	        var total_freq = total_frequency(this_cancer_type_group);

	        svg.append('text')
	            .text('*')
	            .attr('id', 'star')
	            .attr('x', x(params.this_cancer_study))
	            .attr('y', y(-1 * total_freq) + 10)
	            .style("font-family", "Helvetica Neue, Helvetica, Arial, sans-serif")
	            .style("font-size", (x.rangeBand()*3) + "px");
	    }

	    function qtip(svg) {
	        var mouseOverBar = d3.select(svg).selectAll('.mouseOver')
	            .data(all_cancer_studies)
	            .enter()
	            .append('rect')
	            .attr('class', 'mouseOver')
	            .attr('y', params.margin.top)
	            .attr('x', function(d) {
	                return x(d) + params.margin.left;
	            })
	            .attr('opacity', '0')
	            .attr('height', height + 5)
	            .attr('width', x.rangeBand())
	            .on('mouseover', function() { d3.select(this).attr('opacity', '0.25'); })
	            .on('mouseout', function() { d3.select(this).attr('opacity', '0'); });

	        // add qtips for each bar
	        mouseOverBar.each(function(d) {
	            $(this).qtip({
	                content: {text: 'mouseover failed'},
	                position: {my:'left top', at:'center right', viewport: $(window)},
	                style: { classes: 'qtip-light qtip-rounded qtip-shadow qtip-wide' },
	                hide: { fixed: true, delay: 100 },
	                events: {
	                    render: function(event, api) {
	                        var data = getRectsByCancerStudy(d).map(function(rect) { return rect[0].__data__; });
	                        var bykeyword = data.filter(function(d) { return _.has(d, "keyword"); })[0] || {};
	                        var bygene = data.filter(function(d) { return !_.has(d, "keyword"); })[0] || {};
	                        var cancer_study = bygene.cancer_study;     // there should always be a bygene datum
	                        var total = cancer_study2meta_data[cancer_study].num_sequenced_samples;
	                        var text = "<p style='font-weight:bold;'>" + cancer_study + "</p>"
	                            + countText(bykeyword, bygene, total);

	                        api.set('content.text', text);
	                    }
	                }
	            });
	        });
	    }

	    function qtip_template(d, total) {
	        var count = d.count || 0;
	        if (!('frequency' in d)) d.frequency = count / total;
	        var percent = (d.frequency * 100).toFixed(1)+'%';
	        return (_.template("<span><b>{{percent}}</b> (<b>{{count}}</b> of {{total}} sequenced samples)</span>"))({percent: percent, count: count, total: total});
	    }
	    
	    function countText(bykeyword, bygene, total) {
	        return "<p style='color: " + googlered + "; margin-bottom:0;'>"
	                + keyword  + ": "  + qtip_template(bykeyword, total) + "</p>"
	                + "<p style='color: " + googleblue + "; margin-top:0;'>"
	                + "Other " + hugo_gene_name +  " mutations: "  + qtip_template(bygene, total) + "</p>";
	    }

	    function getRectsByCancerStudy(cancer_study) {
	        return rect.filter(function(d) { return d.cancer_study === cancer_study; });
	    }

	    return {
	        el: el,
	        qtip: qtip,
	        overallCountText: function() {return countText({count:totalByKeyword}, {count:totalByGene}, totalSequenced);}
	    };
	}

	module.exports = PancanMutationHistogram;

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2016 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDetailsEvents = __webpack_require__(22);
	var MutationViewsUtil = __webpack_require__(129);
	var BackboneTemplateCache = __webpack_require__(23);

	var Backbone = __webpack_require__(12);
	var _ = __webpack_require__(5);
	var $ = __webpack_require__(7);

	/**
	 * Mutation Details Customization Panel View.
	 *
	 * This view is designed to provide a customization panel for Mutation Details page.
	 *
	 * options: {el: [target container],
	 *           model: {},
	 *          }
	 *
	 * @author Selcuk Onur Sumer
	 */
	var MutationInfoPanelView = Backbone.View.extend({
		initialize : function (options) {
			this.options = options || {};

			// custom event dispatcher
			this.dispatcher = {};
			_.extend(this.dispatcher, Backbone.Events);

			// initial count by type map
			//this.initialMapByType = this._mapMutationsByType(this.model.mutations);
			this.initialMapByType = this._mapMutationsByMainType(this.model.mutations.getData());
			//this.selectionMap = this.resetSelectionMap();
		},
		render: function()
		{
			var self = this;
			self.updateView(self.model.mutations.getData());
		},
		format: function()
		{
			var self = this;

			self.$el.find(".mutation-type-info-link").on('click', function(evt) {
				evt.preventDefault();
				var mutationType = $(this).attr("alt");

				//if (self.selectionMap[mutationType] != null)
				//{
				//	self.selectionMap[mutationType] += 1;
				//}

				self.dispatcher.trigger(
					MutationDetailsEvents.INFO_PANEL_MUTATION_TYPE_SELECTED,
					mutationType);
			});
		},
		updateView: function(mutations) {
			var self = this;
			//self.currentMapByType = self._mapMutationsByType(mutations);
			self.currentMapByType = self._mapMutationsByMainType(mutations);
			var countByType = self._countMutationsByType(self.currentMapByType);
			var mutationTypeStyle = MutationViewsUtil.getVisualStyleMaps().mutationType;
			var content = [];

			countByType = _.extend(self._generateZeroCountMap(self.initialMapByType), countByType);

			// sort mutation types by priority
			var keys = _.keys(countByType).sort(function(a, b) {
				var priorityA = 1024;
				var priorityB = 1024;

				if (mutationTypeStyle[a] && mutationTypeStyle[a].priority) {
					priorityA = mutationTypeStyle[a].priority;
				}

				if (mutationTypeStyle[b] && mutationTypeStyle[b].priority) {
					priorityB = mutationTypeStyle[b].priority;
				}

				return priorityA - priorityB;
			});

			_.each(keys, function(mutationType) {
				var templateFn = BackboneTemplateCache.getTemplateFn("mutation_info_panel_type_template");

				var text = "Other";
				var textStyle = mutationTypeStyle["other"].style;

				var view = mutationTypeStyle[mutationType];

				if (view && view.mainType)
				{
					view = mutationTypeStyle[view.mainType];
				}

				if (view)
				{
					text = view.longName || text;
					textStyle = view.style || textStyle;
				}

				var count = countByType[mutationType];

				var variables = {
					mutationType: mutationType,
					type: text,
					textStyle: textStyle,
					count: count,
					countStyle: textStyle + "_count"
				};

				var template = templateFn(variables);
				content.push(template);
			});

			// template vars
			var variables = {
				mutationTypeContent: content.join("\n")
			};

			// compile the template using underscore
			var templateFn = BackboneTemplateCache.getTemplateFn("mutation_info_panel_template");
			var template = templateFn(variables);

			// load the compiled HTML into the Backbone "el"
			self.$el.html(template);

			// format after rendering
			self.format();
		},
		_generateZeroCountMap: function(mapByType) {
			var zeroCountMap = {};

			_.each(_.keys(mapByType), function (key) {
				zeroCountMap[key] = 0;
			});

			return zeroCountMap;
		},
		resetSelectionMap: function() {
			var self = this;

			self.selectionMap = self._generateZeroCountMap(self.initialMapByType);
		},
		// TODO move these into a utility class
		_mapMutationsByType: function(mutations) {
			return _.groupBy(mutations, function(mutation) {
				return mutation.get("mutationType").toLowerCase();
			});
		},
		_mapMutationsByMainType: function(mutations) {
			var mutationTypeStyle = MutationViewsUtil.getVisualStyleMaps().mutationType;

			return _.groupBy(mutations, function(mutation) {
				var type = mutation.get("mutationType");
				if (type) {
					type = type.toLowerCase();
				}
				else {
					type = "other";
				}

				var mainType;

				if (mutationTypeStyle[type]) {
					mainType = mutationTypeStyle[type].mainType;
				}
				else {
					mainType = "other";
				}

				return mainType;
			});
		},
		_countMutationsByType: function(mapByType) {
			var countByType = {};

			_.each(_.keys(mapByType), function(type) {
				countByType[type] = _.size(mapByType[type]);
			});

			return countByType;
		}
	});

	module.exports = MutationInfoPanelView;

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2016 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This file is part of cBioPortal.
	 *
	 * cBioPortal is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as
	 * published by the Free Software Foundation, either version 3 of the
	 * License.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationDetailsEvents = __webpack_require__(22);
	var MutationDetailsUtil = __webpack_require__(114);
	var MutationDataConverter = __webpack_require__(125);

	var $ = __webpack_require__(7);
	var jQuery = $;
	var _ = __webpack_require__(5);


	/**
	 * @author Selcuk Onur Sumer
	 */
	function MutationData(options)
	{
	    var _self = this;
	    var _dispatcher = {};
	    var _mutationDataUtil = null;

	    var _data = {

	    };

	    var _defaultOpts = {

	    };

	    var _state = {
	        highlighted: [],
	        selected: [],
	        filtered: []
	    };

	    // merge options with default options to use defaults for missing values
	    var _options = jQuery.extend(true, {}, _defaultOpts, options);

	    function updateData(data)
	    {
	        setData(jQuery.extend(true, {}, _data, data));
	    }

	    function setData(data)
	    {
	        _data = data;
	        _state.filtered = data;
	        _mutationDataUtil = new MutationDetailsUtil(
	            MutationDataConverter.convertToCollection(data));
	    }

	    function getData()
	    {
	        return _data;
	    }

	    function getDataUtil()
	    {
	        return _mutationDataUtil;
	    }

	    function getState()
	    {
	        return _state;
	    }

	    function update(state, mutations, event, info)
	    {
	        var prevState = _state[state];

	        // update the corresponding set with the given mutations
	        // this overrides all the previous content!
	        _state[state] = mutations;

	        // trigger an event only if there is a change in the state
	        if (!_.isEqual(prevState, _state[state])) {
	            // trigger a custom event
	            $(_dispatcher).trigger(event, buildParams(info));
	        }
	    }

	    function add(state, mutations, event, info)
	    {
	        var prevState = _state[state];

	        // add given mutations to the corresponding set
	        _state[state] = _.union(_state[state], mutations);

	        // trigger an event only if there is a change in the state
	        if (!_.isEqual(prevState, _state[state])) {
	            // trigger a custom event
	            $(_dispatcher).trigger(event, buildParams(info));
	        }
	    }

	    function remove(state, mutations, event, info)
	    {
	        var prevState = _state[state];

	        if (mutations == null)
	        {
	            // reset all
	            _state[state] = [];
	        }
	        else
	        {
	            // remove given mutations from the corresponding set
	            _state[state] = _.difference(_state[state], mutations);
	        }

	        // trigger an event only if there is a change in the state
	        if (!_.isEqual(prevState, _state[state])) {
	            // trigger a custom event
	            $(_dispatcher).trigger(event, buildParams(info));
	        }
	    }

	    function updateHighlightedMutations(mutations, info)
	    {
	        update("highlighted", mutations, MutationDetailsEvents.MUTATION_HIGHLIGHT, info);
	    }

	    function highlightMutations(mutations, info)
	    {
	        // add given mutations to the set of highlighted mutations
	        add("highlighted", mutations, MutationDetailsEvents.MUTATION_HIGHLIGHT, info);
	    }

	    function unHighlightMutations(mutations, info)
	    {
	        // remove given mutations from the set of highlighted mutations
	        remove("highlighted", mutations, MutationDetailsEvents.MUTATION_HIGHLIGHT, info);
	    }

	    function updateFilteredMutations(mutations, info)
	    {
	        update("filtered", mutations, MutationDetailsEvents.MUTATION_FILTER, info);
	    }

	    function filterMutations(mutations, info)
	    {
	        // add given mutations to the set of filtered mutations
	        add("filtered", mutations, MutationDetailsEvents.MUTATION_FILTER, info);
	    }

	    function unfilterMutations(mutations, info)
	    {
	        if (mutations == null) {
	            _state.filtered = _data;
	            $(_dispatcher).trigger(MutationDetailsEvents.MUTATION_FILTER,
	                                   buildParams(info));
	        }
	        else {
	            // remove given mutations from the set of filtered mutations
	            remove("filtered", mutations, MutationDetailsEvents.MUTATION_FILTER, info);
	        }
	    }

	    function updateSelectedMutations(mutations, info)
	    {
	        update("selected", mutations, MutationDetailsEvents.MUTATION_SELECT, info);
	    }

	    function selectMutations(mutations, info)
	    {
	        // add given mutations to the set of selected mutations
	        add("selected", mutations, MutationDetailsEvents.MUTATION_SELECT, info);
	    }

	    function unSelectMutations(mutations, info)
	    {
	        // remove given mutations from the set of selected mutations
	        remove("selected", mutations, MutationDetailsEvents.MUTATION_SELECT, info);
	    }

	    function buildParams(info)
	    {
	        var params = info || {};

	        params.mutationData = _self;

	        return params;
	    }

	    this.updateData = updateData;
	    this.setData = setData;
	    this.getData = getData;
	    this.getDataUtil = getDataUtil;
	    this.getState = getState;
	    this.updateHighlightedMutations = updateHighlightedMutations;
	    this.highlightMutations = highlightMutations;
	    this.unHighlightMutations = unHighlightMutations;
	    this.updateFilteredMutations = updateFilteredMutations;
	    this.filterMutations = filterMutations;
	    this.unfilterMutations = unfilterMutations;
	    this.updateSelectedMutations = updateSelectedMutations;
	    this.selectMutations = selectMutations;
	    this.unSelectMutations = unSelectMutations;
	    this.dispatcher = _dispatcher;
	}

	module.exports = MutationData;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
	 *
	 * This library is distributed in the hope that it will be useful, but WITHOUT
	 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
	 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
	 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
	 * obligations to provide maintenance, support, updates, enhancements or
	 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
	 * liable to any party for direct, indirect, special, incidental or
	 * consequential damages, including lost profits, arising out of the use of this
	 * software and its documentation, even if Memorial Sloan-Kettering Cancer
	 * Center has been advised of the possibility of such damage.
	 */

	/*
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Lesser General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	var MutationCollection = __webpack_require__(112);
	var MutationModel = __webpack_require__(113);
	var VariantAnnotationUtil = __webpack_require__(3);

	var _ = __webpack_require__(5);

	/**
	 * Utility class to parse the custom mutation input data.
	 *
	 * @author Selcuk Onur Sumer
	 */
	function MutationInputParser ()
	{
		var _data = null; // MutationCollection
		var _geneList = null;
		var _sampleList = null;
		var _idCounter = 0;

		// TODO add column name alternatives?
		// map of <mutation model field name, input header name> pairs
		var _headerMap = {
			"proteinPosEnd": "protein_position_end",
			"uniprotId": "uniprot_id",
			"cancerType": "cancer_type",
			"tumorType": "tumor_type",
			"cancerStudyLink": "cancer_study_link",
			"codonChange": "codon_change",
			"proteinPosStart": "protein_position_start",
			"linkToPatientView": "patient_view_link",
			"geneticProfileId": "genetic_profile_id",
			"mutationCount": "mutation_count",
			"mutationType": "mutation_type", // "variant_classification"
			"referenceAllele": "reference_allele",
			"uniprotAcc": "uniprot_accession",
			"fisValue": "fis_value",
			"functionalImpactScore": "fis",
			"cancerStudy": "cancer_study",
			"normalRefCount": "normal_ref_count",
			"ncbiBuildNo": "ncbi_build",
			"normalFreq": "normal_frequency",
			"cancerStudyShort": "cancer_study_short",
			"msaLink": "msa_link",
			"mutationStatus": "mutation_status",
			"cna": "copy_number",
			"proteinChange": "protein_change",
			"aminoAcidChange": "amino_acid_change",
			"endPos": "end_position",
			//"refseqMrnaId": "",
			"geneSymbol": "hugo_symbol",
			"tumorFreq": "tumor_frequency",
			"startPos": "start_position",
			"keyword": "keyword",
			"cosmic": "cosmic",
			"validationStatus": "validation_status",
			"mutationSid": "mutation_sid",
			//"canonicalTranscript": "",
			"normalAltCount": "normal_alt_count",
			"variantAllele": "variant_allele",
			//"mutationEventId": "",
			"mutationId": "mutation_id",
			"caseId": "sample_id", // "tumor_sample_barcode"
			"xVarLink": "xvar_link",
			"pdbLink": "pdb_link",
			"tumorAltCount": "tumor_alt_count",
			"tumorRefCount": "tumor_ref_count",
			"sequencingCenter": "center",
			"chr": "chromosome"
		};

		/**
		 * Initializes a default mutation object where all data fields are empty strings.
		 *
		 * @returns {Object}    a default "empty" mutation object
		 */
		function initMutation()
		{
			return {
				"proteinPosEnd": "",
				"uniprotId": "",
				"cancerType": "",
				"tumorType": "",
				"cancerStudyLink": "",
				"codonChange": "",
				"proteinPosStart": "",
				"linkToPatientView": "",
				"geneticProfileId": "",
				"mutationCount": "",
				"mutationType": "",
				"referenceAllele": "",
				"uniprotAcc": "",
				"fisValue": "",
				"functionalImpactScore": "",
				"cancerStudy": "",
				"normalRefCount": "",
				"ncbiBuildNo": "",
				"normalFreq": "",
				"cancerStudyShort": "",
				"msaLink": "",
				"mutationStatus": "",
				"cna": "",
				"proteinChange": "",
				"aminoAcidChange": "",
				"endPos": "",
				"refseqMrnaId": "",
				"geneSymbol": "",
				"tumorFreq": "",
				"startPos": "",
				"keyword": "",
				"cosmic": "",
				"validationStatus": "",
				"mutationSid": "",
				//"canonicalTranscript": "",
				"normalAltCount": "",
				"variantAllele": "",
				//"mutationEventId": "",
				"mutationId": "",
				"caseId": "",
				"xVarLink": "",
				"pdbLink": "",
				"tumorAltCount": "",
				"tumorRefCount": "",
				"sequencingCenter": "",
				"chr": ""
			};
		}

		/**
		 * Parses the entire input data and creates an array of mutation objects.
		 *
		 * @param input     input string/file.
		 * @returns {MutationCollection} an array of mutation objects.
		 */
		function parseInput(input)
		{
			var mutationData = new MutationCollection();

			var lines = input.split("\n");

			if (lines.length > 0)
			{
				// assuming first line is a header
				// TODO allow comments?
				var indexMap = buildIndexMap(lines[0]);

				// rest should be data
				for (var i=1; i < lines.length; i++)
				{
					// skip empty lines
					if (lines[i].length > 0)
					{
						mutationData.push(parseLine(lines[i], indexMap));
					}
				}
			}

			_data = mutationData;

			return mutationData;
		}

		/**
		 * Parses a single line of the input and returns a new mutation object.
		 *
		 * @param line      single line of the input data
		 * @param indexMap  map of <header name, index> pairs
		 * @returns {MutationModel}    a mutation model object
		 */
		function parseLine(line, indexMap)
		{
			//var mutation = initMutation();
			// init an empty mutation object
			var mutation = new MutationModel();

			// assuming values are separated by tabs
			var values = line.split("\t");
			var attributes = {};

			// find the corresponding column for each field, and set the value
			_.each(_.keys(_headerMap), function(key) {
				var value = parseValue(key, values, indexMap);

				if (value)
				{
					attributes[key] = value;
				}
			});

			attributes.mutationId = attributes.mutationId || nextId();

			// TODO mutationSid?
			attributes.mutationSid = attributes.mutationSid || attributes.mutationId;

			attributes.variantKey = VariantAnnotationUtil.generateVariantKey(attributes);

			mutation.set(attributes);
			return mutation;
		}

		/**
		 * Parses the value of a single input cell.
		 *
		 * @param field     name of the mutation model field
		 * @param values    array of values for a single input line
		 * @param indexMap  map of <header name, index> pairs
		 * @returns {string|undefined}    data value for the given field name.
		 */
		function parseValue(field, values, indexMap)
		{
			// get the column name for the given field name
			var column = _headerMap[field];
			var index = indexMap[column];
			var value = undefined;

			if (index != null &&
			    values[index] != null)
			{
				value = values[index].trim();
			}

			return value;
		}

		/**
		 * Builds a map of <header name, index> pairs, to use header names
		 * instead of index constants.
		 *
		 * @param header    header line (first line) of the input
		 * @returns {object} map of <header name, index> pairs
		 */
		function buildIndexMap(header)
		{
			var columns = header.split("\t");
			var map = {};

			_.each(columns, function(column, index) {
				map[column.trim().toLowerCase()] = index;
			});

			return map;
		}

		/**
		 * Processes the input data and creates a list of sample (case) ids.
		 *
		 * @returns {Array} an array of sample ids
		 */
		function getSampleArray()
		{
			if (_data == null)
			{
				return [];
			}

			if (_sampleList == null)
			{
				var sampleSet = {};

				_data.each(function(mutation, idx) {
					if (mutation.get("caseId") != null &&
					    mutation.get("caseId").length > 0)
					{
						sampleSet[mutation.get("caseId")] = mutation.get("caseId");
					}
				});

				_sampleList = _.values(sampleSet);
			}

			return _sampleList;
		}

		function getGeneList()
		{
			if (_data == null)
			{
				return [];
			}

			if (_geneList == null)
			{
				var geneSet = {};

				_data.each(function(mutation, idx) {
					if (mutation.get("geneSymbol") != null &&
					    mutation.get("geneSymbol").length > 0)
					{
						geneSet[mutation.get("geneSymbol").toUpperCase()] =
							mutation.get("geneSymbol").toUpperCase();
					}
				});

				_geneList = _.values(geneSet);
			}

			return _geneList;
		}

		function nextId()
		{
		    _idCounter++;

			return "stalone_mut_" + _idCounter;
		}

		return {
			parseInput: parseInput,
			getSampleArray: getSampleArray,
			getGeneList: getGeneList
		};
	}

	module.exports = MutationInputParser;

/***/ }
/******/ ])
});
;